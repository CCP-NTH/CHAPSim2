var tipuesearch = {"pages":[{"title":" CHAPSim2 ","text":"CHAPSim2 src_dir: ./src\nexclude_dir: \n  - ./build\n  - ./tests\n  - . exclude: \n  - ./src/. output_dir: ./doc predocmark: >\ndocmark: !\npredocmark_alt: *\ndocmark_alt: * display: \n  - public\n  - protected\n  - private source: true\ngraph: true\nsearch: true macro: VERSION=1.0.0 license: GPL3.0 warn: true\npage_dir: ./doc_pages Developer Info Wei Wang Senior Computational Scientist, Scientific Computing Department, UKRI-STFC","tags":"home","url":"index.html"},{"title":"t_fluidThermoProperty – CHAPSim2 ","text":"type, public :: t_fluidThermoProperty Components Type Visibility Attributes Name Initial real(kind=WP), public :: t real(kind=WP), public :: d real(kind=WP), public :: m real(kind=WP), public :: k real(kind=WP), public :: h real(kind=WP), public :: rhoh real(kind=WP), public :: cp real(kind=WP), public :: b","tags":"","url":"type/t_fluidthermoproperty.html"},{"title":"t_fluid_parameter – CHAPSim2 ","text":"type, public :: t_fluid_parameter Components Type Visibility Attributes Name Initial character(len=64), public :: inputProperty integer, public :: ifluid integer, public :: ipropertyState integer, public :: nlist real(kind=WP), public :: TM0 real(kind=WP), public :: TB0 real(kind=WP), public :: HM0 real(kind=WP), public :: CoD (0:1) real(kind=WP), public :: CoK (0:2) real(kind=WP), public :: CoB real(kind=WP), public :: CoCp (-2:2) real(kind=WP), public :: CoH (-1:3) real(kind=WP), public :: CoM (-1:1) real(kind=WP), public :: dhmax real(kind=WP), public :: dhmin type( t_fluidThermoProperty ), public :: ftp0ref type( t_fluidThermoProperty ), public :: ftpini","tags":"","url":"type/t_fluid_parameter.html"},{"title":"t_domain – CHAPSim2 ","text":"type, public :: t_domain Components Type Visibility Attributes Name Initial logical, public :: is_periodic (NDIM) logical, public :: is_stretching (NDIM) logical, public :: is_compact_scheme logical, public :: is_thermo logical, public :: is_conv_outlet logical, public :: is_record_xoutlet logical, public :: is_read_xinlet logical, public :: is_mhd integer, public :: idom integer, public :: icase integer, public :: icoordinate integer, public :: ifft_lib integer, public :: icht integer, public :: iTimeScheme integer, public :: iviscous integer, public :: iAccuracy integer, public :: ckpt_nfre integer, public :: visu_nfre integer, public :: visu_idim integer, public :: visu_nskip (NDIM) integer, public :: stat_istart integer, public :: stat_nskip (NDIM) integer, public :: nsubitr integer, public :: istret integer, public :: mstret integer, public :: ndbfre integer, public :: ndbend integer, public :: nc (NDIM) integer, public :: np_geo (NDIM) integer, public :: np (NDIM) integer, public :: proben integer, public :: ibcx_qx (2) integer, public :: ibcy_qx (2) integer, public :: ibcz_qx (2) integer, public :: ibcx_qy (2) integer, public :: ibcy_qy (2) integer, public :: ibcz_qy (2) integer, public :: ibcx_qz (2) integer, public :: ibcy_qz (2) integer, public :: ibcz_qz (2) integer, public :: ibcx_pr (2) integer, public :: ibcy_pr (2) integer, public :: ibcz_pr (2) integer, public :: ibcx_Tm (2) integer, public :: ibcy_Tm (2) integer, public :: ibcz_Tm (2) integer, public :: ibcx_ftp (2) integer, public :: ibcy_ftp (2) integer, public :: ibcz_ftp (2) integer, public :: ibcx_nominal (2,NBC) integer, public :: ibcy_nominal (2,NBC) integer, public :: ibcz_nominal (2,NBC) real(kind=wp), public :: fbcx_const (2,NBC) real(kind=wp), public :: fbcy_const (2,NBC) real(kind=wp), public :: fbcz_const (2,NBC) real(kind=wp), public :: lxx real(kind=wp), public :: lyt real(kind=wp), public :: lyb real(kind=wp), public :: lzz real(kind=WP), public :: rstret real(kind=wp), public :: dt real(kind=wp), public :: h (NDIM) real(kind=wp), public :: h1r (NDIM) real(kind=wp), public :: h2r (NDIM) real(kind=wp), public :: tGamma (0:3) real(kind=wp), public :: tZeta (0:3) real(kind=wp), public :: tAlpha (0:3) real(kind=wp), public :: sigma1p real(kind=wp), public :: sigma2p type(DECOMP_INFO), public :: dccc type(DECOMP_INFO), public :: dpcc type(DECOMP_INFO), public :: dcpc type(DECOMP_INFO), public :: dccp type(DECOMP_INFO), public :: dppc type(DECOMP_INFO), public :: dpcp type(DECOMP_INFO), public :: dcpp type(DECOMP_INFO), public :: dppp type(DECOMP_INFO), public :: d4cc type(DECOMP_INFO), public :: d4pc type(DECOMP_INFO), public :: dxcc type(DECOMP_INFO), public :: dxpc type(DECOMP_INFO), public :: dxcp real(kind=wp), public, allocatable :: yMappingpt (:,:) real(kind=wp), public, allocatable :: yMappingcc (:,:) real(kind=wp), public, allocatable :: yp (:) real(kind=wp), public, allocatable :: yc (:) real(kind=wp), public, allocatable :: rc (:) real(kind=wp), public, allocatable :: rp (:) real(kind=wp), public, allocatable :: rci (:) real(kind=wp), public, allocatable :: rpi (:) integer, public, allocatable :: ijnp_sym (:) integer, public, allocatable :: ijnc_sym (:) integer, public, allocatable :: knc_sym (:) real(kind=wp), public, allocatable :: fbcx_qx (:,:,:) real(kind=wp), public, allocatable :: fbcy_qx (:,:,:) real(kind=wp), public, allocatable :: fbcz_qx (:,:,:) real(kind=wp), public, allocatable :: fbcx_gx (:,:,:) real(kind=wp), public, allocatable :: fbcy_gx (:,:,:) real(kind=wp), public, allocatable :: fbcz_gx (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy (:,:,:) real(kind=wp), public, allocatable :: fbcy_qy (:,:,:) real(kind=wp), public, allocatable :: fbcz_qy (:,:,:) real(kind=wp), public, allocatable :: fbcy_qyr (:,:,:) real(kind=wp), public, allocatable :: fbcz_qyr (:,:,:) real(kind=wp), public, allocatable :: fbcx_gy (:,:,:) real(kind=wp), public, allocatable :: fbcy_gy (:,:,:) real(kind=wp), public, allocatable :: fbcz_gy (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz (:,:,:) real(kind=wp), public, allocatable :: fbcy_qz (:,:,:) real(kind=wp), public, allocatable :: fbcz_qz (:,:,:) real(kind=wp), public, allocatable :: fbcy_qzr (:,:,:) real(kind=wp), public, allocatable :: fbcz_qzr (:,:,:) real(kind=wp), public, allocatable :: fbcx_gz (:,:,:) real(kind=wp), public, allocatable :: fbcy_gz (:,:,:) real(kind=wp), public, allocatable :: fbcz_gz (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr (:,:,:) real(kind=wp), public, allocatable :: fbcy_pr (:,:,:) real(kind=wp), public, allocatable :: fbcz_pr (:,:,:) real(kind=wp), public, allocatable :: fbcx_qw (:,:,:) real(kind=wp), public, allocatable :: fbcy_qw (:,:,:) real(kind=wp), public, allocatable :: fbcz_qw (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_inl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_inl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_inl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_inl2 (:,:,:) type( t_fluidThermoProperty ), public, allocatable :: fbcx_ftp (:,:,:) type( t_fluidThermoProperty ), public, allocatable :: fbcy_ftp (:,:,:) type( t_fluidThermoProperty ), public, allocatable :: fbcz_ftp (:,:,:) real(kind=WP), public, allocatable :: probexyz (:,:) logical, public, allocatable :: probe_is_in (:) integer, public, allocatable :: probexid (:,:)","tags":"","url":"type/t_domain.html"},{"title":"t_flow – CHAPSim2 ","text":"type, public :: t_flow Components Type Visibility Attributes Name Initial integer, public :: idriven integer, public :: igravity integer, public :: inittype integer, public :: iterfrom integer, public :: initReTo integer, public :: nIterFlowStart integer, public :: nIterFlowEnd integer, public :: iteration real(kind=WP), public :: time real(kind=WP), public :: ren real(kind=WP), public :: rre real(kind=WP), public :: init_velo3d (NDIM) real(kind=wp), public :: reninit real(kind=WP), public :: drvfc real(kind=WP), public :: fgravity (NDIM) real(kind=wp), public :: noiselevel real(kind=wp), public :: mcon (3) real(kind=wp), public :: tt_mass_change real(kind=wp), public :: tt_kinetic_energy real(kind=WP), public, allocatable :: qx (:,:,:) real(kind=WP), public, allocatable :: qy (:,:,:) real(kind=WP), public, allocatable :: qz (:,:,:) real(kind=WP), public, allocatable :: gx (:,:,:) real(kind=WP), public, allocatable :: gy (:,:,:) real(kind=WP), public, allocatable :: gz (:,:,:) real(kind=WP), public, allocatable :: gx0 (:,:,:) real(kind=WP), public, allocatable :: gy0 (:,:,:) real(kind=WP), public, allocatable :: gz0 (:,:,:) real(kind=WP), public, allocatable :: pres (:,:,:) real(kind=WP), public, allocatable :: pcor (:,:,:) real(kind=WP), public, allocatable :: pcor_zpencil_ggg (:,:,:) real(kind=WP), public, allocatable :: dDens (:,:,:) real(kind=WP), public, allocatable :: drhodt (:,:,:) real(kind=WP), public, allocatable :: mVisc (:,:,:) real(kind=WP), public, allocatable :: dDensm1 (:,:,:) real(kind=WP), public, allocatable :: dDensm2 (:,:,:) real(kind=WP), public, allocatable :: mx_rhs (:,:,:) real(kind=WP), public, allocatable :: my_rhs (:,:,:) real(kind=WP), public, allocatable :: mz_rhs (:,:,:) real(kind=WP), public, allocatable :: mx_rhs0 (:,:,:) real(kind=WP), public, allocatable :: my_rhs0 (:,:,:) real(kind=WP), public, allocatable :: mz_rhs0 (:,:,:) real(kind=WP), public, allocatable :: fbcx_qx_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_qy_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_qz_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_gx_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_gy_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_gz_rhs0 (:,:) real(kind=WP), public, allocatable :: lrfx (:,:,:) real(kind=WP), public, allocatable :: lrfy (:,:,:) real(kind=WP), public, allocatable :: lrfz (:,:,:) real(kind=WP), public, allocatable :: u_vector_mean (:,:,:,:) real(kind=WP), public, allocatable :: pr_mean (:,:,:) real(kind=WP), public, allocatable :: uu_tensor6_mean (:,:,:,:)","tags":"","url":"type/t_flow.html"},{"title":"t_thermo – CHAPSim2 ","text":"type, public :: t_thermo Components Type Visibility Attributes Name Initial integer, public :: ifluid integer, public :: inittype integer, public :: iterfrom integer, public :: iteration integer, public :: nIterThermoStart integer, public :: nIterThermoEnd real(kind=WP), public :: ref_l0 real(kind=WP), public :: ref_T0 real(kind=WP), public :: init_T0 real(kind=WP), public :: time real(kind=WP), public :: rPrRen real(kind=WP), public :: tt_enthalpy real(kind=WP), public, allocatable :: rhoh (:,:,:) real(kind=WP), public, allocatable :: hEnth (:,:,:) real(kind=WP), public, allocatable :: kCond (:,:,:) real(kind=WP), public, allocatable :: tTemp (:,:,:) real(kind=WP), public, allocatable :: ene_rhs (:,:,:) real(kind=WP), public, allocatable :: ene_rhs0 (:,:,:) real(kind=WP), public, allocatable :: fbcx_rhoh_rhs0 (:,:) real(kind=WP), public, allocatable :: t_mean (:,:,:) real(kind=WP), public, allocatable :: tt_mean (:,:,:) type( t_fluidThermoProperty ), public :: ftp_ini","tags":"","url":"type/t_thermo.html"},{"title":"t_mhd – CHAPSim2 ","text":"type, public :: t_mhd Components Type Visibility Attributes Name Initial logical, public :: is_NStuart logical, public :: is_NHartmn real(kind=WP), public :: NStuart real(kind=WP), public :: NHartmn real(kind=WP), public :: B_static (3) real(kind=WP), public, allocatable :: ep (:,:,:) real(kind=WP), public, allocatable :: jx (:,:,:) real(kind=WP), public, allocatable :: jy (:,:,:) real(kind=WP), public, allocatable :: jz (:,:,:) real(kind=WP), public, allocatable :: bx (:,:,:) real(kind=WP), public, allocatable :: by (:,:,:) real(kind=WP), public, allocatable :: bz (:,:,:) integer, public :: ibcx_ep (2) integer, public :: ibcy_ep (2) integer, public :: ibcz_ep (2) integer, public :: ibcx_jx (2) integer, public :: ibcy_jx (2) integer, public :: ibcz_jx (2) integer, public :: ibcx_jy (2) integer, public :: ibcy_jy (2) integer, public :: ibcz_jy (2) integer, public :: ibcx_jz (2) integer, public :: ibcy_jz (2) integer, public :: ibcz_jz (2) integer, public :: ibcx_bx (2) integer, public :: ibcy_bx (2) integer, public :: ibcz_bx (2) integer, public :: ibcx_by (2) integer, public :: ibcy_by (2) integer, public :: ibcz_by (2) integer, public :: ibcx_bz (2) integer, public :: ibcy_bz (2) integer, public :: ibcz_bz (2) real(kind=WP), public, allocatable :: fbcx_ep (:,:,:) real(kind=WP), public, allocatable :: fbcy_ep (:,:,:) real(kind=WP), public, allocatable :: fbcz_ep (:,:,:) real(kind=WP), public, allocatable :: fbcx_jx (:,:,:) real(kind=WP), public, allocatable :: fbcy_jx (:,:,:) real(kind=WP), public, allocatable :: fbcz_jx (:,:,:) real(kind=WP), public, allocatable :: fbcx_jy (:,:,:) real(kind=WP), public, allocatable :: fbcy_jy (:,:,:) real(kind=WP), public, allocatable :: fbcz_jy (:,:,:) real(kind=WP), public, allocatable :: fbcx_jz (:,:,:) real(kind=WP), public, allocatable :: fbcy_jz (:,:,:) real(kind=WP), public, allocatable :: fbcz_jz (:,:,:) real(kind=WP), public, allocatable :: fbcx_bx (:,:,:) real(kind=WP), public, allocatable :: fbcy_bx (:,:,:) real(kind=WP), public, allocatable :: fbcz_bx (:,:,:) real(kind=WP), public, allocatable :: fbcx_by (:,:,:) real(kind=WP), public, allocatable :: fbcy_by (:,:,:) real(kind=WP), public, allocatable :: fbcz_by (:,:,:) real(kind=WP), public, allocatable :: fbcx_bz (:,:,:) real(kind=WP), public, allocatable :: fbcy_bz (:,:,:) real(kind=WP), public, allocatable :: fbcz_bz (:,:,:)","tags":"","url":"type/t_mhd.html"},{"title":"Test_algorithms – CHAPSim2","text":"subroutine Test_algorithms() Uses vars_df_mod geometry_mod boundary_conditions_mod mpi_mod operations burgers_eq_mod tridiagonal_matrix_algorithm \\brief In-code independent test code for algorithms and schemes This subroutine is only called in the main program for testing.\nPlease select the test options which you are interested in.\n\\param[in]     none          NA\n\\param[out]    none          NA Arguments None","tags":"","url":"proc/test_algorithms.html"},{"title":"test_poisson – CHAPSim2","text":"subroutine test_poisson(dm) Uses udf_type_mod boundary_conditions_mod poisson_interface_mod operations math_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/test_poisson.html"},{"title":"profile_interpolation – CHAPSim2","text":"subroutine profile_interpolation(nin, yin, uin, nout, ycase, ucase) Uses print_msg_mod cubic_spline_interpolation precision_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: nin real(kind=WP), intent(in), dimension(nin) :: yin real(kind=WP), intent(in), dimension(nin) :: uin integer, intent(in) :: nout real(kind=WP), intent(in), dimension(nout) :: ycase real(kind=WP), intent(out), dimension(nout) :: ucase","tags":"","url":"proc/profile_interpolation.html"},{"title":"initialise_chapsim – CHAPSim2","text":"subroutine initialise_chapsim() Uses apx_prerun_mod continuity_eq_mod io_visualisation_mod domain_decomposition_mod geometry_mod boundary_conditions_mod poisson_interface_mod flow_thermo_initialiasation input_general_mod wrt_debug_field_mod code_performance_mod mpi_mod operations solver_tools_mod thermo_info_mod eq_momentum_mod io_files_mod mhd_mod \\brief Initialisation and preprocessing of geometry, mesh and tools\nThis subroutine is called at beginning of the main program Arguments None","tags":"","url":"proc/initialise_chapsim.html"},{"title":"Solve_eqs_iteration – CHAPSim2","text":"subroutine Solve_eqs_iteration() Uses continuity_eq_mod vars_df_mod typeconvert_mod mhd_mod eq_energy_mod flow_thermo_initialiasation thermo_info_mod statistics_mod code_performance_mod io_monitor_mod io_restart_mod boundary_conditions_mod input_general_mod mpi_mod io_tools_mod eq_momentum_mod solver_tools_mod wtformat_mod find_max_min_ave_mod io_visualisation_mod \\brief solve the governing equations in iteration This subroutine is the main solver. \\param[in]     none          NA\n\\param[out]    none          NA Arguments None","tags":"","url":"proc/solve_eqs_iteration.html"},{"title":"Finalise_chapsim – CHAPSim2","text":"subroutine Finalise_chapsim() Uses code_performance_mod mpi_mod Arguments None","tags":"","url":"proc/finalise_chapsim.html"},{"title":"rl – CHAPSim2","text":"function rl(complexnumber) Uses decomp_2d_mpi Arguments Type Intent Optional Attributes Name complex(kind=mytype) :: complexnumber Return Value real(kind=mytype)","tags":"","url":"proc/rl.html"},{"title":"iy – CHAPSim2","text":"function iy(complexnumber) Uses decomp_2d_constants Arguments Type Intent Optional Attributes Name complex(kind=mytype) :: complexnumber Return Value real(kind=mytype)","tags":"","url":"proc/iy.html"},{"title":"cx – CHAPSim2","text":"function cx(realpart, imaginarypart) Uses decomp_2d_constants Arguments Type Intent Optional Attributes Name real(kind=mytype) :: realpart real(kind=mytype) :: imaginarypart Return Value complex(kind=mytype)","tags":"","url":"proc/cx.html"},{"title":"inversion5_v1 – CHAPSim2","text":"subroutine inversion5_v1(aaa_in, eee, spI) Uses fft2decomp_interface_mod decomp_2d Arguments Type Intent Optional Attributes Name complex(kind=mytype), dimension(spI%yst(1):spI%yen(1),ny/2,spI%yst(3):spI%yen(3),5) :: aaa_in complex(kind=mytype), dimension(spI%yst(1):spI%yen(1),spI%yst(2):spI%yen(2),spI%yst(3):spI%yen(3)) :: eee type(DECOMP_INFO) :: spI","tags":"","url":"proc/inversion5_v1.html"},{"title":"inversion5_v2 – CHAPSim2","text":"subroutine inversion5_v2(aaa, eee, spI) Uses fft2decomp_interface_mod decomp_2d Arguments Type Intent Optional Attributes Name complex(kind=mytype), dimension(spI%yst(1):spI%yen(1),nym,spI%yst(3):spI%yen(3),5) :: aaa complex(kind=mytype), dimension(spI%yst(1):spI%yen(1),nym,spI%yst(3):spI%yen(3)) :: eee type(DECOMP_INFO) :: spI","tags":"","url":"proc/inversion5_v2.html"},{"title":"ypencil_index_lgl2ggl – CHAPSim2","text":"public  subroutine ypencil_index_lgl2ggl(vin, vou, dtmp) Uses decomp_2d Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%ysz(1),               dtmp%ysz(2), dtmp%ysz(3)) :: vin real(kind=WP), intent(out), dimension(dtmp%yst(1) : dtmp%yen(2), dtmp%ysz(2), dtmp%zsz(3)) :: vou type(DECOMP_INFO), intent(in) :: dtmp","tags":"","url":"proc/ypencil_index_lgl2ggl.html"},{"title":"zpencil_index_llg2ggg – CHAPSim2","text":"public  subroutine zpencil_index_llg2ggg(vin, vou, dtmp) Uses decomp_2d Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%zsz(1),               dtmp%zsz(2),               dtmp%zsz(3)) :: vin real(kind=WP), intent(out), dimension(dtmp%zst(1) : dtmp%zen(1), dtmp%zst(2) : dtmp%zen(2), dtmp%zsz(3)) :: vou type(DECOMP_INFO), intent(in) :: dtmp","tags":"","url":"proc/zpencil_index_llg2ggg.html"},{"title":"zpencil_index_ggg2llg – CHAPSim2","text":"public  subroutine zpencil_index_ggg2llg(vin, vou, dtmp) Uses decomp_2d Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%zst(1) : dtmp%zen(1), dtmp%zst(2) : dtmp%zen(2), dtmp%zsz(3)) :: vin real(kind=WP), intent(out), dimension(dtmp%zsz(1),               dtmp%zsz(2),               dtmp%zsz(3)) :: vou type(DECOMP_INFO), intent(in) :: dtmp","tags":"","url":"proc/zpencil_index_ggg2llg.html"},{"title":"initialise_fft – CHAPSim2","text":"public  subroutine initialise_fft(dm) Uses udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm","tags":"","url":"proc/initialise_fft.html"},{"title":"solve_fft_poisson – CHAPSim2","text":"public  subroutine solve_fft_poisson(rhs_xpencil, dm) Uses udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ) :: rhs_xpencil type( t_domain ), intent(in) :: dm","tags":"","url":"proc/solve_fft_poisson.html"},{"title":"ftp_refresh_thermal_properties_from_T_undim_3D – CHAPSim2","text":"public  subroutine ftp_refresh_thermal_properties_from_T_undim_3D(ftp3d) Arguments Type Intent Optional Attributes Name type( t_fluidThermoProperty ), intent(inout) :: ftp3d (:,:,:)","tags":"","url":"proc/ftp_refresh_thermal_properties_from_t_undim_3d.html"},{"title":"ftp_refresh_thermal_properties_from_DH – CHAPSim2","text":"public  subroutine ftp_refresh_thermal_properties_from_DH(this) \\brief Defination of a procedure in the type t_fluidThermoProperty.\n to update the thermal properties based on the known enthalpy per unit mass. This subroutine is called as required to update all thermal properties from\nthe known enthalpy per unit mass (dimensionless only). \\param[inout]  this          a cell element with udf property Arguments Type Intent Optional Attributes Name type( t_fluidThermoProperty ), intent(inout) :: this","tags":"","url":"proc/ftp_refresh_thermal_properties_from_dh.html"},{"title":"Convert_thermal_input_2undim – CHAPSim2","text":"public  subroutine Convert_thermal_input_2undim(tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/convert_thermal_input_2undim.html"},{"title":"initialise_thermal_properties – CHAPSim2","text":"public  subroutine initialise_thermal_properties(fl, tm) \\brief Initialise thermal variables if ithermo = 1. Scope:  mpi    called-freq    xdomain     module\n        all    once           specified   private\n\\param[inout]  fl   flow type\n\\param[inout]  tm   thermo type Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm","tags":"","url":"proc/initialise_thermal_properties.html"},{"title":"Buildup_thermo_mapping_relations – CHAPSim2","text":"public  subroutine Buildup_thermo_mapping_relations(tm) \\brief Initialise thermal variables if ithermo = 1. Scope:  mpi    called-freq    xdomain     module\n        all    once           specified   private\n\\param[inout]  fl   flow type\n\\param[inout]  tm   thermo type\n\\brief The main code for thermal property initialisation.\nScope:  mpi    called-freq    xdomain\n        all    once           all\n\\param[inout]  none          NA Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm","tags":"","url":"proc/buildup_thermo_mapping_relations.html"},{"title":"Preprocess_TDMA_coeffs – CHAPSim2","text":"public  subroutine Preprocess_TDMA_coeffs(a, b, c, d, n) Uses parameters_constant_mod math_mod precision_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: a (n) real(kind=WP), intent(in) :: b (n) real(kind=WP), intent(inout) :: c (n) real(kind=WP), intent(out) :: d (n) integer, intent(in) :: n","tags":"","url":"proc/preprocess_tdma_coeffs.html"},{"title":"Solve_TDMA – CHAPSim2","text":"public  subroutine Solve_TDMA(peri, x, a, b, c, d, n) Uses input_general_mod precision_mod Arguments Type Intent Optional Attributes Name logical, intent(in) :: peri real(kind=WP), intent(inout) :: x (n) real(kind=WP), intent(in) :: a (n) real(kind=WP), intent(in) :: b (n) real(kind=WP), intent(in) :: c (n) real(kind=WP), intent(in) :: d (n) integer, intent(in) :: n","tags":"","url":"proc/solve_tdma.html"},{"title":"Test_TDMA_noncyclic – CHAPSim2","text":"public  subroutine Test_TDMA_noncyclic() Uses math_mod precision_mod Arguments None","tags":"","url":"proc/test_tdma_noncyclic.html"},{"title":"Test_TDMA_cyclic – CHAPSim2","text":"public  subroutine Test_TDMA_cyclic() Uses math_mod precision_mod Arguments None","tags":"","url":"proc/test_tdma_cyclic.html"},{"title":"write_visu_ini – CHAPSim2","text":"public  subroutine write_visu_ini(dm) Uses parameters_constant_mod udf_type_mod typeconvert_mod iso_fortran_env decomp_2d io_files_mod math_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_visu_ini.html"},{"title":"write_visu_flow – CHAPSim2","text":"public  subroutine write_visu_flow(fl, dm, suffix) Uses parameters_constant_mod precision_mod operations udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm character(len=4), intent(in), optional :: suffix","tags":"","url":"proc/write_visu_flow.html"},{"title":"write_visu_thermo – CHAPSim2","text":"public  subroutine write_visu_thermo(tm, fl, dm, str) Uses precision_mod operations udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm character(len=4), intent(in), optional :: str","tags":"","url":"proc/write_visu_thermo.html"},{"title":"write_visu_mhd – CHAPSim2","text":"public  subroutine write_visu_mhd(mh, fl, dm, suffix) Uses parameters_constant_mod precision_mod operations udf_type_mod Arguments Type Intent Optional Attributes Name type( t_mhd ), intent(in) :: mh type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm character(len=4), intent(in), optional :: suffix","tags":"","url":"proc/write_visu_mhd.html"},{"title":"write_visu_stats_flow – CHAPSim2","text":"public  subroutine write_visu_stats_flow(fl, dm) Uses precision_mod operations udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_visu_stats_flow.html"},{"title":"write_visu_stats_thermo – CHAPSim2","text":"public  subroutine write_visu_stats_thermo(tm, dm) Uses precision_mod operations udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_visu_stats_thermo.html"},{"title":"write_visu_any3darray – CHAPSim2","text":"public  subroutine write_visu_any3darray(var, varname, visuname, dtmp, dm, iter) Uses parameters_constant_mod udf_type_mod precision_mod operations io_files_mod decomp_operation_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension( dtmp%xsz(1), dtmp%xsz(2), dtmp%xsz(3) ) :: var character(len=*), intent(in) :: varname character(len=*), intent(in) :: visuname type(DECOMP_INFO), intent(in) :: dtmp type( t_domain ), intent(in) :: dm integer, intent(in) :: iter","tags":"","url":"proc/write_visu_any3darray.html"},{"title":"initialise_decomp_io – CHAPSim2","text":"public  subroutine initialise_decomp_io(dm) Uses decomp_2d_io udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm","tags":"","url":"proc/initialise_decomp_io.html"},{"title":"generate_pathfile_name – CHAPSim2","text":"public  subroutine generate_pathfile_name(flname_path, dmtag, keyword, path, extension, opt_timetag, opt_flname) Uses typeconvert_mod Arguments Type Intent Optional Attributes Name character(len=120), intent(out) :: flname_path integer, intent(in) :: dmtag character(len=*), intent(in) :: keyword character(len=*), intent(in) :: path character(len=*), intent(in) :: extension integer, intent(in), optional :: opt_timetag character(len=120), intent(inout), optional :: opt_flname","tags":"","url":"proc/generate_pathfile_name.html"},{"title":"generate_file_name – CHAPSim2","text":"public  subroutine generate_file_name(flname, dmtag, keyword, extension, timetag) Uses typeconvert_mod Arguments Type Intent Optional Attributes Name character(len=120), intent(out) :: flname integer, intent(in) :: dmtag character(len=*), intent(in) :: keyword character(len=*), intent(in) :: extension integer, intent(in), optional :: timetag","tags":"","url":"proc/generate_file_name.html"},{"title":"Solve_momentum_eq – CHAPSim2","text":"public  subroutine Solve_momentum_eq(fl, dm, isub) Uses continuity_eq_mod parameters_constant_mod udf_type_mod typeconvert_mod boundary_conditions_mod mpi_mod solver_tools_mod operations wtformat_mod io_visulisation_mod \\brief To update the provisional u or rho u. \\param[inout]  fl            flow field\n\\param[inout]  dm            domain\n\\param[in]     isub         RK sub-iteration Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"proc/solve_momentum_eq.html"},{"title":"initialise_burgers_flow – CHAPSim2","text":"public  subroutine initialise_burgers_flow(dm, ux, uy, uz, p) Uses parameters_constant_mod math_mod input_general_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm real(kind=WP), intent(inout) :: ux (:,:,:) real(kind=WP), intent(inout) :: uy (:,:,:) real(kind=WP), intent(inout) :: uz (:,:,:) real(kind=WP), intent(inout) :: p (:,:,:)","tags":"","url":"proc/initialise_burgers_flow.html"},{"title":"Plot_burgers_profile – CHAPSim2","text":"public  subroutine Plot_burgers_profile(fl, dm, iter) Uses parameters_constant_mod udf_type_mod typeconvert_mod input_general_mod mpi_mod operations io_files_mod math_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm integer, intent(in) :: iter","tags":"","url":"proc/plot_burgers_profile.html"},{"title":"Solve_burgers_eq_iteration – CHAPSim2","text":"public  subroutine Solve_burgers_eq_iteration() Uses parameters_constant_mod vars_df_mod input_general_mod code_performance_mod mpi_mod thermo_info_mod solver_tools_mod Arguments None","tags":"","url":"proc/solve_burgers_eq_iteration.html"},{"title":"initialise_mpi – CHAPSim2","text":"public  subroutine initialise_mpi() \\brief mpi initialisation. this initialisation is a simple one.\n\\param[in]     d          domain type Arguments None","tags":"","url":"proc/initialise_mpi.html"},{"title":"Finalise_mpi – CHAPSim2","text":"public  subroutine Finalise_mpi() Arguments None","tags":"","url":"proc/finalise_mpi.html"},{"title":"file_exists – CHAPSim2","text":"public  function file_exists(filename) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","url":"proc/file_exists.html"},{"title":"create_directory – CHAPSim2","text":"public  subroutine create_directory() Arguments None","tags":"","url":"proc/create_directory.html"},{"title":"operator( .f. ) – CHAPSim2","text":"public interface operator( .f. ) Module Procedures public  function file_exists (filename) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","url":"interface/operator( .f. ).html"},{"title":"abs_sp – CHAPSim2","text":"public elemental function abs_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/abs_sp.html"},{"title":"abs_dp – CHAPSim2","text":"public elemental function abs_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/abs_dp.html"},{"title":"abs_csp – CHAPSim2","text":"public elemental function abs_csp(r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/abs_csp.html"},{"title":"abs_cdp – CHAPSim2","text":"public elemental function abs_cdp(r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/abs_cdp.html"},{"title":"sqrt_sp – CHAPSim2","text":"public pure function sqrt_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/sqrt_sp.html"},{"title":"sqrt_dp – CHAPSim2","text":"public pure function sqrt_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/sqrt_dp.html"},{"title":"sin_sp – CHAPSim2","text":"public pure function sin_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/sin_sp.html"},{"title":"sin_dp – CHAPSim2","text":"public pure function sin_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/sin_dp.html"},{"title":"cos_sp – CHAPSim2","text":"public pure function cos_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/cos_sp.html"},{"title":"cos_dp – CHAPSim2","text":"public pure function cos_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/cos_dp.html"},{"title":"tanh_sp – CHAPSim2","text":"public pure function tanh_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/tanh_sp.html"},{"title":"tanh_dp – CHAPSim2","text":"public pure function tanh_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/tanh_dp.html"},{"title":"tan_sp – CHAPSim2","text":"public pure function tan_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/tan_sp.html"},{"title":"tan_dp – CHAPSim2","text":"public pure function tan_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/tan_dp.html"},{"title":"atan_sp – CHAPSim2","text":"public pure function atan_sp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P)","tags":"","url":"proc/atan_sp.html"},{"title":"atan_dp – CHAPSim2","text":"public pure function atan_dp(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"proc/atan_dp.html"},{"title":"heaviside_step – CHAPSim2","text":"public pure function heaviside_step(r) result(d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: r Return Value real(kind=WP)","tags":"","url":"proc/heaviside_step.html"},{"title":"sqrt_wp – CHAPSim2","text":"public interface sqrt_wp Module Procedures public pure function sqrt_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sqrt_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/sqrt_wp.html"},{"title":"tanh_wp – CHAPSim2","text":"public interface tanh_wp Module Procedures public pure function tanh_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function tanh_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/tanh_wp.html"},{"title":"abs_wp – CHAPSim2","text":"public interface abs_wp Module Procedures public elemental function abs_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/abs_wp.html"},{"title":"abs_prec – CHAPSim2","text":"public interface abs_prec Module Procedures public elemental function abs_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public elemental function abs_csp (r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_cdp (r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/abs_prec.html"},{"title":"sin_wp – CHAPSim2","text":"public interface sin_wp Module Procedures public pure function sin_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sin_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/sin_wp.html"},{"title":"sin_prec – CHAPSim2","text":"public interface sin_prec Module Procedures public pure function sin_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sin_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/sin_prec.html"},{"title":"cos_wp – CHAPSim2","text":"public interface cos_wp Module Procedures public pure function cos_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function cos_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/cos_wp.html"},{"title":"cos_prec – CHAPSim2","text":"public interface cos_prec Module Procedures public pure function cos_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function cos_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/cos_prec.html"},{"title":"tan_wp – CHAPSim2","text":"public interface tan_wp Module Procedures public pure function tan_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function tan_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/tan_wp.html"},{"title":"atan_wp – CHAPSim2","text":"public interface atan_wp Module Procedures public pure function atan_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function atan_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P)","tags":"","url":"interface/atan_wp.html"},{"title":"int2str – CHAPSim2","text":"public  function int2str(k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k Return Value character(len=20)","tags":"","url":"proc/int2str.html"},{"title":"real2str – CHAPSim2","text":"public  function real2str(r) Uses precision_mod Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value character(len=20)","tags":"","url":"proc/real2str.html"},{"title":"is_even – CHAPSim2","text":"public  function is_even(number) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Return Value logical","tags":"","url":"proc/is_even.html"},{"title":"flatten_3d_to_1d – CHAPSim2","text":"public  function flatten_3d_to_1d(i, j, k, Nx, Ny) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: Nx integer, intent(in) :: Ny Return Value integer","tags":"","url":"proc/flatten_3d_to_1d.html"},{"title":"flatten_2d_to_1d – CHAPSim2","text":"public  function flatten_2d_to_1d(i, j, Nx) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: Nx Return Value integer","tags":"","url":"proc/flatten_2d_to_1d.html"},{"title":"flatten_index – CHAPSim2","text":"public interface flatten_index Module Procedures public  function flatten_3d_to_1d (i, j, k, Nx, Ny) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: Nx integer, intent(in) :: Ny Return Value integer public  function flatten_2d_to_1d (i, j, Nx) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: Nx Return Value integer","tags":"","url":"interface/flatten_index.html"},{"title":"Prepare_LHS_coeffs_for_operations – CHAPSim2","text":"public  subroutine Prepare_LHS_coeffs_for_operations() Uses mpi_mod parameters_constant_mod vars_df_mod \\brief Preparing coefficients for TDMA calculation.\nScope:  mpi    called-freq    xdomain\n        all    once           all Arguments None","tags":"","url":"proc/prepare_lhs_coeffs_for_operations.html"},{"title":"Get_x_midp_C2P_3D – CHAPSim2","text":"public  subroutine Get_x_midp_C2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod \\brief To caculate the mid-point interpolation in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_midp_c2p_3d.html"},{"title":"Get_x_midp_P2C_3D – CHAPSim2","text":"public  subroutine Get_x_midp_P2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_midp_p2c_3d.html"},{"title":"Get_y_midp_C2P_3D – CHAPSim2","text":"public  subroutine Get_y_midp_C2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_midp_c2p_3d.html"},{"title":"Get_y_midp_P2C_3D – CHAPSim2","text":"public  subroutine Get_y_midp_P2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_midp_p2c_3d.html"},{"title":"Get_z_midp_C2P_3D – CHAPSim2","text":"public  subroutine Get_z_midp_C2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_midp_c2p_3d.html"},{"title":"Get_z_midp_P2C_3D – CHAPSim2","text":"public  subroutine Get_z_midp_P2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_midp_p2c_3d.html"},{"title":"Get_x_1st_derivative_C2C_3D – CHAPSim2","text":"public  subroutine Get_x_1st_derivative_C2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod \\brief To caculate the 1st-deriviate in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1st_derivative_c2c_3d.html"},{"title":"Get_x_1st_derivative_P2P_3D – CHAPSim2","text":"public  subroutine Get_x_1st_derivative_P2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1st_derivative_p2p_3d.html"},{"title":"Get_x_1st_derivative_C2P_3D – CHAPSim2","text":"public  subroutine Get_x_1st_derivative_C2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1st_derivative_c2p_3d.html"},{"title":"Get_x_1st_derivative_P2C_3D – CHAPSim2","text":"public  subroutine Get_x_1st_derivative_P2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1st_derivative_p2c_3d.html"},{"title":"Get_y_1st_derivative_C2C_3D – CHAPSim2","text":"public  subroutine Get_y_1st_derivative_C2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1st_derivative_c2c_3d.html"},{"title":"Get_y_1st_derivative_P2P_3D – CHAPSim2","text":"public  subroutine Get_y_1st_derivative_P2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1st_derivative_p2p_3d.html"},{"title":"Get_y_1st_derivative_C2P_3D – CHAPSim2","text":"public  subroutine Get_y_1st_derivative_C2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1st_derivative_c2p_3d.html"},{"title":"Get_y_1st_derivative_P2C_3D – CHAPSim2","text":"public  subroutine Get_y_1st_derivative_P2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1st_derivative_p2c_3d.html"},{"title":"Get_z_1st_derivative_C2C_3D – CHAPSim2","text":"public  subroutine Get_z_1st_derivative_C2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1st_derivative_c2c_3d.html"},{"title":"Get_z_1st_derivative_P2P_3D – CHAPSim2","text":"public  subroutine Get_z_1st_derivative_P2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1st_derivative_p2p_3d.html"},{"title":"Get_z_1st_derivative_C2P_3D – CHAPSim2","text":"public  subroutine Get_z_1st_derivative_C2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1st_derivative_c2p_3d.html"},{"title":"Get_z_1st_derivative_P2C_3D – CHAPSim2","text":"public  subroutine Get_z_1st_derivative_P2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1st_derivative_p2c_3d.html"},{"title":"Get_x_2nd_derivative_C2C_3D – CHAPSim2","text":"public  subroutine Get_x_2nd_derivative_C2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod \\brief To caculate the 2nd-deriviate in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_2nd_derivative_c2c_3d.html"},{"title":"Get_x_2nd_derivative_P2P_3D – CHAPSim2","text":"public  subroutine Get_x_2nd_derivative_P2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_2nd_derivative_p2p_3d.html"},{"title":"Get_y_2nd_derivative_C2C_3D – CHAPSim2","text":"public  subroutine Get_y_2nd_derivative_C2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_2nd_derivative_c2c_3d.html"},{"title":"Get_y_2nd_derivative_P2P_3D – CHAPSim2","text":"public  subroutine Get_y_2nd_derivative_P2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_2nd_derivative_p2p_3d.html"},{"title":"Get_z_2nd_derivative_C2C_3D – CHAPSim2","text":"public  subroutine Get_z_2nd_derivative_C2C_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_2nd_derivative_c2c_3d.html"},{"title":"Get_z_2nd_derivative_P2P_3D – CHAPSim2","text":"public  subroutine Get_z_2nd_derivative_P2P_3D(fi3d, fo3d, dm, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_2nd_derivative_p2p_3d.html"},{"title":"Test_interpolation – CHAPSim2","text":"public  subroutine Test_interpolation(dm) Uses EvenOdd_mod parameters_constant_mod math_mod udf_type_mod \\brief To test this subroutine for mid-point interpolation. This subroutine is called in \\ref Test_algorithms. Define the logicals to choose\nwhich test section is required. \\param[in]     d             domain Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/test_interpolation.html"},{"title":"Test_1st_derivative – CHAPSim2","text":"public  subroutine Test_1st_derivative(dm) Uses EvenOdd_mod parameters_constant_mod math_mod udf_type_mod \\brief To test this subroutine for mid-point interpolation. This subroutine is called in \\ref Test_algorithms. Define the logicals to choose\nwhich test section is required. \\param[in]     d             domain Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/test_1st_derivative.html"},{"title":"Test_2nd_derivative – CHAPSim2","text":"public  subroutine Test_2nd_derivative(dm) Uses EvenOdd_mod parameters_constant_mod math_mod udf_type_mod \\brief To test this subroutine for mid-point interpolation. This subroutine is called in \\ref Test_algorithms. Define the logicals to choose\nwhich test section is required. \\param[in]     d             domain Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/test_2nd_derivative.html"},{"title":"Print_error_msg – CHAPSim2","text":"public  subroutine Print_error_msg(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","url":"proc/print_error_msg.html"},{"title":"Print_warning_msg – CHAPSim2","text":"public  subroutine Print_warning_msg(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","url":"proc/print_warning_msg.html"},{"title":"Print_note_msg – CHAPSim2","text":"public  subroutine Print_note_msg(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","url":"proc/print_note_msg.html"},{"title":"Print_debug_start_msg – CHAPSim2","text":"public  subroutine Print_debug_start_msg(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg","tags":"","url":"proc/print_debug_start_msg.html"},{"title":"Print_debug_inline_msg – CHAPSim2","text":"public  subroutine Print_debug_inline_msg(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","url":"proc/print_debug_inline_msg.html"},{"title":"Print_debug_mid_msg – CHAPSim2","text":"public  subroutine Print_debug_mid_msg(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","url":"proc/print_debug_mid_msg.html"},{"title":"Print_debug_end_msg – CHAPSim2","text":"public  subroutine Print_debug_end_msg() Arguments None","tags":"","url":"proc/print_debug_end_msg.html"},{"title":"Print_3d_array – CHAPSim2","text":"public  subroutine Print_3d_array(var, nx, ny, nz, str) Uses precision_mod Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: var (nx,ny,nz) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz character(len=*), intent(in) :: str","tags":"","url":"proc/print_3d_array.html"},{"title":"is_same_decomp – CHAPSim2","text":"public  function is_same_decomp(a, b) result(f) Uses decomp_2d Arguments Type Intent Optional Attributes Name type(DECOMP_INFO), intent(in) :: a type(DECOMP_INFO), intent(in) :: b Return Value logical","tags":"","url":"proc/is_same_decomp.html"},{"title":"call_cpu_time – CHAPSim2","text":"public  subroutine call_cpu_time(itype, iterfrom, niter, iter) Arguments Type Intent Optional Attributes Name integer, intent(in) :: itype integer, intent(in) :: iterfrom integer, intent(in) :: niter integer, intent(in), optional :: iter","tags":"","url":"proc/call_cpu_time.html"},{"title":"spline_interpolation – CHAPSim2","text":"public  function spline_interpolation(n, yprofile, b, c, d, y) result(eval) Uses precision_mod evaluate spline interpolation Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(in) :: yprofile (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: d (n) real(kind=WP), intent(in) :: y Return Value real(kind=WP)","tags":"","url":"proc/spline_interpolation.html"},{"title":"cubic_spline – CHAPSim2","text":"public  subroutine cubic_spline(n, x, y, b, c, d) Uses precision_mod Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(in) :: y (n) real(kind=wp), intent(out) :: b (n) real(kind=wp), intent(out) :: c (n) real(kind=wp), intent(out) :: d (n)","tags":"","url":"proc/cubic_spline.html"},{"title":"initialise_random_number – CHAPSim2","text":"public  subroutine initialise_random_number(seed) random_initialise initialises the FORTRAN 90 random number seed. Arguments Type Intent Optional Attributes Name integer :: seed","tags":"","url":"proc/initialise_random_number.html"},{"title":"Generate_rvec_random – CHAPSim2","text":"public  subroutine Generate_rvec_random(alo, ahi, n, a) RVEC_random RETURNs a random REAL(WP) vector in a given range. Arguments Type Intent Optional Attributes Name real(kind=wp) :: alo real(kind=wp) :: ahi integer :: n real(kind=wp) :: a (n)","tags":"","url":"proc/generate_rvec_random.html"},{"title":"Generate_r_random – CHAPSim2","text":"public  subroutine Generate_r_random(rlo, rhi, r) R_random RETURNs a random REAL(WP) in a given range. Arguments Type Intent Optional Attributes Name real(kind=wp) :: rlo real(kind=wp) :: rhi real(kind=wp) :: r","tags":"","url":"proc/generate_r_random.html"},{"title":"wrt_3d_pt_debug – CHAPSim2","text":"public  subroutine wrt_3d_pt_debug(var, dtmp, iter, irk, loc) Uses io_files_mod print_msg_mod udf_type_mod precision_mod Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: var (dtmp%xsz(1),dtmp%xsz(2),dtmp%xsz(3)) type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: iter integer, intent(in) :: irk character(len=*), intent(in) :: loc","tags":"","url":"proc/wrt_3d_pt_debug.html"},{"title":"wrt_3d_all_debug – CHAPSim2","text":"public  subroutine wrt_3d_all_debug(var, dtmp, iter, str, loc) Uses io_files_mod print_msg_mod udf_type_mod precision_mod Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: var (dtmp%xsz(1),dtmp%xsz(2),dtmp%xsz(3)) type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: iter character(len=*), intent(in) :: str character(len=*), intent(in) :: loc","tags":"","url":"proc/wrt_3d_all_debug.html"},{"title":"axis_estimating_radial_xpx – CHAPSim2","text":"public  subroutine axis_estimating_radial_xpx(var, dtmp, pencil, dm, idir, is_reversed) Uses math_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: pencil type( t_domain ), intent(in) :: dm integer, intent(in) :: idir logical, intent(in), optional :: is_reversed","tags":"","url":"proc/axis_estimating_radial_xpx.html"},{"title":"multiple_cylindrical_rn – CHAPSim2","text":"public  subroutine multiple_cylindrical_rn(var, dtmp, r, n, pencil) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: r (:) integer, intent(in) :: n integer, intent(in) :: pencil","tags":"","url":"proc/multiple_cylindrical_rn.html"},{"title":"multiple_cylindrical_rn_xx4 – CHAPSim2","text":"public  subroutine multiple_cylindrical_rn_xx4(var, dtmp, r, n, pencil) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: r (:) integer, intent(in) :: n integer, intent(in) :: pencil","tags":"","url":"proc/multiple_cylindrical_rn_xx4.html"},{"title":"multiple_cylindrical_rn_x4x – CHAPSim2","text":"public  subroutine multiple_cylindrical_rn_x4x(var, dtmp, r, n, pencil) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: r (:) integer, intent(in) :: n integer, intent(in) :: pencil","tags":"","url":"proc/multiple_cylindrical_rn_x4x.html"},{"title":"is_valid_number_3D – CHAPSim2","text":"public  subroutine is_valid_number_3D(var, varname) Uses ieee_arithmetic parameters_constant_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) character(len=*), intent(in) :: varname","tags":"","url":"proc/is_valid_number_3d.html"},{"title":"Find_maximum_absvar3d – CHAPSim2","text":"public  subroutine Find_maximum_absvar3d(var, varmax_work, dtmp, str, nxst0) Uses parameters_constant_mod typeconvert_mod precision_mod mpi_mod wtformat_mod math_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: varmax_work type(DECOMP_INFO), intent(in) :: dtmp character(len=*), intent(in) :: str integer, intent(in), optional :: nxst0","tags":"","url":"proc/find_maximum_absvar3d.html"},{"title":"Find_max_min_3d – CHAPSim2","text":"public  subroutine Find_max_min_3d(var, str, fmt) Uses mpi_mod parameters_constant_mod math_mod precision_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) character(len=*), intent(in) :: str character(len=*), intent(in) :: fmt","tags":"","url":"proc/find_max_min_3d.html"},{"title":"Find_max_min_absvar3d – CHAPSim2","text":"public  subroutine Find_max_min_absvar3d(var, str, fmt) Uses mpi_mod parameters_constant_mod math_mod precision_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) character(len=*), intent(in) :: str character(len=*), intent(in) :: fmt","tags":"","url":"proc/find_max_min_absvar3d.html"},{"title":"Get_volumetric_average_3d_for_var_xcx – CHAPSim2","text":"public  subroutine Get_volumetric_average_3d_for_var_xcx(dm, dtmp, var, fo_work, itype, str) Uses parameters_constant_mod udf_type_mod mpi_mod wtformat_mod decomp_2d Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work integer, intent(in) :: itype character(len=*), intent(in), optional :: str","tags":"","url":"proc/get_volumetric_average_3d_for_var_xcx.html"},{"title":"Get_area_average_2d_for_fbcx – CHAPSim2","text":"public  subroutine Get_area_average_2d_for_fbcx(dm, dtmp, var, fo_work, itype, str) Uses parameters_constant_mod udf_type_mod mpi_mod wtformat_mod decomp_2d Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work (2) integer, intent(in) :: itype character(len=4), intent(in) :: str","tags":"","url":"proc/get_area_average_2d_for_fbcx.html"},{"title":"Get_area_average_2d_for_fbcz – CHAPSim2","text":"public  subroutine Get_area_average_2d_for_fbcz(dm, dtmp, var, fo_work, itype, str) Uses parameters_constant_mod udf_type_mod mpi_mod wtformat_mod decomp_2d Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work (2) integer, intent(in) :: itype character(len=4), intent(in) :: str","tags":"","url":"proc/get_area_average_2d_for_fbcz.html"},{"title":"Get_area_average_2d_for_fbcy – CHAPSim2","text":"public  subroutine Get_area_average_2d_for_fbcy(dm, dtmp, var, fo_work, itype, str) Uses parameters_constant_mod udf_type_mod mpi_mod wtformat_mod decomp_2d Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work (2) integer, intent(in) :: itype character(len=4), intent(in) :: str","tags":"","url":"proc/get_area_average_2d_for_fbcy.html"},{"title":"Solve_momentum_eq – CHAPSim2","text":"public  subroutine Solve_momentum_eq(fl, dm, isub) Uses continuity_eq_mod parameters_constant_mod io_restart_mod udf_type_mod typeconvert_mod boundary_conditions_mod convert_primary_conservative_mod mpi_mod io_tools_mod solver_tools_mod wtformat_mod find_max_min_ave_mod \\brief To update the provisional u or rho u. \\param[inout]  fl            flow field\n\\param[inout]  dm            domain\n\\param[in]     isub         RK sub-iteration Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"proc/solve_momentum_eq~2.html"},{"title":"Buildup_geometry_mesh_info – CHAPSim2","text":"public  subroutine Buildup_geometry_mesh_info(dm) Uses parameters_constant_mod udf_type_mod typeconvert_mod mpi_mod wtformat_mod find_max_min_ave_mod io_files_mod math_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/buildup_geometry_mesh_info.html"},{"title":"fishpack_fft_init – CHAPSim2","text":"public  subroutine fishpack_fft_init(dm) Uses print_msg_mod io_files_mod parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm","tags":"","url":"proc/fishpack_fft_init.html"},{"title":"fishpack_fft_simple – CHAPSim2","text":"public  subroutine fishpack_fft_simple(rhs_xpencil, dm) Uses udf_type_mod write( , ) 'fft-xzfft ', rhs_ypencil Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: rhs_xpencil (dm%dccc%xsz(1),dm%dccc%xsz(2),dm%dccc%xsz(3)) type( t_domain ), intent(in) :: dm","tags":"","url":"proc/fishpack_fft_simple.html"},{"title":"update_fbcx_convective_outlet_flow – CHAPSim2","text":"public  subroutine update_fbcx_convective_outlet_flow(fl, dm, isub) Uses bc_dirichlet_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"proc/update_fbcx_convective_outlet_flow.html"},{"title":"update_fbcx_convective_outlet_thermo – CHAPSim2","text":"public  subroutine update_fbcx_convective_outlet_thermo(fl, tm, dm, isub) Uses thermo_info_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"proc/update_fbcx_convective_outlet_thermo.html"},{"title":"write_instantaneous_flow – CHAPSim2","text":"public  subroutine write_instantaneous_flow(fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_instantaneous_flow.html"},{"title":"write_instantaneous_thermo – CHAPSim2","text":"public  subroutine write_instantaneous_thermo(tm, dm) Uses thermo_info_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_instantaneous_thermo.html"},{"title":"read_instantaneous_flow – CHAPSim2","text":"public  subroutine read_instantaneous_flow(fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/read_instantaneous_flow.html"},{"title":"restore_flow_variables_from_restart – CHAPSim2","text":"public  subroutine restore_flow_variables_from_restart(fl, dm) Uses boundary_conditions_mod mpi_mod solver_tools_mod wtformat_mod find_max_min_ave_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/restore_flow_variables_from_restart.html"},{"title":"read_instantaneous_thermo – CHAPSim2","text":"public  subroutine read_instantaneous_thermo(tm, dm) Uses thermo_info_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/read_instantaneous_thermo.html"},{"title":"restore_thermo_variables_from_restart – CHAPSim2","text":"public  subroutine restore_thermo_variables_from_restart(fl, tm, dm) Uses udf_type_mod eq_energy_mod convert_primary_conservative_mod solver_tools_mod thermo_info_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/restore_thermo_variables_from_restart.html"},{"title":"write_instantaneous_xoutlet – CHAPSim2","text":"public  subroutine write_instantaneous_xoutlet(fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/write_instantaneous_xoutlet.html"},{"title":"read_instantaneous_xinlet – CHAPSim2","text":"public  subroutine read_instantaneous_xinlet(fl, dm) Uses typeconvert_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/read_instantaneous_xinlet.html"},{"title":"write_monitor_ini – CHAPSim2","text":"public  subroutine write_monitor_ini(dm) Uses parameters_constant_mod udf_type_mod typeconvert_mod io_tools_mod wtformat_mod io_files_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/write_monitor_ini.html"},{"title":"write_monitor_bulk – CHAPSim2","text":"public  subroutine write_monitor_bulk(fl, dm, tm) Uses parameters_constant_mod udf_type_mod typeconvert_mod io_tools_mod solver_tools_mod operations wtformat_mod find_max_min_ave_mod io_files_mod cylindrical_rn_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm type( t_thermo ), intent(in), optional :: tm","tags":"","url":"proc/write_monitor_bulk.html"},{"title":"write_monitor_probe – CHAPSim2","text":"public  subroutine write_monitor_probe(fl, dm, tm) Uses parameters_constant_mod udf_type_mod typeconvert_mod io_tools_mod wtformat_mod io_files_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm type( t_thermo ), intent(in), optional :: tm","tags":"","url":"proc/write_monitor_probe.html"},{"title":"extract_dirichlet_fbcx – CHAPSim2","text":"public  subroutine extract_dirichlet_fbcx(fbc, var, dtmp) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(out) :: fbc (4,dtmp%xsz(2),dtmp%xsz(3)) real(kind=WP), intent(in) :: var (dtmp%xsz(1),dtmp%xsz(2),dtmp%xsz(3)) type(DECOMP_INFO), intent(in) :: dtmp","tags":"","url":"proc/extract_dirichlet_fbcx.html"},{"title":"extract_dirichlet_fbcy – CHAPSim2","text":"public  subroutine extract_dirichlet_fbcy(fbc, var, dtmp, dm, is_reversed) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(out) :: fbc (dtmp%ysz(1),4,dtmp%ysz(3)) real(kind=WP), intent(in) :: var (dtmp%ysz(1),dtmp%ysz(2),dtmp%ysz(3)) type(DECOMP_INFO), intent(in) :: dtmp type( t_domain ), intent(in) :: dm logical, intent(in), optional :: is_reversed","tags":"","url":"proc/extract_dirichlet_fbcy.html"},{"title":"extract_dirichlet_fbcz – CHAPSim2","text":"public  subroutine extract_dirichlet_fbcz(fbc, var, dtmp) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(out) :: fbc (dtmp%zsz(1),dtmp%zsz(2),4) real(kind=WP), intent(in) :: var (dtmp%zsz(1),dtmp%zsz(2),dtmp%zsz(3)) type(DECOMP_INFO), intent(in) :: dtmp","tags":"","url":"proc/extract_dirichlet_fbcz.html"},{"title":"initialise_fbcx_given_profile – CHAPSim2","text":"public  subroutine initialise_fbcx_given_profile(fbcx, var1y, jst, str) Uses io_files_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: fbcx (:,:,:) real(kind=WP), intent(in) :: var1y (:) integer, intent(in) :: jst character(len=2), intent(in) :: str","tags":"","url":"proc/initialise_fbcx_given_profile.html"},{"title":"initialise_fbc_flow_given – CHAPSim2","text":"public  subroutine initialise_fbc_flow_given(dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/initialise_fbc_flow_given.html"},{"title":"initialise_fbc_thermo_given – CHAPSim2","text":"public  subroutine initialise_fbc_thermo_given(tm, dm) Uses thermo_info_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/initialise_fbc_thermo_given.html"},{"title":"enforce_velo_from_fbc – CHAPSim2","text":"public  subroutine enforce_velo_from_fbc(dm, ux, uy, uz, fbcx0, fbcy0, fbcz0) Uses print_msg_mod parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm real(kind=WP), intent(inout), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: ux real(kind=WP), intent(inout), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: uy real(kind=WP), intent(inout), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: uz real(kind=WP), intent(in), optional, dimension(4, dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: fbcx0 real(kind=WP), intent(in), optional, dimension(dm%dcpc%ysz(1), 4, dm%dcpc%ysz(3)) :: fbcy0 real(kind=WP), intent(in), optional, dimension(dm%dccp%zsz(1), dm%dccp%zsz(2), 4) :: fbcz0","tags":"","url":"proc/enforce_velo_from_fbc.html"},{"title":"convert_primary_conservative – CHAPSim2","text":"public  subroutine convert_primary_conservative(fl, dm, itag) Uses parameters_constant_mod decomp_2d udf_type_mod operations cylindrical_rn_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: itag","tags":"","url":"proc/convert_primary_conservative.html"},{"title":"initialise_mhd – CHAPSim2","text":"public  subroutine initialise_mhd(fl, mh, dm) Uses udf_type_mod mpi_mod print_msg_mod io_visualisation_mod math_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_mhd ), intent(inout) :: mh type( t_domain ), intent(in) :: dm","tags":"","url":"proc/initialise_mhd.html"},{"title":"compute_Lorentz_force – CHAPSim2","text":"public  subroutine compute_Lorentz_force(fl, mh, dm) Uses continuity_eq_mod udf_type_mod poisson_interface_mod operations decomp_2d io_visualisation_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_mhd ), intent(inout) :: mh type( t_domain ), intent(in) :: dm","tags":"","url":"proc/compute_lorentz_force.html"},{"title":"build_up_fft2decomp_interface – CHAPSim2","text":"public  subroutine build_up_fft2decomp_interface(dm) Uses parameters_constant_mod operations udf_type_mod ipinter=1 : conventional sixth-order interpolation coefficients as described in Lele 1992 <https://www.sciencedirect.com/science/article/pii/002199919290324R> _\\ ipinter=2 : optimal sixth-order interpolation coefficients designed to be as close as possible to spectral interpolators. ipinter=3 : aggressive sixth-order interpolation coefficients designed to add some numerical dissipation at small scales but they could result in spurious oscillations close to a wall.\n if(dm%iAccuracy == IACCU_CD2) then\n   ailcaix6 = ZERO\n   aicix6 = HALF \n   bicix6 = ZERO\n   cicix6 = ZERO\n   dicix6 = ZERO\n else\n   ailcaix6 = THREE * ZPONE\n   aicix6 = ONEPFIVE * HALF\n   bicix6 = ONE * ZPONE * HALF\n   cicix6 = ZERO\n   dicix6 = ZERO\n end if Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm","tags":"","url":"proc/build_up_fft2decomp_interface.html"},{"title":"decomp_2d_poisson_init – CHAPSim2","text":"public  subroutine decomp_2d_poisson_init() !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Arguments None","tags":"","url":"proc/decomp_2d_poisson_init.html"},{"title":"decomp_2d_poisson_finalize – CHAPSim2","text":"public  subroutine decomp_2d_poisson_finalize() Arguments None","tags":"","url":"proc/decomp_2d_poisson_finalize.html"},{"title":"Prepare_LHS_coeffs_for_operations – CHAPSim2","text":"public  subroutine Prepare_LHS_coeffs_for_operations() Uses mpi_mod parameters_constant_mod vars_df_mod \\brief Preparing coefficients for TDMA calculation.\nScope:  mpi    called-freq    xdomain\n        all    once           all Arguments None","tags":"","url":"proc/prepare_lhs_coeffs_for_operations~2.html"},{"title":"Get_x_midp_C2P_3D – CHAPSim2","text":"public  subroutine Get_x_midp_C2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod \\brief To caculate the mid-point interpolation in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_midp_c2p_3d~2.html"},{"title":"Get_x_midp_P2C_3D – CHAPSim2","text":"public  subroutine Get_x_midp_P2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_midp_p2c_3d~2.html"},{"title":"Get_y_midp_C2P_3D – CHAPSim2","text":"public  subroutine Get_y_midp_C2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_midp_c2p_3d~2.html"},{"title":"Get_y_midp_P2C_3D – CHAPSim2","text":"public  subroutine Get_y_midp_P2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_midp_p2c_3d~2.html"},{"title":"Get_z_midp_C2P_3D – CHAPSim2","text":"public  subroutine Get_z_midp_C2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_midp_c2p_3d~2.html"},{"title":"Get_z_midp_P2C_3D – CHAPSim2","text":"public  subroutine Get_z_midp_P2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_midp_p2c_3d~2.html"},{"title":"Get_x_1der_C2C_3D – CHAPSim2","text":"public  subroutine Get_x_1der_C2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod \\brief To caculate the 1st-deriviate in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1der_c2c_3d.html"},{"title":"Get_x_1der_P2P_3D – CHAPSim2","text":"public  subroutine Get_x_1der_P2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1der_p2p_3d.html"},{"title":"Get_x_1der_C2P_3D – CHAPSim2","text":"public  subroutine Get_x_1der_C2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1der_c2p_3d.html"},{"title":"Get_x_1der_P2C_3D – CHAPSim2","text":"public  subroutine Get_x_1der_P2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_x_1der_p2c_3d.html"},{"title":"Get_y_1der_C2C_3D – CHAPSim2","text":"public  subroutine Get_y_1der_C2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1der_c2c_3d.html"},{"title":"Get_y_1der_P2P_3D – CHAPSim2","text":"public  subroutine Get_y_1der_P2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1der_p2p_3d.html"},{"title":"Get_y_1der_C2P_3D – CHAPSim2","text":"public  subroutine Get_y_1der_C2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1der_c2p_3d.html"},{"title":"Get_y_1der_P2C_3D – CHAPSim2","text":"public  subroutine Get_y_1der_P2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_y_1der_p2c_3d.html"},{"title":"Get_z_1der_C2C_3D – CHAPSim2","text":"public  subroutine Get_z_1der_C2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1der_c2c_3d.html"},{"title":"Get_z_1der_P2P_3D – CHAPSim2","text":"public  subroutine Get_z_1der_P2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1der_p2p_3d.html"},{"title":"Get_z_1der_C2P_3D – CHAPSim2","text":"public  subroutine Get_z_1der_C2P_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1der_c2p_3d.html"},{"title":"Get_z_1der_P2C_3D – CHAPSim2","text":"public  subroutine Get_z_1der_P2C_3D(fi3d, fo3d, dm, iacc, ibc, fbc2d) Uses parameters_constant_mod tridiagonal_matrix_algorithm udf_type_mod Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:)","tags":"","url":"proc/get_z_1der_p2c_3d.html"},{"title":"Test_interpolation – CHAPSim2","text":"public  subroutine Test_interpolation(dm) Uses EvenOdd_mod parameters_constant_mod math_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/test_interpolation~2.html"},{"title":"Test_1st_derivative – CHAPSim2","text":"public  subroutine Test_1st_derivative(dm) Uses EvenOdd_mod parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/test_1st_derivative~2.html"},{"title":"Calculate_drhodt – CHAPSim2","text":"public  subroutine Calculate_drhodt(fl, dm) Uses parameters_constant_mod udf_type_mod \\brief To calculate d(\\rho)/dt in the continuity eq.\n\\param[in]  dDens            density at the current time step\n\\param[in]  dDensm1          density at the t-1 time step\n\\param[in]  dDensm2          density at the t-2 time step\n\\param[out] drhodt           d(rho)/dt\n\\param[in]  itime            the sub-step in RK3 Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/calculate_drhodt.html"},{"title":"Get_divergence_flow – CHAPSim2","text":"public  subroutine Get_divergence_flow(fl, div, dm) Uses cylindrical_rn_mod parameters_constant_mod solver_tools_mod udf_type_mod \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[out]    div          div(q) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl real(kind=WP), intent(out), dimension(dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3)) :: div type( t_domain ), intent(in) :: dm","tags":"","url":"proc/get_divergence_flow.html"},{"title":"Get_divergence_vector – CHAPSim2","text":"public  subroutine Get_divergence_vector(ux, uy, uz, div, dm) Uses cylindrical_rn_mod parameters_constant_mod udf_type_mod \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[in]     ux           ux or gx\n\\param[in]     uy           uy or gy\n\\param[in]     uz           uz or gz\n\\param[out]    div          div(u) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: ux real(kind=WP), intent(in), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: uy real(kind=WP), intent(in), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: uz real(kind=WP), intent(out), dimension(dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3)) :: div type( t_domain ), intent(in) :: dm","tags":"","url":"proc/get_divergence_vector.html"},{"title":"Get_divergence_vel_x2z – CHAPSim2","text":"public  subroutine Get_divergence_vel_x2z(ux, uy, uz, div_zpencil_ggg, dm) Uses cylindrical_rn_mod parameters_constant_mod decomp_extended_mod udf_type_mod \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[in]     ux           ux or gx\n\\param[in]     uy           uy or gy\n\\param[in]     uz           uz or gz\n\\param[out]    div          div(u) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: ux real(kind=WP), intent(in), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: uy real(kind=WP), intent(in), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: uz real(kind=WP), intent(out), dimension(dm%dccc%zst(1) : dm%dccc%zen(1), dm%dccc%zst(2) : dm%dccc%zen(2), dm%dccc%zst(3) : dm%dccc%zen(3)) :: div_zpencil_ggg type( t_domain ), intent(in) :: dm","tags":"","url":"proc/get_divergence_vel_x2z.html"},{"title":"Check_element_mass_conservation – CHAPSim2","text":"public  subroutine Check_element_mass_conservation(fl, dm, iter, opt_isub, opt_str) Uses parameters_constant_mod udf_type_mod typeconvert_mod input_general_mod precision_mod mpi_mod solver_tools_mod wtformat_mod find_max_min_ave_mod io_visualisation_mod math_mod \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[in]     ux           ux or gx\n\\param[in]     uy           uy or gy\n\\param[in]     uz           uz or gz\n\\param[out]    div          div(u) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm integer, intent(in) :: iter integer, intent(in), optional :: opt_isub character(len=*), intent(in), optional :: opt_str","tags":"","url":"proc/check_element_mass_conservation.html"},{"title":"config_calc_basic_ibc – CHAPSim2","text":"public  subroutine config_calc_basic_ibc(dm) Uses wtformat_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/config_calc_basic_ibc.html"},{"title":"allocate_fbc_flow – CHAPSim2","text":"public  subroutine allocate_fbc_flow(dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/allocate_fbc_flow.html"},{"title":"allocate_fbc_thermo – CHAPSim2","text":"public  subroutine allocate_fbc_thermo(dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/allocate_fbc_thermo.html"},{"title":"update_fbcy_cc_flow_halo – CHAPSim2","text":"public  subroutine update_fbcy_cc_flow_halo(fl, dm) Uses cylindrical_rn_mod find_max_min_ave_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/update_fbcy_cc_flow_halo.html"},{"title":"update_fbcy_cc_thermo_halo – CHAPSim2","text":"public  subroutine update_fbcy_cc_thermo_halo(fl, tm, dm) Uses cylindrical_rn_mod thermo_info_mod find_max_min_ave_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(in) :: tm type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/update_fbcy_cc_thermo_halo.html"},{"title":"build_bc_symm_operation – CHAPSim2","text":"public  subroutine build_bc_symm_operation(ibc, mbc, jbc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) integer, intent(out) :: mbc (2,3) integer, intent(in), optional :: jbc (2)","tags":"","url":"proc/build_bc_symm_operation.html"},{"title":"config_calc_eqs_ibc – CHAPSim2","text":"public  subroutine config_calc_eqs_ibc(dm) Uses wtformat_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/config_calc_eqs_ibc.html"},{"title":"get_fbcx_iTh – CHAPSim2","text":"public  subroutine get_fbcx_iTh(ibc, dm, fbc) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) type( t_domain ), intent(in) :: dm real(kind=WP), intent(out) :: fbc (4,dm%dpcc%xsz(2),dm%dpcc%xsz(3))","tags":"","url":"proc/get_fbcx_ith.html"},{"title":"get_fbcy_iTh – CHAPSim2","text":"public  subroutine get_fbcy_iTh(ibc, dm, fbc) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) type( t_domain ), intent(in) :: dm real(kind=WP), intent(out) :: fbc (dm%dcpc%ysz(1),4,dm%dcpc%ysz(3))","tags":"","url":"proc/get_fbcy_ith.html"},{"title":"get_fbcz_iTh – CHAPSim2","text":"public  subroutine get_fbcz_iTh(ibc, dm, fbc) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) type( t_domain ), intent(in) :: dm real(kind=WP), intent(out) :: fbc (dm%dccp%zsz(1),dm%dccp%zsz(2),4)","tags":"","url":"proc/get_fbcz_ith.html"},{"title":"get_name_drivenforce – CHAPSim2","text":"public  function get_name_drivenforce(ifl) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ifl Return Value character(len=72)","tags":"","url":"proc/get_name_drivenforce.html"},{"title":"Read_input_parameters – CHAPSim2","text":"public  subroutine Read_input_parameters() Uses parameters_constant_mod vars_df_mod boundary_conditions_mod code_performance_mod mpi_mod thermo_info_mod wtformat_mod EvenOdd_mod \\brief Reading the input parameters from the given file. Scope:  mpi    called-freq    xdomain\n        all    once           all\n\\param[in]     none          NA\n\\param[out]    none          NA Arguments None","tags":"","url":"proc/read_input_parameters.html"},{"title":"estimate_spacial_resolution – CHAPSim2","text":"public  subroutine estimate_spacial_resolution(fl, dm) Uses udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/estimate_spacial_resolution.html"},{"title":"estimate_temporal_resolution – CHAPSim2","text":"public  subroutine estimate_temporal_resolution(fl, dm) Uses udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/estimate_temporal_resolution.html"},{"title":"Update_thermal_properties – CHAPSim2","text":"public  subroutine Update_thermal_properties(fl, tm, dm) Uses parameters_constant_mod udf_type_mod operations thermo_info_mod cylindrical_rn_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/update_thermal_properties.html"},{"title":"Solve_energy_eq – CHAPSim2","text":"public  subroutine Solve_energy_eq(fl, tm, dm, isub) Uses boundary_conditions_mod solver_tools_mod thermo_info_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"proc/solve_energy_eq.html"},{"title":"decomp_2d_poisson_init – CHAPSim2","text":"public  subroutine decomp_2d_poisson_init() !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Arguments None","tags":"","url":"proc/decomp_2d_poisson_init~2.html"},{"title":"decomp_2d_poisson_finalize – CHAPSim2","text":"public  subroutine decomp_2d_poisson_finalize() Arguments None","tags":"","url":"proc/decomp_2d_poisson_finalize~2.html"},{"title":"update_fbc_2dm_flow_halo – CHAPSim2","text":"public  subroutine update_fbc_2dm_flow_halo(dm1, fl1, dm2, fl2) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm1 type( t_flow ), intent(in) :: fl1 type( t_domain ), intent(inout) :: dm2 type( t_flow ), intent(in) :: fl2","tags":"","url":"proc/update_fbc_2dm_flow_halo.html"},{"title":"update_fbc_2dm_thermo_halo – CHAPSim2","text":"public  subroutine update_fbc_2dm_thermo_halo(dm1, tm1, dm2, tm2) Uses thermo_info_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm1 type( t_thermo ), intent(in) :: tm1 type( t_domain ), intent(inout) :: dm2 type( t_thermo ), intent(in) :: tm2","tags":"","url":"proc/update_fbc_2dm_thermo_halo.html"},{"title":"init_statistics_flow – CHAPSim2","text":"public  subroutine init_statistics_flow(fl, dm) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/init_statistics_flow.html"},{"title":"read_statistics_flow – CHAPSim2","text":"public  subroutine read_statistics_flow(fl, dm) Uses io_visualisation_mod parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/read_statistics_flow.html"},{"title":"init_statistics_thermo – CHAPSim2","text":"public  subroutine init_statistics_thermo(tm, dm) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/init_statistics_thermo.html"},{"title":"read_statistics_thermo – CHAPSim2","text":"public  subroutine read_statistics_thermo(tm, dm) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/read_statistics_thermo.html"},{"title":"update_statistics_flow – CHAPSim2","text":"public  subroutine update_statistics_flow(fl, dm) Uses parameters_constant_mod operations udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/update_statistics_flow.html"},{"title":"write_statistics_flow – CHAPSim2","text":"public  subroutine write_statistics_flow(fl, dm) Uses udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_statistics_flow.html"},{"title":"update_statistics_thermo – CHAPSim2","text":"public  subroutine update_statistics_thermo(tm, dm) Uses parameters_constant_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/update_statistics_thermo.html"},{"title":"write_statistics_thermo – CHAPSim2","text":"public  subroutine write_statistics_thermo(tm, dm) Uses udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/write_statistics_thermo.html"},{"title":"Update_Re – CHAPSim2","text":"public  subroutine Update_Re(iter, fl) Uses parameters_constant_mod thermo_info_mod udf_type_mod \\brief The main code for initialising flow variables\nThis subroutine is called once in \\ref initialise_chapsim. \\param[inout] Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter type( t_flow ), intent(inout) :: fl","tags":"","url":"proc/update_re.html"},{"title":"Update_PrGr – CHAPSim2","text":"public  subroutine Update_PrGr(fl, tm) Uses parameters_constant_mod thermo_info_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm","tags":"","url":"proc/update_prgr.html"},{"title":"Calculate_xz_mean_yprofile – CHAPSim2","text":"public  subroutine Calculate_xz_mean_yprofile(var, dtmp, n, varxz_work1) Uses mpi_mod parameters_constant_mod udf_type_mod \\brief The main code for initialising flow variables not changing storage position, exclude b.c. values, for example, developing\nflow.\nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z)\n\\param[inout]  none          NA Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%xsz(1), dtmp%xsz(2), dtmp%xsz(3)) :: var type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: n real(kind=WP), intent(out), optional, dimension(n) :: varxz_work1","tags":"","url":"proc/calculate_xz_mean_yprofile.html"},{"title":"Adjust_to_xzmean_zero – CHAPSim2","text":"public  subroutine Adjust_to_xzmean_zero(var, dtmp, n, varxz) Uses mpi_mod udf_type_mod \\brief : \nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z)\n\\param[inout] Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout), dimension(dtmp%xsz(1), dtmp%xsz(2), dtmp%xsz(3)) :: var type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: n real(kind=WP), intent(in), dimension(n) :: varxz","tags":"","url":"proc/adjust_to_xzmean_zero.html"},{"title":"Check_cfl_diffusion – CHAPSim2","text":"public  subroutine Check_cfl_diffusion(fl, dm) Uses parameters_constant_mod udf_type_mod mpi_mod print_msg_mod wtformat_mod \\brief : \nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z)\n\\param[inout] Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/check_cfl_diffusion.html"},{"title":"Check_cfl_convection – CHAPSim2","text":"public  subroutine Check_cfl_convection(u, v, w, dm) Uses parameters_constant_mod udf_type_mod find_max_min_ave_mod operations wtformat_mod decomp_2d \\brief : to check CFL for convection terms\nCFL = u&#94;x/dx + v&#94;y/dy + w&#94;z/dz < limit\nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z) \\param[inout] Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: u real(kind=WP), intent(in), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: v real(kind=WP), intent(in), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: w type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/check_cfl_convection.html"},{"title":"get_fbcx_ftp_4pc – CHAPSim2","text":"public  subroutine get_fbcx_ftp_4pc(fbcx_ftp_4cc, fbcx_ftp_4pc, dm) Uses print_msg_mod parameters_constant_mod operations udf_type_mod \\brief : to calculate:\n         fo = \\int_1&#94;nx \\int_\n This is based only y-direction stretching.\n \\todo Here is 2nd order Trapezoid Method. Need to improve! Check!\n Scope:  mpi    called-freq    xdomain     module\n         all    needed         specified   pubic\n MPI : \n     default x-pencil\n     working in : y-pencil\n  (y) &#94; _ | |_____|______|\n      |_____|_____|______| > (z)\n Y: index arrangment\n      j'-1   j'-1  j'    j'+1  j'+2\n      _| . | . | . | . | . j-2   j-1   j     j+1    j+2\n \\param[inout] Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%d4cc%xsz(1), dm%d4cc%xsz(2), dm%d4cc%xsz(3)) :: fbcx_ftp_4cc real(kind=WP), intent(out), dimension(dm%d4pc%xsz(1), dm%d4pc%xsz(2), dm%d4pc%xsz(3)) :: fbcx_ftp_4pc type( t_domain ), intent(in) :: dm","tags":"","url":"proc/get_fbcx_ftp_4pc.html"},{"title":"Allocate_flow_variables – CHAPSim2","text":"public  subroutine Allocate_flow_variables(fl, dm) Uses mpi_mod parameters_constant_mod \\brief Allocate flow and thermal variables. Scope:  mpi    called-freq    xdomain     module\n        all    once           specified   private\n\\param[in]     none          NA\n\\param[out]    none          NA Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/allocate_flow_variables.html"},{"title":"Allocate_thermo_variables – CHAPSim2","text":"public  subroutine Allocate_thermo_variables(tm, dm) Uses mpi_mod parameters_constant_mod thermo_info_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"proc/allocate_thermo_variables.html"},{"title":"initialise_flow_from_given_inlet – CHAPSim2","text":"public  subroutine initialise_flow_from_given_inlet(dm, fl) Uses parameters_constant_mod precision_mod boundary_conditions_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type( t_flow ), intent(inout) :: fl","tags":"","url":"proc/initialise_flow_from_given_inlet.html"},{"title":"initialise_flow_fields – CHAPSim2","text":"public  subroutine initialise_flow_fields(fl, dm) Uses io_restart_mod parameters_constant_mod continuity_eq_mod udf_type_mod boundary_conditions_mod convert_primary_conservative_mod wrt_debug_field_mod solver_tools_mod wtformat_mod io_visualisation_mod statistics_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/initialise_flow_fields.html"},{"title":"initialise_thermo_fields – CHAPSim2","text":"public  subroutine initialise_thermo_fields(tm, fl, dm) Uses io_restart_mod parameters_constant_mod io_visualisation_mod udf_type_mod eq_energy_mod thermo_info_mod statistics_mod Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"proc/initialise_thermo_fields.html"},{"title":"Validate_TGV2D_error – CHAPSim2","text":"public  subroutine Validate_TGV2D_error(fl, dm) Uses io_files_mod parameters_constant_mod math_mod udf_type_mod Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"proc/validate_tgv2d_error.html"},{"title":"Buildup_mpi_domain_decomposition – CHAPSim2","text":"public  subroutine Buildup_mpi_domain_decomposition() Uses vars_df_mod mpi_mod io_monitor_mod io_tools_mod io_visualisation_mod statistics_mod \\brief domain decompistion. Scope:  mpi    called-freq    xdomain   module\n        all    once           all       public\n\\param[in]     none          NA Arguments None","tags":"","url":"proc/buildup_mpi_domain_decomposition.html"},{"title":"decomp_extended_mod – CHAPSim2","text":"Uses parameters_constant_mod Subroutines public  subroutine ypencil_index_lgl2ggl (vin, vou, dtmp) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%ysz(1),               dtmp%ysz(2), dtmp%ysz(3)) :: vin real(kind=WP), intent(out), dimension(dtmp%yst(1) : dtmp%yen(2), dtmp%ysz(2), dtmp%zsz(3)) :: vou type(DECOMP_INFO), intent(in) :: dtmp public  subroutine zpencil_index_llg2ggg (vin, vou, dtmp) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%zsz(1),               dtmp%zsz(2),               dtmp%zsz(3)) :: vin real(kind=WP), intent(out), dimension(dtmp%zst(1) : dtmp%zen(1), dtmp%zst(2) : dtmp%zen(2), dtmp%zsz(3)) :: vou type(DECOMP_INFO), intent(in) :: dtmp public  subroutine zpencil_index_ggg2llg (vin, vou, dtmp) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%zst(1) : dtmp%zen(1), dtmp%zst(2) : dtmp%zen(2), dtmp%zsz(3)) :: vin real(kind=WP), intent(out), dimension(dtmp%zsz(1),               dtmp%zsz(2),               dtmp%zsz(3)) :: vou type(DECOMP_INFO), intent(in) :: dtmp","tags":"","url":"module/decomp_extended_mod.html"},{"title":"poisson_interface_mod – CHAPSim2","text":"Uses parameters_constant_mod decomp_2d_poisson decomp_extended_mod fishpack_fft fft2decomp_interface_mod Subroutines public  subroutine initialise_fft (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm public  subroutine solve_fft_poisson (rhs_xpencil, dm) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ) :: rhs_xpencil type( t_domain ), intent(in) :: dm","tags":"","url":"module/poisson_interface_mod.html"},{"title":"thermo_info_mod – CHAPSim2","text":"\\file input_thermo.f90 \\brief Reading the input parameters from the given file and building up the\nrelationships between properties. Uses parameters_constant_mod udf_type_mod mpi_mod print_msg_mod wtformat_mod Variables Type Visibility Attributes Name Initial integer, public, save :: N_FUNC2TABLE = 1024 logical, public :: is_ftplist_dim type( t_fluidThermoProperty ), public, save, allocatable, dimension(:) :: ftplist Subroutines public  subroutine ftp_refresh_thermal_properties_from_T_undim_3D (ftp3d) Arguments Type Intent Optional Attributes Name type( t_fluidThermoProperty ), intent(inout) :: ftp3d (:,:,:) public  subroutine ftp_refresh_thermal_properties_from_DH (this) \\brief Defination of a procedure in the type t_fluidThermoProperty.\n to update the thermal properties based on the known enthalpy per unit mass. Read more… Arguments Type Intent Optional Attributes Name type( t_fluidThermoProperty ), intent(inout) :: this public  subroutine Convert_thermal_input_2undim (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm public  subroutine initialise_thermal_properties (fl, tm) \\brief Initialise thermal variables if ithermo = 1. Scope:  mpi    called-freq    xdomain     module\n        all    once           specified   private\n\\param[inout]  fl   flow type\n\\param[inout]  tm   thermo type Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm public  subroutine Buildup_thermo_mapping_relations (tm) \\brief Initialise thermal variables if ithermo = 1. Scope:  mpi    called-freq    xdomain     module\n        all    once           specified   private\n\\param[inout]  fl   flow type\n\\param[inout]  tm   thermo type\n\\brief The main code for thermal property initialisation.\nScope:  mpi    called-freq    xdomain\n        all    once           all\n\\param[inout]  none          NA Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm","tags":"","url":"module/thermo_info_mod.html"},{"title":"tridiagonal_matrix_algorithm – CHAPSim2","text":"Subroutines public  subroutine Preprocess_TDMA_coeffs (a, b, c, d, n) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: a (n) real(kind=WP), intent(in) :: b (n) real(kind=WP), intent(inout) :: c (n) real(kind=WP), intent(out) :: d (n) integer, intent(in) :: n public  subroutine Solve_TDMA (peri, x, a, b, c, d, n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: peri real(kind=WP), intent(inout) :: x (n) real(kind=WP), intent(in) :: a (n) real(kind=WP), intent(in) :: b (n) real(kind=WP), intent(in) :: c (n) real(kind=WP), intent(in) :: d (n) integer, intent(in) :: n public  subroutine Test_TDMA_noncyclic () Arguments None public  subroutine Test_TDMA_cyclic () Arguments None","tags":"","url":"module/tridiagonal_matrix_algorithm.html"},{"title":"io_visualisation_mod – CHAPSim2","text":"Uses print_msg_mod io_tools_mod parameters_constant_mod Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: io_name = \"solution-io\" integer, public, parameter :: XDMF_HEADER = 1 integer, public, parameter :: XDMF_FOOTER = 2 integer, public, parameter :: PLANE_AVERAGE = -1 character(len=6), public, parameter :: SCALAR = \"Scalar\" character(len=6), public, parameter :: VECTOR = \"Vector\" character(len=6), public, parameter :: TENSOR = \"Tensor\" character(len=4), public, parameter :: CELL = \"Cell\" character(len=4), public, parameter :: NODE = \"Node\" integer, public, parameter :: N_DIRECTION = 0 integer, public, parameter :: X_DIRECTION = 1 integer, public, parameter :: Y_DIRECTION = 2 integer, public, parameter :: Z_DIRECTION = 3 integer, public, allocatable :: nnd_visu (:,:) integer, public, allocatable :: ncl_visu (:,:) real(kind=WP), public, allocatable :: rp (:,:,:) real(kind=WP), public, allocatable :: ta (:,:,:) real(kind=WP), public, allocatable :: xp (:,:,:) real(kind=WP), public, allocatable :: yp (:,:,:) real(kind=WP), public, allocatable :: zp (:,:,:) real(kind=WP), public, allocatable :: xp1 (:) real(kind=WP), public, allocatable :: yp1 (:) real(kind=WP), public, allocatable :: zp1 (:) character(len=120), public :: grid_flname character(len=120), public :: grid_flname_x character(len=120), public :: grid_flname_y character(len=120), public :: grid_flname_z Subroutines public  subroutine write_visu_ini (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm public  subroutine write_visu_flow (fl, dm, suffix) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm character(len=4), intent(in), optional :: suffix public  subroutine write_visu_thermo (tm, fl, dm, str) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm character(len=4), intent(in), optional :: str public  subroutine write_visu_mhd (mh, fl, dm, suffix) Arguments Type Intent Optional Attributes Name type( t_mhd ), intent(in) :: mh type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm character(len=4), intent(in), optional :: suffix public  subroutine write_visu_stats_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm public  subroutine write_visu_stats_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(in) :: dm public  subroutine write_visu_any3darray (var, varname, visuname, dtmp, dm, iter) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension( dtmp%xsz(1), dtmp%xsz(2), dtmp%xsz(3) ) :: var character(len=*), intent(in) :: varname character(len=*), intent(in) :: visuname type(DECOMP_INFO), intent(in) :: dtmp type( t_domain ), intent(in) :: dm integer, intent(in) :: iter","tags":"","url":"module/io_visualisation_mod.html"},{"title":"io_tools_mod – CHAPSim2","text":"Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: io_restart = \"restart-io\" character(len=*), public, parameter :: io_in2outlet = \"outlet2inlet-io\" integer, public, parameter :: Ivisu_3D = 0 integer, public, parameter :: Ivisu_2D_YZ = 1 integer, public, parameter :: Ivisu_2D_XZ = 2 integer, public, parameter :: Ivisu_2D_XY = 3 integer, public, parameter :: Ivisu_1D_Y = 4 Subroutines public  subroutine initialise_decomp_io (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm public  subroutine generate_pathfile_name (flname_path, dmtag, keyword, path, extension, opt_timetag, opt_flname) Arguments Type Intent Optional Attributes Name character(len=120), intent(out) :: flname_path integer, intent(in) :: dmtag character(len=*), intent(in) :: keyword character(len=*), intent(in) :: path character(len=*), intent(in) :: extension integer, intent(in), optional :: opt_timetag character(len=120), intent(inout), optional :: opt_flname public  subroutine generate_file_name (flname, dmtag, keyword, extension, timetag) Arguments Type Intent Optional Attributes Name character(len=120), intent(out) :: flname integer, intent(in) :: dmtag character(len=*), intent(in) :: keyword character(len=*), intent(in) :: extension integer, intent(in), optional :: timetag","tags":"","url":"module/io_tools_mod.html"},{"title":"eq_momentum_mod – CHAPSim2","text":"Uses print_msg_mod operations decomp_2d precision_mod Subroutines public  subroutine Solve_momentum_eq (fl, dm, isub) \\brief To update the provisional u or rho u. Read more… Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"module/eq_momentum_mod.html"},{"title":"burgers_eq_mod – CHAPSim2","text":"Uses parameters_constant_mod precision_mod Variables Type Visibility Attributes Name Initial integer, public, parameter :: ICASE_BURGERS1D = 11 integer, public, parameter :: ICASE_BURGERS1D_VISCOUS = 12 integer, public, parameter :: ICASE_BURGERS1D_INVISCID = 13 integer, public, parameter :: ICASE_BURGERS1D_WAVEPROPAGATION = 14 real(kind=WP), public :: alpha = ONE real(kind=WP), public :: beta = ZERO real(kind=WP), public :: nu integer, public :: icase = 11 integer, public :: idir = 1 Subroutines public  subroutine initialise_burgers_flow (dm, ux, uy, uz, p) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm real(kind=WP), intent(inout) :: ux (:,:,:) real(kind=WP), intent(inout) :: uy (:,:,:) real(kind=WP), intent(inout) :: uz (:,:,:) real(kind=WP), intent(inout) :: p (:,:,:) public  subroutine Plot_burgers_profile (fl, dm, iter) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm integer, intent(in) :: iter public  subroutine Solve_burgers_eq_iteration () Arguments None","tags":"","url":"module/burgers_eq_mod.html"},{"title":"mpi_mod – CHAPSim2","text":"Uses decomp_2d_mpi mpi decomp_2d Variables Type Visibility Attributes Name Initial integer, public :: ierror integer, public :: nxdomain integer, public :: p_row integer, public :: p_col Subroutines public  subroutine initialise_mpi () \\brief mpi initialisation. Read more… Arguments None public  subroutine Finalise_mpi () Arguments None","tags":"","url":"module/mpi_mod.html"},{"title":"precision_mod – CHAPSim2","text":"Uses mpi_mod Variables Type Visibility Attributes Name Initial integer, public, parameter :: I4 = selected_int_kind(4) integer, public, parameter :: I8 = selected_int_kind(8) integer, public, parameter :: I15 = selected_int_kind(15) integer, public, parameter :: S6P = selected_real_kind(p=6, r=37) integer, public, parameter :: D15P = selected_real_kind(p=15, r=307) integer, public, parameter :: Q33P = selected_real_kind(p=33, r=4931) integer, public, parameter :: WP = D15P integer, public, parameter :: MPI_REAL_WP = MPI_DOUBLE_PRECISION integer, public, parameter :: MPI_CPLX_WP = MPI_DOUBLE_COMPLEX","tags":"","url":"module/precision_mod.html"},{"title":"parameters_constant_mod – CHAPSim2","text":"Uses precision_mod Variables Type Visibility Attributes Name Initial real(kind=WP), public, parameter :: ZPONE = 0.1_WP real(kind=WP), public, parameter :: EIGHTH = 0.125_WP real(kind=WP), public, parameter :: ZPTWO = 0.2_WP real(kind=WP), public, parameter :: QUARTER = 0.25_WP real(kind=WP), public, parameter :: ZPTHREE = 0.3_WP real(kind=WP), public, parameter :: ZPFOUR = 0.4_WP real(kind=WP), public, parameter :: HALF = 0.5_WP real(kind=WP), public, parameter :: ZPSIX = 0.6_WP real(kind=WP), public, parameter :: ZPSEVEN = 0.7_WP real(kind=WP), public, parameter :: ZPEIGHT = 0.8_WP real(kind=WP), public, parameter :: ZPNINE = 0.9_WP real(kind=WP), public, parameter :: ZERO = 0.0_WP real(kind=WP), public, parameter :: ONE = 1.0_WP real(kind=WP), public, parameter :: ONEPFIVE = 1.5_WP real(kind=WP), public, parameter :: TWO = 2.0_WP real(kind=WP), public, parameter :: TWOPFIVE = 2.5_WP real(kind=WP), public, parameter :: THREE = 3.0_WP real(kind=WP), public, parameter :: threepfive = 3.5_WP real(kind=WP), public, parameter :: FOUR = 4.0_WP real(kind=WP), public, parameter :: FIVE = 5.0_WP real(kind=WP), public, parameter :: SIX = 6.0_WP real(kind=WP), public, parameter :: SEVEN = 7.0_WP real(kind=WP), public, parameter :: EIGHT = 8.0_WP real(kind=WP), public, parameter :: NINE = 9.0_WP real(kind=WP), public, parameter :: ONE_THIRD = 0.33333333333333333333_WP real(kind=WP), public, parameter :: TWO_THIRD = 0.66666666666666666667_WP real(kind=WP), public, parameter :: TEN = 10.0_WP real(kind=WP), public, parameter :: ELEVEN = 11.0_WP real(kind=WP), public, parameter :: TWELVE = 12.0_WP real(kind=WP), public, parameter :: THIRTEEN = 13.0_WP real(kind=WP), public, parameter :: FOURTEEN = 14.0_WP real(kind=WP), public, parameter :: FIFTEEN = 15.0_WP real(kind=WP), public, parameter :: SIXTEEN = 16.0_WP real(kind=WP), public, parameter :: SEVENTEEN = 17.0_WP real(kind=WP), public, parameter :: TWENTY = 20.0_WP real(kind=WP), public, parameter :: TWENTYTWO = 22.0_WP real(kind=WP), public, parameter :: TWENTYTHREE = 23.0_WP real(kind=WP), public, parameter :: TWENTYFOUR = 24.0_WP real(kind=WP), public, parameter :: TWENTYFIVE = 25.0_WP real(kind=WP), public, parameter :: TWENTYSIX = 26.0_WP real(kind=WP), public, parameter :: TWENTYSEVEN = 27.0_WP real(kind=WP), public, parameter :: THIRTYTWO = 32.0_WP real(kind=WP), public, parameter :: THIRTYFIVE = 35.0_WP real(kind=WP), public, parameter :: THIRTYSIX = 36.0_WP real(kind=WP), public, parameter :: THIRTYSEVEN = 37.0_WP real(kind=WP), public, parameter :: FOURTYFIVE = 45.0_WP real(kind=WP), public, parameter :: FIFTY = 50.0_WP real(kind=WP), public, parameter :: SIXTY = 60.0_WP real(kind=WP), public, parameter :: SIXTYTWO = 62.0_WP real(kind=WP), public, parameter :: SIXTYTHREE = 63.0_WP real(kind=WP), public, parameter :: EIGHTYSEVEN = 87.0_WP real(kind=WP), public, parameter :: MINP = 1.0E-16_WP real(kind=WP), public, parameter :: MAXP = 1.0E16_WP real(kind=WP), public, parameter :: MAXVELO = 1.0E3_WP real(kind=WP), public, parameter :: MINN = -1.0E16_WP real(kind=WP), public, parameter :: MAXN = -1.0E-16_WP real(kind=WP), public, parameter :: TRUNCERR = 1.0E-16_WP real(kind=WP), public, parameter :: PI = 2.0_WP*(DASIN(1.0_WP)) real(kind=WP), public, parameter :: TWOPI = TWO*PI complex(kind=mytype), public, parameter :: cx_one_one = cmplx(one, one, kind=mytype) real(kind=WP), public, parameter,               dimension(3, 3) :: KRONECKER_DELTA = reshape((/ONE, ZERO, ZERO, ZERO, ONE, ZERO, ZERO, ZERO, ONE/), (/3, 3/)) real(kind=WP), public, parameter :: GRAVITY = 9.80665_WP integer, public, parameter :: FFT_2DECOMP_3DFFT = 3 integer, public, parameter :: FFT_FISHPACK_2DFFT = 2 integer, public, parameter :: MSTRET_3FMD = 1 integer, public, parameter :: MSTRET_TANH = 2 integer, public, parameter :: MSTRET_POWL = 3 integer, public, parameter :: ICASE_OTHERS = 0 integer, public, parameter :: ICASE_CHANNEL = 1 integer, public, parameter :: ICASE_PIPE = 2 integer, public, parameter :: ICASE_ANNULAR = 3 integer, public, parameter :: ICASE_TGV3D = 4 integer, public, parameter :: ICASE_TGV2D = 5 integer, public, parameter :: ICASE_BURGERS = 6 integer, public, parameter :: ICASE_ALGTEST = 7 integer, public, parameter :: INIT_RESTART = 0 integer, public, parameter :: INIT_INTERPL = 1 integer, public, parameter :: INIT_RANDOM = 2 integer, public, parameter :: INIT_INLET = 3 integer, public, parameter :: INIT_GVCONST = 4 integer, public, parameter :: INIT_POISEUILLE = 5 integer, public, parameter :: INIT_FUNCTION = 6 integer, public, parameter :: ICARTESIAN = 1 integer, public, parameter :: ICYLINDRICAL = 2 integer, public, parameter :: ISTRET_NO = 0 integer, public, parameter :: ISTRET_CENTRE = 1 integer, public, parameter :: ISTRET_2SIDES = 2 integer, public, parameter :: ISTRET_BOTTOM = 3 integer, public, parameter :: ISTRET_TOP = 4 integer, public, parameter :: ISTRET_INPUT = 5 integer, public, parameter :: ITIME_RK3 = 3 integer, public, parameter :: ITIME_RK3_CN = 2 integer, public, parameter :: ITIME_AB2 = 1 integer, public, parameter :: ITIME_EULER = 0 integer, public, parameter :: IBC_INTERIOR = 0 integer, public, parameter :: IBC_PERIODIC = 1 integer, public, parameter :: IBC_SYMMETRIC = 2 integer, public, parameter :: IBC_ASYMMETRIC = 3 integer, public, parameter :: IBC_DIRICHLET = 4 integer, public, parameter :: IBC_NEUMANN = 5 integer, public, parameter :: IBC_INTRPL = 6 integer, public, parameter :: IBC_CONVECTIVE = 7 integer, public, parameter :: IBC_TURBGEN = 8 integer, public, parameter :: IBC_PROFILE1D = 9 integer, public, parameter :: IBC_DATABASE = 10 integer, public, parameter :: IBC_OTHERS = 11 integer, public, parameter :: NBC = 5 integer, public, parameter :: NDIM = 3 integer, public, parameter :: IDIM (0:3) = (/0, 1, 2, 3/) integer, public, parameter :: IPENCIL (3) = (/1, 2, 3/) integer, public, parameter :: JBC_SELF = 1 integer, public, parameter :: JBC_GRAD = 2 integer, public, parameter :: JBC_PROD = 3 integer, public, parameter :: SPACE_INTEGRAL = 0 integer, public, parameter :: SPACE_AVERAGE = 1 integer, public, parameter :: IG2Q = -1 integer, public, parameter :: IQ2G = 1 integer, public, parameter :: IACCU_CD2 = 1 integer, public, parameter :: IACCU_CD4 = 2 integer, public, parameter :: IACCU_CP4 = 3 integer, public, parameter :: IACCU_CP6 = 4 integer, public, parameter :: IVIS_EXPLICIT = 1 integer, public, parameter :: IVIS_SEMIMPLT = 2 integer, public, parameter :: IDRVF_NO = 0 integer, public, parameter :: IDRVF_X_MASSFLUX = 1 integer, public, parameter :: IDRVF_X_TAUW = 2 integer, public, parameter :: IDRVF_X_DPDX = 3 integer, public, parameter :: IDRVF_Z_MASSFLUX = 4 integer, public, parameter :: IDRVF_Z_TAUW = 5 integer, public, parameter :: IDRVF_Z_DPDZ = 6 integer, public, parameter :: THERMAL_BC_CONST_T = 0 integer, public, parameter :: THERMAL_BC_CONST_H = 1 integer, public, parameter :: ISCP_WATER = 1 integer, public, parameter :: ISCP_CO2 = 2 integer, public, parameter :: ILIQUID_SODIUM = 3 integer, public, parameter :: ILIQUID_LEAD = 4 integer, public, parameter :: ILIQUID_BISMUTH = 5 integer, public, parameter :: ILIQUID_LBE = 6 integer, public, parameter :: ILIQUID_WATER = 7 integer, public, parameter :: IPROPERTY_TABLE = 1 integer, public, parameter :: IPROPERTY_FUNCS = 2 character(len=64), public, parameter :: INPUT_SCP_WATER = 'NIST_WATER_23.5MP.DAT' character(len=64), public, parameter :: INPUT_SCP_CO2 = 'NIST_CO2_8MP.DAT' real(kind=WP), public, parameter :: TM0_Na = 371.0_WP real(kind=WP), public, parameter :: TM0_Pb = 600.6_WP real(kind=WP), public, parameter :: TM0_BI = 544.6_WP real(kind=WP), public, parameter :: TM0_LBE = 398.0_WP real(kind=WP), public, parameter :: TM0_H2O = 273.15_WP real(kind=WP), public, parameter :: TB0_Na = 1155.0_WP real(kind=WP), public, parameter :: TB0_Pb = 2021.0_WP real(kind=WP), public, parameter :: TB0_BI = 1831.0_WP real(kind=WP), public, parameter :: TB0_LBE = 1927.0_WP real(kind=WP), public, parameter :: TB0_H2O = 373.15_WP real(kind=WP), public, parameter :: HM0_Na = 113.0e3_WP real(kind=WP), public, parameter :: HM0_Pb = 23.07e3_WP real(kind=WP), public, parameter :: HM0_BI = 53.3e3_WP real(kind=WP), public, parameter :: HM0_LBE = 38.6e3_WP real(kind=WP), public, parameter :: HM0_H2O = 334.0e3_WP real(kind=WP), public, parameter :: CoD_Na (0:1) = (/1014.0_WP, -0.235_WP/) real(kind=WP), public, parameter :: CoD_Pb (0:1) = (/11441.0_WP, -1.2795_WP/) real(kind=WP), public, parameter :: CoD_Bi (0:1) = (/10725.0_WP, -1.22_WP/) real(kind=WP), public, parameter :: CoD_LBE (0:1) = (/11065.0_WP, 1.293_WP/) real(kind=WP), public, parameter :: CoK_Na (0:2) = (/104.0_WP, -0.047_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoK_Pb (0:2) = (/9.2_WP, 0.011_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoK_Bi (0:2) = (/7.34_WP, 9.5E-3_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoK_LBE (0:2) = (/3.284_WP, 1.617E-2_WP, -2.305E-6_WP/) real(kind=WP), public, parameter :: CoB_Na = 4316.0_WP real(kind=WP), public, parameter :: CoB_Pb = 8942.0_WP real(kind=WP), public, parameter :: CoB_BI = 8791.0_WP real(kind=WP), public, parameter :: CoB_LBE = 8558.0_WP real(kind=WP), public, parameter :: CoCp_Na (-2:2) = (/-3.001e6_WP, 0.0_WP, 1658.0_WP, -0.8479_WP, 4.454E-4_WP/) real(kind=WP), public, parameter :: CoCp_Pb (-2:2) = (/-1.524e6_WP, 0.0_WP, 176.2_WP, -4.923E-2_WP, 1.544E-5_WP/) real(kind=WP), public, parameter :: CoCp_Bi (-2:2) = (/7.183e6_WP, 0.0_WP, 118.2_WP, 5.934E-3_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoCp_LBE (-2:2) = (/-4.56e5_WP, 0.0_WP, 164.8_WP, -3.94E-2_WP, 1.25E-5_WP/) real(kind=WP), public, parameter :: CoH_Na (-1:3) = (/4.56e5_WP, 0.0_WP, 164.8_WP, -1.97E-2_WP, 4.167E-4_WP/) real(kind=WP), public, parameter :: CoH_Pb (-1:3) = (/1.524e6_WP, 0.0_WP, 176.2_WP, -2.4615E-2_WP, 5.147E-6_WP/) real(kind=WP), public, parameter :: CoH_Bi (-1:3) = (/-7.183e6_WP, 0.0_WP, 118.2_WP, 2.967E-3_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoH_LBE (-1:3) = (/4.56e5_WP, 0.0_WP, 164.8_WP, -1.97E-2_WP, 4.167E-4_WP/) real(kind=WP), public, parameter :: CoM_Na (-1:1) = (/556.835_WP, -6.4406_WP, -0.3958_WP/) real(kind=WP), public, parameter :: CoM_Pb (-1:1) = (/1069.0_WP, 4.55E-4_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoM_Bi (-1:1) = (/780.0_WP, 4.456E-4_WP, 0.0_WP/) real(kind=WP), public, parameter :: CoM_LBE (-1:1) = (/754.1_WP, 4.94E-4_WP, 0.0_WP/)","tags":"","url":"module/parameters_constant_mod.html"},{"title":"wtformat_mod – CHAPSim2","text":"Variables Type Visibility Attributes Name Initial character(len=19), public :: wrtfmt1i = '(2X, A40, 1I8.1 )' character(len=19), public :: wrtfmt1il = '(2X, A40, 1I15.1)' character(len=19), public :: wrtfmt2i = '(2X, A40, 2I8.1,)' character(len=19), public :: wrtfmt2il = '(2X, A40, 2I15.1)' character(len=19), public :: wrtfmt3i = '(2X, A40, 3I8.1 )' character(len=19), public :: wrtfmt4i = '(2X, A40, 4I8.1 )' character(len=19), public :: wrtfmt1r = '(2X, A40, 1F14.7)' character(len=19), public :: wrtfmt2r = '(2X, A40, 2F14.7)' character(len=19), public :: wrtfmt3r = '(2X, A40, 3F14.7)' character(len=22), public :: wrtfmt1el = '(2X, A40, 1ES23.15)' character(len=22), public :: wrtfmt2el = '(2X, A40, 2ES23.15)' character(len=22), public :: wrtfmt1e = '(2X, A40, 1ES16.8)' character(len=22), public :: wrtfmt2e = '(2X, A40, 2ES16.8)' character(len=24), public :: wrtfmt2ae = '(2X, 2(A15, 1ES23.15))' character(len=26), public :: wrtfmt1i1r = '(2X, A40, 1I8.1, 1F14.7)' character(len=26), public :: wrtfmt1il1r = '(2X, A40, 1I15.1, 1F14.7)' character(len=26), public :: wrtfmt2i2r = '(2X, A40, 2I8.1, 2F14.7)' character(len=26), public :: wrtfmt4i2r = '(2X, A20, 4I8.1, 2F14.7)' character(len=15), public :: wrtfmt3l = '(2X, A40, 3L4)' character(len=15), public :: wrtfmt1l = '(2X, A40, 1L4)' character(len=17), public :: wrtfmt2s = '(2X, A40, 1A72)' character(len=17), public :: wrtfmt3s = '(2X, A40, 2A15)' character(len=9), public :: wrtfmt1s = '(2X, A80)'","tags":"","url":"module/wtformat_mod.html"},{"title":"udf_type_mod – CHAPSim2","text":"Uses mpi_mod parameters_constant_mod Variables Type Visibility Attributes Name Initial type( t_fluid_parameter ), public :: fluidparam Derived Types type, public :: t_fluidThermoProperty Components Type Visibility Attributes Name Initial real(kind=WP), public :: t real(kind=WP), public :: d real(kind=WP), public :: m real(kind=WP), public :: k real(kind=WP), public :: h real(kind=WP), public :: rhoh real(kind=WP), public :: cp real(kind=WP), public :: b type, public :: t_fluid_parameter Components Type Visibility Attributes Name Initial character(len=64), public :: inputProperty integer, public :: ifluid integer, public :: ipropertyState integer, public :: nlist real(kind=WP), public :: TM0 real(kind=WP), public :: TB0 real(kind=WP), public :: HM0 real(kind=WP), public :: CoD (0:1) real(kind=WP), public :: CoK (0:2) real(kind=WP), public :: CoB real(kind=WP), public :: CoCp (-2:2) real(kind=WP), public :: CoH (-1:3) real(kind=WP), public :: CoM (-1:1) real(kind=WP), public :: dhmax real(kind=WP), public :: dhmin type( t_fluidThermoProperty ), public :: ftp0ref type( t_fluidThermoProperty ), public :: ftpini type, public :: t_domain Components Type Visibility Attributes Name Initial logical, public :: is_periodic (NDIM) logical, public :: is_stretching (NDIM) logical, public :: is_compact_scheme logical, public :: is_thermo logical, public :: is_conv_outlet logical, public :: is_record_xoutlet logical, public :: is_read_xinlet logical, public :: is_mhd integer, public :: idom integer, public :: icase integer, public :: icoordinate integer, public :: ifft_lib integer, public :: icht integer, public :: iTimeScheme integer, public :: iviscous integer, public :: iAccuracy integer, public :: ckpt_nfre integer, public :: visu_nfre integer, public :: visu_idim integer, public :: visu_nskip (NDIM) integer, public :: stat_istart integer, public :: stat_nskip (NDIM) integer, public :: nsubitr integer, public :: istret integer, public :: mstret integer, public :: ndbfre integer, public :: ndbend integer, public :: nc (NDIM) integer, public :: np_geo (NDIM) integer, public :: np (NDIM) integer, public :: proben integer, public :: ibcx_qx (2) integer, public :: ibcy_qx (2) integer, public :: ibcz_qx (2) integer, public :: ibcx_qy (2) integer, public :: ibcy_qy (2) integer, public :: ibcz_qy (2) integer, public :: ibcx_qz (2) integer, public :: ibcy_qz (2) integer, public :: ibcz_qz (2) integer, public :: ibcx_pr (2) integer, public :: ibcy_pr (2) integer, public :: ibcz_pr (2) integer, public :: ibcx_Tm (2) integer, public :: ibcy_Tm (2) integer, public :: ibcz_Tm (2) integer, public :: ibcx_ftp (2) integer, public :: ibcy_ftp (2) integer, public :: ibcz_ftp (2) integer, public :: ibcx_nominal (2,NBC) integer, public :: ibcy_nominal (2,NBC) integer, public :: ibcz_nominal (2,NBC) real(kind=wp), public :: fbcx_const (2,NBC) real(kind=wp), public :: fbcy_const (2,NBC) real(kind=wp), public :: fbcz_const (2,NBC) real(kind=wp), public :: lxx real(kind=wp), public :: lyt real(kind=wp), public :: lyb real(kind=wp), public :: lzz real(kind=WP), public :: rstret real(kind=wp), public :: dt real(kind=wp), public :: h (NDIM) real(kind=wp), public :: h1r (NDIM) real(kind=wp), public :: h2r (NDIM) real(kind=wp), public :: tGamma (0:3) real(kind=wp), public :: tZeta (0:3) real(kind=wp), public :: tAlpha (0:3) real(kind=wp), public :: sigma1p real(kind=wp), public :: sigma2p type(DECOMP_INFO), public :: dccc type(DECOMP_INFO), public :: dpcc type(DECOMP_INFO), public :: dcpc type(DECOMP_INFO), public :: dccp type(DECOMP_INFO), public :: dppc type(DECOMP_INFO), public :: dpcp type(DECOMP_INFO), public :: dcpp type(DECOMP_INFO), public :: dppp type(DECOMP_INFO), public :: d4cc type(DECOMP_INFO), public :: d4pc type(DECOMP_INFO), public :: dxcc type(DECOMP_INFO), public :: dxpc type(DECOMP_INFO), public :: dxcp real(kind=wp), public, allocatable :: yMappingpt (:,:) real(kind=wp), public, allocatable :: yMappingcc (:,:) real(kind=wp), public, allocatable :: yp (:) real(kind=wp), public, allocatable :: yc (:) real(kind=wp), public, allocatable :: rc (:) real(kind=wp), public, allocatable :: rp (:) real(kind=wp), public, allocatable :: rci (:) real(kind=wp), public, allocatable :: rpi (:) integer, public, allocatable :: ijnp_sym (:) integer, public, allocatable :: ijnc_sym (:) integer, public, allocatable :: knc_sym (:) real(kind=wp), public, allocatable :: fbcx_qx (:,:,:) real(kind=wp), public, allocatable :: fbcy_qx (:,:,:) real(kind=wp), public, allocatable :: fbcz_qx (:,:,:) real(kind=wp), public, allocatable :: fbcx_gx (:,:,:) real(kind=wp), public, allocatable :: fbcy_gx (:,:,:) real(kind=wp), public, allocatable :: fbcz_gx (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy (:,:,:) real(kind=wp), public, allocatable :: fbcy_qy (:,:,:) real(kind=wp), public, allocatable :: fbcz_qy (:,:,:) real(kind=wp), public, allocatable :: fbcy_qyr (:,:,:) real(kind=wp), public, allocatable :: fbcz_qyr (:,:,:) real(kind=wp), public, allocatable :: fbcx_gy (:,:,:) real(kind=wp), public, allocatable :: fbcy_gy (:,:,:) real(kind=wp), public, allocatable :: fbcz_gy (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz (:,:,:) real(kind=wp), public, allocatable :: fbcy_qz (:,:,:) real(kind=wp), public, allocatable :: fbcz_qz (:,:,:) real(kind=wp), public, allocatable :: fbcy_qzr (:,:,:) real(kind=wp), public, allocatable :: fbcz_qzr (:,:,:) real(kind=wp), public, allocatable :: fbcx_gz (:,:,:) real(kind=wp), public, allocatable :: fbcy_gz (:,:,:) real(kind=wp), public, allocatable :: fbcz_gz (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr (:,:,:) real(kind=wp), public, allocatable :: fbcy_pr (:,:,:) real(kind=wp), public, allocatable :: fbcz_pr (:,:,:) real(kind=wp), public, allocatable :: fbcx_qw (:,:,:) real(kind=wp), public, allocatable :: fbcy_qw (:,:,:) real(kind=wp), public, allocatable :: fbcz_qw (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_outl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_outl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qx_inl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qy_inl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_qz_inl2 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_inl1 (:,:,:) real(kind=wp), public, allocatable :: fbcx_pr_inl2 (:,:,:) type( t_fluidThermoProperty ), public, allocatable :: fbcx_ftp (:,:,:) type( t_fluidThermoProperty ), public, allocatable :: fbcy_ftp (:,:,:) type( t_fluidThermoProperty ), public, allocatable :: fbcz_ftp (:,:,:) real(kind=WP), public, allocatable :: probexyz (:,:) logical, public, allocatable :: probe_is_in (:) integer, public, allocatable :: probexid (:,:) type, public :: t_flow Components Type Visibility Attributes Name Initial integer, public :: idriven integer, public :: igravity integer, public :: inittype integer, public :: iterfrom integer, public :: initReTo integer, public :: nIterFlowStart integer, public :: nIterFlowEnd integer, public :: iteration real(kind=WP), public :: time real(kind=WP), public :: ren real(kind=WP), public :: rre real(kind=WP), public :: init_velo3d (NDIM) real(kind=wp), public :: reninit real(kind=WP), public :: drvfc real(kind=WP), public :: fgravity (NDIM) real(kind=wp), public :: noiselevel real(kind=wp), public :: mcon (3) real(kind=wp), public :: tt_mass_change real(kind=wp), public :: tt_kinetic_energy real(kind=WP), public, allocatable :: qx (:,:,:) real(kind=WP), public, allocatable :: qy (:,:,:) real(kind=WP), public, allocatable :: qz (:,:,:) real(kind=WP), public, allocatable :: gx (:,:,:) real(kind=WP), public, allocatable :: gy (:,:,:) real(kind=WP), public, allocatable :: gz (:,:,:) real(kind=WP), public, allocatable :: gx0 (:,:,:) real(kind=WP), public, allocatable :: gy0 (:,:,:) real(kind=WP), public, allocatable :: gz0 (:,:,:) real(kind=WP), public, allocatable :: pres (:,:,:) real(kind=WP), public, allocatable :: pcor (:,:,:) real(kind=WP), public, allocatable :: pcor_zpencil_ggg (:,:,:) real(kind=WP), public, allocatable :: dDens (:,:,:) real(kind=WP), public, allocatable :: drhodt (:,:,:) real(kind=WP), public, allocatable :: mVisc (:,:,:) real(kind=WP), public, allocatable :: dDensm1 (:,:,:) real(kind=WP), public, allocatable :: dDensm2 (:,:,:) real(kind=WP), public, allocatable :: mx_rhs (:,:,:) real(kind=WP), public, allocatable :: my_rhs (:,:,:) real(kind=WP), public, allocatable :: mz_rhs (:,:,:) real(kind=WP), public, allocatable :: mx_rhs0 (:,:,:) real(kind=WP), public, allocatable :: my_rhs0 (:,:,:) real(kind=WP), public, allocatable :: mz_rhs0 (:,:,:) real(kind=WP), public, allocatable :: fbcx_qx_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_qy_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_qz_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_gx_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_gy_rhs0 (:,:) real(kind=WP), public, allocatable :: fbcx_gz_rhs0 (:,:) real(kind=WP), public, allocatable :: lrfx (:,:,:) real(kind=WP), public, allocatable :: lrfy (:,:,:) real(kind=WP), public, allocatable :: lrfz (:,:,:) real(kind=WP), public, allocatable :: u_vector_mean (:,:,:,:) real(kind=WP), public, allocatable :: pr_mean (:,:,:) real(kind=WP), public, allocatable :: uu_tensor6_mean (:,:,:,:) type, public :: t_thermo Components Type Visibility Attributes Name Initial integer, public :: ifluid integer, public :: inittype integer, public :: iterfrom integer, public :: iteration integer, public :: nIterThermoStart integer, public :: nIterThermoEnd real(kind=WP), public :: ref_l0 real(kind=WP), public :: ref_T0 real(kind=WP), public :: init_T0 real(kind=WP), public :: time real(kind=WP), public :: rPrRen real(kind=WP), public :: tt_enthalpy real(kind=WP), public, allocatable :: rhoh (:,:,:) real(kind=WP), public, allocatable :: hEnth (:,:,:) real(kind=WP), public, allocatable :: kCond (:,:,:) real(kind=WP), public, allocatable :: tTemp (:,:,:) real(kind=WP), public, allocatable :: ene_rhs (:,:,:) real(kind=WP), public, allocatable :: ene_rhs0 (:,:,:) real(kind=WP), public, allocatable :: fbcx_rhoh_rhs0 (:,:) real(kind=WP), public, allocatable :: t_mean (:,:,:) real(kind=WP), public, allocatable :: tt_mean (:,:,:) type( t_fluidThermoProperty ), public :: ftp_ini type, public :: t_mhd Components Type Visibility Attributes Name Initial logical, public :: is_NStuart logical, public :: is_NHartmn real(kind=WP), public :: NStuart real(kind=WP), public :: NHartmn real(kind=WP), public :: B_static (3) real(kind=WP), public, allocatable :: ep (:,:,:) real(kind=WP), public, allocatable :: jx (:,:,:) real(kind=WP), public, allocatable :: jy (:,:,:) real(kind=WP), public, allocatable :: jz (:,:,:) real(kind=WP), public, allocatable :: bx (:,:,:) real(kind=WP), public, allocatable :: by (:,:,:) real(kind=WP), public, allocatable :: bz (:,:,:) integer, public :: ibcx_ep (2) integer, public :: ibcy_ep (2) integer, public :: ibcz_ep (2) integer, public :: ibcx_jx (2) integer, public :: ibcy_jx (2) integer, public :: ibcz_jx (2) integer, public :: ibcx_jy (2) integer, public :: ibcy_jy (2) integer, public :: ibcz_jy (2) integer, public :: ibcx_jz (2) integer, public :: ibcy_jz (2) integer, public :: ibcz_jz (2) integer, public :: ibcx_bx (2) integer, public :: ibcy_bx (2) integer, public :: ibcz_bx (2) integer, public :: ibcx_by (2) integer, public :: ibcy_by (2) integer, public :: ibcz_by (2) integer, public :: ibcx_bz (2) integer, public :: ibcy_bz (2) integer, public :: ibcz_bz (2) real(kind=WP), public, allocatable :: fbcx_ep (:,:,:) real(kind=WP), public, allocatable :: fbcy_ep (:,:,:) real(kind=WP), public, allocatable :: fbcz_ep (:,:,:) real(kind=WP), public, allocatable :: fbcx_jx (:,:,:) real(kind=WP), public, allocatable :: fbcy_jx (:,:,:) real(kind=WP), public, allocatable :: fbcz_jx (:,:,:) real(kind=WP), public, allocatable :: fbcx_jy (:,:,:) real(kind=WP), public, allocatable :: fbcy_jy (:,:,:) real(kind=WP), public, allocatable :: fbcz_jy (:,:,:) real(kind=WP), public, allocatable :: fbcx_jz (:,:,:) real(kind=WP), public, allocatable :: fbcy_jz (:,:,:) real(kind=WP), public, allocatable :: fbcz_jz (:,:,:) real(kind=WP), public, allocatable :: fbcx_bx (:,:,:) real(kind=WP), public, allocatable :: fbcy_bx (:,:,:) real(kind=WP), public, allocatable :: fbcz_bx (:,:,:) real(kind=WP), public, allocatable :: fbcx_by (:,:,:) real(kind=WP), public, allocatable :: fbcy_by (:,:,:) real(kind=WP), public, allocatable :: fbcz_by (:,:,:) real(kind=WP), public, allocatable :: fbcx_bz (:,:,:) real(kind=WP), public, allocatable :: fbcy_bz (:,:,:) real(kind=WP), public, allocatable :: fbcz_bz (:,:,:)","tags":"","url":"module/udf_type_mod.html"},{"title":"vars_df_mod – CHAPSim2","text":"Uses udf_type_mod Variables Type Visibility Attributes Name Initial type( t_domain ), public, allocatable, save :: domain (:) type( t_flow ), public, allocatable, save :: flow (:) type( t_thermo ), public, allocatable, save :: thermo (:) type( t_mhd ), public, allocatable, save :: mhd (:)","tags":"","url":"module/vars_df_mod.html"},{"title":"io_files_mod – CHAPSim2","text":"Variables Type Visibility Attributes Name Initial character(len=8), public :: dir_code = '0_src' character(len=9), public :: dir_data = '1_data' character(len=6), public :: dir_visu = '2_visu' character(len=9), public :: dir_moni = '3_monitor' character(len=9), public :: dir_chkp = '4_check' Interfaces public        interface operator( .f. ) public  function file_exists (filename) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Functions public  function file_exists (filename) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Subroutines public  subroutine create_directory () Arguments None","tags":"","url":"module/io_files_mod.html"},{"title":"math_mod – CHAPSim2","text":"Uses parameters_constant_mod precision_mod Interfaces public        interface sqrt_wp public pure function sqrt_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sqrt_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface tanh_wp public pure function tanh_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function tanh_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface abs_wp public elemental function abs_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface abs_prec public elemental function abs_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public elemental function abs_csp (r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_cdp (r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface sin_wp public pure function sin_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sin_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface sin_prec public pure function sin_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sin_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface cos_wp public pure function cos_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function cos_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface cos_prec public pure function cos_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function cos_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface tan_wp public pure function tan_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function tan_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public        interface atan_wp public pure function atan_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function atan_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) Functions public elemental function abs_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public elemental function abs_csp (r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public elemental function abs_cdp (r) result(d) Arguments Type Intent Optional Attributes Name complex(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function sqrt_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sqrt_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function sin_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function sin_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function cos_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function cos_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function tanh_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function tanh_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function tan_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function tan_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function atan_sp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=S6P), intent(in) :: r Return Value real(kind=S6P) public pure function atan_dp (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=D15P), intent(in) :: r Return Value real(kind=D15P) public pure function heaviside_step (r) result(d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: r Return Value real(kind=WP)","tags":"","url":"module/math_mod.html"},{"title":"typeconvert_mod – CHAPSim2","text":"Functions public  function int2str (k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k Return Value character(len=20) public  function real2str (r) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value character(len=20)","tags":"","url":"module/typeconvert_mod.html"},{"title":"EvenOdd_mod – CHAPSim2","text":"Functions public  function is_even (number) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Return Value logical","tags":"","url":"module/evenodd_mod.html"},{"title":"flatten_index_mod – CHAPSim2","text":"Interfaces public        interface flatten_index public  function flatten_3d_to_1d (i, j, k, Nx, Ny) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: Nx integer, intent(in) :: Ny Return Value integer public  function flatten_2d_to_1d (i, j, Nx) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: Nx Return Value integer Functions public  function flatten_3d_to_1d (i, j, k, Nx, Ny) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: Nx integer, intent(in) :: Ny Return Value integer public  function flatten_2d_to_1d (i, j, Nx) result(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: Nx Return Value integer","tags":"","url":"module/flatten_index_mod.html"},{"title":"operations – CHAPSim2","text":"\\file operations.f90 \\brief A general operation of derivative and interpolation in 1D. Uses precision_mod Variables Type Visibility Attributes Name Initial real(kind=WP), public, save :: d1fC2C (5,3,0:6) real(kind=WP), public, save :: d1rC2C (5,4,0:6) real(kind=WP), public, save :: d1fC2P (5,3,0:6) real(kind=WP), public, save :: d1rC2P (5,4,0:6) real(kind=WP), public, save :: d2fC2C (5,3,0:6) real(kind=WP), public, save :: d2rC2C (5,4,0:6) real(kind=WP), public, save :: m1fC2P (5,3,0:6) real(kind=WP), public, save :: m1rC2P (5,4,0:6) Subroutines public  subroutine Prepare_LHS_coeffs_for_operations () \\brief Preparing coefficients for TDMA calculation.\nScope:  mpi    called-freq    xdomain\n        all    once           all Arguments None public  subroutine Get_x_midp_C2P_3D (fi3d, fo3d, dm, ibc, fbc2d) \\brief To caculate the mid-point interpolation in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_midp_P2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_midp_C2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_midp_P2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_midp_C2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_midp_P2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1st_derivative_C2C_3D (fi3d, fo3d, dm, ibc, fbc2d) \\brief To caculate the 1st-deriviate in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1st_derivative_P2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1st_derivative_C2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1st_derivative_P2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1st_derivative_C2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1st_derivative_P2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1st_derivative_C2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1st_derivative_P2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1st_derivative_C2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1st_derivative_P2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1st_derivative_C2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1st_derivative_P2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_2nd_derivative_C2C_3D (fi3d, fo3d, dm, ibc, fbc2d) \\brief To caculate the 2nd-deriviate in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_2nd_derivative_P2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_2nd_derivative_C2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_2nd_derivative_P2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_2nd_derivative_C2C_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_2nd_derivative_P2P_3D (fi3d, fo3d, dm, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Test_interpolation (dm) \\brief To test this subroutine for mid-point interpolation. Read more… Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine Test_1st_derivative (dm) \\brief To test this subroutine for mid-point interpolation. Read more… Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine Test_2nd_derivative (dm) \\brief To test this subroutine for mid-point interpolation. Read more… Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"module/operations.html"},{"title":"print_msg_mod – CHAPSim2","text":"Subroutines public  subroutine Print_error_msg (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine Print_warning_msg (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine Print_note_msg (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine Print_debug_start_msg (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg public  subroutine Print_debug_inline_msg (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine Print_debug_mid_msg (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine Print_debug_end_msg () Arguments None public  subroutine Print_3d_array (var, nx, ny, nz, str) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: var (nx,ny,nz) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz character(len=*), intent(in) :: str","tags":"","url":"module/print_msg_mod.html"},{"title":"decomp_operation_mod – CHAPSim2","text":"Functions public  function is_same_decomp (a, b) result(f) Arguments Type Intent Optional Attributes Name type(DECOMP_INFO), intent(in) :: a type(DECOMP_INFO), intent(in) :: b Return Value logical","tags":"","url":"module/decomp_operation_mod.html"},{"title":"code_performance_mod – CHAPSim2","text":"Uses typeconvert_mod print_msg_mod mpi_mod parameters_constant_mod Variables Type Visibility Attributes Name Initial integer, public, parameter :: CPU_TIME_CODE_START = 1 integer, public, parameter :: CPU_TIME_STEP_START = 2 integer, public, parameter :: CPU_TIME_ITER_START = 3 integer, public, parameter :: CPU_TIME_ITER_END = 4 integer, public, parameter :: CPU_TIME_STEP_END = 5 integer, public, parameter :: CPU_TIME_CODE_END = 6 real(kind=wp), public, save :: t_code_start real(kind=wp), public, save :: t_step_start real(kind=wp), public, save :: t_iter_start real(kind=wp), public, save :: t_iter_end real(kind=wp), public, save :: t_step_end real(kind=wp), public, save :: t_code_end integer, public :: cpu_nfre Subroutines public  subroutine call_cpu_time (itype, iterfrom, niter, iter) Arguments Type Intent Optional Attributes Name integer, intent(in) :: itype integer, intent(in) :: iterfrom integer, intent(in) :: niter integer, intent(in), optional :: iter","tags":"","url":"module/code_performance_mod.html"},{"title":"cubic_spline_interpolation – CHAPSim2","text":"Functions public  function spline_interpolation (n, yprofile, b, c, d, y) result(eval) evaluate spline interpolation Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(in) :: yprofile (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: d (n) real(kind=WP), intent(in) :: y Return Value real(kind=WP) Subroutines public  subroutine cubic_spline (n, x, y, b, c, d) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(in) :: y (n) real(kind=wp), intent(out) :: b (n) real(kind=wp), intent(out) :: c (n) real(kind=wp), intent(out) :: d (n)","tags":"","url":"module/cubic_spline_interpolation.html"},{"title":"random_number_generation_mod – CHAPSim2","text":"Uses precision_mod Subroutines public  subroutine initialise_random_number (seed) random_initialise initialises the FORTRAN 90 random number seed. Read more… Arguments Type Intent Optional Attributes Name integer :: seed public  subroutine Generate_rvec_random (alo, ahi, n, a) RVEC_random RETURNs a random REAL(WP) vector in a given range. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: alo real(kind=wp) :: ahi integer :: n real(kind=wp) :: a (n) public  subroutine Generate_r_random (rlo, rhi, r) R_random RETURNs a random REAL(WP) in a given range. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: rlo real(kind=wp) :: rhi real(kind=wp) :: r","tags":"","url":"module/random_number_generation_mod.html"},{"title":"wrt_debug_field_mod – CHAPSim2","text":"Subroutines public  subroutine wrt_3d_pt_debug (var, dtmp, iter, irk, loc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: var (dtmp%xsz(1),dtmp%xsz(2),dtmp%xsz(3)) type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: iter integer, intent(in) :: irk character(len=*), intent(in) :: loc public  subroutine wrt_3d_all_debug (var, dtmp, iter, str, loc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: var (dtmp%xsz(1),dtmp%xsz(2),dtmp%xsz(3)) type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: iter character(len=*), intent(in) :: str character(len=*), intent(in) :: loc","tags":"","url":"module/wrt_debug_field_mod.html"},{"title":"cylindrical_rn_mod – CHAPSim2","text":"Uses print_msg_mod parameters_constant_mod udf_type_mod Subroutines public  subroutine axis_estimating_radial_xpx (var, dtmp, pencil, dm, idir, is_reversed) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: pencil type( t_domain ), intent(in) :: dm integer, intent(in) :: idir logical, intent(in), optional :: is_reversed public  subroutine multiple_cylindrical_rn (var, dtmp, r, n, pencil) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: r (:) integer, intent(in) :: n integer, intent(in) :: pencil public  subroutine multiple_cylindrical_rn_xx4 (var, dtmp, r, n, pencil) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: r (:) integer, intent(in) :: n integer, intent(in) :: pencil public  subroutine multiple_cylindrical_rn_x4x (var, dtmp, r, n, pencil) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: var (:,:,:) type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: r (:) integer, intent(in) :: n integer, intent(in) :: pencil","tags":"","url":"module/cylindrical_rn_mod.html"},{"title":"find_max_min_ave_mod – CHAPSim2","text":"Uses print_msg_mod Subroutines public  subroutine is_valid_number_3D (var, varname) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) character(len=*), intent(in) :: varname public  subroutine Find_maximum_absvar3d (var, varmax_work, dtmp, str, nxst0) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: varmax_work type(DECOMP_INFO), intent(in) :: dtmp character(len=*), intent(in) :: str integer, intent(in), optional :: nxst0 public  subroutine Find_max_min_3d (var, str, fmt) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) character(len=*), intent(in) :: str character(len=*), intent(in) :: fmt public  subroutine Find_max_min_absvar3d (var, str, fmt) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: var (:,:,:) character(len=*), intent(in) :: str character(len=*), intent(in) :: fmt public  subroutine Get_volumetric_average_3d_for_var_xcx (dm, dtmp, var, fo_work, itype, str) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work integer, intent(in) :: itype character(len=*), intent(in), optional :: str public  subroutine Get_area_average_2d_for_fbcx (dm, dtmp, var, fo_work, itype, str) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work (2) integer, intent(in) :: itype character(len=4), intent(in) :: str public  subroutine Get_area_average_2d_for_fbcz (dm, dtmp, var, fo_work, itype, str) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work (2) integer, intent(in) :: itype character(len=4), intent(in) :: str public  subroutine Get_area_average_2d_for_fbcy (dm, dtmp, var, fo_work, itype, str) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type(DECOMP_INFO), intent(in) :: dtmp real(kind=WP), intent(in) :: var (:,:,:) real(kind=WP), intent(out) :: fo_work (2) integer, intent(in) :: itype character(len=4), intent(in) :: str","tags":"","url":"module/find_max_min_ave_mod.html"},{"title":"eq_momentum_mod – CHAPSim2","text":"Uses wrt_debug_field_mod precision_mod print_msg_mod operations decomp_2d Subroutines public  subroutine Solve_momentum_eq (fl, dm, isub) \\brief To update the provisional u or rho u. Read more… Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"module/eq_momentum_mod~2.html"},{"title":"geometry_mod – CHAPSim2","text":"\\file geometry.f90 \\brief Building up the geometry and mesh information. Uses print_msg_mod vars_df_mod precision_mod Subroutines public  subroutine Buildup_geometry_mesh_info (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"module/geometry_mod.html"},{"title":"fishpack_fft – CHAPSim2","text":"Uses precision_mod Subroutines public  subroutine fishpack_fft_init (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm public  subroutine fishpack_fft_simple (rhs_xpencil, dm) write( , ) 'fft-xzfft ', rhs_ypencil Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: rhs_xpencil (dm%dccc%xsz(1),dm%dccc%xsz(2),dm%dccc%xsz(3)) type( t_domain ), intent(in) :: dm","tags":"","url":"module/fishpack_fft.html"},{"title":"bc_convective_outlet_mod – CHAPSim2","text":"Uses parameters_constant_mod udf_type_mod decomp_2d Subroutines public  subroutine update_fbcx_convective_outlet_flow (fl, dm, isub) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub public  subroutine update_fbcx_convective_outlet_thermo (fl, tm, dm, isub) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"module/bc_convective_outlet_mod.html"},{"title":"io_restart_mod – CHAPSim2","text":"Uses parameters_constant_mod decomp_2d_io udf_type_mod io_tools_mod print_msg_mod io_files_mod Variables Type Visibility Attributes Name Initial character(len=10), public, parameter :: io_name = \"restart-io\" Subroutines public  subroutine write_instantaneous_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm public  subroutine write_instantaneous_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(in) :: dm public  subroutine read_instantaneous_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm public  subroutine restore_flow_variables_from_restart (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm public  subroutine read_instantaneous_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm public  subroutine restore_thermo_variables_from_restart (fl, tm, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm public  subroutine write_instantaneous_xoutlet (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(inout) :: dm public  subroutine read_instantaneous_xinlet (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(inout) :: dm","tags":"","url":"module/io_restart_mod.html"},{"title":"io_monitor_mod – CHAPSim2","text":"Uses print_msg_mod precision_mod Subroutines public  subroutine write_monitor_ini (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine write_monitor_bulk (fl, dm, tm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm type( t_thermo ), intent(in), optional :: tm public  subroutine write_monitor_probe (fl, dm, tm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm type( t_thermo ), intent(in), optional :: tm","tags":"","url":"module/io_monitor_mod.html"},{"title":"bc_dirichlet_mod – CHAPSim2","text":"Uses print_msg_mod parameters_constant_mod udf_type_mod Variables Type Visibility Attributes Name Initial character(len=18), public :: filename (5) Subroutines public  subroutine extract_dirichlet_fbcx (fbc, var, dtmp) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(out) :: fbc (4,dtmp%xsz(2),dtmp%xsz(3)) real(kind=WP), intent(in) :: var (dtmp%xsz(1),dtmp%xsz(2),dtmp%xsz(3)) type(DECOMP_INFO), intent(in) :: dtmp public  subroutine extract_dirichlet_fbcy (fbc, var, dtmp, dm, is_reversed) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(out) :: fbc (dtmp%ysz(1),4,dtmp%ysz(3)) real(kind=WP), intent(in) :: var (dtmp%ysz(1),dtmp%ysz(2),dtmp%ysz(3)) type(DECOMP_INFO), intent(in) :: dtmp type( t_domain ), intent(in) :: dm logical, intent(in), optional :: is_reversed public  subroutine extract_dirichlet_fbcz (fbc, var, dtmp) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(out) :: fbc (dtmp%zsz(1),dtmp%zsz(2),4) real(kind=WP), intent(in) :: var (dtmp%zsz(1),dtmp%zsz(2),dtmp%zsz(3)) type(DECOMP_INFO), intent(in) :: dtmp public  subroutine initialise_fbcx_given_profile (fbcx, var1y, jst, str) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: fbcx (:,:,:) real(kind=WP), intent(in) :: var1y (:) integer, intent(in) :: jst character(len=2), intent(in) :: str public  subroutine initialise_fbc_flow_given (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine initialise_fbc_thermo_given (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(inout) :: dm public  subroutine enforce_velo_from_fbc (dm, ux, uy, uz, fbcx0, fbcy0, fbcz0) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm real(kind=WP), intent(inout), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: ux real(kind=WP), intent(inout), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: uy real(kind=WP), intent(inout), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: uz real(kind=WP), intent(in), optional, dimension(4, dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: fbcx0 real(kind=WP), intent(in), optional, dimension(dm%dcpc%ysz(1), 4, dm%dcpc%ysz(3)) :: fbcy0 real(kind=WP), intent(in), optional, dimension(dm%dccp%zsz(1), dm%dccp%zsz(2), 4) :: fbcz0","tags":"","url":"module/bc_dirichlet_mod.html"},{"title":"convert_primary_conservative_mod – CHAPSim2","text":"Subroutines public  subroutine convert_primary_conservative (fl, dm, itag) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm integer, intent(in) :: itag","tags":"","url":"module/convert_primary_conservative_mod.html"},{"title":"mhd_mod – CHAPSim2","text":"Uses parameters_constant_mod Subroutines public  subroutine initialise_mhd (fl, mh, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_mhd ), intent(inout) :: mh type( t_domain ), intent(in) :: dm public  subroutine compute_Lorentz_force (fl, mh, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_mhd ), intent(inout) :: mh type( t_domain ), intent(in) :: dm","tags":"","url":"module/mhd_mod.html"},{"title":"fft2decomp_interface_mod – CHAPSim2","text":"Uses parameters_constant_mod mpi_mod print_msg_mod decomp_2d math_mod Variables Type Visibility Attributes Name Initial integer, public :: istret integer, public, parameter :: IFORWARD = 1 integer, public, parameter :: IBACKWARD = -1 real(kind=mytype), public :: xlx real(kind=mytype), public :: yly real(kind=mytype), public :: zlz logical, public :: nclx logical, public :: ncly logical, public :: nclz integer, public :: nclx1 integer, public :: ncly1 integer, public :: nclz1 integer, public, save :: nx integer, public, save :: ny integer, public, save :: nz integer, public, save :: nxm integer, public, save :: nym integer, public, save :: nzm real(kind=mytype), public, save :: dx real(kind=mytype), public, save :: dy real(kind=mytype), public, save :: dz real(kind=mytype), public, save :: alpha real(kind=mytype), public, save :: beta real(kind=mytype), public, save :: alcaix6 real(kind=mytype), public, save :: acix6 real(kind=mytype), public, save :: bcix6 real(kind=mytype), public, save :: alcaiy6 real(kind=mytype), public, save :: aciy6 real(kind=mytype), public, save :: bciy6 real(kind=mytype), public, save :: alcaiz6 real(kind=mytype), public, save :: aciz6 real(kind=mytype), public, save :: bciz6 real(kind=mytype), public, save :: ailcaix6 real(kind=mytype), public, save :: aicix6 real(kind=mytype), public, save :: bicix6 real(kind=mytype), public, save :: cicix6 real(kind=mytype), public, save :: dicix6 real(kind=mytype), public, save :: ailcaiy6 real(kind=mytype), public, save :: aiciy6 real(kind=mytype), public, save :: biciy6 real(kind=mytype), public, save :: ciciy6 real(kind=mytype), public, save :: diciy6 real(kind=mytype), public, save :: ailcaiz6 real(kind=mytype), public, save :: aiciz6 real(kind=mytype), public, save :: biciz6 real(kind=mytype), public, save :: ciciz6 real(kind=mytype), public, save :: diciz6 complex(kind=mytype), public, allocatable, dimension(:), save :: zkz complex(kind=mytype), public, allocatable, dimension(:), save :: zk2 complex(kind=mytype), public, allocatable, dimension(:), save :: ezs complex(kind=mytype), public, allocatable, dimension(:), save :: yky complex(kind=mytype), public, allocatable, dimension(:), save :: yk2 complex(kind=mytype), public, allocatable, dimension(:), save :: eys complex(kind=mytype), public, allocatable, dimension(:), save :: xkx complex(kind=mytype), public, allocatable, dimension(:), save :: xk2 complex(kind=mytype), public, allocatable, dimension(:), save :: exs Subroutines public  subroutine build_up_fft2decomp_interface (dm) ipinter=1 : conventional sixth-order interpolation coefficients as described in Lele 1992 <https://www.sciencedirect.com/science/article/pii/002199919290324R> _\\ ipinter=2 : optimal sixth-order interpolation coefficients designed to be as close as possible to spectral interpolators. ipinter=3 : aggressive sixth-order interpolation coefficients designed to add some numerical dissipation at small scales but they could result in spurious oscillations close to a wall.\n if(dm%iAccuracy == IACCU_CD2) then\n   ailcaix6 = ZERO\n   aicix6 = HALF \n   bicix6 = ZERO\n   cicix6 = ZERO\n   dicix6 = ZERO\n else\n   ailcaix6 = THREE * ZPONE\n   aicix6 = ONEPFIVE * HALF\n   bicix6 = ONE * ZPONE * HALF\n   cicix6 = ZERO\n   dicix6 = ZERO\n end if Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm","tags":"","url":"module/fft2decomp_interface_mod.html"},{"title":"decomp_2d_poisson – CHAPSim2","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses decomp_2d_fft fft2decomp_interface_mod decomp_2d Variables Type Visibility Attributes Name Initial procedure(poisson_xxx), public, pointer :: poisson Subroutines public  subroutine decomp_2d_poisson_init () !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Read more… Arguments None public  subroutine decomp_2d_poisson_finalize () Arguments None","tags":"","url":"module/decomp_2d_poisson.html"},{"title":"operations – CHAPSim2","text":"\\file operations.f90 \\brief A general operation of derivative and interpolation in 1D. Uses parameters_constant_mod print_msg_mod precision_mod Variables Type Visibility Attributes Name Initial real(kind=WP), public, save :: d1fC2C (NL,NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1rC2C (NL,2*NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1fP2P (NL,NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1rP2P (NL,2*NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1fC2P (NL,NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1rC2P (NL,2*NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1fP2C (NL,NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: d1rP2C (NL,2*NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: m1fP2C (NL,NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: m1rP2C (NL,2*NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: m1fC2P (NL,NS,NBCS:NBCE,NACC) real(kind=WP), public, save :: m1rC2P (NL,2*NS,NBCS:NBCE,NACC) Subroutines public  subroutine Prepare_LHS_coeffs_for_operations () \\brief Preparing coefficients for TDMA calculation.\nScope:  mpi    called-freq    xdomain\n        all    once           all Arguments None public  subroutine Get_x_midp_C2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) \\brief To caculate the mid-point interpolation in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_midp_P2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_midp_C2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_midp_P2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_midp_C2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_midp_P2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1der_C2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) \\brief To caculate the 1st-deriviate in 3D.\nScope:  mpi            called-freq    xdomain     module\n      in-given pencil    needed       specified   pubic\n\\param[in]     ixsub         x-subdomain index\n\\param[in]     ibc           bc type\n\\param[in]     fbc           bc value\n\\param[in]     inbr          the neibouring index of 4 bc nodes\n\\param[in]     fi            the input array of original variable\n\\param[out]    fo            the output array of interpolated variable Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1der_P2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1der_C2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_x_1der_P2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1der_C2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1der_P2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1der_C2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_y_1der_P2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1der_C2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1der_P2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1der_C2P_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Get_z_1der_P2C_3D (fi3d, fo3d, dm, iacc, ibc, fbc2d) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in) :: fi3d (:,:,:) real(kind=WP), intent(out) :: fo3d (:,:,:) type( t_domain ), intent(in) :: dm integer, intent(in) :: iacc integer, intent(in) :: ibc (2) real(kind=WP), intent(in), optional :: fbc2d (:,:,:) public  subroutine Test_interpolation (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine Test_1st_derivative (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm","tags":"","url":"module/operations~2.html"},{"title":"continuity_eq_mod – CHAPSim2","text":"Uses operations decomp_2d Subroutines public  subroutine Calculate_drhodt (fl, dm) \\brief To calculate d(\\rho)/dt in the continuity eq.\n\\param[in]  dDens            density at the current time step\n\\param[in]  dDensm1          density at the t-1 time step\n\\param[in]  dDensm2          density at the t-2 time step\n\\param[out] drhodt           d(rho)/dt\n\\param[in]  itime            the sub-step in RK3 Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm public  subroutine Get_divergence_flow (fl, div, dm) \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[out]    div          div(q) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl real(kind=WP), intent(out), dimension(dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3)) :: div type( t_domain ), intent(in) :: dm public  subroutine Get_divergence_vector (ux, uy, uz, div, dm) \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[in]     ux           ux or gx\n\\param[in]     uy           uy or gy\n\\param[in]     uz           uz or gz\n\\param[out]    div          div(u) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: ux real(kind=WP), intent(in), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: uy real(kind=WP), intent(in), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: uz real(kind=WP), intent(out), dimension(dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3)) :: div type( t_domain ), intent(in) :: dm public  subroutine Get_divergence_vel_x2z (ux, uy, uz, div_zpencil_ggg, dm) \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[in]     ux           ux or gx\n\\param[in]     uy           uy or gy\n\\param[in]     uz           uz or gz\n\\param[out]    div          div(u) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: ux real(kind=WP), intent(in), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: uy real(kind=WP), intent(in), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: uz real(kind=WP), intent(out), dimension(dm%dccc%zst(1) : dm%dccc%zen(1), dm%dccc%zst(2) : dm%dccc%zen(2), dm%dccc%zst(3) : dm%dccc%zen(3)) :: div_zpencil_ggg type( t_domain ), intent(in) :: dm public  subroutine Check_element_mass_conservation (fl, dm, iter, opt_isub, opt_str) \\brief To calculate divergence of (rho * u) or divergence of (u)\n\\param[in]     ux           ux or gx\n\\param[in]     uy           uy or gy\n\\param[in]     uz           uz or gz\n\\param[out]    div          div(u) or div(g)\n\\param[in]     d            domain Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm integer, intent(in) :: iter integer, intent(in), optional :: opt_isub character(len=*), intent(in), optional :: opt_str","tags":"","url":"module/continuity_eq_mod.html"},{"title":"boundary_conditions_mod – CHAPSim2","text":"Uses parameters_constant_mod bc_dirichlet_mod udf_type_mod bc_convective_outlet_mod bc_ndomain_interior_mod print_msg_mod Variables Type Visibility Attributes Name Initial integer, public, save :: mbcx_cov1 (2) integer, public, save :: mbcy_cov1 (2) integer, public, save :: mbcz_cov1 (2) integer, public, save :: mbcx_tau1 (2) integer, public, save :: mbcy_tau1 (2) integer, public, save :: mbcz_tau1 (2) integer, public, save :: mbcx_cov2 (2) integer, public, save :: mbcy_cov2 (2) integer, public, save :: mbcz_cov2 (2) integer, public, save :: mbcr_cov2 (2) integer, public, save :: mbcy_tau2 (2) integer, public, save :: mbcx_tau2 (2) integer, public, save :: mbcz_tau2 (2) integer, public, save :: mbcr_tau2 (2) integer, public, save :: mbcx_cov3 (2) integer, public, save :: mbcy_cov3 (2) integer, public, save :: mbcz_cov3 (2) integer, public, save :: mbcr_cov3 (2) integer, public, save :: mbcy_tau3 (2) integer, public, save :: mbcx_tau3 (2) integer, public, save :: mbcz_tau3 (2) integer, public, save :: mbcr_tau3 (2) integer, public, save :: ebcx_conv (2) integer, public, save :: ebcy_conv (2) integer, public, save :: ebcz_conv (2) integer, public, save :: ebcx_difu (2) integer, public, save :: ebcy_difu (2) integer, public, save :: ebcz_difu (2) logical, public, save :: is_fbcx_velo_required logical, public, save :: is_fbcy_velo_required logical, public, save :: is_fbcz_velo_required Subroutines public  subroutine config_calc_basic_ibc (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine allocate_fbc_flow (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine allocate_fbc_thermo (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine update_fbcy_cc_flow_halo (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm public  subroutine update_fbcy_cc_thermo_halo (fl, tm, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(in) :: tm type( t_domain ), intent(inout) :: dm public  subroutine build_bc_symm_operation (ibc, mbc, jbc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) integer, intent(out) :: mbc (2,3) integer, intent(in), optional :: jbc (2) public  subroutine config_calc_eqs_ibc (dm) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm public  subroutine get_fbcx_iTh (ibc, dm, fbc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) type( t_domain ), intent(in) :: dm real(kind=WP), intent(out) :: fbc (4,dm%dpcc%xsz(2),dm%dpcc%xsz(3)) public  subroutine get_fbcy_iTh (ibc, dm, fbc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) type( t_domain ), intent(in) :: dm real(kind=WP), intent(out) :: fbc (dm%dcpc%ysz(1),4,dm%dcpc%ysz(3)) public  subroutine get_fbcz_iTh (ibc, dm, fbc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ibc (2) type( t_domain ), intent(in) :: dm real(kind=WP), intent(out) :: fbc (dm%dccp%zsz(1),dm%dccp%zsz(2),4)","tags":"","url":"module/boundary_conditions_mod.html"},{"title":"input_general_mod – CHAPSim2","text":"\\file input_general.f90\n\\brief Reading the input parameters from the given file.\n\\author Wei Wang wei.wang@stfc.ac.uk\n\\date 11-05-2022, checked. Uses print_msg_mod parameters_constant_mod Variables Type Visibility Attributes Name Initial logical, public :: is_prerun logical, public :: is_postprocess Functions public  function get_name_drivenforce (ifl) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ifl Return Value character(len=72) Subroutines public  subroutine Read_input_parameters () \\brief Reading the input parameters from the given file. Scope:  mpi    called-freq    xdomain\n        all    once           all\n\\param[in]     none          NA\n\\param[out]    none          NA Arguments None","tags":"","url":"module/input_general_mod.html"},{"title":"apx_prerun_mod – CHAPSim2","text":"Uses parameters_constant_mod input_general_mod mpi_mod wtformat_mod math_mod Variables Type Visibility Attributes Name Initial real(kind=WP), public, parameter :: dxplus_max = 10.0_WP real(kind=WP), public, parameter :: dzplus_max = 5.0_WP real(kind=WP), public, parameter :: dyplus_max = 1.0_WP real(kind=WP), public, parameter :: Cflmax = 0.714_WP real(kind=WP), public, parameter :: Ctmmax = 0.1_WP real(kind=WP), public, save :: dymax real(kind=WP), public, save :: dymin real(kind=WP), public, save :: rmin real(kind=WP), public, save :: rmax real(kind=WP), public, save :: Re_tau real(kind=WP), public, save :: u_tau Subroutines public  subroutine estimate_spacial_resolution (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm public  subroutine estimate_temporal_resolution (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"module/apx_prerun_mod.html"},{"title":"eq_energy_mod – CHAPSim2","text":"Uses wrt_debug_field_mod operations decomp_2d Subroutines public  subroutine Update_thermal_properties (fl, tm, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm public  subroutine Solve_energy_eq (fl, tm, dm, isub) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(inout) :: dm integer, intent(in) :: isub","tags":"","url":"module/eq_energy_mod.html"},{"title":"decomp_2d_poisson – CHAPSim2","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses decomp_2d_fft poisson_interface_mod decomp_2d Variables Type Visibility Attributes Name Initial procedure(poisson_xxx), public, pointer :: poisson Subroutines public  subroutine decomp_2d_poisson_init () !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Read more… Arguments None public  subroutine decomp_2d_poisson_finalize () Arguments None","tags":"","url":"module/decomp_2d_poisson~2.html"},{"title":"bc_ndomain_interior_mod – CHAPSim2","text":"Uses print_msg_mod parameters_constant_mod decomp_2d udf_type_mod Subroutines public  subroutine update_fbc_2dm_flow_halo (dm1, fl1, dm2, fl2) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm1 type( t_flow ), intent(in) :: fl1 type( t_domain ), intent(inout) :: dm2 type( t_flow ), intent(in) :: fl2 public  subroutine update_fbc_2dm_thermo_halo (dm1, tm1, dm2, tm2) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(inout) :: dm1 type( t_thermo ), intent(in) :: tm1 type( t_domain ), intent(inout) :: dm2 type( t_thermo ), intent(in) :: tm2","tags":"","url":"module/bc_ndomain_interior_mod.html"},{"title":"statistics_mod – CHAPSim2","text":"Uses print_msg_mod parameters_constant_mod Variables Type Visibility Attributes Name Initial character(len=13), public, parameter :: io_name = \"statistics-io\" integer, public, allocatable :: ncl_stat (:,:) Subroutines public  subroutine init_statistics_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm public  subroutine read_statistics_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm public  subroutine init_statistics_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm public  subroutine read_statistics_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm public  subroutine update_statistics_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm public  subroutine write_statistics_flow (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm public  subroutine update_statistics_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm public  subroutine write_statistics_thermo (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(in) :: tm type( t_domain ), intent(in) :: dm","tags":"","url":"module/statistics_mod.html"},{"title":"solver_tools_mod – CHAPSim2","text":"Subroutines public  subroutine Update_Re (iter, fl) \\brief The main code for initialising flow variables\nThis subroutine is called once in \\ref initialise_chapsim. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter type( t_flow ), intent(inout) :: fl public  subroutine Update_PrGr (fl, tm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_thermo ), intent(inout) :: tm public  subroutine Calculate_xz_mean_yprofile (var, dtmp, n, varxz_work1) \\brief The main code for initialising flow variables Read more… Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dtmp%xsz(1), dtmp%xsz(2), dtmp%xsz(3)) :: var type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: n real(kind=WP), intent(out), optional, dimension(n) :: varxz_work1 public  subroutine Adjust_to_xzmean_zero (var, dtmp, n, varxz) \\brief : \nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z)\n\\param[inout] Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout), dimension(dtmp%xsz(1), dtmp%xsz(2), dtmp%xsz(3)) :: var type(DECOMP_INFO), intent(in) :: dtmp integer, intent(in) :: n real(kind=WP), intent(in), dimension(n) :: varxz public  subroutine Check_cfl_diffusion (fl, dm) \\brief : \nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z)\n\\param[inout] Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm public  subroutine Check_cfl_convection (u, v, w, dm) \\brief : to check CFL for convection terms\nCFL = u&#94;x/dx + v&#94;y/dy + w&#94;z/dz < limit\nMPI : x-pencil\n (y) &#94; _ | |_____|______|\n     |_____|_____|______| > (z) Read more… Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)) :: u real(kind=WP), intent(in), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)) :: v real(kind=WP), intent(in), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)) :: w type( t_domain ), intent(inout) :: dm public  subroutine get_fbcx_ftp_4pc (fbcx_ftp_4cc, fbcx_ftp_4pc, dm) \\brief : to calculate:\n         fo = \\int_1&#94;nx \\int_\n This is based only y-direction stretching.\n \\todo Here is 2nd order Trapezoid Method. Need to improve! Check!\n Scope:  mpi    called-freq    xdomain     module\n         all    needed         specified   pubic\n MPI : \n     default x-pencil\n     working in : y-pencil\n  (y) &#94; _ | |_____|______|\n      |_____|_____|______| > (z)\n Y: index arrangment\n      j'-1   j'-1  j'    j'+1  j'+2\n      _| . | . | . | . | . j-2   j-1   j     j+1    j+2\n \\param[inout] Arguments Type Intent Optional Attributes Name real(kind=WP), intent(in), dimension(dm%d4cc%xsz(1), dm%d4cc%xsz(2), dm%d4cc%xsz(3)) :: fbcx_ftp_4cc real(kind=WP), intent(out), dimension(dm%d4pc%xsz(1), dm%d4pc%xsz(2), dm%d4pc%xsz(3)) :: fbcx_ftp_4pc type( t_domain ), intent(in) :: dm","tags":"","url":"module/solver_tools_mod.html"},{"title":"flow_thermo_initialiasation – CHAPSim2","text":"Uses print_msg_mod vars_df_mod solver_tools_mod Subroutines public  subroutine Allocate_flow_variables (fl, dm) \\brief Allocate flow and thermal variables. Scope:  mpi    called-freq    xdomain     module\n        all    once           specified   private\n\\param[in]     none          NA\n\\param[out]    none          NA Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(in) :: dm public  subroutine Allocate_thermo_variables (tm, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_domain ), intent(in) :: dm public  subroutine initialise_flow_from_given_inlet (dm, fl) Arguments Type Intent Optional Attributes Name type( t_domain ), intent(in) :: dm type( t_flow ), intent(inout) :: fl public  subroutine initialise_flow_fields (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm public  subroutine initialise_thermo_fields (tm, fl, dm) Arguments Type Intent Optional Attributes Name type( t_thermo ), intent(inout) :: tm type( t_flow ), intent(inout) :: fl type( t_domain ), intent(inout) :: dm public  subroutine Validate_TGV2D_error (fl, dm) Arguments Type Intent Optional Attributes Name type( t_flow ), intent(in) :: fl type( t_domain ), intent(in) :: dm","tags":"","url":"module/flow_thermo_initialiasation.html"},{"title":"domain_decomposition_mod – CHAPSim2","text":"Uses mpi_mod decomp_2d Subroutines public  subroutine Buildup_mpi_domain_decomposition () \\brief domain decompistion. Scope:  mpi    called-freq    xdomain   module\n        all    once           all       public\n\\param[in]     none          NA Arguments None","tags":"","url":"module/domain_decomposition_mod.html"},{"title":"chapsim – CHAPSim2","text":"CHAPSim version 2.0.0\n                  -------------------------- This file is part of CHAPSim, a general-purpose CFD tool. This program is free software; you can redistribute it and/or modify it under\n the terms of the GNU General Public License as published by the Free Software\n Foundation; either version 3 of the License, or (at your option) any later\n version. This program is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n details. You should have received a copy of the GNU General Public License along with\n this program; if not, write to the Free Software Foundation, Inc., 51 Franklin\n Street, Fifth Floor, Boston, MA 02110-1301, USA.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n \\file chapsim.f90\n \\brief the main program.\n \\author Wei Wang, wei.wang@stfc.ac.uk\n \\date","tags":"","url":"program/chapsim.html"},{"title":"poisson_interface.f90 – CHAPSim2","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Source Code module decomp_extended_mod use parameters_constant_mod implicit none public :: ypencil_index_lgl2ggl public :: zpencil_index_llg2ggg public :: zpencil_index_ggg2llg contains !========================================================================================================== subroutine ypencil_index_lgl2ggl ( vin , vou , dtmp ) use decomp_2d implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )), intent ( in ) :: vin real ( WP ), dimension ( dtmp % yst ( 1 ) : dtmp % yen ( 2 ), dtmp % ysz ( 2 ), dtmp % zsz ( 3 )), intent ( out ) :: vou integer :: i , j , k , ii vou = ZERO do k = 1 , dtmp % ysz ( 3 ) do j = 1 , dtmp % ysz ( 2 ) do i = 1 , dtmp % ysz ( 1 ) ii = dtmp % yst ( 1 ) + i - 1 vou ( ii , j , k ) = vin ( i , j , k ) end do end do end do return end subroutine !========================================================================================================== subroutine zpencil_index_llg2ggg ( vin , vou , dtmp ) use decomp_2d implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )), intent ( in ) :: vin real ( WP ), dimension ( dtmp % zst ( 1 ) : dtmp % zen ( 1 ), dtmp % zst ( 2 ) : dtmp % zen ( 2 ), dtmp % zsz ( 3 )), intent ( out ) :: vou integer :: i , j , k , jj , ii vou = ZERO do k = 1 , dtmp % zsz ( 3 ) do j = 1 , dtmp % zsz ( 2 ) jj = dtmp % zst ( 2 ) + j - 1 !local2global_yid(j, dtmp) do i = 1 , dtmp % zsz ( 1 ) ii = dtmp % zst ( 1 ) + i - 1 vou ( ii , jj , k ) = vin ( i , j , k ) end do end do end do return end subroutine !========================================================================================================== subroutine zpencil_index_ggg2llg ( vin , vou , dtmp ) use decomp_2d implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), dimension ( dtmp % zst ( 1 ) : dtmp % zen ( 1 ), dtmp % zst ( 2 ) : dtmp % zen ( 2 ), dtmp % zsz ( 3 )), intent ( in ) :: vin real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )), intent ( out ) :: vou integer :: i , j , k , jj , ii !write(*,*) 'vin', nrank, size(vin, 1), size(vin, 2),size(vin, 3) !write(*,*) 'vou', nrank, size(vou, 1), size(vou, 2),size(vou, 3) vou = ZERO do k = 1 , dtmp % zsz ( 3 ) do j = 1 , dtmp % zsz ( 2 ) jj = dtmp % zst ( 2 ) + j - 1 !local2global_yid(j, dtmp) do i = 1 , dtmp % zsz ( 1 ) ii = dtmp % zst ( 1 ) + i - 1 vou ( i , j , k ) = vin ( ii , jj , k ) end do end do end do return end subroutine end module !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !========================================================================================================== module poisson_interface_mod use parameters_constant_mod use fft2decomp_interface_mod use decomp_2d_poisson use decomp_extended_mod use fishpack_fft implicit none public :: initialise_fft public :: solve_fft_poisson contains !========================================================================================================== !========================================================================================================== subroutine initialise_fft ( dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialising the Poisson solver ...\" ) if ( dm % ifft_lib == FFT_2DECOMP_3DFFT ) then call build_up_fft2decomp_interface ( dm ) call decomp_2d_poisson_init () else if ( dm % ifft_lib == FFT_FISHPACK_2DFFT ) then call fishpack_fft_init ( dm ) else call Print_error_msg ( 'Error in selecting FFT libs' ) end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine solve_fft_poisson ( rhs_xpencil , dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm integer :: i , j , k real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ), intent ( INOUT ) :: rhs_xpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: rhs_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: rhs_zpencil real ( WP ), dimension ( dm % dccc % zst ( 1 ) : dm % dccc % zen ( 1 ), & dm % dccc % zst ( 2 ) : dm % dccc % zen ( 2 ), & dm % dccc % zst ( 3 ) : dm % dccc % zen ( 3 ) ) :: rhs_zpencil_ggg if ( dm % ifft_lib == FFT_2DECOMP_3DFFT ) then call transpose_x_to_y ( rhs_xpencil , rhs_ypencil , dm % dccc ) call transpose_y_to_z ( rhs_ypencil , rhs_zpencil , dm % dccc ) call zpencil_index_llg2ggg ( rhs_zpencil , rhs_zpencil_ggg , dm % dccc ) call poisson ( rhs_zpencil_ggg ) call zpencil_index_ggg2llg ( rhs_zpencil_ggg , rhs_zpencil , dm % dccc ) call transpose_z_to_y ( rhs_zpencil , rhs_ypencil , dm % dccc ) call transpose_y_to_x ( rhs_ypencil , rhs_xpencil , dm % dccc ) else if ( dm % ifft_lib == FFT_FISHPACK_2DFFT ) then call fishpack_fft_simple ( rhs_xpencil , dm ) else call Print_error_msg ( 'Error in selecting FFT libs' ) end if return end subroutine end module","tags":"","url":"sourcefile/poisson_interface.f90.html"},{"title":"input_thermo.f90 – CHAPSim2","text":"Source Code !---------------------------------------------------------------------------------------------------------- !                      CHAPSim version 2.0.0 !                      -------------------------- ! This file is part of CHAPSim, a general-purpose CFD tool. ! ! This program is free software; you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation; either version 3 of the License, or (at your option) any later ! version. ! ! This program is distributed in the hope that it will be useful, but WITHOUT ! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS ! FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more ! details. ! ! You should have received a copy of the GNU General Public License along with ! this program; if not, write to the Free Software Foundation, Inc., 51 Franklin ! Street, Fifth Floor, Boston, MA 02110-1301, USA. !---------------------------------------------------------------------------------------------------------- !========================================================================================================== !> \\file input_thermo.f90 !> !> \\brief Reading the input parameters from the given file and building up the !> relationships between properties. !> !========================================================================================================== module thermo_info_mod use parameters_constant_mod use udf_type_mod use wtformat_mod use mpi_mod use print_msg_mod implicit none integer , save :: N_FUNC2TABLE = 1024 logical :: is_ftplist_dim type ( t_fluidThermoProperty ), save , allocatable , dimension (:) :: ftplist private :: buildup_property_relations_from_table private :: buildup_property_relations_from_function private :: ftplist_check_monotonicity_DH_of_HorT private :: Buildup_fluidparam private :: ftplist_sort_t_small2big private :: Write_thermo_property private :: ftp_is_T_in_scope private :: ftp_get_thermal_properties_dimensional_from_T private :: ftp_refresh_thermal_properties_from_T_undim public :: ftp_refresh_thermal_properties_from_T_undim_3D private :: ftp_refresh_thermal_properties_from_H private :: ftp_convert_undim_to_dim private :: ftp_print public :: ftp_refresh_thermal_properties_from_DH public :: Buildup_thermo_mapping_relations public :: initialise_thermal_properties public :: Convert_thermal_input_2undim contains !========================================================================================================== !========================================================================================================== !> \\brief Defination of a procedure in the type t_fluidThermoProperty. !>  to check the temperature limitations. !> !> This subroutine is called as required to check the temperature !> of given element is within the given limits as a single phase !> flow. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  this          a cell element with udf property !_______________________________________________________________________________ subroutine ftp_is_T_in_scope ( this ) type ( t_fluidThermoProperty ), intent ( in ) :: this integer :: nlist nlist = fluidparam % nlist if ( fluidparam % ipropertyState == IPROPERTY_TABLE ) then if ( ( this % t < ftplist ( 1 )% t ) . OR . & ( this % t > ftplist ( nlist )% t ) ) then write ( * , wrtfmt3r ) 'this T, low T, high T:' , this % t , ftplist ( 1 )% t , ftplist ( nlist )% t write ( * , wrtfmt3r ) 'this rhoh, low rhoh, high rhoh' , this % rhoh , fluidparam % dhmin , fluidparam % dhmax call Print_error_msg ( 'temperature exceeds specified range.' ) end if end if if ( fluidparam % ipropertyState == IPROPERTY_FUNCS ) then if ( ( this % t < ( fluidparam % TM0 / fluidparam % ftp0ref % t ) ) . OR . & ( this % t > ( fluidparam % TB0 / fluidparam % ftp0ref % t ) ) ) then write ( * , wrtfmt3r ) 'this T, low T, high T:' , this % t , fluidparam % TM0 / fluidparam % ftp0ref % t , fluidparam % TB0 / fluidparam % ftp0ref % t write ( * , wrtfmt3r ) 'this rhoh, low rhoh, high rhoh' , this % rhoh , fluidparam % dhmin , fluidparam % dhmax call Print_error_msg ( 'temperature exceeds specified range.' ) end if end if return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief Defination of a procedure in the type t_fluidThermoProperty. !>  to update the thermal properties based on the known temperature. !> !> This subroutine is called as required to update all thermal properties from !> the known temperature (dimensional or dimensionless). !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  this          a cell element with udf property !> \\param[in]     dim           an optional indicator of dimensional !>                              /dimensionless T. Exsiting of \\ref dim indicates !>                              the known/given T is dimensional. Otherwise, not. !_______________________________________________________________________________ subroutine ftp_get_thermal_properties_dimensional_from_T ( this ) type ( t_fluidThermoProperty ), intent ( inout ) :: this integer :: i1 , i2 , im real ( WP ) :: d1 , dm real ( WP ) :: w1 , w2 real ( WP ) :: t1 , dummy if (. not . is_ftplist_dim ) call Print_error_msg ( \"Error. Please provide dimensional thermal property.\" ) if ( fluidparam % ipropertyState == IPROPERTY_TABLE ) then i1 = 1 i2 = fluidparam % nlist do while ( ( i2 - i1 ) > 1 ) im = i1 + ( i2 - i1 ) / 2 d1 = ftplist ( i1 )% t - this % t dm = ftplist ( im )% t - this % t if ( ( d1 * dm ) > MINP ) then i1 = im else i2 = im end if end do w1 = ( ftplist ( i2 )% t - this % t ) / ( ftplist ( i2 )% t - ftplist ( i1 )% t ) w2 = ONE - w1 this % d = w1 * ftplist ( i1 )% d + w2 * ftplist ( i2 )% d this % m = w1 * ftplist ( i1 )% m + w2 * ftplist ( i2 )% m this % k = w1 * ftplist ( i1 )% k + w2 * ftplist ( i2 )% k this % h = w1 * ftplist ( i1 )% h + w2 * ftplist ( i2 )% h this % b = w1 * ftplist ( i1 )% b + w2 * ftplist ( i2 )% b this % cp = w1 * ftplist ( i1 )% cp + w2 * ftplist ( i2 )% cp this % rhoh = this % d * this % h else if ( fluidparam % ipropertyState == IPROPERTY_FUNCS ) then t1 = this % t ! D = density = f(T) this % d = fluidparam % CoD ( 0 ) + & fluidparam % CoD ( 1 ) * t1 ! K = thermal conductivity = f(T) this % k = fluidparam % CoK ( 0 ) + & fluidparam % CoK ( 1 ) * t1 + & fluidparam % CoK ( 2 ) * t1 ** 2 ! Cp = f(T) this % cp = fluidparam % CoCp ( - 2 ) * t1 ** ( - 2 ) + & fluidparam % CoCp ( - 1 ) * t1 ** ( - 1 ) + & fluidparam % CoCp ( 0 ) + & fluidparam % CoCp ( 1 ) * t1 + & fluidparam % CoCp ( 2 ) * t1 ** 2 ! H = entropy = f(T) this % h = fluidparam % Hm0 + & fluidparam % CoH ( - 1 ) * ( ONE / t1 - ONE / fluidparam % TM0 ) + & fluidparam % CoH ( 0 ) + & fluidparam % CoH ( 1 ) * ( t1 - fluidparam % TM0 ) + & fluidparam % CoH ( 2 ) * ( t1 ** 2 - fluidparam % TM0 ** 2 ) + & fluidparam % CoH ( 3 ) * ( t1 ** 3 - fluidparam % TM0 ** 3 ) ! B = f(T) this % b = ONE / ( fluidparam % CoB - t1 ) ! dynamic viscosity = f(T) select case ( fluidparam % ifluid ) ! unit: T(Kelvin), M(Pa S) case ( ILIQUID_SODIUM ) dummy = EXP ( CoM_Na ( - 1 ) / t1 + & CoM_Na ( 0 ) + & CoM_Na ( 1 ) * LOG ( t1 ) ) case ( ILIQUID_LEAD ) dummy = CoM_Pb ( 0 ) * EXP ( CoM_Pb ( - 1 ) / t1 ) case ( ILIQUID_BISMUTH ) dummy = CoM_Bi ( 0 ) * EXP ( CoM_Bi ( - 1 ) / t1 ) case ( ILIQUID_LBE ) dummy = CoM_LBE ( 0 ) * EXP ( CoM_LBE ( - 1 ) / t1 ) case default dummy = EXP ( CoM_Na ( - 1 ) / t1 + & CoM_Na ( 0 ) + & CoM_Na ( 1 ) * LOG ( t1 ) ) end select this % m = dummy this % rhoh = this % d * this % h else call Print_error_msg ( \"Error.\" ) end if return end subroutine ftp_get_thermal_properties_dimensional_from_T !========================================================================================================== !========================================================================================================== subroutine ftp_refresh_thermal_properties_from_T_undim ( this ) type ( t_fluidThermoProperty ), intent ( inout ) :: this type ( t_fluidThermoProperty ) :: ftp0ref integer :: i1 , i2 , im real ( WP ) :: d1 , dm real ( WP ) :: w1 , w2 real ( WP ) :: t1 , dummy !call Print_debug_start_msg(\"ftp_refresh_thermal_properties_from_T_undim\") if ( fluidparam % ipropertyState == IPROPERTY_TABLE ) then i1 = 1 i2 = fluidparam % nlist do while ( ( i2 - i1 ) > 1 ) im = i1 + ( i2 - i1 ) / 2 d1 = ftplist ( i1 )% t - this % t dm = ftplist ( im )% t - this % t if ( ( d1 * dm ) > MINP ) then i1 = im else i2 = im end if end do w1 = ( ftplist ( i2 )% t - this % t ) / ( ftplist ( i2 )% t - ftplist ( i1 )% t ) w2 = ONE - w1 this % d = w1 * ftplist ( i1 )% d + w2 * ftplist ( i2 )% d this % m = w1 * ftplist ( i1 )% m + w2 * ftplist ( i2 )% m this % k = w1 * ftplist ( i1 )% k + w2 * ftplist ( i2 )% k this % h = w1 * ftplist ( i1 )% h + w2 * ftplist ( i2 )% h this % b = w1 * ftplist ( i1 )% b + w2 * ftplist ( i2 )% b this % cp = w1 * ftplist ( i1 )% cp + w2 * ftplist ( i2 )% cp this % rhoh = this % d * this % h else if ( fluidparam % ipropertyState == IPROPERTY_FUNCS ) then ftp0ref = fluidparam % ftp0ref ! convert undim to dim t1 = this % t * ftp0ref % t ! D = density = f(T) dummy = fluidparam % CoD ( 0 ) + & fluidparam % CoD ( 1 ) * t1 this % d = dummy / ftp0ref % d ! K = thermal conductivity = f(T) dummy = fluidparam % CoK ( 0 ) + & fluidparam % CoK ( 1 ) * t1 + & fluidparam % CoK ( 2 ) * t1 ** 2 this % k = dummy / ftp0ref % k ! Cp = f(T) dummy = fluidparam % CoCp ( - 2 ) * t1 ** ( - 2 ) + & fluidparam % CoCp ( - 1 ) * t1 ** ( - 1 ) + & fluidparam % CoCp ( 0 ) + & fluidparam % CoCp ( 1 ) * t1 + & fluidparam % CoCp ( 2 ) * t1 ** 2 this % cp = dummy / ftp0ref % cp ! H = entropy = f(T) dummy = fluidparam % Hm0 + & fluidparam % CoH ( - 1 ) * ( ONE / t1 - ONE / fluidparam % TM0 ) + & fluidparam % CoH ( 0 ) + & fluidparam % CoH ( 1 ) * ( t1 - fluidparam % TM0 ) + & fluidparam % CoH ( 2 ) * ( t1 ** 2 - fluidparam % TM0 ** 2 ) + & fluidparam % CoH ( 3 ) * ( t1 ** 3 - fluidparam % TM0 ** 3 ) this % h = ( dummy - ftp0ref % h ) / ( ftp0ref % cp * ftp0ref % t ) ! B = f(T) dummy = ONE / ( fluidparam % CoB - t1 ) this % b = dummy / ftp0ref % b ! dynamic viscosity = f(T) select case ( fluidparam % ifluid ) ! unit: T(Kelvin), M(Pa S) case ( ILIQUID_SODIUM ) dummy = EXP ( CoM_Na ( - 1 ) / t1 + CoM_Na ( 0 ) + CoM_Na ( 1 ) * LOG ( t1 ) ) case ( ILIQUID_LEAD ) dummy = CoM_Pb ( 0 ) * EXP ( CoM_Pb ( - 1 ) / t1 ) case ( ILIQUID_BISMUTH ) dummy = CoM_Bi ( 0 ) * EXP ( CoM_Bi ( - 1 ) / t1 ) case ( ILIQUID_LBE ) dummy = CoM_LBE ( 0 ) * EXP ( CoM_LBE ( - 1 ) / t1 ) case default dummy = EXP ( CoM_Na ( - 1 ) / t1 + CoM_Na ( 0 ) + CoM_Na ( 1 ) * LOG ( t1 ) ) end select this % m = dummy / ftp0ref % m this % rhoh = this % d * this % h else this % t = ONE this % d = ONE this % m = ONE this % k = ONE this % cp = ONE this % b = ONE this % h = ZERO this % rhoh = ZERO end if return end subroutine ftp_refresh_thermal_properties_from_T_undim !========================================================================================================== !========================================================================================================== subroutine ftp_refresh_thermal_properties_from_T_undim_3D ( ftp3d ) type ( t_fluidThermoProperty ), intent ( inout ) :: ftp3d (:, :, :) integer :: i , j , k do i = 1 , size ( ftp3d , 1 ) do j = 1 , size ( ftp3d , 2 ) do k = 1 , size ( ftp3d , 3 ) call ftp_refresh_thermal_properties_from_T_undim ( ftp3d ( i , j , k )) end do end do end do return end subroutine ftp_refresh_thermal_properties_from_T_undim_3D !========================================================================================================== !========================================================================================================== !> \\brief Defination of a procedure in the type t_fluidThermoProperty. !>  to update the thermal properties based on the known enthalpy. !> !> This subroutine is called as required to update all thermal properties from !> the known enthalpy (dimensionless only). !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  this          a cell element with udf property !_______________________________________________________________________________ subroutine ftp_refresh_thermal_properties_from_H ( this ) type ( t_fluidThermoProperty ), intent ( inout ) :: this integer :: i1 , i2 , im real ( WP ) :: d1 , dm real ( WP ) :: w1 , w2 i1 = 1 i2 = fluidparam % nlist do while ( ( i2 - i1 ) > 1 ) im = i1 + ( i2 - i1 ) / 2 d1 = ftplist ( i1 )% h - this % h dm = ftplist ( im )% h - this % h if ( ( d1 * dm ) > MINP ) then i1 = im else i2 = im end if end do w1 = ( ftplist ( i2 )% h - this % h ) / ( ftplist ( i2 )% h - ftplist ( i1 )% h ) w2 = ONE - w1 this % d = w1 * ftplist ( i1 )% d + w2 * ftplist ( i2 )% d this % m = w1 * ftplist ( i1 )% m + w2 * ftplist ( i2 )% m this % k = w1 * ftplist ( i1 )% k + w2 * ftplist ( i2 )% k this % t = w1 * ftplist ( i1 )% t + w2 * ftplist ( i2 )% t this % b = w1 * ftplist ( i1 )% b + w2 * ftplist ( i2 )% b this % cp = w1 * ftplist ( i1 )% cp + w2 * ftplist ( i2 )% cp !this%rhoh = this%d * this%h return end subroutine ftp_refresh_thermal_properties_from_H !========================================================================================================== !========================================================================================================== !> \\brief Defination of a procedure in the type t_fluidThermoProperty. !>  to update the thermal properties based on the known enthalpy per unit mass. !> !> This subroutine is called as required to update all thermal properties from !> the known enthalpy per unit mass (dimensionless only). !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  this          a cell element with udf property !_______________________________________________________________________________ subroutine ftp_refresh_thermal_properties_from_DH ( this ) type ( t_fluidThermoProperty ), intent ( inout ) :: this integer :: i1 , i2 , im real ( WP ) :: d1 , dm real ( WP ) :: w1 , w2 if ( is_ftplist_dim ) call Print_error_msg ( \"Error. Please provide undimentional variables.\" ) if ( this % rhoh < fluidparam % dhmin ) then if ( nrank == 0 ) then write ( * , wrtfmt2r ) 'this%rhoh < fluidparam%dhmin' , this % rhoh , fluidparam % dhmin call Print_error_msg ( \"rho*h is out of range.\" ) end if this % rhoh = fluidparam % dhmin else if ( this % rhoh > fluidparam % dhmax ) then if ( nrank == 0 ) then write ( * , wrtfmt2r ) 'this%rhoh > fluidparam%dhmax' , this % rhoh , fluidparam % dhmax call Print_error_msg ( \"rho*h is out of range.\" ) end if this % rhoh = fluidparam % dhmax end if i1 = 1 i2 = fluidparam % nlist do while ( ( i2 - i1 ) > 1 ) im = i1 + ( i2 - i1 ) / 2 d1 = ftplist ( i1 )% rhoh - this % rhoh dm = ftplist ( im )% rhoh - this % rhoh if ( ( d1 * dm ) > MINP ) then i1 = im else i2 = im end if end do w1 = ( ftplist ( i2 )% rhoh - this % rhoh ) / ( ftplist ( i2 )% rhoh - ftplist ( i1 )% rhoh ) w2 = ONE - w1 if ( fluidparam % ipropertyState == IPROPERTY_TABLE ) then this % h = w1 * ftplist ( i1 )% h + w2 * ftplist ( i2 )% h call ftp_refresh_thermal_properties_from_H ( this ) this % h = this % rhoh / this % d call ftp_refresh_thermal_properties_from_H ( this ) else if ( fluidparam % ipropertyState == IPROPERTY_FUNCS ) then this % t = w1 * ftplist ( i1 )% t + w2 * ftplist ( i2 )% t call ftp_refresh_thermal_properties_from_T_undim ( this ) else call Print_error_msg ( 'No such option of ipropertyState.' ) end if return end subroutine ftp_refresh_thermal_properties_from_DH !========================================================================================================== !========================================================================================================== !> \\brief Defination of a procedure in the type t_fluidThermoProperty. !>  to print out the thermal properties at the given element. !> !> This subroutine is called as required to print out thermal properties !> for degbugging. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     this          a cell element with udf property !> \\param[in]     unit !> \\param[in]     iotype !> \\param[in]     v_list !> \\param[out]    iostat !> \\param[inout]  iomsg !_______________________________________________________________________________ subroutine ftp_print ( this , unit , iotype , v_list , iostat , iomsg ) type ( t_fluidThermoProperty ), intent ( in ) :: this integer , intent ( in ) :: unit character ( len = * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len = * ), intent ( inout ) :: iomsg integer :: i_pass iostat = 0 iomsg = \"\" do i_pass = 1 , 1 !write(unit, *, iostat = iostat, iomsg = iomsg) 'thermalProperty' !if(iostat /= 0) exit if ( iotype ( 1 : 2 ) == 'DT' . and . len ( iotype ) > 2 ) & write ( unit , * , iostat = iostat , iomsg = iomsg ) iotype ( 3 :) if ( iostat /= 0 ) exit write ( unit , * , iostat = iostat , iomsg = iomsg ) & this % h , this % t , this % d , this % m , this % k , this % cp , this % b , this % rhoh if ( iostat /= 0 ) exit end do if ( iostat /= 0 ) then write ( * , \"(A)\" ) \"print error : \" // trim ( iomsg ) write ( * , \"(A, I0)\" ) \"  iostat : \" , iostat end if return end subroutine ftp_print !========================================================================================================== !> \\brief Sort out the user given thermal property table based on the temperature !>  from small to big. !> !> This subroutine is called locally once reading in the given thermal table. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout]  list         the thermal table element array !========================================================================================================== subroutine ftplist_sort_t_small2big integer :: i , n , k real ( WP ) :: buf n = fluidparam % nlist do i = 1 , n k = minloc ( ftplist ( i : n )% t , dim = 1 ) + i - 1 buf = ftplist ( i )% t ftplist ( i )% t = ftplist ( k )% t ftplist ( k )% t = buf buf = ftplist ( i )% d ftplist ( i )% d = ftplist ( k )% d ftplist ( k )% d = buf buf = ftplist ( i )% m ftplist ( i )% m = ftplist ( k )% m ftplist ( k )% m = buf buf = ftplist ( i )% k ftplist ( i )% k = ftplist ( k )% k ftplist ( k )% k = buf buf = ftplist ( i )% b ftplist ( i )% b = ftplist ( k )% b ftplist ( k )% b = buf buf = ftplist ( i )% cp ftplist ( i )% cp = ftplist ( k )% cp ftplist ( k )% cp = buf buf = ftplist ( i )% h ftplist ( i )% h = ftplist ( k )% h ftplist ( k )% h = buf buf = ftplist ( i )% rhoh ftplist ( i )% rhoh = ftplist ( k )% rhoh ftplist ( k )% rhoh = buf end do return end subroutine ftplist_sort_t_small2big !========================================================================================================== !========================================================================================================== !> \\brief Check the monotonicity of the $\\rho h$ along $h$ and $T$ !> !> This subroutine is called locally once building up the thermal property !> relationships. Non-monotonicity could happen in fluids at supercritical !> pressure when inproper reference temperature is given. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  none          NA !_______________________________________________________________________________ subroutine ftplist_check_monotonicity_DH_of_HorT integer :: i real ( WP ) :: ddh1 , dt1 , dh1 real ( WP ) :: ddh2 , dt2 , dh2 real ( WP ) :: ddt , ddh if ( nrank /= 0 ) return do i = 2 , fluidparam % nlist - 1 ddh1 = ftplist ( i )% rhoh - ftplist ( i - 1 )% rhoh dt1 = ftplist ( i )% t - ftplist ( i - 1 )% t dh1 = ftplist ( i )% h - ftplist ( i - 1 )% h ddh2 = ftplist ( i + 1 )% rhoh - ftplist ( i )% rhoh dt2 = ftplist ( i + 1 )% t - ftplist ( i )% t dh2 = ftplist ( i + 1 )% h - ftplist ( i )% h ddt = ddh1 / dt1 * ddh2 / dt2 ddh = ddh1 / dh1 * ddh2 / dh2 if ( ddt < MINP . and . nrank == 0 ) then call Print_warning_msg ( 'The relation (rho * h) = FUNCTION (T) is not monotonicity.' ) write ( * , wrtfmt1r ) ' This occurs from T(K) = ' , ftplist ( i )% t * fluidparam % ftp0ref % t call Print_warning_msg ( 'If this temperature locates in-between your interested range, please try to increase your reference temeprature.' ) end if if ( ddh < MINP . and . nrank == 0 ) then call Print_warning_msg ( 'The relation (rho * h) = FUNCTION (H) is not monotonicity.' ) write ( * , wrtfmt1r ) ' This occurs from H(J/KG) = ' , \\ ftplist ( i )% h * fluidparam % ftp0ref % t * fluidparam % ftp0ref % cp + fluidparam % ftp0ref % h call Print_warning_msg ( 'If this H locates in-between your interested range, please try to increase your reference temeprature.' ) end if end do return end subroutine ftplist_check_monotonicity_DH_of_HorT !========================================================================================================== !> \\brief Building up the thermal property relations from the given table. !! This subroutine is called once after reading the table. !! [mpi] all ranks !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     ref_T0          reference temperature !========================================================================================================== subroutine buildup_property_relations_from_table integer , parameter :: IOMSG_LEN = 200 character ( len = IOMSG_LEN ) :: iotxt integer :: ioerr , inputUnit character ( len = 80 ) :: str real ( WP ) :: rtmp integer :: i !---------------------------------------------------------------------------------------------------------- ! to read given table of thermal properties, dimensional !---------------------------------------------------------------------------------------------------------- open ( newunit = inputUnit , & file = fluidparam % inputProperty , & status = 'old' , & action = 'read' , & iostat = ioerr , & iomsg = iotxt ) if ( ioerr /= 0 ) then !write (*, *) 'Problem openning : ', fluidparam%inputProperty, ' for reading.' !write (*, *) 'Message: ', trim (iotxt) call Print_error_msg ( 'Problem openning fluidparam%inputProperty for reading.' ) end if fluidparam % nlist = 0 read ( inputUnit , * , iostat = ioerr ) str do read ( inputUnit , * , iostat = ioerr ) rtmp , rtmp , rtmp , rtmp , & rtmp , rtmp , rtmp , rtmp if ( ioerr /= 0 ) exit fluidparam % nlist = fluidparam % nlist + 1 end do rewind ( inputUnit ) !---------------------------------------------------------------------------------------------------------- ! to read given table of thermal properties, dimensional !---------------------------------------------------------------------------------------------------------- allocate ( ftplist ( fluidparam % nlist ) ) read ( inputUnit , * , iostat = ioerr ) str do i = 1 , fluidparam % nlist read ( inputUnit , * , iostat = ioerr ) rtmp , ftplist ( i )% h , ftplist ( i )% t , ftplist ( i )% d , & ftplist ( i )% m , ftplist ( i )% k , ftplist ( i )% cp , ftplist ( i )% b ftplist ( i )% rhoh = ftplist ( i )% d * ftplist ( i )% h end do close ( inputUnit ) !---------------------------------------------------------------------------------------------------------- ! to sort input date (dimensional) based on Temperature (small to big) !---------------------------------------------------------------------------------------------------------- call ftplist_sort_t_small2big !---------------------------------------------------------------------------------------------------------- ! to update reference of thermal properties !---------------------------------------------------------------------------------------------------------- call ftp_get_thermal_properties_dimensional_from_T ( fluidparam % ftp0ref ) call ftp_get_thermal_properties_dimensional_from_T ( fluidparam % ftpini ) !---------------------------------------------------------------------------------------------------------- ! to unify/undimensionalize the table of thermal property !---------------------------------------------------------------------------------------------------------- do i = 1 , fluidparam % nlist ftplist ( i )% t = ftplist ( i )% t / fluidparam % ftp0ref % t ftplist ( i )% d = ftplist ( i )% d / fluidparam % ftp0ref % d ftplist ( i )% m = ftplist ( i )% m / fluidparam % ftp0ref % m ftplist ( i )% k = ftplist ( i )% k / fluidparam % ftp0ref % k ftplist ( i )% b = ftplist ( i )% b / fluidparam % ftp0ref % b ftplist ( i )% cp = ftplist ( i )% cp / fluidparam % ftp0ref % cp ftplist ( i )% h = ( ftplist ( i )% h - fluidparam % ftp0ref % h ) / fluidparam % ftp0ref % t / fluidparam % ftp0ref % cp ftplist ( i )% rhoh = ftplist ( i )% d * ftplist ( i )% h end do call ftplist_check_monotonicity_DH_of_HorT i = minloc ( ftplist ( 1 : fluidparam % nlist )% rhoh , dim = 1 ) fluidparam % dhmin = ftplist ( i )% rhoh ! undim i = maxloc ( ftplist ( 1 : fluidparam % nlist )% rhoh , dim = 1 ) fluidparam % dhmax = ftplist ( i )% rhoh ! undim is_ftplist_dim = . false . return end subroutine buildup_property_relations_from_table !========================================================================================================== subroutine ftp_convert_undim_to_dim ( ftp_undim , ftp_dim ) type ( t_fluidThermoProperty ), intent ( in ) :: ftp_undim type ( t_fluidThermoProperty ), intent ( out ) :: ftp_dim ftp_dim % t = ftp_undim % t * fluidparam % ftp0ref % t ftp_dim % d = ftp_undim % d * fluidparam % ftp0ref % d ftp_dim % m = ftp_undim % m * fluidparam % ftp0ref % m ftp_dim % k = ftp_undim % k * fluidparam % ftp0ref % k ftp_dim % b = ftp_undim % b * fluidparam % ftp0ref % b ftp_dim % cp = ftp_undim % cp * fluidparam % ftp0ref % cp ftp_dim % h = ftp_undim % h * fluidparam % ftp0ref % t * fluidparam % ftp0ref % cp + fluidparam % ftp0ref % h ftp_dim % rhoh = ftp_dim % d * ftp_dim % h return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief Building up the thermal property relations from defined relations. !> !> This subroutine is called once after defining the relations. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout]  none          NA !========================================================================================================== subroutine buildup_property_relations_from_function integer :: i call ftp_get_thermal_properties_dimensional_from_T ( fluidparam % ftp0ref ) call ftp_get_thermal_properties_dimensional_from_T ( fluidparam % ftpini ) fluidparam % nlist = N_FUNC2TABLE allocate ( ftplist ( fluidparam % nlist ) ) do i = 1 , fluidparam % nlist ftplist ( i )% t = ( fluidparam % TM0 + ( fluidparam % Tb0 - fluidparam % TM0 ) * real ( i , WP ) / real ( fluidparam % nlist , WP ) ) & / fluidparam % ftp0ref % t ! undimensional call ftp_refresh_thermal_properties_from_T_undim ( ftplist ( i )) end do call ftplist_check_monotonicity_DH_of_HorT i = minloc ( ftplist ( 1 : fluidparam % nlist )% rhoh , dim = 1 ) fluidparam % dhmin = ftplist ( i )% rhoh i = maxloc ( ftplist ( 1 : fluidparam % nlist )% rhoh , dim = 1 ) fluidparam % dhmax = ftplist ( i )% rhoh is_ftplist_dim = . false . return end subroutine buildup_property_relations_from_function !========================================================================================================== !========================================================================================================== !> \\brief Write out the rebuilt thermal property relations. !> !> This subroutine is called for testing. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  none          NA !_______________________________________________________________________________ subroutine Write_thermo_property type ( t_fluidThermoProperty ) :: ftp type ( t_fluidThermoProperty ) :: ftp_dim integer :: n , i real ( WP ) :: dhmax , dhmin integer :: ftp_unit1 , ftp_unit2 if ( nrank /= 0 ) return ! dhmin = MAXP ! dhmax = MINP ! if(fluidparam%ipropertyState == IPROPERTY_TABLE) then !   do i = 1, fluidparam%nlist !     if(ftplist(i)%rhoh < dhmin) dhmin = ftplist(i)%rhoh !     if(ftplist(i)%rhoh > dhmax) dhmax = ftplist(i)%rhoh !   end do !   !dhmin = dhmin + TRUNCERR !   !dhmax = dhmax - TRUNCERR ! else if(fluidparam%ipropertyState == IPROPERTY_FUNCS) then !   ftp%t  = fluidparam%TB0 / fluidparam%ftp0ref%t !   call ftp_refresh_thermal_properties_from_T_undim(ftp) !   dhmin1 = ftp%rhoh !   ftp%t  = fluidparam%TM0 / fluidparam%ftp0ref%t !   call ftp_refresh_thermal_properties_from_T_undim(ftp) !   dhmax1 = ftp%rhoh !   dhmin = dmin1( dhmin1, dhmax1) + TRUNCERR !   dhmax = dmax1( dhmin1, dhmax1) - TRUNCERR ! else !   dhmin = MAXP !   dhmax = MINP ! end if open ( newunit = ftp_unit1 , file = 'check_ftplist_undim.dat' ) write ( ftp_unit1 , * ) '# Enthalpy H, Temperature T, Density D, DViscosity M, Tconductivity K, Cp, Texpansion B, rho*h' open ( newunit = ftp_unit2 , file = 'check_ftplist_dim.dat' ) write ( ftp_unit2 , * ) '# Enthalpy H, Temperature T, Density D, DViscosity M, Tconductivity K, Cp, Texpansion B, rho*h' do i = 1 , fluidparam % nlist write ( ftp_unit1 , '(8ES13.5)' ) ftplist ( i )% h , ftplist ( i )% t , ftplist ( i )% d , ftplist ( i )% m , ftplist ( i )% k , ftplist ( i )% cp , ftplist ( i )% b , ftplist ( i )% rhoh call ftp_convert_undim_to_dim ( ftplist ( i ), ftp_dim ) write ( ftp_unit2 , '(8ES13.5)' ) ftp_dim % h , ftp_dim % t , ftp_dim % d , ftp_dim % m , ftp_dim % k , ftp_dim % cp , ftp_dim % b , ftp_dim % rhoh end do close ( ftp_unit1 ) close ( ftp_unit2 ) n = 128 dhmin = fluidparam % dhmin + TRUNCERR dhmax = fluidparam % dhmax - TRUNCERR open ( newunit = ftp_unit1 , file = 'check_ftp_from_dh_undim.dat' ) write ( ftp_unit1 , * ) '# Enthalpy H, Temperature T, Density D, DViscosity M, Tconductivity K, Cp, Texpansion B, rho*h' open ( newunit = ftp_unit2 , file = 'check_ftp_from_dh_dim.dat' ) write ( ftp_unit2 , * ) '# Enthalpy H, Temperature T, Density D, DViscosity M, Tconductivity K, Cp, Texpansion B, rho*h' do i = 1 , n ftp % rhoh = dhmin + ( dhmax - dhmin ) * real ( i - 1 , WP ) / real ( n - 1 , WP ) !write(*,*) ftp%rhoh call ftp_refresh_thermal_properties_from_DH ( ftp ) call ftp_is_T_in_scope ( ftp ) write ( ftp_unit1 , '(8ES13.5)' ) ftp % h , ftp % t , ftp % d , ftp % m , ftp % k , ftp % cp , ftp % b , ftp % rhoh call ftp_convert_undim_to_dim ( ftp , ftp_dim ) write ( ftp_unit2 , '(8ES13.5)' ) ftp_dim % h , ftp_dim % t , ftp_dim % d , ftp_dim % m , ftp_dim % k , ftp_dim % cp , ftp_dim % b , ftp_dim % rhoh end do close ( ftp_unit1 ) close ( ftp_unit2 ) if ( nrank == 0 ) then call Print_debug_mid_msg ( \"The range of the property table (undim)\" ) write ( * , wrtfmt2e ) 'rho*h(Kg J/m3):' , fluidparam % dhmin , fluidparam % dhmax call Print_debug_mid_msg ( \"The reference thermal properties (dimensional) are\" ) write ( * , wrtfmt1r ) 'Temperature(K):' , fluidparam % ftp0ref % t write ( * , wrtfmt1r ) 'Density(Kg/m3):' , fluidparam % ftp0ref % d write ( * , wrtfmt1e ) 'Dynamic Viscosity(Pa-s):' , fluidparam % ftp0ref % m write ( * , wrtfmt1r ) 'Thermal Conductivity(W/m-K):' , fluidparam % ftp0ref % k write ( * , wrtfmt1r ) 'Cp(J/Kg/K):' , fluidparam % ftp0ref % cp write ( * , wrtfmt1e ) 'Enthalphy(J):' , fluidparam % ftp0ref % h write ( * , wrtfmt1e ) 'mass enthaphy(Kg J/m3):' , fluidparam % ftp0ref % rhoh call Print_debug_mid_msg ( \"The initial thermal properties (dimensional) are\" ) write ( * , wrtfmt1r ) 'Temperature(K):' , fluidparam % ftpini % t write ( * , wrtfmt1r ) 'Density(Kg/m3):' , fluidparam % ftpini % d write ( * , wrtfmt1e ) 'Dynamic Viscosity(Pa-s):' , fluidparam % ftpini % m write ( * , wrtfmt1r ) 'Thermal Conductivity(W/m-K):' , fluidparam % ftpini % k write ( * , wrtfmt1r ) 'Cp(J/Kg/K):' , fluidparam % ftpini % cp write ( * , wrtfmt1e ) 'Enthalphy(J):' , fluidparam % ftpini % h write ( * , wrtfmt1e ) 'mass enthaphy(Kg J/m3):' , fluidparam % ftpini % rhoh write ( * , wrtfmt1e ) 'Prandtl Number :' , fluidparam % ftp0ref % m * fluidparam % ftp0ref % cp / fluidparam % ftp0ref % k end if return end subroutine Write_thermo_property !========================================================================================================== !> \\brief Identify table or equations for thermal properties based on input !>  fluid material. !> !> This subroutine is called once in setting up thermal relations. !> [mpi] all ranks !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout]  none          NA !========================================================================================================== subroutine Buildup_fluidparam ( tm ) type ( t_thermo ), intent ( in ) :: tm if ( nrank == 0 ) call Print_debug_inline_msg ( \"Initialising thermal parameters ...\" ) is_ftplist_dim = . true . fluidparam % ifluid = tm % ifluid fluidparam % ftp0ref % t = tm % ref_T0 ! dim fluidparam % ftpini % t = tm % init_T0 ! dim !---------------------------------------------------------------------------------------------------------- ! get given file name or coefficients !---------------------------------------------------------------------------------------------------------- select case ( fluidparam % ifluid ) case ( ISCP_WATER ) fluidparam % ipropertyState = IPROPERTY_TABLE fluidparam % inputProperty = TRIM ( INPUT_SCP_WATER ) case ( ISCP_CO2 ) fluidparam % ipropertyState = IPROPERTY_TABLE fluidparam % inputProperty = TRIM ( INPUT_SCP_CO2 ) case ( ILIQUID_SODIUM ) fluidparam % nlist = N_FUNC2TABLE fluidparam % ipropertyState = IPROPERTY_FUNCS fluidparam % TM0 = TM0_Na fluidparam % TB0 = TB0_Na fluidparam % HM0 = HM0_Na fluidparam % CoD ( 0 : 1 ) = CoD_Na ( 0 : 1 ) fluidparam % CoK ( 0 : 2 ) = CoK_Na ( 0 : 2 ) fluidparam % CoB = CoB_Na fluidparam % CoCp ( - 2 : 2 ) = CoCp_Na ( - 2 : 2 ) fluidparam % CoH ( - 1 : 3 ) = CoH_Na ( - 1 : 3 ) fluidparam % CoM ( - 1 : 1 ) = CoM_Na ( - 1 : 1 ) case ( ILIQUID_LEAD ) fluidparam % nlist = N_FUNC2TABLE fluidparam % ipropertyState = IPROPERTY_FUNCS fluidparam % TM0 = TM0_Pb fluidparam % TB0 = TB0_Pb fluidparam % HM0 = HM0_Pb fluidparam % CoD ( 0 : 1 ) = CoD_Pb ( 0 : 1 ) fluidparam % CoK ( 0 : 2 ) = CoK_Pb ( 0 : 2 ) fluidparam % CoB = CoB_Pb fluidparam % CoCp ( - 2 : 2 ) = CoCp_Pb ( - 2 : 2 ) fluidparam % CoH ( - 1 : 3 ) = CoH_Pb ( - 1 : 3 ) fluidparam % CoM ( - 1 : 1 ) = CoM_Pb ( - 1 : 1 ) case ( ILIQUID_BISMUTH ) fluidparam % ipropertyState = IPROPERTY_FUNCS fluidparam % TM0 = TM0_BI fluidparam % TB0 = TB0_BI fluidparam % HM0 = HM0_BI fluidparam % CoD ( 0 : 1 ) = CoD_BI ( 0 : 1 ) fluidparam % CoK ( 0 : 2 ) = CoK_BI ( 0 : 2 ) fluidparam % CoB = CoB_BI fluidparam % CoCp ( - 2 : 2 ) = CoCp_BI ( - 2 : 2 ) fluidparam % CoH ( - 1 : 3 ) = CoH_BI ( - 1 : 3 ) fluidparam % CoM ( - 1 : 1 ) = CoM_BI ( - 1 : 1 ) case ( ILIQUID_LBE ) fluidparam % nlist = N_FUNC2TABLE fluidparam % ipropertyState = IPROPERTY_FUNCS fluidparam % TM0 = TM0_LBE fluidparam % TB0 = TB0_LBE fluidparam % HM0 = HM0_LBE fluidparam % CoD ( 0 : 1 ) = CoD_LBE ( 0 : 1 ) fluidparam % CoK ( 0 : 2 ) = CoK_LBE ( 0 : 2 ) fluidparam % CoB = CoB_LBE fluidparam % CoCp ( - 2 : 2 ) = CoCp_LBE ( - 2 : 2 ) fluidparam % CoH ( - 1 : 3 ) = CoH_LBE ( - 1 : 3 ) fluidparam % CoM ( - 1 : 1 ) = CoM_LBE ( - 1 : 1 ) case default fluidparam % nlist = N_FUNC2TABLE fluidparam % ipropertyState = IPROPERTY_FUNCS fluidparam % TM0 = TM0_Na fluidparam % TB0 = TB0_Na fluidparam % HM0 = HM0_Na fluidparam % CoD ( 0 : 1 ) = CoD_Na ( 0 : 1 ) fluidparam % CoK ( 0 : 2 ) = CoK_Na ( 0 : 2 ) fluidparam % CoB = CoB_Na fluidparam % CoCp ( - 2 : 2 ) = CoCp_Na ( - 2 : 2 ) fluidparam % CoH ( - 1 : 3 ) = CoH_Na ( - 1 : 3 ) fluidparam % CoM ( - 1 : 1 ) = CoM_Na ( - 1 : 1 ) end select return end subroutine Buildup_fluidparam !========================================================================================================== subroutine Convert_thermal_input_2undim ( tm , dm ) type ( t_domain ), intent ( inout ) :: dm type ( t_thermo ), intent ( inout ) :: tm character ( 16 ) :: filename1 = 'pf1d_T1y_dim.dat' character ( 18 ) :: filename2 = 'pf1d_T1y_undim.dat' integer :: n , i integer , parameter :: IOMSG_LEN = 200 character ( len = IOMSG_LEN ) :: iotxt integer :: ioerr , inputUnit , outputUnit character ( len = 80 ) :: str real ( WP ) :: rtmp1 , rtmp2 if (. not . dm % is_thermo ) return !---------------------------------------------------------------------------------------------------------- !   for x-pencil !   scale the given thermo b.c. in dimensional to undimensional !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! x-bc !---------------------------------------------------------------------------------------------------------- do n = 1 , 2 if ( dm % ibcx_Tm ( n ) == IBC_DIRICHLET ) then dm % fbcx_const ( n , 5 ) = dm % fbcx_const ( n , 5 ) / tm % ref_T0 ! undim end if if ( dm % ibcx_Tm ( n ) == IBC_NEUMANN ) then dm % fbcx_const ( n , 5 ) = dm % fbcx_const ( n , 5 ) * tm % ref_l0 / fluidparam % ftp0ref % k / fluidparam % ftp0ref % t end if end do !---------------------------------------------------------------------------------------------------------- ! y-bc !---------------------------------------------------------------------------------------------------------- do n = 1 , 2 if ( dm % ibcy_Tm ( n ) == IBC_DIRICHLET ) then dm % fbcy_const ( n , 5 ) = dm % fbcy_const ( n , 5 ) / tm % ref_T0 ! undim end if if ( dm % ibcy_Tm ( n ) == IBC_NEUMANN ) then dm % fbcy_const ( n , 5 ) = dm % fbcy_const ( n , 5 ) * tm % ref_l0 / fluidparam % ftp0ref % k / fluidparam % ftp0ref % t end if end do !---------------------------------------------------------------------------------------------------------- ! z-bc !---------------------------------------------------------------------------------------------------------- do n = 1 , 2 if ( dm % ibcz_Tm ( n ) == IBC_DIRICHLET ) then dm % fbcz_const ( n , 5 ) = dm % fbcz_const ( n , 5 ) / tm % ref_T0 ! undim end if if ( dm % ibcz_Tm ( n ) == IBC_NEUMANN ) then dm % fbcz_const ( n , 5 ) = dm % fbcz_const ( n , 5 ) * tm % ref_l0 / fluidparam % ftp0ref % k / fluidparam % ftp0ref % t end if end do ! if ( dm % ibcx_Tm ( 1 ) == IBC_PROFILE1D . and . nrank == 0 ) then open ( newunit = inputUnit , & file = trim ( filename1 ), & status = 'old' , & action = 'read' , & iostat = ioerr , & iomsg = iotxt ) open ( newunit = outputUnit , & file = trim ( filename2 ), & status = 'new' , & action = 'write' , & iostat = ioerr , & iomsg = iotxt ) if ( ioerr /= 0 ) then str = 'Problem opening: ' // trim ( filename1 ) call Print_error_msg ( trim ( str )) end if n = 0 read ( inputUnit , * , iostat = ioerr ) str do read ( inputUnit , * , iostat = ioerr ) rtmp1 , rtmp2 if ( ioerr /= 0 ) exit n = n + 1 end do rewind ( inputUnit ) read ( inputUnit , * , iostat = ioerr ) str do i = 1 , n read ( inputUnit , * , iostat = ioerr ) rtmp1 , rtmp2 write ( outputUnit , * , iostat = ioerr ) rtmp1 , rtmp2 / tm % ref_T0 end do close ( inputUnit ) close ( outputUnit ) end if return end subroutine !========================================================================================================== !> \\brief Initialise thermal variables if ithermo = 1. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout]  fl   flow type !> \\param[inout]  tm   thermo type !========================================================================================================== subroutine initialise_thermal_properties ( fl , tm ) type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialise thermal variables ...\" ) !---------------------------------------------------------------------------------------------------------- !   initialise thermal fields !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then call Print_debug_mid_msg ( \"The initial thermal properties (undim) are\" ) write ( * , wrtfmt1r ) '  Temperature:' , tm % ftp_ini % t write ( * , wrtfmt1r ) '  Density:' , tm % ftp_ini % d write ( * , wrtfmt1r ) '  Dynamic Viscosity:' , tm % ftp_ini % m write ( * , wrtfmt1r ) '  Thermal Conductivity:' , tm % ftp_ini % k write ( * , wrtfmt1r ) '  Cp:' , tm % ftp_ini % cp write ( * , wrtfmt1r ) '  Enthalphy:' , tm % ftp_ini % h write ( * , wrtfmt1r ) '  mass enthaphy:' , tm % ftp_ini % rhoh end if fl % dDens (:, :, :) = tm % ftp_ini % d fl % mVisc (:, :, :) = tm % ftp_ini % m tm % rhoh (:, :, :) = tm % ftp_ini % rhoh tm % hEnth (:, :, :) = tm % ftp_ini % h tm % kCond (:, :, :) = tm % ftp_ini % k tm % tTemp (:, :, :) = tm % ftp_ini % t fl % dDensm2 (:, :, :) = fl % dDensm1 (:, :, :) fl % dDensm1 (:, :, :) = fl % dDens (:, :, :) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine initialise_thermal_properties !========================================================================================================== !> \\brief Initialise thermal variables if ithermo = 1. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout]  fl   flow type !> \\param[inout]  tm   thermo type !========================================================================================================== !   subroutine get_bc_tdm (dm) ! apply once !     use parameters_constant_mod !     implicit none !     type(t_flow),   intent(inout) :: fl !     type(t_thermo), intent(inout) :: tm !     type(t_fluidThermoProperty) :: ftpx, ftpy, ftpz !     do k = 1, size(dm%fbcx_var, 3) !       do j = 1, size(dm%fbcx_var, 2) !         do i = 1, size(dm%fbcx_var, 1) ! !---------------------------------------------------------------------------------------------------------- ! !         update density and viscousity at b.c. ! !         for temperature bc, heat flux bc (to chdck) ! !---------------------------------------------------------------------------------------------------------- !           ftpx%t = dm%fbcx_var(i, j, k, 5) !           ftpy%t = dm%fbcy_var(i, j, k, 5) !           ftpz%t = dm%fbcz_var(i, j, k, 5) !           call ftp_refresh_thermal_properties_from_T_undim(ftpx) !           call ftp_refresh_thermal_properties_from_T_undim(ftpy) !           call ftp_refresh_thermal_properties_from_T_undim(ftpz) !           dm%fbcx_var(i, j, k, 9)  = ftpx%d !           dm%fbcx_var(i, j, k, 10) = ftpx%m !         end do !       end do !     end do !     return !   end subroutine apply_bc_thermmal_properties !========================================================================================================== !========================================================================================================== !> \\brief The main code for thermal property initialisation. !> Scope:  mpi    called-freq    xdomain !>         all    once           all !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[inout]  none          NA !_______________________________________________________________________________ subroutine Buildup_thermo_mapping_relations ( tm ) type ( t_thermo ), intent ( inout ) :: tm if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialising thermal mapping relations ...\" ) call Buildup_fluidparam ( tm ) if ( fluidparam % ipropertyState == IPROPERTY_TABLE ) call buildup_property_relations_from_table if ( fluidparam % ipropertyState == IPROPERTY_FUNCS ) call buildup_property_relations_from_function call Write_thermo_property tm % ftp_ini % t = tm % init_T0 / tm % ref_T0 ! already undim call ftp_refresh_thermal_properties_from_T_undim ( tm % ftp_ini ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine Buildup_thermo_mapping_relations end module thermo_info_mod","tags":"","url":"sourcefile/input_thermo.f90.html"},{"title":"basics_algorithms.f90 – CHAPSim2","text":"Source Code module tridiagonal_matrix_algorithm implicit none private :: Solve_TDMA_basic private :: Solve_TDMA_cyclic public :: Preprocess_TDMA_coeffs public :: Solve_TDMA public :: Test_TDMA_noncyclic public :: Test_TDMA_cyclic contains !========================================================================================================== subroutine Preprocess_TDMA_coeffs ( a , b , c , d , n ) use math_mod use parameters_constant_mod , only : ONE use precision_mod implicit none integer , intent ( in ) :: n real ( WP ), intent ( in ) :: a ( n ), b ( n ) real ( WP ), intent ( inout ) :: c ( n ) real ( WP ), intent ( out ) :: d ( n ) integer :: i ! prepare coefficients c ( 1 ) = c ( 1 ) / b ( 1 ) do i = 2 , n d ( i ) = ONE / ( b ( i ) - a ( i ) * c ( i - 1 ) ) if ( i < n ) c ( i ) = c ( i ) * d ( i ) end do return end subroutine Preprocess_TDMA_coeffs !========================================================================================================== subroutine Solve_TDMA_basic ( x , a , b , c , d , n ) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! solution of a tridiagnal system of n equations of the form ! !  a(i) * x(i-1) + b(i) * x(i) + c(i) * x(i+1) = R(i), i = 1, ..., n !  a(1) and c(n) are not used. !  The solution x(i) is restored in R(i). !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! use precision_mod implicit none !========================================================================================================== integer , intent ( in ) :: n real ( WP ), intent ( inout ) :: x ( n ) ! R in, X out. real ( WP ), intent ( in ) :: a ( n ), b ( n ) real ( WP ), intent ( in ) :: c ( n ), d ( n ) integer :: i x ( 1 ) = x ( 1 ) / b ( 1 ) ! forward substitution do i = 2 , n x ( i ) = ( x ( i ) - a ( i ) * x ( i - 1 ) ) * d ( i ) end do ! backward substitution do i = n - 1 , 1 , - 1 x ( i ) = x ( i ) - c ( i ) * x ( i + 1 ) end do return end subroutine Solve_TDMA_basic !========================================================================================================== subroutine Solve_TDMA_cyclic ( x , a , b , c , d , n ) use precision_mod implicit none integer , intent ( in ) :: n real ( WP ), intent ( inout ) :: x ( n ) ! R in, X out. real ( WP ), intent ( in ) :: a ( n ), b ( n ) real ( WP ), intent ( in ) :: c ( n ), d ( n ) real ( WP ) :: x1 ( n ) call Solve_TDMA_basic ( x ( 1 : n - 1 ), a ( 1 : n - 1 ), b ( 1 : n - 1 ), c ( 1 : n - 1 ), d ( 1 : n - 1 ), n - 1 ) x1 (:) = 0.0 x1 ( 1 ) = - a ( 1 ) x1 ( n - 1 ) = - c ( n - 1 ) call Solve_TDMA_basic ( x1 ( 1 : n - 1 ), a ( 1 : n - 1 ), b ( 1 : n - 1 ), c ( 1 : n - 1 ), d ( 1 : n - 1 ), n - 1 ) x ( n ) = ( x ( n ) - c ( n ) * x ( 1 ) - a ( n ) * x ( n - 1 )) / & ( b ( n ) + c ( n ) * x1 ( 1 ) + a ( n ) * x1 ( n - 1 )) x ( 1 : n - 1 ) = x ( 1 : n - 1 ) + x1 ( 1 : n - 1 ) * x ( n ) return end subroutine Solve_TDMA_cyclic !========================================================================================================== subroutine Solve_TDMA ( peri , x , a , b , c , d , n ) use input_general_mod use precision_mod implicit none logical , intent ( in ) :: peri integer , intent ( in ) :: n real ( WP ), intent ( inout ) :: x ( n ) ! R in, X out. real ( WP ), intent ( in ) :: a ( n ), b ( n ) real ( WP ), intent ( in ) :: c ( n ), d ( n ) if ( peri ) then call Solve_TDMA_cyclic ( x (:), a (:), b (:), c (:), d (:), n ) else call Solve_TDMA_basic ( x (:), a (:), b (:), c (:), d (:), n ) end if return end subroutine !========================================================================================================== subroutine Test_TDMA_noncyclic !use iso_fortran_env use precision_mod use math_mod implicit none integer , parameter :: n = 10 real ( WP ) :: a ( n ), b ( n ), c ( n ), d ( n ), r ( n ) real ( WP ) :: ref ( n ) integer :: i !real(WP) :: PI = 3.1416926 ! example 1, n = 10 a ( 1 : n ) = [ 3.0_WP , 1.0_WP , 1.0_WP , 7.0_WP , 6.0_WP , 3.0_WP , 8.0_WP , 6.0_WP , 5.0_WP , 4.0_WP ] b ( 1 : n ) = [ 2.0_WP , 3.0_WP , 3.0_WP , 2.0_WP , 2.0_WP , 4.0_WP , 1.0_WP , 2.0_WP , 4.0_WP , 5.0_WP ] c ( 1 : n ) = [ 1.0_WP , 2.0_WP , 1.0_WP , 6.0_WP , 1.0_WP , 3.0_WP , 5.0_WP , 7.0_WP , 3.0_WP , 5.0_WP ] r ( 1 : n ) = [ 1.0_WP , 2.0_WP , 6.0_WP , 3 4.0_WP , 1 0.0_WP , 1.0_WP , 4.0_WP , 2 2.0_WP , 2 5.0_WP , 3.0_WP ] ref = [ 1.0_WP , - 1.0_WP , 2.0_WP , 1.0_WP , 3.0_WP , - 2.0_WP , 0.0_WP , 4.0_WP , 2.0_WP , - 1.0_WP ] ! example 2, n = 7 ! a(1 : n) = [2.0_WP, 1.0_WP/4.0_WP, 1.0_WP/3.0_WP, 1.0_WP/3.0_WP, 1.0_WP/3.0_WP, 1.0_WP/4.0_WP, 2.0_WP] ! b(1 : n) = [1.0_WP, 1.0_WP, 1.0_WP, 1.0_WP, 1.0_WP, 1.0_WP, 1.0_WP] ! c(1 : n) = [2.0_WP, 1.0_WP/4.0_WP, 1.0_WP/3.0_WP, 1.0_WP/3.0_WP, 1.0_WP/3.0_WP, 1.0_WP/4.0_WP, 2.0_WP] ! r(1 : n) = [2.06748E+00_WP,  6.20245E-01_WP, -6.66189E-01_WP, -1.33238E+00_WP, -6.66189E-01_WP,  & !             6.20245E-01_WP,  2.06748E+00_WP] ! ref(1: n) = [dcos(0.0_WP), dcos(PI/3.0_WP), dcos(2.0_WP*PI/3.0_WP), & !             dcos(PI), dcos(4.0_WP*PI/3.0_WP), dcos(5.0_WP*PI/3.0_WP), dcos(2.0_WP*PI)] d (:) = 0.0 call Preprocess_TDMA_coeffs ( a (:), b (:), c (:), d (:), n ) !write (*,'(A,7F8.4)') 'a', a(:) !write (*,'(A,7F8.4)') 'b', b(:) !write (*,'(A,7F8.4)') 'c', c(:) !write (*,'(A,7F8.4)') 'd', d(:) !write (*,'(A,7F8.4)') 'r', r(:) call Solve_TDMA (. false ., r (:), a (:), b (:), c (:), d (:), n ) !write (*,'(A,7F8.4)') 'o', r(:) ! data output write ( * , '(A)' ) 'Test_TDMA_noncyclic: cal, ref, diff' do i = 1 , n write ( * , '(I3, 2F8.4, 1ES17.7E3)' ) i , r ( i ), ref ( i ), abs_wp ( r ( i ) - ref ( i )) end do return end subroutine Test_TDMA_noncyclic !========================================================================================================== subroutine Test_TDMA_cyclic use precision_mod use math_mod !use iso_fortran_env implicit none integer , parameter :: n = 10 real ( WP ) :: a ( n ), b ( n ), c ( n ), d ( n ), r ( n ) real ( WP ) :: ref ( n ) integer :: i a ( 1 : n ) = [ 3.0_WP , 1.0_WP , 1.0_WP , 7.0_WP , 6.0_WP , 3.0_WP , 8.0_WP , 6.0_WP , 5.0_WP , 4.0_WP ] b ( 1 : n ) = [ 2.0_WP , 3.0_WP , 3.0_WP , 2.0_WP , 2.0_WP , 4.0_WP , 1.0_WP , 2.0_WP , 4.0_WP , 5.0_WP ] c ( 1 : n ) = [ 1.0_WP , 2.0_WP , 1.0_WP , 6.0_WP , 1.0_WP , 3.0_WP , 5.0_WP , 7.0_WP , 3.0_WP , 5.0_WP ] r ( 1 : n ) = [ 1.0_WP , 2.0_WP , 6.0_WP , 3 4.0_WP , 1 0.0_WP , 1.0_WP , 4.0_WP , 2 2.0_WP , 2 5.0_WP , 3.0_WP ] d (:) = 0.0 call Preprocess_TDMA_coeffs ( a ( 1 : n - 1 ), b ( 1 : n - 1 ), c ( 1 : n - 1 ), d ( 1 : n - 1 ), n - 1 ) call Solve_TDMA (. true ., r (:), a (:), b (:), c (:), d (:), n ) ! data output ref = [ 51866 3._WP / 17474 6._WP , - 29929 7._WP / 17474 6._WP , 18218 0._WP / 8737 3._WP , & 541 9._WP / 371 8._WP , 48024 3._WP / 17474 6._WP , - 37059 2._WP / 8737 3._WP , 56625 1._WP / 17474 6._WP , & 121244 1._WP / 17474 6._WP , - 7 6._WP / 4 7._WP , - 18776 1._WP / 17474 6._WP ] write ( * , '(A)' ) 'Test_TDMA_cyclic: cal, ref, diff' do i = 1 , n write ( * , '(I3, 2F8.4, 1ES17.7E3)' ) i , r ( i ), ref ( i ), abs_wp ( r ( i ) - ref ( i )) end do return end subroutine Test_TDMA_cyclic end module tridiagonal_matrix_algorithm","tags":"","url":"sourcefile/basics_algorithms.f90.html"},{"title":"io_visulisation.f90 – CHAPSim2","text":"Source Code module io_visualisation_mod use io_tools_mod use parameters_constant_mod use print_msg_mod implicit none character ( len =* ), parameter :: io_name = \"solution-io\" integer , parameter :: XDMF_HEADER = 1 , & XDMF_FOOTER = 2 integer , parameter :: PLANE_AVERAGE = - 1 character ( 6 ), parameter :: SCALAR = \"Scalar\" , & VECTOR = \"Vector\" , & TENSOR = \"Tensor\" character ( 4 ), parameter :: CELL = \"Cell\" , & NODE = \"Node\" integer , parameter :: N_DIRECTION = 0 , & X_DIRECTION = 1 , & Y_DIRECTION = 2 , & Z_DIRECTION = 3 integer , allocatable :: nnd_visu (:, :) integer , allocatable :: ncl_visu (:, :) !real(WP), allocatable :: xp(:), yp(:), zp(:) real ( WP ), allocatable :: rp (:, :, :), ta (:, :, :) real ( WP ), allocatable :: xp (:, :, :), yp (:, :, :), zp (:, :, :) real ( WP ), allocatable :: xp1 (:), yp1 (:), zp1 (:) character ( 120 ) :: grid_flname , grid_flname_x , grid_flname_y , grid_flname_z !character(6)  :: svisudim private :: write_visu_headerfooter private :: write_visu_field private :: visu_average_periodic_data private :: write_visu_profile private :: process_and_write_field private :: write_mesh_binary_cylindrical public :: write_visu_ini public :: write_visu_flow public :: write_visu_thermo public :: write_visu_mhd public :: write_visu_any3darray public :: write_visu_stats_flow public :: write_visu_stats_thermo contains !======================================================================================================== ! Generic subroutine to process and write a field (velocity or thermal) !======================================================================================================== subroutine process_and_write_field ( field , dm , field_name , filename , iteration , direction , opt_bc ) use udf_type_mod use operations implicit none real ( WP ), contiguous , intent ( in ) :: field (:, :, :) type ( t_domain ), intent ( in ) :: dm character ( * ), intent ( in ) :: field_name , filename integer , intent ( in ) :: iteration integer , intent ( in ), optional :: opt_bc (:) integer , intent ( in ) :: direction ! Local variables real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) :: accc_xpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: accc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) :: accc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: acpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: accp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: accp_zpencil #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_inline_msg ( \"Writing the field [\" // trim ( field_name ) // & \"] to the file with a keyword [\" // trim ( filename ) // \"]\" ) #endif select case ( direction ) case ( N_DIRECTION ) ! Process scalar field (e.g., pressure) call write_visu_field ( dm , field , dm % dccc , trim ( field_name ), trim ( filename ), SCALAR , CELL , iteration ) case ( X_DIRECTION ) ! Process x-direction field (e.g., qx or gx) call Get_x_midp_P2C_3D ( field , accc_xpencil , dm , dm % iAccuracy , opt_bc ) call write_visu_field ( dm , accc_xpencil , dm % dccc , trim ( field_name ), trim ( filename ), SCALAR , CELL , iteration ) case ( Y_DIRECTION ) ! Process y-direction field (e.g., qy or gy) call transpose_x_to_y ( field , acpc_ypencil , dm % dcpc ) call Get_y_midp_P2C_3D ( acpc_ypencil , accc_ypencil , dm , dm % iAccuracy , opt_bc ) call transpose_y_to_x ( accc_ypencil , accc_xpencil , dm % dccc ) call write_visu_field ( dm , accc_xpencil , dm % dccc , trim ( field_name ), trim ( filename ), SCALAR , CELL , iteration ) case ( Z_DIRECTION ) ! Process z-direction field (e.g., qz or gz) call transpose_x_to_y ( field , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) call Get_z_midp_P2C_3D ( accp_zpencil , accc_zpencil , dm , dm % iAccuracy , opt_bc ) call transpose_z_to_y ( accc_zpencil , accc_ypencil , dm % dccc ) call transpose_y_to_x ( accc_ypencil , accc_xpencil , dm % dccc ) call write_visu_field ( dm , accc_xpencil , dm % dccc , trim ( field_name ), trim ( filename ), SCALAR , CELL , iteration ) case default if ( nrank == 0 ) call Print_debug_inline_msg ( \"Error: Invalid direction in process_and_write_field.\" ) end select end subroutine process_and_write_field ! subroutine write_mesh_hdf5(xp, yp, zp, filename) !   use precision_mod !   use hdf5 !   implicit none !   real(WP), intent(in) :: xp(:,:,:), yp(:,:,:), zp(:,:,:) !   character(len=*), intent(in) :: filename !   ! --- HDF5 handles and variables --- !   integer(HID_T) :: file_id, dset_id, dspace_id, plist_id !   integer(HSIZE_T), dimension(4) :: dims !   integer :: error, rank !   real(WP), allocatable :: coords(:,:,:,:) !   logical :: parallel_io_available = .false. !   ! --- Initialize HDF5 --- !   call h5open_f(error) !   if (error /= 0) error stop \"HDF5 initialization failed\" !   ! --- Create file access property list --- !   call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, error) !   if (error /= 0) error stop \"Failed to create property list\" !   ! --- Try to set MPI-IO (only if compiled with parallel HDF5) --- !   parallel_io_available = .true. !   call h5pset_fapl_mpio_f(plist_id, MPI_COMM_WORLD, MPI_INFO_NULL, error) !   if (error /= 0) then !       parallel_io_available = .false. !       call h5pclose_f(plist_id, error) !       call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, error) !   end if !   ! --- Create HDF5 file --- !   call h5fcreate_f(trim(filename), H5F_ACC_TRUNC_F, file_id, error, access_prp=plist_id) !   if (error /= 0) error stop \"Failed to create HDF5 file: \"//trim(filename) !   call h5pclose_f(plist_id, error) !   ! --- Dataset dimensions --- !   rank = 4 !   dims = [size(xp,1), size(xp,2), size(xp,3), 3] !   ! --- Create dataspace --- !   call h5screate_simple_f(rank, dims, dspace_id, error) !   if (error /= 0) error stop \"Failed to create dataspace\" !   ! --- Create dataset --- !   ! Note: Changed dataset name from filename to \"coordinates\" to avoid confusion !   if (WP == kind(1.0)) then !       call h5dcreate_f(file_id, \"coordinates\", H5T_NATIVE_REAL, dspace_id, dset_id, error) !   else if (WP == kind(1.0d0)) then !       call h5dcreate_f(file_id, \"coordinates\", H5T_NATIVE_DOUBLE, dspace_id, dset_id, error) !   else !       error stop \"Unsupported precision in write_mesh_hdf5\" !   end if !   if (error /= 0) error stop \"Failed to create dataset\" !   ! --- Write data --- !   allocate(coords(dims(1), dims(2), dims(3), dims(4)), stat=error) !   if (error /= 0) error stop \"Allocation failed\" !   coords(:,:,:,1) = xp !   coords(:,:,:,2) = yp !   coords(:,:,:,3) = zp !   ! Use the correct precision for writing !   if (WP == kind(1.0)) then !       call h5dwrite_f(dset_id, H5T_NATIVE_REAL, coords, dims, error) !   else !       call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, coords, dims, error) !   end if !   if (error /= 0) error stop \"Failed to write dataset\" !   ! --- Cleanup --- !   deallocate(coords, stat=error) !   call h5dclose_f(dset_id, error) !   call h5sclose_f(dspace_id, error) !   call h5fclose_f(file_id, error) !   call h5close_f(error) ! end subroutine write_mesh_hdf5 subroutine write_mesh_binary_cylindrical ( xp , yp , zp , filename ) use precision_mod use iso_fortran_env , only : int32 implicit none real ( WP ), intent ( in ) :: xp (:,:,:), yp (:,:,:), zp (:,:,:) character ( len =* ), intent ( in ) :: filename ! --- HDF5 handles and variables --- integer ( int32 ) :: dims ( 3 ) integer :: error , i , j , k , unit real ( WP ) :: coord_buffer ( 3 ) logical :: parallel_io_available = . false . ! --- Dataset dimensions --- dims = [ size ( xp , 1 ), size ( xp , 2 ), size ( xp , 3 )] ! --- Write data --- if ( error /= 0 ) error stop \"Allocation failed\" ! Write to binary file open ( newunit = unit , file = trim ( filename ), access = 'stream' , form = 'unformatted' , & status = 'replace' , action = 'write' , iostat = error ) !, convert='BIG_ENDIAN') if ( error /= 0 ) error stop \"Failed to open binary file for writing\" ! Write dimensions first write ( unit ) dims ( 1 ), dims ( 2 ), dims ( 3 ) ! Write coordinates in order (x,y,z) for each point do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) coord_buffer ( 1 ) = xp ( i , j , k ) coord_buffer ( 2 ) = yp ( i , j , k ) coord_buffer ( 3 ) = zp ( i , j , k ) write ( unit ) coord_buffer end do end do end do close ( unit ) end subroutine write_mesh_binary_cylindrical !========================================================================================================== ! xszV means: ! x - xpencil, could also be y, z ! sz - size, could also be st, en ! V - visualisation ! xszV is the same as dppp%xsz/nskip, based on nodes, considering the skip nodes !========================================================================================================== subroutine write_visu_ini ( dm ) use udf_type_mod use parameters_constant_mod , only : MAXP use decomp_2d , only : xszV , yszV , zszV use io_files_mod use math_mod use typeconvert_mod use iso_fortran_env , only : int32 implicit none type ( t_domain ), intent ( in ) :: dm integer :: i , j , k character ( 120 ) :: keyword integer :: iogrid character ( 12 ) :: istr ( 3 ) if ( nrank /= 0 ) return if ( nrank == 0 ) call Print_debug_start_msg ( \"Writing visu initial files ...\" ) ! note:: skip_nodes is not considered here, the visualisation is based on the nodes. !---------------------------------------------------------------------------------------------------------- ! allocate !---------------------------------------------------------------------------------------------------------- if (. not . allocated ( nnd_visu )) allocate ( nnd_visu ( 3 , nxdomain )) if (. not . allocated ( ncl_visu )) allocate ( ncl_visu ( 3 , nxdomain )) nnd_visu = 0 ncl_visu = 0 ! !---------------------------------------------------------------------------------------------------------- ! ! global size ! !---------------------------------------------------------------------------------------------------------- !     !svisudim = '' !     !if(dm%visu_idim == Ivisu_3D) then !       !svisudim = \"3d\" !       nnd_visu(1, dm%idom) = xszV(1) !       nnd_visu(2, dm%idom) = yszV(2) !       nnd_visu(3, dm%idom) = zszV(3) !       do i = 1, 3 !         if(dm%is_periodic(i)) then !           ncl_visu(i, dm%idom) = nnd_visu(i, dm%idom) !           nnd_visu(i, dm%idom) = nnd_visu(i, dm%idom) + 1 !         else !           ncl_visu(i, dm%idom) = MAX(nnd_visu(i, dm%idom) - 1, 1) !         end if !       end do !     ! !else if(dm%visu_idim == Ivisu_2D_YZ) then !     !   svisudim = \"2d_xa\" !     !   nnd_visu(1, dm%idom) = 1 !     !   nnd_visu(2, dm%idom) = yszV(2) !     !   nnd_visu(3, dm%idom) = zszV(3) !     !   do i = 1, 3 !     !     if(dm%is_periodic(i)) then !     !       ncl_visu(i, dm%idom) = nnd_visu(i, dm%idom) !     !       nnd_visu(i, dm%idom) = nnd_visu(i, dm%idom) + 1 !     !     else !     !       ncl_visu(i, dm%idom) = MAX(nnd_visu(i, dm%idom) - 1, 1) !     !     end if !     !   end do !     ! else if(dm%visu_idim == Ivisu_2D_XZ) then !     !   svisudim = \"2d_ya\" !     !   nnd_visu(1, dm%idom) = xszV(1) !     !   nnd_visu(2, dm%idom) = 1 !     !   nnd_visu(3, dm%idom) = zszV(3) !     !   do i = 1, 3 !     !     if(dm%is_periodic(i)) then !     !       ncl_visu(i, dm%idom) = nnd_visu(i, dm%idom) !     !       nnd_visu(i, dm%idom) = nnd_visu(i, dm%idom) + 1 !     !     else !     !       ncl_visu(i, dm%idom) = MAX(nnd_visu(i, dm%idom) - 1, 1) !     !     end if !     !   end do !     ! else if(dm%visu_idim == Ivisu_2D_XY) then !     !   svisudim = \"2d_za\" !     !   nnd_visu(1, dm%idom) = xszV(1) !     !   nnd_visu(2, dm%idom) = yszV(2) !     !   nnd_visu(3, dm%idom) = 1 !     !   do i = 1, 3 !     !     if(dm%is_periodic(i)) then !     !       ncl_visu(i, dm%idom) = nnd_visu(i, dm%idom) !     !       nnd_visu(i, dm%idom) = nnd_visu(i, dm%idom) + 1 !     !     else !     !       ncl_visu(i, dm%idom) = MAX(nnd_visu(i, dm%idom) - 1, 1) !     !     end if !     !   end do !     ! else if(dm%visu_idim == Ivisu_1D_Y) then !     !   svisudim = \"2d_xza\" !     !   nnd_visu(1, dm%idom) = 1 !     !   nnd_visu(2, dm%idom) = yszV(2) !     !   nnd_visu(3, dm%idom) = 1 !     !   do i = 1, 3 !     !     if(dm%is_periodic(i)) then !     !       ncl_visu(i, dm%idom) = nnd_visu(i, dm%idom) !     !       nnd_visu(i, dm%idom) = nnd_visu(i, dm%idom) + 1 !     !     else !     !       ncl_visu(i, dm%idom) = MAX(nnd_visu(i, dm%idom) - 1, 1) !     !     end if !     !   end do !     ! else !     !   svisudim = \"3d\" !     !   nnd_visu(1, dm%idom) = xszV(1) !     !   nnd_visu(2, dm%idom) = yszV(2) !     !   nnd_visu(3, dm%idom) = zszV(3) !     !   do i = 1, 3 !     !     if(dm%is_periodic(i)) then !     !       ncl_visu(i, dm%idom) = nnd_visu(i, dm%idom) !     !       nnd_visu(i, dm%idom) = nnd_visu(i, dm%idom) + 1 !     !     else !     !       ncl_visu(i, dm%idom) = MAX(nnd_visu(i, dm%idom) - 1, 1) !     !     end if !     !   end do !     ! end if !---------------------------------------------------------------------------------------------------------- ! calculated structured grids geometry - Cartesian Coordinates !---------------------------------------------------------------------------------------------------------- nnd_visu ( 1 : 3 , dm % idom ) = dm % np_geo ( 1 : 3 ) ncl_visu ( 1 : 3 , dm % idom ) = dm % nc ( 1 : 3 ) if ( nrank == 0 ) then if ( dm % icoordinate == ICARTESIAN ) then if (. not . allocated ( xp )) allocate ( xp1 ( nnd_visu ( 1 , dm % idom ))) if (. not . allocated ( yp )) allocate ( yp1 ( nnd_visu ( 2 , dm % idom ))) if (. not . allocated ( zp )) allocate ( zp1 ( nnd_visu ( 3 , dm % idom ))) xp1 = MAXP yp1 = MAXP zp1 = MAXP do i = 1 , nnd_visu ( 1 , dm % idom ) xp1 ( i ) = real ( i - 1 , WP ) * dm % h ( 1 ) enddo do j = 1 , nnd_visu ( 2 , dm % idom ) if ( dm % is_stretching ( 2 )) then yp1 ( j ) = dm % yp ( j ) else yp1 ( j ) = real ( j - 1 , WP ) * dm % h ( 2 ) end if end do do k = 1 , nnd_visu ( 3 , dm % idom ) zp1 ( k ) = real ( k - 1 , WP ) * dm % h ( 3 ) enddo end if !---------------------------------------------------------------------------------------------------------- ! calculated structured grids geometry - Cylindrical Coordinates !---------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) then if (. not . allocated ( xp )) allocate ( xp ( nnd_visu ( 1 , dm % idom ), nnd_visu ( 2 , dm % idom ), nnd_visu ( 3 , dm % idom ))) if (. not . allocated ( yp )) allocate ( yp ( nnd_visu ( 1 , dm % idom ), nnd_visu ( 2 , dm % idom ), nnd_visu ( 3 , dm % idom ))) if (. not . allocated ( zp )) allocate ( zp ( nnd_visu ( 1 , dm % idom ), nnd_visu ( 2 , dm % idom ), nnd_visu ( 3 , dm % idom ))) if (. not . allocated ( rp )) allocate ( rp ( nnd_visu ( 1 , dm % idom ), nnd_visu ( 2 , dm % idom ), nnd_visu ( 3 , dm % idom ))) if (. not . allocated ( ta )) allocate ( ta ( nnd_visu ( 1 , dm % idom ), nnd_visu ( 2 , dm % idom ), nnd_visu ( 3 , dm % idom ))) rp = MAXP ta = MAXP xp = MAXP yp = MAXP zp = MAXP do i = 1 , nnd_visu ( 1 , dm % idom ) xp ( i , :, :) = real ( i - 1 , WP ) * dm % h ( 1 ) enddo do j = 1 , nnd_visu ( 2 , dm % idom ) if ( dm % is_stretching ( 2 )) then yp (:, j , :) = dm % yp ( j ) else yp (:, j , :) = real ( j - 1 , WP ) * dm % h ( 2 ) end if end do do k = 1 , nnd_visu ( 3 , dm % idom ) zp (:, :, k ) = real ( k - 1 , WP ) * dm % h ( 3 ) enddo rp (:, :, :) = yp (:, :, :) ta (:, :, :) = zp (:, :, :) do k = 1 , nnd_visu ( 3 , dm % idom ) do j = 1 , nnd_visu ( 2 , dm % idom ) do i = 1 , nnd_visu ( 1 , dm % idom ) zp ( i , j , k ) = rp ( i , j , k ) * dcos ( ta ( i , j , k )) yp ( i , j , k ) = rp ( i , j , k ) * dsin ( ta ( i , j , k )) end do end do end do end if !---------------------------------------------------------------------------------------------------------- ! write grids - Cartesian Coordinates, well-structured rectangular grid !---------------------------------------------------------------------------------------------------------- istr ( 1 ) = trim ( int2str ( nnd_visu ( 1 , dm % idom ))) istr ( 2 ) = trim ( int2str ( nnd_visu ( 2 , dm % idom ))) istr ( 3 ) = trim ( int2str ( nnd_visu ( 3 , dm % idom ))) if ( dm % icoordinate == ICARTESIAN ) then ! Write binary files for each coordinate direction in double precision keyword = \"grid_x\" call generate_pathfile_name ( grid_flname_x , dm % idom , keyword , dir_visu , 'bin' ) open ( newunit = iogrid , file = trim ( grid_flname_x ), access = 'stream' , form = 'unformatted' , & status = 'replace' , action = 'write' ) write ( iogrid ) int ( size ( xp1 ), kind = int32 ) ! Write dimension as 4-byte integer write ( iogrid ) xp1 ! Write coordinates as 8-byte floats (double precision) close ( iogrid ) keyword = \"grid_y\" call generate_pathfile_name ( grid_flname_y , dm % idom , keyword , dir_visu , 'bin' ) open ( newunit = iogrid , file = trim ( grid_flname_y ), access = 'stream' , form = 'unformatted' , & status = 'replace' , action = 'write' ) write ( iogrid ) int ( size ( yp1 ), kind = int32 ) write ( iogrid ) yp1 close ( iogrid ) keyword = \"grid_z\" call generate_pathfile_name ( grid_flname_z , dm % idom , keyword , dir_visu , 'bin' ) open ( newunit = iogrid , file = trim ( grid_flname_z ), access = 'stream' , form = 'unformatted' , & status = 'replace' , action = 'write' ) write ( iogrid ) int ( size ( zp1 ), kind = int32 ) write ( iogrid ) zp1 close ( iogrid ) end if !---------------------------------------------------------------------------------------------------------- ! write grids - Cylindrical Coordinates, well-structured non-rectangular grid !---------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) then keyword = \"grids\" !call generate_pathfile_name(grid_flname, dm%idom, keyword, dir_visu, 'h5') !call write_mesh_hdf5(xp, yp, zp, trim(grid_flname)) call generate_pathfile_name ( grid_flname , dm % idom , keyword , dir_visu , 'bin' ) call write_mesh_binary_cylindrical ( xp , yp , zp , trim ( grid_flname )) end if end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== ! ref: https://www.xdmf.org/index.php/XDMF_Model_and_Format !========================================================================================================== subroutine write_visu_headerfooter ( dm , visuname , iheadfoot , iter ) use precision_mod use parameters_constant_mod , only : MAXP use udf_type_mod , only : t_domain use decomp_2d , only : xszV , yszV , zszV use decomp_2d_constants , only : mytype use decomp_2d_mpi use io_files_mod use typeconvert_mod use iso_fortran_env , only : int32 implicit none integer , intent ( in ) :: iheadfoot integer , intent ( in ) :: iter type ( t_domain ), intent ( in ) :: dm character ( * ), intent ( in ) :: visuname character ( 120 ) :: keyword character ( 120 ) :: visu_flname character ( 12 ) :: istr ( 3 ) character ( len = 20 ) :: byte_str integer :: ioxdmf integer :: nsz , i , j , k if ( nrank /= 0 ) return !---------------------------------------------------------------------------------------------------------- ! visu file name !---------------------------------------------------------------------------------------------------------- keyword = trim ( visuname ) call generate_pathfile_name ( visu_flname , dm % idom , keyword , dir_visu , 'xdmf' , iter ) open ( newunit = ioxdmf , file = trim ( visu_flname ), action = \"write\" , position = \"append\" ) nsz = nnd_visu ( 3 , dm % idom ) * nnd_visu ( 2 , dm % idom ) * nnd_visu ( 1 , dm % idom ) ! Calculate header size (3 integers) write ( byte_str , '(I0)' ) storage_size ( 0_int32 ) / 8 * 3 !---------------------------------------------------------------------------------------------------------- ! xdmf head !---------------------------------------------------------------------------------------------------------- if ( iheadfoot == XDMF_HEADER ) then istr ( 1 ) = trim ( int2str ( nnd_visu ( 1 , dm % idom ))) istr ( 2 ) = trim ( int2str ( nnd_visu ( 2 , dm % idom ))) istr ( 3 ) = trim ( int2str ( nnd_visu ( 3 , dm % idom ))) !---------------------------------------------------------------------------------------------------------- ! write header ! geometry is based on node coordinates ! to do: write mesh into mesh.bin !---------------------------------------------------------------------------------------------------------- ! Write XDMF header write ( ioxdmf , '(a)' ) '<?xml version=\"1.0\" ?>' write ( ioxdmf , '(a)' ) '<Xdmf Version=\"3.0\">' write ( ioxdmf , '(a)' ) ' <Domain>' write ( ioxdmf , '(a)' ) '   <Grid Name=\"' // trim ( keyword ) // '\" GridType=\"Uniform\">' if ( dm % icoordinate == ICARTESIAN ) then ! Write topology write ( ioxdmf , '(a)' ) '     <Topology TopologyType=\"3DRectMesh\" Dimensions=\" ' & // trim ( istr ( 3 )) // ' ' // trim ( istr ( 2 )) // ' ' // trim ( istr ( 1 )) // '\"/>' ! Write geometry write ( ioxdmf , '(a)' ) '     <Geometry GeometryType=\"VXVYVZ\">' write ( ioxdmf , '(a)' ) '        <DataItem ItemType=\"Uniform\"' write ( ioxdmf , '(a)' ) '                 Dimensions=\"' // trim ( istr ( 1 )) // '\"' write ( ioxdmf , '(a)' ) '                 NumberType=\"Float\"' write ( ioxdmf , '(a)' ) '                 Precision=\"8\"' ! 8-byte precision write ( ioxdmf , '(a)' ) '                 Format=\"Binary\"' write ( ioxdmf , '(a)' ) '                 Seek=\"4\">' ! Skip 4-byte integer header write ( ioxdmf , '(a)' ) '          ../' // trim ( grid_flname_x ) write ( ioxdmf , '(a)' ) '        </DataItem>' write ( ioxdmf , '(a)' ) '        <DataItem ItemType=\"Uniform\"' write ( ioxdmf , '(a)' ) '                 Dimensions=\"' // trim ( istr ( 2 )) // '\"' write ( ioxdmf , '(a)' ) '                 NumberType=\"Float\"' write ( ioxdmf , '(a)' ) '                 Precision=\"8\"' ! 8-byte precision write ( ioxdmf , '(a)' ) '                 Format=\"Binary\"' write ( ioxdmf , '(a)' ) '                 Seek=\"4\">' ! Skip 4-byte integer header write ( ioxdmf , '(a)' ) '          ../' // trim ( grid_flname_y ) write ( ioxdmf , '(a)' ) '        </DataItem>' write ( ioxdmf , '(a)' ) '        <DataItem ItemType=\"Uniform\"' write ( ioxdmf , '(a)' ) '                 Dimensions=\"' // trim ( istr ( 3 )) // '\"' write ( ioxdmf , '(a)' ) '                 NumberType=\"Float\"' write ( ioxdmf , '(a)' ) '                 Precision=\"8\"' ! 8-byte precision write ( ioxdmf , '(a)' ) '                 Format=\"Binary\"' write ( ioxdmf , '(a)' ) '                 Seek=\"4\">' ! Skip 4-byte integer header write ( ioxdmf , '(a)' ) '          ../' // trim ( grid_flname_z ) write ( ioxdmf , '(a)' ) '        </DataItem>' write ( ioxdmf , '(a)' ) '      </Geometry>' end if if ( dm % icoordinate == ICYLINDRICAL ) then ! Write topology write ( ioxdmf , '(a)' ) '     <Topology TopologyType=\"3DSMesh\" Dimensions=\" ' & // trim ( istr ( 3 )) // ' ' // trim ( istr ( 2 )) // ' ' // trim ( istr ( 1 )) // '\"/>' ! Write geometry write ( ioxdmf , '(a)' ) '     <Geometry GeometryType=\"XYZ\">' write ( ioxdmf , '(a)' ) '        <DataItem ItemType=\"Uniform\"' write ( ioxdmf , '(a)' ) '                 Dimensions=\"' // trim ( int2str ( nsz )) // ' 3\"' write ( ioxdmf , '(a)' ) '                 NumberType=\"Float\"' write ( ioxdmf , '(a)' ) '                 Precision=\"' // merge ( '4' , '8' , WP == kind ( 1.0 )) // '\"' write ( ioxdmf , '(a)' ) '                 Format=\"Binary\"' write ( ioxdmf , '(a)' ) '                 Endian=\"Big\"' write ( ioxdmf , '(a)' ) '                 Seek=\"' // trim ( byte_str ) // '\">' write ( ioxdmf , '(a)' ) '           ' // \"../\" // trim ( grid_flname ) write ( ioxdmf , '(a)' ) '        </DataItem>' write ( ioxdmf , '(a)' ) '      </Geometry>' end if else if ( iheadfoot == XDMF_FOOTER ) then write ( ioxdmf , '(a)' ) '   </Grid>' write ( ioxdmf , '(a)' ) ' </Domain>' write ( ioxdmf , '(a)' ) '</Xdmf>' else end if close ( ioxdmf ) return end subroutine !========================================================================================================== ! ref: https://www.xdmf.org/index.php/XDMF_Model_and_Format !========================================================================================================== subroutine write_visu_field ( dm , var , dtmp , varname , visuname , attributetype , centring , iter ) use precision_mod use decomp_2d use decomp_2d_io use udf_type_mod , only : t_domain use io_files_mod use decomp_operation_mod use typeconvert_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), contiguous , intent ( in ) :: var (:, :, :) character ( len =* ), intent ( in ) :: varname character ( len =* ), intent ( in ) :: visuname character ( * ), intent ( in ) :: attributetype character ( * ), intent ( in ) :: centring type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ), optional :: iter character ( 120 ) :: data_flname character ( 120 ) :: data_flname_path character ( 120 ) :: visu_flname_path character ( 120 ) :: keyword integer :: nsz ( 3 ), nsz0 integer :: ioxdmf if ((. not . is_same_decomp ( dtmp , dm % dccc ))) then if ( nrank == 0 ) call Print_error_msg ( \"Data is not stored at cell centre. varname = \" // trim ( varname )) end if !---------------------------------------------------------------------------------------------------------- ! xmdf file name !---------------------------------------------------------------------------------------------------------- keyword = trim ( visuname ) call generate_pathfile_name ( visu_flname_path , dm % idom , keyword , dir_visu , 'xdmf' , iter ) !---------------------------------------------------------------------------------------------------------- ! write data into binary file !---------------------------------------------------------------------------------------------------------- if ( dm % visu_idim == Ivisu_3D ) then keyword = trim ( varname ) call generate_pathfile_name ( data_flname_path , dm % idom , keyword , dir_data , 'bin' , iter ) if (. not . file_exists ( data_flname_path )) & call decomp_2d_write_one ( IPENCIL ( 1 ), var , trim ( data_flname_path ), opt_decomp = dtmp ) else if ( dm % visu_idim == Ivisu_1D_Y ) then !to add 1D profile else keyword = trim ( varname ) call generate_file_name ( data_flname , dm % idom , keyword , 'bin' , iter ) call generate_pathfile_name ( data_flname_path , dm % idom , keyword , dir_data , 'bin' , iter ) !call decomp_2d_write_plane(IPENCIL(1), var, dm%visu_idim, PLANE_AVERAGE, trim(dir_data), & !      trim(data_flname), io_name, opt_decomp=dtmp) ! to update, to check end if !---------------------------------------------------------------------------------------------------------- ! dataitem for xdmf file !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then open ( newunit = ioxdmf , file = trim ( visu_flname_path ), action = \"write\" , status = \"old\" , position = \"append\" ) if ( trim ( centring ) == TRIM ( CELL )) then nsz ( 1 : 3 ) = ncl_visu ( 1 : 3 , dm % idom ) else if ( trim ( centring ) == TRIM ( NODE )) then nsz ( 1 : 3 ) = nnd_visu ( 1 : 3 , dm % idom ) else end if nsz0 = nsz ( 1 ) * nsz ( 2 ) * nsz ( 3 ) if ( dm % icoordinate == ICARTESIAN ) then keyword = trim ( int2str ( nsz ( 3 ))) // ' ' // trim ( int2str ( nsz ( 2 ))) // ' ' // trim ( int2str ( nsz ( 1 ))) end if if ( dm % icoordinate == ICYLINDRICAL ) then !keyword = trim(int2str(nsz0))//' 3' keyword = trim ( int2str ( nsz ( 3 ))) // ' ' // trim ( int2str ( nsz ( 2 ))) // ' ' // trim ( int2str ( nsz ( 1 ))) end if write ( ioxdmf , '(a)' ) '      <Attribute Name=\"' // trim ( varname ) // & '\" AttributeType=\"' // trim ( attributetype ) // & '\" Center=\"' // trim ( centring ) // '\">' write ( ioxdmf , '(a)' ) '        <DataItem ItemType=\"Uniform\"' write ( ioxdmf , '(a)' ) '                 NumberType=\"Float\"' write ( ioxdmf , '(a)' ) '                 Precision=\"8\"' write ( ioxdmf , '(a)' ) '                 Format=\"Binary\"' write ( ioxdmf , '(a)' ) '                 Dimensions=\"' // trim ( keyword ) // '\">' write ( ioxdmf , '(a)' ) '          ../' // trim ( data_flname_path ) write ( ioxdmf , '(a)' ) '        </DataItem>' write ( ioxdmf , '(a)' ) '      </Attribute>' close ( ioxdmf ) end if return end subroutine !========================================================================================================== ! ref: https://www.xdmf.org/index.php/XDMF_Model_and_Format !========================================================================================================== subroutine write_visu_profile ( dm , var , dtmp , varname , visuname , attributetype , centring , idim , iter ) use precision_mod use decomp_2d use decomp_2d_io use udf_type_mod , only : t_domain use io_files_mod use decomp_operation_mod use typeconvert_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( in ) :: var (:) character ( len =* ), intent ( in ) :: varname character ( len =* ), intent ( in ) :: visuname character ( * ), intent ( in ) :: attributetype character ( * ), intent ( in ) :: centring type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ) :: idim integer , intent ( in ), optional :: iter character ( 120 ) :: data_flname character ( 120 ) :: data_flname_path character ( 120 ) :: visu_flname_path character ( 120 ) :: keyword integer :: nsz ( 3 ) integer :: ioxdmf , iofl integer :: j if ((. not . is_same_decomp ( dtmp , dm % dccc ))) then if ( nrank == 0 ) call Print_error_msg ( \"Data is not stored at cell centre. varname = \" // trim ( varname )) end if !---------------------------------------------------------------------------------------------------------- ! write data !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then keyword = trim ( varname ) call generate_pathfile_name ( data_flname_path , dm % idom , keyword , dir_data , 'dat' , iter ) open ( newunit = iofl , file = data_flname_path , action = \"write\" , status = \"replace\" ) if ( idim /= 2 ) call Print_error_msg ( 'Error in direction' ) do j = 1 , dtmp % ysz ( 2 ) write ( iofl , * ) j , dm % yc ( j ), var ( j ) end do close ( iofl ) end if return end subroutine !========================================================================================================== ! Subroutine to write flow visualization data !========================================================================================================== subroutine write_visu_flow ( fl , dm , suffix ) use udf_type_mod use precision_mod use operations use parameters_constant_mod implicit none ! Input variables type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl character ( 4 ), intent ( in ), optional :: suffix ! Local variables integer :: iteration character ( 120 ) :: visu_filename ! Initialize iteration and filename iteration = fl % iteration visu_filename = 'flow' if ( present ( suffix )) visu_filename = trim ( visu_filename ) // '_' // trim ( suffix ) ! Write XDMF header call write_visu_headerfooter ( dm , trim ( visu_filename ), XDMF_HEADER , iteration ) ! Write pressure field (cell-centered) call process_and_write_field ( fl % pres , dm , \"pressure\" , trim ( visu_filename ), iteration , & N_DIRECTION ) call process_and_write_field ( fl % pcor , dm , \"phi\" , trim ( visu_filename ), iteration , & N_DIRECTION ) ! Process and write velocity components (qx, qy, qz) call process_and_write_field ( fl % qx , dm , \"qx_velocity\" , trim ( visu_filename ), iteration , & X_DIRECTION , opt_bc = dm % ibcx_qx ) call process_and_write_field ( fl % qy , dm , \"qy_velocity\" , trim ( visu_filename ), iteration , & Y_DIRECTION , opt_bc = dm % ibcy_qy ) call process_and_write_field ( fl % qz , dm , \"qz_velocity\" , trim ( visu_filename ), iteration , & Z_DIRECTION , opt_bc = dm % ibcz_qz ) ! Process and write thermal fields if enabled if ( dm % is_thermo ) then call process_and_write_field ( fl % gx , dm , \"gx_thermal\" , trim ( visu_filename ), iteration , & X_DIRECTION , opt_bc = dm % ibcx_qx ) call process_and_write_field ( fl % gy , dm , \"gy_thermal\" , trim ( visu_filename ), iteration , & Y_DIRECTION , opt_bc = dm % ibcy_qy ) call process_and_write_field ( fl % gz , dm , \"gz_thermal\" , trim ( visu_filename ), iteration , & Z_DIRECTION , opt_bc = dm % ibcz_qz ) end if ! Write XDMF footer call write_visu_headerfooter ( dm , trim ( visu_filename ), XDMF_FOOTER , iteration ) ! Debug message if ( nrank == 0 ) call Print_debug_inline_msg ( \"Flow field visualization data written successfully.\" ) return end subroutine !========================================================================================================== subroutine write_visu_thermo ( tm , fl , dm , str ) use udf_type_mod use precision_mod use operations implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( in ) :: tm type ( t_flow ), intent ( in ) :: fl character ( 4 ), intent ( in ), optional :: str integer :: iter character ( 120 ) :: visuname iter = tm % iteration visuname = 'thermo' if ( present ( str )) visuname = trim ( visuname ) // '_' // trim ( str ) !---------------------------------------------------------------------------------------------------------- ! write xdmf header !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_HEADER , iter ) !---------------------------------------------------------------------------------------------------------- ! write data, temperature, to cell centre !---------------------------------------------------------------------------------------------------------- call write_visu_field ( dm , tm % tTemp , dm % dccc , \"Temp_visu\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % dDens , dm % dccc , \"Dens_visu\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % mVisc , dm % dccc , \"Visc_visu\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , tm % kCond , dm % dccc , \"Cond_visu\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , tm % hEnth , dm % dccc , \"Enth_visu\" , trim ( visuname ), SCALAR , CELL , iter ) !---------------------------------------------------------------------------------------------------------- ! write xdmf footer !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_FOOTER , iter ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"Write out visualisation for thermal field.\" ) return end subroutine !========================================================================================================== subroutine write_visu_mhd ( mh , fl , dm , suffix ) use udf_type_mod use precision_mod use operations use parameters_constant_mod implicit none ! Input variables type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl type ( t_mhd ), intent ( in ) :: mh character ( 4 ), intent ( in ), optional :: suffix ! Local variables integer :: iteration character ( 120 ) :: visu_filename ! Initialize iteration and filename iteration = fl % iteration visu_filename = 'mhd' if ( present ( suffix )) visu_filename = trim ( visu_filename ) // '_' // trim ( suffix ) ! Write XDMF header call write_visu_headerfooter ( dm , trim ( visu_filename ), XDMF_HEADER , iteration ) ! Write electric potential field (cell-centered) call process_and_write_field ( mh % ep , dm , \"potential\" , trim ( visu_filename ), iteration , & N_DIRECTION ) ! Process and write current density components (jx, jy, jz) call process_and_write_field ( mh % jx , dm , \"jx_current\" , trim ( visu_filename ), iteration , & X_DIRECTION , opt_bc = mh % ibcx_jx ) call process_and_write_field ( mh % jy , dm , \"jy_current\" , trim ( visu_filename ), iteration , & Y_DIRECTION , opt_bc = mh % ibcy_jy ) call process_and_write_field ( mh % jz , dm , \"jz_current\" , trim ( visu_filename ), iteration , & Z_DIRECTION , opt_bc = mh % ibcz_jz ) ! Process and write Lorentz components call process_and_write_field ( fl % lrfx , dm , \"fx_Lorentz\" , trim ( visu_filename ), iteration , & X_DIRECTION , opt_bc = dm % ibcx_qx ) call process_and_write_field ( fl % lrfy , dm , \"fy_Lorentz\" , trim ( visu_filename ), iteration , & Y_DIRECTION , opt_bc = dm % ibcy_qy ) call process_and_write_field ( fl % lrfz , dm , \"fz_Lorentz\" , trim ( visu_filename ), iteration , & Z_DIRECTION , opt_bc = dm % ibcz_qz ) ! Write XDMF footer call write_visu_headerfooter ( dm , trim ( visu_filename ), XDMF_FOOTER , iteration ) ! Debug message if ( nrank == 0 ) call Print_debug_inline_msg ( \"MHD field visualization data written successfully.\" ) return end subroutine !========================================================================================================== subroutine write_visu_stats_flow ( fl , dm ) use udf_type_mod use precision_mod use operations implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl integer :: iter character ( 120 ) :: visuname !========================================================================================================== ! write time averaged 3d data !========================================================================================================== iter = fl % iteration visuname = 'time_averaged_flow' !---------------------------------------------------------------------------------------------------------- ! write xdmf header !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_HEADER , iter ) !---------------------------------------------------------------------------------------------------------- ! write data, !---------------------------------------------------------------------------------------------------------- call write_visu_field ( dm , fl % pr_mean , dm % dccc , \"time_averaged_pr\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % u_vector_mean (:, :, :, 1 ), dm % dccc , \"time_averaged_ux\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % u_vector_mean (:, :, :, 2 ), dm % dccc , \"time_averaged_uy\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % u_vector_mean (:, :, :, 3 ), dm % dccc , \"time_averaged_uz\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % uu_tensor6_mean (:, :, :, 1 ), dm % dccc , \"time_averaged_uu\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % uu_tensor6_mean (:, :, :, 2 ), dm % dccc , \"time_averaged_vv\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % uu_tensor6_mean (:, :, :, 3 ), dm % dccc , \"time_averaged_ww\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % uu_tensor6_mean (:, :, :, 4 ), dm % dccc , \"time_averaged_uv\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % uu_tensor6_mean (:, :, :, 5 ), dm % dccc , \"time_averaged_uw\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , fl % uu_tensor6_mean (:, :, :, 6 ), dm % dccc , \"time_averaged_vw\" , trim ( visuname ), SCALAR , CELL , iter ) !---------------------------------------------------------------------------------------------------------- ! write xdmf footer !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_FOOTER , iter ) !========================================================================================================== ! write time averaged and space averaged 3d data (stored 2d or 1d data) !========================================================================================================== if ( ANY ( dm % is_periodic (:))) then iter = fl % iteration visuname = 'time_space_averaged_flow' !---------------------------------------------------------------------------------------------------------- ! write xdmf header !---------------------------------------------------------------------------------------------------------- if (. not . ( dm % is_periodic ( 1 ) . and . dm % is_periodic ( 3 ))) & call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_HEADER , iter ) !---------------------------------------------------------------------------------------------------------- ! write data, !---------------------------------------------------------------------------------------------------------- call visu_average_periodic_data ( fl % pr_mean , dm % dccc , dm , \"time_space_averaged_pr\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % u_vector_mean (:, :, :, 1 ), dm % dccc , dm , \"time_space_averaged_ux\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % u_vector_mean (:, :, :, 2 ), dm % dccc , dm , \"time_space_averaged_uy\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % u_vector_mean (:, :, :, 3 ), dm % dccc , dm , \"time_space_averaged_uz\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % uu_tensor6_mean (:, :, :, 1 ), dm % dccc , dm , \"time_space_averaged_uu\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % uu_tensor6_mean (:, :, :, 2 ), dm % dccc , dm , \"time_space_averaged_vv\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % uu_tensor6_mean (:, :, :, 3 ), dm % dccc , dm , \"time_space_averaged_ww\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % uu_tensor6_mean (:, :, :, 4 ), dm % dccc , dm , \"time_space_averaged_uv\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % uu_tensor6_mean (:, :, :, 5 ), dm % dccc , dm , \"time_space_averaged_uw\" , trim ( visuname ), iter ) call visu_average_periodic_data ( fl % uu_tensor6_mean (:, :, :, 6 ), dm % dccc , dm , \"time_space_averaged_vw\" , trim ( visuname ), iter ) !---------------------------------------------------------------------------------------------------------- ! write xdmf footer !---------------------------------------------------------------------------------------------------------- if (. not . ( dm % is_periodic ( 1 ) . and . dm % is_periodic ( 3 ))) & call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_FOOTER , iter ) end if return end subroutine !========================================================================================================== subroutine write_visu_stats_thermo ( tm , dm ) use udf_type_mod use precision_mod use operations implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( in ) :: tm integer :: iter character ( 120 ) :: visuname !========================================================================================================== ! write time averaged 3d data !========================================================================================================== iter = tm % iteration visuname = 'time_averaged_thermo' !---------------------------------------------------------------------------------------------------------- ! write xdmf header !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_HEADER , iter ) !---------------------------------------------------------------------------------------------------------- ! write data, !---------------------------------------------------------------------------------------------------------- call write_visu_field ( dm , tm % t_mean , dm % dccc , \"time_averaged_T\" , trim ( visuname ), SCALAR , CELL , iter ) call write_visu_field ( dm , tm % tt_mean , dm % dccc , \"time_averaged_TT\" , trim ( visuname ), SCALAR , CELL , iter ) !---------------------------------------------------------------------------------------------------------- ! write xdmf footer !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_FOOTER , iter ) !========================================================================================================== ! write time averaged and space averaged 3d data (stored 2d or 1d data) !========================================================================================================== if ( ANY ( dm % is_periodic (:))) then iter = tm % iteration visuname = 'time_space_averaged_thermo' !---------------------------------------------------------------------------------------------------------- ! write xdmf header !---------------------------------------------------------------------------------------------------------- if (. not . ( dm % is_periodic ( 1 ) . and . dm % is_periodic ( 3 ))) & call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_HEADER , iter ) !---------------------------------------------------------------------------------------------------------- ! write data, !---------------------------------------------------------------------------------------------------------- call visu_average_periodic_data ( tm % t_mean , dm % dccc , dm , \"time_space_averaged_T\" , trim ( visuname ), iter ) call visu_average_periodic_data ( tm % tt_mean , dm % dccc , dm , \"time_space_averaged_TT\" , trim ( visuname ), iter ) !---------------------------------------------------------------------------------------------------------- ! write xdmf footer !---------------------------------------------------------------------------------------------------------- if (. not . ( dm % is_periodic ( 1 ) . and . dm % is_periodic ( 3 ))) & call write_visu_headerfooter ( dm , trim ( visuname ), XDMF_FOOTER , iter ) end if return end subroutine !========================================================================================================== subroutine write_visu_any3darray ( var , varname , visuname , dtmp , dm , iter ) use udf_type_mod use precision_mod use operations use decomp_operation_mod use io_files_mod use parameters_constant_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( DECOMP_INFO ), intent ( in ) :: dtmp character ( * ), intent ( in ) :: varname real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 ) ), intent ( in ) :: var integer , intent ( in ) :: iter character ( * ), intent ( in ) :: visuname real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil character ( 120 ) :: keyword !---------------------------------------------------------------------------------------------------------- ! write xdmf header !---------------------------------------------------------------------------------------------------------- keyword = trim ( visuname ) // \"_\" // trim ( varname ) // '_visu' call write_visu_headerfooter ( dm , trim ( keyword ), XDMF_HEADER , iter ) !if(nrank==0) write(*,*) keyword, iter !---------------------------------------------------------------------------------------------------------- ! write data, temperature, to cell centre !---------------------------------------------------------------------------------------------------------- if ( is_same_decomp ( dtmp , dm % dccc )) then call process_and_write_field ( var , dm , trim ( varname ), trim ( keyword ), iter , N_DIRECTION ) else if ( is_same_decomp ( dtmp , dm % dpcc )) then call process_and_write_field ( var , dm , trim ( varname ), trim ( keyword ), iter , X_DIRECTION , opt_bc = dm % ibcx_qx ) else if ( is_same_decomp ( dtmp , dm % dcpc )) then call process_and_write_field ( var , dm , trim ( varname ), trim ( keyword ), iter , Y_DIRECTION , opt_bc = dm % ibcy_qy ) else if ( is_same_decomp ( dtmp , dm % dccp )) then call process_and_write_field ( var , dm , trim ( varname ), trim ( keyword ), iter , Z_DIRECTION , opt_bc = dm % ibcz_qz ) else call Print_error_msg ( \"Given decomp_into is not supported \" // trim ( varname )) end if !---------------------------------------------------------------------------------------------------------- ! write xdmf footer !---------------------------------------------------------------------------------------------------------- call write_visu_headerfooter ( dm , trim ( keyword ), XDMF_FOOTER , iter ) return end subroutine !========================================================================================================== !========================================================================================================== subroutine visu_average_periodic_data ( data_in , dtmp , dm , str1 , str2 , iter ) use udf_type_mod use parameters_constant_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( in ) :: data_in character ( * ), intent ( in ) :: str1 character ( * ), intent ( in ) :: str2 integer , intent ( in ) :: iter real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )) :: a_xpencil real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )) :: a_ypencil real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )) :: a_zpencil real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )) :: b_zpencil real ( WP ), dimension ( dtmp % ysz ( 2 )) :: var integer :: i , j , k real ( WP ) :: sum if ( dm % is_periodic ( 1 ) . and . & dm % is_periodic ( 3 ) . and . & dm % is_periodic ( 2 )) then ! do nothing here, but bulk value output else if ( dm % is_periodic ( 1 ) . and . & dm % is_periodic ( 3 ) . and . & . not . dm % is_periodic ( 2 )) then do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) sum = ZERO do i = 1 , dtmp % xsz ( 1 ) sum = sum + data_in ( i , j , k ) end do sum = sum / real ( dtmp % xsz ( 1 ), WP ) a_xpencil (:, j , k ) = sum end do end do call transpose_x_to_y ( a_xpencil , a_ypencil , dtmp ) call transpose_y_to_z ( a_ypencil , a_zpencil , dtmp ) do i = 1 , dtmp % zsz ( 1 ) do j = 1 , dtmp % zsz ( 2 ) sum = ZERO do k = 1 , dtmp % zsz ( 3 ) sum = sum + a_zpencil ( i , j , k ) end do b_zpencil ( i , j , :) = sum / real ( dtmp % zsz ( 3 ), WP ) end do end do call transpose_z_to_y ( b_zpencil , a_ypencil , dtmp ) var = a_ypencil ( 1 ,:, 1 ) call write_visu_profile ( dm , var , dm % dccc , trim ( str1 ), trim ( str2 ), SCALAR , CELL , 2 , iter ) else if ( dm % is_periodic ( 1 ) . and . & . not . dm % is_periodic ( 3 ) . and . & . not . dm % is_periodic ( 2 )) then do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) sum = ZERO do i = 1 , dtmp % xsz ( 1 ) sum = sum + data_in ( i , j , k ) end do sum = sum / real ( dtmp % xsz ( 1 ), WP ) a_xpencil (:, j , k ) = sum end do end do call write_visu_field ( dm , a_xpencil , dm % dccc , trim ( str1 ), trim ( str2 ), SCALAR , CELL , iter ) else if ( & . not . dm % is_periodic ( 1 ) . and . & dm % is_periodic ( 3 ) . and . & . not . dm % is_periodic ( 2 )) then call transpose_x_to_y ( data_in , a_ypencil , dtmp ) call transpose_y_to_z ( a_ypencil , a_zpencil , dtmp ) do j = 1 , dtmp % zsz ( 2 ) do i = 1 , dtmp % zsz ( 1 ) sum = ZERO do k = 1 , dtmp % zsz ( 3 ) sum = sum + a_zpencil ( i , j , k ) end do sum = sum / real ( dtmp % zsz ( 3 ), WP ) b_zpencil ( i , j , :) = sum end do end do call transpose_z_to_y ( b_zpencil , a_ypencil , dtmp ) call transpose_y_to_x ( a_ypencil , a_xpencil , dtmp ) call write_visu_field ( dm , a_xpencil , dm % dccc , trim ( str1 ), trim ( str2 ), SCALAR , CELL , iter ) else ! do nothing here !data_out = data_in end if return end subroutine end module","tags":"","url":"sourcefile/io_visulisation.f90.html"},{"title":"io_tools.f90 – CHAPSim2","text":"Source Code module io_tools_mod implicit none !---------------------------------------------------------------------------------------------------------- ! io parameters !---------------------------------------------------------------------------------------------------------- character ( * ), parameter :: io_restart = \"restart-io\" character ( * ), parameter :: io_in2outlet = \"outlet2inlet-io\" integer , parameter :: Ivisu_3D = 0 , & Ivisu_2D_YZ = 1 , & ! yz plane, should not change this value. Ivisu_2D_XZ = 2 , & ! xz plane Ivisu_2D_XY = 3 , & ! xy plane Ivisu_1D_Y = 4 ! y profile public :: initialise_decomp_io public :: generate_file_name public :: generate_pathfile_name contains !========================================================================================================== subroutine initialise_decomp_io ( dm ) use udf_type_mod use decomp_2d_io implicit none type ( t_domain ), intent ( in ) :: dm logical is_start1 ! is index starting from 1. !---------------------------------------------------------------------------------------------------------- ! if not #ifdef ADIOS2, do nothing below. !---------------------------------------------------------------------------------------------------------- call decomp_2d_io_init () !---------------------------------------------------------------------------------------------------------- ! re-define the grid mesh size, considering the nskip ! based on decomp_info of dppp (default one defined) !---------------------------------------------------------------------------------------------------------- is_start1 = . true . !call init_coarser_mesh_statV(dm%visu_nskip(1), dm%visu_nskip(2), dm%visu_nskip(3), is_start1) !call init_coarser_mesh_statS(dm%stat_nskip(1), dm%stat_nskip(2), dm%stat_nskip(3), is_start1) end subroutine !========================================================================================================== subroutine generate_pathfile_name ( flname_path , dmtag , keyword , path , extension , opt_timetag , opt_flname ) use typeconvert_mod implicit none integer , intent ( in ) :: dmtag character ( * ), intent ( in ) :: keyword character ( * ), intent ( in ) :: path character ( * ), intent ( in ) :: extension character ( 120 ), intent ( inout ), optional :: opt_flname character ( 120 ), intent ( out ) :: flname_path integer , intent ( in ), optional :: opt_timetag character ( 120 ) :: flname if ( present ( opt_timetag )) then flname = \"/domain\" // trim ( int2str ( dmtag )) // '_' // trim ( keyword ) // '_' // trim ( int2str ( opt_timetag )) // \".\" // trim ( extension ) else flname = \"/domain\" // trim ( int2str ( dmtag )) // '_' // trim ( keyword ) // \".\" // trim ( extension ) end if if ( present ( opt_flname )) then opt_flname = flname end if flname_path = trim ( path ) // trim ( flname ) return end subroutine !========================================================================================================== subroutine generate_file_name ( flname , dmtag , keyword , extension , timetag ) use typeconvert_mod implicit none integer , intent ( in ) :: dmtag character ( * ), intent ( in ) :: keyword character ( * ), intent ( in ) :: extension character ( 120 ), intent ( out ) :: flname integer , intent ( in ), optional :: timetag if ( present ( timetag )) then flname = \"domain\" // trim ( int2str ( dmtag )) // '_' // trim ( keyword ) // '_' // trim ( int2str ( timetag )) // \".\" // trim ( extension ) else flname = \"domain\" // trim ( int2str ( dmtag )) // '_' // trim ( keyword ) // \".\" // trim ( extension ) end if return end subroutine !========================================================================================================== end module","tags":"","url":"sourcefile/io_tools.f90.html"},{"title":".eq_momentum.f90 – CHAPSim2","text":"Source Code module eq_momentum_mod use operations use precision_mod use decomp_2d use print_msg_mod implicit none private :: Calculate_momentum_fractional_step private :: Compute_momentum_rhs private :: Correct_massflux private :: solve_poisson private :: solve_poisson_x2z public :: Solve_momentum_eq contains !========================================================================================================== !========================================================================================================== !> \\brief To calcuate the convection and diffusion terms in rhs of momentum eq. !> !> This subroutine is called everytime when calcuting the rhs of momentum eqs. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                         ! !______________________________________________________________________________! !> \\param[inout]  rhs0          the last iteration rhs !> \\param[inout]  rhs1          the current iteration rhs !> \\param[in]     rhs1_semi     the semi-implicit term !> \\param[in]     isub          the RK iteration to get correct Coefficient !_______________________________________________________________________________ subroutine Calculate_momentum_fractional_step ( rhs0 , rhs1 , rhs1_pfc , dtmp , dm , isub ) use parameters_constant_mod use udf_type_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( in ) :: rhs1_pfc real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: rhs0 , rhs1 integer , intent ( in ) :: isub real ( WP ) :: rhs_explicit_current , rhs_explicit_last , rhs_total integer :: i , j , k do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) do i = 1 , dtmp % xsz ( 1 ) ! add explicit terms : convection+viscous rhs rhs_explicit_current = rhs1 ( i , j , k ) rhs_explicit_last = rhs0 ( i , j , k ) rhs_total = ( dm % tGamma ( isub ) * rhs_explicit_current + & dm % tZeta ( isub ) * rhs_explicit_last ) * dm % dt rhs0 ( i , j , k ) = rhs_explicit_current ! add pressure gradient rhs_total = rhs_total + & dm % tAlpha ( isub ) * rhs1_pfc ( i , j , k ) * dm % dt ! times the time step rhs1 ( i , j , k ) = rhs_total end do end do end do !write(*,*) 'rkcoeff', nrank, isub, dm%tGamma(isub), dm%tZeta(isub), dm%tAlpha(isub), correct. return end subroutine !========================================================================================================== !> \\brief To calcuate all rhs of momentum eq. !> !> This subroutine is called everytime when calcuting the rhs of momentum eqs. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                         ! !______________________________________________________________________________! !> \\param[inout]  f             flow field !> \\param[inout]  d             domain !> \\param[in]     isub          the RK iteration to get correct Coefficient !_______________________________________________________________________________ subroutine Compute_momentum_rhs ( fl , dm , isub ) use parameters_constant_mod use udf_type_mod use operations use solver_tools_mod use typeconvert_mod use boundary_conditions_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: isub !---------------------------------------------------------------------------------------------------------- ! common vars !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: qx_ypencil real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: qx_zpencil real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: mx_rhs_ypencil real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: mx_rhs_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: mx_rhs_pfc real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qy_ypencil real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: qy_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: my_rhs_ypencil ! real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: my_rhs_zpencil ! real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: my_rhs_pfc real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: my_rhs_pfc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: qz_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qz_zpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: mz_rhs_ypencil ! real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: mz_rhs_zpencil ! real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: mz_rhs_pfc real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: mz_rhs_pfc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: mz_rhs_pfc_zpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc , acpc_test real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: accp , accp_test ! real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: apcc_ypencil real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: apcc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil ! real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: acpc_zpencil ! real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil ! real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil ! real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: pres_ypencil ! p real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: pres_zpencil ! p real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: qx_ppc_ypencil ! <ux>&#94;y at (xp, yp, zc) real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qy_cpp_zpencil ! <uy>&#94;z at (xc, yp, zp) real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qz_cpp_ypencil ! <uz>&#94;y at (xc, yp, zp) real ( WP ), dimension ( dm % dpcp % ysz ( 1 ), dm % dpcp % ysz ( 2 ), dm % dpcp % ysz ( 3 ) ) :: apcp_ypencil ! real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: qz_pcp ! <uz>&#94;x at (xp, yc, zp) real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: qx_pcp_zpencil ! <ux>&#94;z at (xp, yc, zp) !---------------------------------------------------------------------------------------------------------- ! thermal == 0 only !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: qx_pcp ! <ux>&#94;z at (xp, yc, zp) real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: qx_ppc ! <ux>&#94;y at (xp, yp, zc) real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: qy_ppc ! <uy>&#94;x at (xp, yp, zc) real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: qy_ppc_ypencil ! <uy>&#94;x at (xp, yp, zc) real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qy_cpp_ypencil ! <uy>&#94;z at (xc, yp, zp) real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: qz_pcp_zpencil ! <uz>&#94;x at (xp, yc, zp) real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qz_cpp_zpencil ! <uz>&#94;y at (xc, yp, zp) !---------------------------------------------------------------------------------------------------------- ! thermal == 1 only !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: apcc , apcc_test real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: apcp real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: appc real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: apcp_zpencil real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: appc_ypencil real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: acpp_ypencil real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: acpp_zpencil real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: qx_ccc ! <ux>&#94;x at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qx_ccc_ypencil ! <ux>&#94;x at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: qx_ccc_zpencil ! <ux>&#94;x at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: qy_ccc ! <uy>&#94;y at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qy_ccc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: qy_ccc_zpencil ! <uy>&#94;y at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: qz_ccc ! <uz>&#94;z at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qz_ccc_ypencil ! <uz>&#94;z at (xc, yc, zc), intermediate real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: qz_ccc_zpencil real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: gx_ccc ! <gx>&#94;x at (xc, yc, zc) real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: gx_ppc ! <gx>&#94;y at (xp, yp, zc) real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: gx_pcp ! <gx>&#94;z at (xp, yc, zp) real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: gy_ypencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: gy_ccc_ypencil real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: gy_cpp_ypencil ! <gy>&#94;z at (xc, yp, zp) real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: gy_ppc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: gz_zpencil ! real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: gz_pcp_zpencil ! <gz>&#94;x at (xp, yc, zp) real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: gz_cpp_zpencil ! <gz>&#94;y at (xc, yp, zp) real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: gz_ccc_zpencil ! <gz>&#94;y at (xc, yc, zc) real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: dDens_ypencil ! d real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: dDens_zpencil ! d real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: m_pcc ! <mu>&#94;x       at (xp, yc, zc) real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: m_pcc_ypencil ! <mu>&#94;x       at (xp, yc, zc) real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: m_pcc_zpencil ! <mu>&#94;x       at (xp, yc, zc) real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: m_cpc ! <mu>&#94;y       at (xc, yp, zc) real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: m_cpc_ypencil ! <mu>&#94;y       at (xc, yp, zc) real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: m_cpc_zpencil ! <mu>&#94;y       at (xc, yp, zc) real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: m_ccp ! <mu>&#94;z       at (xc, yc, zp) real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: m_ccp_ypencil ! <mu>&#94;z       at (xc, yc, zp) real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: m_ccp_zpencil ! <mu>&#94;z       at (xc, yc, zp) real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: dmdx_pcc ! d( mu   )/dx at (xp, yc, zc) real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: dmdx_cpc ! d(<mu>&#94;y)/dx at (xc, yp, zc) real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: dmdx_ccp ! d(<mu>&#94;z)/dx at (xc, yc, zp) real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: dmdy_pcc ! d(<mu>&#94;x)/dy at (xp, yc, zc) real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: dmdz_pcc ! d(<mu>&#94;x)/dz at (xp, yc, zc) real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: dmdx_cpc_ypencil ! d( mu   )/dx at (xc, yp, zc) real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: dmdx_ccp_zpencil ! d(<mu>&#94;z)/dx at (xc, yc, zp) real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: dmdy_pcc_ypencil ! d(<mu>&#94;x)/dy at (xp, yc, zc) real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: dmdy_cpc_ypencil ! d( mu   )/dy at (xc, yp, zc) real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: dmdy_ccp_ypencil ! d(<mu>&#94;z)/dy at (xc, yc, zp) real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: dmdy_ccp_zpencil ! d(<mu>&#94;z)/dx at (xc, yc, zp) real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: dmdz_pcc_zpencil ! d(<mu>&#94;x)/dz at (xp, yc, zc) real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: dmdz_cpc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: dmdz_cpc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: dmdz_ccp_zpencil ! d( mu   )/dz at (xc, yc, zp) real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: div real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: div_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: div_zpencil !---------------------------------------------------------------------------------------------------------- ! others !---------------------------------------------------------------------------------------------------------- real ( WP ) :: one_third_rre , two_third_rre , two_rre real ( WP ) :: fbcx ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) real ( WP ) :: fbcy ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) real ( WP ) :: fbcz ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) real ( WP ) :: fbcxc ( 4 , dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) integer :: mbc ( 1 : 2 , 1 : 3 ) integer :: i real ( WP ) :: rhsx_bulk , rhsz_bulk !#ifdef DEBUG_STEPS logical :: iconvection , ipressure , iviscous !if(nrank == 0) & !call Print_debug_start_msg(\"Compute_momentum_rhs at isub = \"//trim(int2str(isub))) iconvection = . true . ipressure = . true . iviscous = . true . !#endif one_third_rre = ONE_THIRD * fl % rre two_third_rre = TWO_THIRD * fl % rre two_rre = TWO * fl % rre !========================================================================================================== ! variable preparation ! In the comments: !     TMP = Intermediate !     NOT = no thermal fields !     WTT = with thermal fields !     WO = both, commom !========================================================================================================== !---------------------------------------------------------------------------------------------------------- !    p --> p_ypencil (y-mom, w+o) --> p_zpencil (z-mom, w+o) !---------------------------------------------------------------------------------------------------------- !write(*,*) nrank,  'test-0' call transpose_x_to_y ( fl % pres , pres_ypencil , dm % dccc ) call transpose_y_to_z ( pres_ypencil , pres_zpencil , dm % dccc ) !---------------------------------------------------------------------------------------------------------- !    qx --> qx_ccc (BOTH) --> qx_ccc_ypencil(WTT) --> qx_ccc_zpencil(WTT) !     | --> qx_ypencil(BOTH) --> qx_ppc_ypencil(BOTH) --> qx_ppc(NOT) !                       |  --> qx_zpencil(BOTH) --> qx_pcp_zpencil(BOTH) --> qx_pcp_ypencil(TMP) --> qx_pcp(NOT) !---------------------------------------------------------------------------------------------------------- call Get_x_midp_P2C_3D ( fl % qx , qx_ccc , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx ) call transpose_x_to_y ( fl % qx , qx_ypencil , dm % dpcc ) call Get_y_midp_C2P_3D ( qx_ypencil , qx_ppc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx (:), dm % fbcy_qx ) ! qx_ppc_ypencil : x-mom, w+o thermal call transpose_y_to_z ( qx_ypencil , qx_zpencil , dm % dpcc ) ! qx_zpencil : x-mom, w+o thermal call Get_z_midp_C2P_3D ( qx_zpencil , qx_pcp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx (:), dm % fbcz_qx ) ! qx_pcp_zpencil : x-mom, w+o thermal if (. not . dm % is_thermo ) then call transpose_y_to_x ( qx_ppc_ypencil , qx_ppc , dm % dppc ) ! call transpose_z_to_y ( qx_pcp_zpencil , apcp_ypencil , dm % dpcp ) ! intermediate, apcp_ypencil = qx_pcp_ypencil call transpose_y_to_x ( apcp_ypencil , qx_pcp , dm % dpcp ) ! qx_pcp : z-mom,  o  thermal else call transpose_x_to_y ( qx_ccc , qx_ccc_ypencil , dm % dccc ) ! qx_ccc_ypencil : y-mom, w   thermal call transpose_y_to_z ( qx_ccc_ypencil , qx_ccc_zpencil , dm % dccc ) ! qx_ccc_zpencil : z-mom, w   thermal end if !---------------------------------------------------------------------------------------------------------- !    qy--> qy_ppc(BOTH) --> qy_ppc_ypencil(NOT) !     |--> qy_ypencil(BOTH) --> qy_zpencil(BOTH) --> qy_cpp_zpencil(BOTH) --> qy_cpp_ypencil(NOT) !                       | --> qy_ccc_ypencil(BOTH) --> qy_ccc(WTT) !                                              | --> qy_ccc_zpencil(WTT) !---------------------------------------------------------------------------------------------------------- call Get_x_midp_C2P_3D ( fl % qy , qy_ppc , dm , dm % iAccuracy , dm % ibcx_qy (:), dm % fbcx_qy ) ! qy_ppc : y-mom, w+o thermal call transpose_x_to_y ( fl % qy , qy_ypencil , dm % dcpc ) ! qy_ypencil : y-mom, w+o thermal call transpose_y_to_z ( qy_ypencil , qy_zpencil , dm % dcpc ) ! qy_zpencil : y-mom, w+o thermal call Get_z_midp_C2P_3D ( qy_zpencil , qy_cpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy (:), dm % fbcz_qy ) ! qy_cpp_zpencil : y-mom, w+o thermal call Get_y_midp_P2C_3D ( qy_ypencil , qy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_qy ) ! if (. not . dm % is_thermo ) then call transpose_x_to_y ( qy_ppc , qy_ppc_ypencil , dm % dppc ) ! qy_ppc_ypencil : x-mom, o thermal call transpose_z_to_y ( qy_cpp_zpencil , qy_cpp_ypencil , dm % dcpp ) ! qy_cpp_ypencil : z-mom, o thermal else call transpose_y_to_x ( qy_ccc_ypencil , qy_ccc , dm % dccc ) ! qy_ccc: x-mom, w   thermal call transpose_y_to_z ( qy_ccc_ypencil , qy_ccc_zpencil , dm % dccc ) ! qy_ccc_zpencil : z-mom, w   thermal end if !---------------------------------------------------------------------------------------------------------- !    qz --> qz_pcp(BOTH) --> qz_pcp_ypencil(TMP) --> qz_pcp_zpencil(NOT) !     | --> qz_ypencil(BOTH) --> qz_cpp_ypencil(BOTH) --> qz_cpp_zpencil(NOT) !                       |  --> qz_zpencil(BOTH) --> qz_ccc_zpencil(BOTH) --> qz_ccc_ypencil(WTT) --> qz_ccc(WTT) !---------------------------------------------------------------------------------------------------------- !write(*,*) nrank,  'test-3' call Get_x_midp_C2P_3D ( fl % qz , qz_pcp , dm , dm % iAccuracy , dm % ibcx_qz (:), dm % fbcx_qz ) ! x-pencil : z-mom, w+o   thermal call transpose_x_to_y ( fl % qz , qz_ypencil , dm % dccp ) ! qz_ypencil : z-mom, w+o   thermal call Get_y_midp_C2P_3D ( qz_ypencil , qz_cpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz (:), dm % fbcy_qz ) ! qz_cpp_ypencil : z-mom, w+o   thermal call transpose_y_to_z ( qz_ypencil , qz_zpencil , dm % dccp ) ! z-pencil : z-mom, w+o   thermal call Get_z_midp_P2C_3D ( qz_zpencil , qz_ccc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_qz ) ! intermediate, accc_zpencil = qz_ccc_zpencil if ( . not . dm % is_thermo ) then call transpose_x_to_y ( qz_pcp , apcp_ypencil , dm % dpcp ) ! intermediate, apcp_ypencil = qz_pcp_ypencil call transpose_y_to_z ( apcp_ypencil , qz_pcp_zpencil , dm % dpcp ) ! qz_pcp_zpencil : x-mom, o   thermal call transpose_y_to_z ( qz_cpp_ypencil , qz_cpp_zpencil , dm % dcpp ) ! z-pencil : y-mom, o   thermal else call transpose_z_to_y ( qz_ccc_zpencil , qz_ccc_ypencil , dm % dccc ) ! y-pencil : y-mom, w   thermal call transpose_y_to_x ( qz_ccc_ypencil , qz_ccc , dm % dccc ) ! x-pencil : x-mom, w   thermal end if if ( dm % is_thermo ) then !---------------------------------------------------------------------------------------------------------- !    gx --> gx_ccc !      |--> gx_ypencil(TMP) --> gx_ppc_ypencil(TMP)--> gx_ppc(WTT) !                     |--> gx_zpencil(TMP) --> gx_pcp_zpencil(TMP) --> gx_pcp_ypencil(TMP) --> gx_pcp !---------------------------------------------------------------------------------------------------------- call Get_x_midp_P2C_3D ( fl % gx , gx_ccc , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_gx ) ! call transpose_x_to_y ( fl % gx , apcc_ypencil , dm % dpcc ) ! intermediate, apcc_ypencil = gx_ypencil call Get_y_midp_C2P_3D ( apcc_ypencil , appc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx (:), dm % fbcy_gx (:, :, :) ) ! intermediate, appc_ypencil = gx_ppc_ypencil call transpose_y_to_x ( appc_ypencil , gx_ppc , dm % dppc ) ! gx_ppc : y-mom, w   thermal call transpose_y_to_z ( apcc_ypencil , apcc_zpencil , dm % dpcc ) ! intermediate, apcc_zpencil = gx_zpencil call Get_z_midp_C2P_3D ( apcc_zpencil , apcp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx (:), dm % fbcz_gx (:, :, :) ) ! intermediate, apcp_zpencil = gx_pcp_zpencil call transpose_z_to_y ( apcp_zpencil , apcp_ypencil , dm % dpcp ) ! intermediate, apcp_ypencil = gx_pcp_ypencil call transpose_y_to_x ( apcp_ypencil , gx_pcp , dm % dpcp ) ! x-pencil : z-mom, wo  thermal !---------------------------------------------------------------------------------------------------------- !    gy --> gy_ypencil(WTT) --> gy_zpencil(TMP) --> gy_cpp_zpencil(TMP) --> gy_cpp_ypencil(WTT) !                         --> gy_ppc(TMP) --> gy_ppc_ypencil(WTT) !                         --> gy_ccc_ypencil(WTT) !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( fl % gy , gy_ypencil , dm % dcpc ) ! y-pencil : y-mom, w   thermal call Get_y_midp_P2C_3D ( gy_ypencil , gy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_gy ) ! call Get_x_midp_C2P_3D ( fl % gy , appc , dm , dm % iAccuracy , dm % ibcx_qy (:), dm % fbcx_gy ) ! call transpose_x_to_y ( appc , gy_ppc_ypencil , dm % dppc ) ! call transpose_y_to_z ( gy_ypencil , acpc_zpencil , dm % dcpc ) ! y-pencil : y-mom, w   thermal call Get_z_midp_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy (:), dm % fbcz_gy ) ! intermediate, acpp_zpencil = gy_cpp_zpencil call transpose_z_to_y ( acpp_zpencil , gy_cpp_ypencil , dm % dcpp ) ! y-pencil : z-mom, w   thermal !---------------------------------------------------------------------------------------------------------- !    gz --> gz_pcp(TMP)    --> gz_pcp_ypencil(TMP) --> gz_pcp_zpencil(WTT) !     | --> gz_ypencil(TMP) --> gz_cpp_ypencil(TMP) --> gz_cpp_zpencil(WTT) !                | --> gz_zpencil | --> gz_ccc_zpencil !---------------------------------------------------------------------------------------------------------- call Get_x_midp_C2P_3D ( fl % gz , apcp , dm , dm % iAccuracy , dm % ibcx_qz (:), dm % fbcx_gz ) ! intermediate, apcp = gz_pcp call transpose_x_to_y ( apcp , apcp_ypencil , dm % dpcp ) ! intermediate  apcp_ypencil = gz_pcp_ypencil call transpose_y_to_z ( apcp_ypencil , gz_pcp_zpencil , dm % dpcp ) ! z-pencil : x-mom, w   thermal call transpose_x_to_y ( fl % gz , accp_ypencil , dm % dccp ) ! intermediate, accp = gz_ypencil call transpose_y_to_z ( accp_ypencil , gz_zpencil , dm % dccp ) ! intermediate, accp = gz_ypencil call Get_z_midp_P2C_3D ( gz_zpencil , gz_ccc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_gz ) ! intermediate, acpp_ypencil = gz_cpp_ypencil call Get_y_midp_C2P_3D ( accp_ypencil , acpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz (:), dm % fbcy_gz ) ! intermediate, acpp_ypencil = gz_cpp_ypencil call transpose_y_to_z ( acpp_ypencil , gz_cpp_zpencil , dm % dcpp ) ! z-pencil : y-mom, w   thermal !---------------------------------------------------------------------------------------------------------- !   d --> d_ypencil --> d_zpencil !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( fl % dDens , dDens_ypencil , dm % dccc ) ! y-pencil : y-mom, w   thermal call transpose_y_to_z ( dDens_ypencil , dDens_zpencil , dm % dccc ) ! z-pencil : z-mom, w   thermal !---------------------------------------------------------------------------------------------------------- !    m --> dmdx_pcc !    | --> m_pcc -->m_pcc_ypencil -->dmdy_pcc_ypencil-->dmdy_pcc !                                 | -->m_pcc_zpencil --> dmdz_pcc_zpencil--> dmdz_pcc_ypencil(TMP) --> dmdz_pcc !    | --> m_ypencil(TMP) --> dmdy_cpc_ypencil !                     | --> m_cpc_ypencil --> m_cpc --> dmdx_cpc --> dmdx_cpc_ypencil !                                       | --> m_cpc_zpencil --> dmdz_cpc_zpencil --> dmdz_cpc_ypencil !                     | --> m_zpencil(TMP) --> dmdz_ccp_zpencil !                                      | --> m_ccp_zpencil --> m_ccp_ypencil --> m_ccp --> dmdx_ccp --> dmdx_ccp_ypencil(TMP) --> dmdx_ccp_zpencil !                                                                     |        --> dmdy_ccp_ypencil --> dmdy_ccp_zpencil !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( fl % mVisc , dmdx_pcc , dm , dm % iAccuracy , dm % ibcx_Th (:), dm % fbcx_ftp (:, :, :)% m ) ! x-pencil : x-mom, w thermal call Get_x_midp_C2P_3D ( fl % mVisc , m_pcc , dm , dm % iAccuracy , dm % ibcx_Th (:), dm % fbcx_ftp (:, :, :)% m ) ! x-pencil : x-mom, w thermal call transpose_x_to_y ( m_pcc , m_pcc_ypencil , dm % dpcc ) ! y-pencil : x-mom, w thermal call Get_y_1der_C2C_3D ( m_pcc_ypencil , dmdy_pcc_ypencil , dm , dm % iAccuracy , dm % ibcy_Th (:), dm % fbcy_ftp (:, :, :)% m ) ! y-pencil : x-mom, w thermal call transpose_y_to_x ( dmdy_pcc_ypencil , dmdy_pcc , dm % dpcc ) ! x-pencil : x-mom, w thermal call transpose_y_to_z ( m_pcc_ypencil , m_pcc_zpencil , dm % dpcc ) ! z-pencil : x-mom, w thermal call Get_z_1der_C2C_3D ( m_pcc_zpencil , dmdz_pcc_zpencil , dm , dm % iAccuracy , dm % ibcz_Th (:), dm % fbcz_ftp (:, :, :)% m ) ! z-pencil : x-mom, w thermal call transpose_z_to_y ( dmdz_pcc_zpencil , apcc_ypencil , dm % dpcc ) ! intermediate, apcc_ypencil = dmdz_pcc_ypencil call transpose_y_to_x ( apcc_ypencil , dmdz_pcc , dm % dpcc ) ! x-pencil : x-mom, w thermal call transpose_x_to_y ( fl % mVisc , accc_ypencil , dm % dccc ) call Get_y_1der_C2P_3D ( accc_ypencil , dmdy_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_Th (:), dm % fbcy_ftp (:, :, :)% m ) ! x-pencil : y-mom, w thermal                                   ! intermediate, accc_ypencil = m_ypencil call Get_y_midp_C2P_3D ( accc_ypencil , m_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_Th (:), dm % fbcy_ftp (:, :, :)% m ) ! y-pencil : y-mom, w thermal call transpose_y_to_z ( m_cpc_ypencil , m_cpc_zpencil , dm % dcpc ) ! z-pencil : y-mom, w thermal call transpose_y_to_x ( m_cpc_ypencil , m_cpc , dm % dcpc ) ! x-pencil : y-mom, w thermal call Get_z_1der_C2C_3D ( m_cpc_zpencil , dmdz_cpc_zpencil , dm , dm % iAccuracy , dm % ibcz_Th (:), dm % fbcz_ftp (:, :, :)% m ) call transpose_z_to_y ( dmdz_cpc_zpencil , dmdz_cpc_ypencil , dm % dcpc ) call Get_x_1der_C2C_3D ( m_cpc , dmdx_cpc , dm , dm % iAccuracy , dm % ibcx_Th (:), dm % fbcx_ftp (:, :, :)% m ) ! x-pencil : y-mom, w thermal call transpose_x_to_y ( dmdx_cpc , dmdx_cpc_ypencil , dm % dcpc ) call transpose_y_to_z ( accc_ypencil , accc_zpencil , dm % dccc ) ! intermediate, accc_zpencil = m_zpencil call Get_z_1der_C2P_3D ( accc_zpencil , dmdz_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_Th (:), dm % fbcz_ftp (:, :, :)% m ) ! z-pencil : z-mom, w thermal call Get_z_midp_C2P_3D ( accc_zpencil , m_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_Th (:), dm % fbcz_ftp (:, :, :)% m ) ! z-pencil : z-mom, w thermal call transpose_z_to_y ( m_ccp_zpencil , m_ccp_ypencil , dm % dccp ) ! y-pencil : z-mom, w thermal call transpose_y_to_x ( m_ccp_ypencil , m_ccp , dm % dccp ) ! x-pencil : z-mom, w thermal call Get_x_1der_C2C_3D ( m_ccp , dmdx_ccp , dm , dm % iAccuracy , dm % ibcx_Th (:), dm % fbcx_ftp (:, :, :)% m ) ! x-pencil : z-mom, w thermal call transpose_x_to_y ( dmdx_ccp , accp_ypencil , dm % dccp ) ! intermidate, accp_ypencil = dmdx_ccp_ypencil call transpose_y_to_z ( accp_ypencil , dmdx_ccp_zpencil , dm % dccp ) ! z-pencil : z-mom, w thermal call Get_y_1der_C2C_3D ( m_ccp_ypencil , dmdy_ccp_ypencil , dm , dm % iAccuracy , dm % ibcy_Th (:), dm % fbcy_ftp (:, :, :)% m ) ! y-pencil : z-mom, w thermal call transpose_y_to_z ( dmdy_ccp_ypencil , dmdy_ccp_zpencil , dm % dccp ) !---------------------------------------------------------------------------------------------------------- ! calculate div(u_vec) !---------------------------------------------------------------------------------------------------------- div = ZERO accc = ZERO call Get_x_1der_P2C_3D ( fl % qx , accc , dm , dm % iAccuracy , dm % ibcx_qx (:)) !, dm%fbcx_qx) ! accc = d(qx)/d(x)_ccc div = div + accc ! = d(qx)/d(x)_ccc call Get_y_1der_P2C_3D ( qy_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:)) ! accc_ypencil = d(qy)/(y)_ccc_ypencil call transpose_y_to_x ( accc_ypencil , accc , dm % dccc ) ! accc = d(qy)/d(y)_ccc div = div + accc ! = d(qx)/d(x)_ccc + d(qy)/d(y)_ccc call Get_z_1der_P2C_3D ( qz_zpencil , accc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:)) ! accc_zpencil = d(qz)/(z)_ccc_zpencil call transpose_z_to_y ( accc_zpencil , accc_ypencil , dm % dccc ) ! accc_ypencil = d(qz)/(z)_ccc_ypencil call transpose_y_to_x ( accc_ypencil , accc , dm % dccc ) ! accc = d(qz)/d(z)_ccc div = div + accc ! = d(qx)/d(x)_ccc + d(qy)/d(y)_ccc + d(qz)/d(z)_ccc call transpose_x_to_y ( div , div_ypencil , dm % dccc ) call transpose_y_to_z ( div_ypencil , div_zpencil , dm % dccc ) end if !write(*,*) nrank,  'test-4' !========================================================================================================== ! the RHS of x-momentum equation !========================================================================================================== fl % mx_rhs = ZERO mx_rhs_ypencil = ZERO mx_rhs_zpencil = ZERO mx_rhs_pfc = ZERO apcc = ZERO apcc_ypencil = ZERO apcc_zpencil = ZERO i = 1 if ( iconvection ) then !---------------------------------------------------------------------------------------------------------- ! X-pencil : X-mom convection term (x-c1/3): -d(gx * qx)/dx at (i', j, k) ! Note: if qx is asymmetric, then qx&#94;2 is symmetric. !---------------------------------------------------------------------------------------------------------- if ( . not . dm % is_thermo ) then call Get_x_1der_C2P_3D ( - qx_ccc * qx_ccc , apcc , dm , dm % iAccuracy , mbcx_cov1 , - dm % fbcx_qx * dm % fbcx_qx ) else call Get_x_1der_C2P_3D ( - gx_ccc * qx_ccc , apcc , dm , dm % iAccuracy , mbcx_cov1 , - dm % fbcx_gx * dm % fbcx_qx ) end if fl % mx_rhs = fl % mx_rhs + apcc !---------------------------------------------------------------------------------------------------------- ! Y-pencil : X-mom convection term (x-c2/3): -d(<gy>&#94;x * <qx>&#94;y)/dy at (i', j, k) !---------------------------------------------------------------------------------------------------------- if ( . not . dm % is_thermo ) then call Get_y_1der_P2C_3D ( - qy_ppc_ypencil * qx_ppc_ypencil , apcc_ypencil , dm , dm % iAccuracy , mbcy_cov1 ) !, -dm%fbcy_qy * dm%fbcy_qx) else call Get_y_1der_P2C_3D ( - gy_ppc_ypencil * qx_ppc_ypencil , apcc_ypencil , dm , dm % iAccuracy , mbcy_cov1 ) !, -dm%fbcy_gy * dm%fbcy_qx) end if mx_rhs_ypencil = mx_rhs_ypencil + apcc_ypencil !---------------------------------------------------------------------------------------------------------- ! Z-pencil : X-mom convection term (x-c3/3): -d(<gz>&#94;x * <qx>&#94;z)/dz at (i', j, k) !---------------------------------------------------------------------------------------------------------- if ( . not . dm % is_thermo ) then call Get_z_1der_P2C_3D ( - qz_pcp_zpencil * qx_pcp_zpencil , apcc_zpencil , dm , dm % iAccuracy , mbcz_cov1 ) !, -dm%fbcz_qz * dm%fbcz_qx ) else call Get_z_1der_P2C_3D ( - gz_pcp_zpencil * qx_pcp_zpencil , apcc_zpencil , dm , dm % iAccuracy , mbcz_cov1 ) !, -dm%fbcz_gz * dm%fbcz_qx ) end if mx_rhs_zpencil = mx_rhs_zpencil + apcc_zpencil #ifdef DEBUG_STEPS apcc_test = fl % mx_rhs call transpose_y_to_x ( mx_rhs_ypencil , apcc , dm % dpcc ) apcc_test = apcc_test + apcc call transpose_z_to_y ( mx_rhs_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , apcc , dm % dpcc ) apcc_test = apcc_test + apcc call wrt_3d_pt_debug ( apcc_test , dm % dpcc , fl % iteration , isub , 'ConX@bf st' ) ! debug_ww #endif end if !---------------------------------------------------------------------------------------------------------- ! X-pencil : X-mom pressure gradient in x direction, d(sigma_1 p) !---------------------------------------------------------------------------------------------------------- if ( ipressure ) then call Get_x_1der_C2P_3D ( - fl % pres , apcc , dm , dm % iAccuracy , dm % ibcx_pr (:), - dm % fbcx_pr (:, :, :) ) mx_rhs_pfc = mx_rhs_pfc + apcc end if !---------------------------------------------------------------------------------------------------------- ! X-pencil : X-mom diffusion term (x-v1-1/7), \\mu&#94;x * LL1(ux) at (i', j, k) !---------------------------------------------------------------------------------------------------------- if ( iviscous ) then !call Get_x_2nd_derivative_P2P_3D(fl%qx, apcc, dm, dm%iAccuracy, dm%ibcx(:, 1)) ! check call Get_x_1der_P2C_3D ( fl % qx , accc , dm , dm % iAccuracy , dm % ibcx_qx (:)) !, dm%fbcx_qx) ! accc = du/dx, at (i, j, k) call reconstruct_symmetry_ibc ( dm % ibcx_qx (:), mbc ) fbcx (:,:,:) = ZERO call Get_x_1der_C2P_3D ( accc , apcc , dm , dm % iAccuracy , mbc (:, JBC_GRAD ), fbcx ) ! accc = d(du/dx)/dx, at (i', j, k) if ( dm % ibcx_qx ( 1 ) == IBC_DIRICHLET . and . dm % dpcc % xst ( 1 ) == 1 ) apcc ( 1 , :, :) = ZERO if ( dm % ibcx_qx ( 2 ) == IBC_DIRICHLET . and . dm % dpcc % xen ( 1 ) == dm % dpcc % xsz ( 1 )) apcc ( dm % dpcc % xsz ( 1 ), :, :) = ZERO ! check, how to deal with wall bc if ( . not . dm % is_thermo ) then fl % mx_rhs = fl % mx_rhs + fl % rre * apcc else fl % mx_rhs = fl % mx_rhs + m_pcc * fl % rre * apcc end if write ( * , * ) 'visx-11' , fl % rre * apcc ( 4 , 1 : 4 , 4 ) !---------------------------------------------------------------------------------------------------------- ! Y-pencil : X-mom diffusion term (x-v1-2/7), \\mu&#94;x * LL2(ux) at (i', j, k) !---------------------------------------------------------------------------------------------------------- !call Get_y_2nd_derivative_C2C_3D(qx_ypencil, apcc_ypencil, dm, dm%iAccuracy, dm%ibcy(:, 1), dm%fbcy_qx(:, :, :)) call Get_y_1der_C2P_3D ( qx_ypencil , appc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx (:), dm % fbcy_qx (:, :, :)) ! du/dy, at (i', j', k) call reconstruct_symmetry_ibc ( dm % ibcy_qx (:), mbc ) fbcy (:, 1 ,:) = appc_ypencil (:, 1 , :) fbcy (:, 2 ,:) = appc_ypencil (:, dm % dppc % ysz ( 2 ), :) call Get_y_1der_P2C_3D ( appc_ypencil , apcc_ypencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) !, fbcy) ! d(du/dy)/dy, at (i', j, k) if ( . not . dm % is_thermo ) then mx_rhs_ypencil = mx_rhs_ypencil + fl % rre * apcc_ypencil else mx_rhs_ypencil = mx_rhs_ypencil + m_pcc_ypencil * fl % rre * apcc_ypencil end if write ( * , * ) 'visx-22' , fl % rre * apcc_ypencil ( 4 , 1 : 4 , 4 ) !---------------------------------------------------------------------------------------------------------- ! Z-pencil : X-mom diffusion term (x-v1-3/7), \\mu&#94;x * LL3(ux) at (i', j, k) !---------------------------------------------------------------------------------------------------------- !call Get_z_2nd_derivative_C2C_3D(qx_zpencil, apcc_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 1), dm%fbcz_var(:, 1)) call Get_z_1der_C2P_3D ( qx_zpencil , apcp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx (:), dm % fbcz_qx (:, :, :)) ! du/dz at (i', j, k') call reconstruct_symmetry_ibc ( dm % ibcz_qx (:), mbc ) fbcz (:,:, 1 ) = apcp_zpencil (:, :, 1 ) fbcz (:,:, 2 ) = apcp_zpencil (:, :, dm % dpcp % zsz ( 3 )) call Get_z_1der_P2C_3D ( apcp_zpencil , apcc_zpencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) !, fbcz) ! d(du/dz)/dz at (i', j, k) if ( . not . dm % is_thermo ) then mx_rhs_zpencil = mx_rhs_zpencil + fl % rre * apcc_zpencil else mx_rhs_zpencil = mx_rhs_zpencil + m_pcc_zpencil * fl % rre * apcc_zpencil end if write ( * , * ) 'visx-33' , fl % rre * apcc_zpencil ( 4 , 1 : 4 , 4 ) if ( dm % is_thermo ) then !---------------------------------------------------------------------------------------------------------- ! x-pencil : X-mom, gravity force in x direction !---------------------------------------------------------------------------------------------------------- if ( fl % igravity == i . or . fl % igravity == - i ) then call Get_x_midp_C2P_3D ( fl % dDens , apcc , dm , dm % iAccuracy , dm % ibcx_Th (:), dm % fbcx_ftp (:, :, :)% d ) mx_rhs_pfc = mx_rhs_pfc + fl % fgravity ( i ) * apcc end if !---------------------------------------------------------------------------------------------------------- !   X-pencil : X-mom diffusion term (x-v2/7), \\mu&#94;x * 1/3 * d (div)/dx at (i', j, k) !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcx_qx (:), mbc ) call Get_x_1der_C2P_3D ( div , apcc , dm , dm % iAccuracy , mbc (:, JBC_GRAD ), fbcx ) ! apcc = d(div)/dx at (i', j, k) fl % mx_rhs = fl % mx_rhs + one_third_rre * m_pcc * apcc !---------------------------------------------------------------------------------------------------------- !   X-pencil : X-mom diffusion term (x-v3/7), -2/3 * d\\mu/dx * (div(u)&#94;x) + !                                                2 * d\\mu/dx * du/dx !---------------------------------------------------------------------------------------------------------- call Get_x_midp_C2P_3D ( div , apcc , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) ! div at (i', j, k), (to add, check: bc is required only if Neumann BC of velocity.) fl % mx_rhs = fl % mx_rhs - two_third_rre * dmdx_pcc * apcc call Get_x_1der_P2P_3D ( fl % qx , apcc , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx (:, :, :) ) ! apcc = d(qx)/dx at (i', j, k) fl % mx_rhs = fl % mx_rhs + two_rre * dmdx_pcc * apcc !---------------------------------------------------------------------------------------------------------- !   X-pencil : X-mom diffusion term (x-v4/7), d(mu&#94;x)/dy * d(qy&#94;y)/dx at (i', j, k) !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( qy_ccc , apcc , dm , dm % iAccuracy , dm % ibcx_qy (:), dm % fbcx_qy (:, :, :) ) !apcc = d(qy)/dx fl % mx_rhs = fl % mx_rhs + fl % rre * dmdy_pcc * apcc !---------------------------------------------------------------------------------------------------------- !   Y-pencil : X-mom diffusion term (x-v5/7), d(mu&#94;x)/dy * d(qx)/dy at (i', j, k) !---------------------------------------------------------------------------------------------------------- call Get_y_1der_C2C_3D ( qx_ypencil , apcc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx (:), dm % fbcy_qx ) !apcc_ypencil = d(qx)/dy_ypencil mx_rhs_ypencil = mx_rhs_ypencil + fl % rre * dmdy_pcc_ypencil * apcc_ypencil !---------------------------------------------------------------------------------------------------------- !   X-pencil : X-mom diffusion term (x-v6/7), d(mu&#94;x)/dz * d(qz&#94;z)/dx at (i', j, k) !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( qz_ccc , apcc , dm , dm % iAccuracy , dm % ibcx_qz (:), dm % fbcx_qz (:, :, :) ) ! apcc = d(qz)/dx fl % mx_rhs = fl % mx_rhs + fl % rre * dmdz_pcc * apcc !---------------------------------------------------------------------------------------------------------- !   Z-pencil : X-mom diffusion term (x-v7/7), d(mu&#94;x)/dz * d(qx)/dz at (i', j, k) !---------------------------------------------------------------------------------------------------------- call Get_z_1der_C2C_3D ( qx_zpencil , apcc_zpencil , dm , dm % iAccuracy , dm % ibcz_qx (:), dm % fbcz_qx ) ! apcc_zpencil = d(qx)/dz mx_rhs_zpencil = mx_rhs_zpencil + fl % rre * dmdz_pcc_zpencil * apcc_zpencil end if end if !---------------------------------------------------------------------------------------------------------- ! x-mom: convert all terms to rhs !---------------------------------------------------------------------------------------------------------- call transpose_y_to_x ( mx_rhs_ypencil , apcc , dm % dpcc ) fl % mx_rhs = fl % mx_rhs + apcc call transpose_z_to_y ( mx_rhs_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , apcc , dm % dpcc ) fl % mx_rhs = fl % mx_rhs + apcc !========================================================================================================== ! the RHS of Y momentum equation !========================================================================================================== fl % my_rhs = ZERO my_rhs_ypencil = ZERO my_rhs_zpencil = ZERO my_rhs_pfc = ZERO my_rhs_pfc_ypencil = ZERO acpc = ZERO acpc_ypencil = ZERO acpc_zpencil = ZERO i = 2 if ( iconvection ) then !---------------------------------------------------------------------------------------------------------- ! X-pencil : Y-mom convection term (y-c1/3), d(gx&#94;y * qy&#94;x)/dx at (i, j', k) !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcx_qx (:), mbc , dm % ibcx_qy (:)) if ( . not . dm % is_thermo ) then call Get_x_1der_P2C_3D ( - qx_ppc * qy_ppc , acpc , dm , dm % iAccuracy , mbc (:, JBC_PROD )) else call Get_x_1der_P2C_3D ( - gx_ppc * qy_ppc , acpc , dm , dm % iAccuracy , mbc (:, JBC_PROD )) end if fl % my_rhs = fl % my_rhs + acpc !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom convection term (y-c2/3), d(gy * qy)/dy at (i, j', k) !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcy_qy (:), mbc , dm % ibcy_qy (:)) if ( . not . dm % is_thermo ) then call Get_y_1der_C2P_3D ( - qy_ccc_ypencil * qy_ccc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbc (:, JBC_PROD ), dm % fbcy_qy * dm % fbcy_qy ) else call Get_y_1der_C2P_3D ( - gy_ccc_ypencil * qy_ccc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbc (:, JBC_PROD ), dm % fbcy_qy * dm % fbcy_qy ) end if my_rhs_ypencil = my_rhs_ypencil + acpc_ypencil ! call transpose_y_to_x(acpc_ypencil, acpc, dm%dcpc) ! write(*,*) 'convy2', acpc(4,1:4,4) !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Y-mom convection term (y-c3/3), d(<gz>&#94;y * <qy>&#94;z)/dz at (i, j', k) !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcz_qz (:), mbc , dm % ibcz_qy (:)) if ( . not . dm % is_thermo ) then call Get_z_1der_P2C_3D ( - qz_cpp_zpencil * qy_cpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , mbc (:, JBC_PROD ) ) else call Get_z_1der_P2C_3D ( - gz_cpp_zpencil * qy_cpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , mbc (:, JBC_PROD ) ) end if my_rhs_zpencil = my_rhs_zpencil + acpc_zpencil ! call transpose_z_to_y(acpc_zpencil, acpc_ypencil) ! call transpose_y_to_x(acpc_ypencil, acpc, dm%dcpc) ! write(*,*) 'convy3', acpc(4,1:4,4) #ifdef DEBUG_STEPS acpc_test = fl % my_rhs call transpose_y_to_x ( my_rhs_ypencil , acpc , dm % dcpc ) acpc_test = acpc_test + acpc call transpose_z_to_y ( my_rhs_zpencil , acpc_ypencil , dm % dcpc ) call transpose_y_to_x ( acpc_ypencil , acpc , dm % dcpc ) acpc_test = acpc_test + acpc call wrt_3d_pt_debug ( acpc_test , dm % dcpc , fl % iteration , isub , 'ConY@bf st' ) ! debug_ww #endif end if if ( ipressure ) then !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom pressure gradient in y direction, d(sigma_1 p) !---------------------------------------------------------------------------------------------------------- call Get_y_1der_C2P_3D ( - pres_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_pr (:), - dm % fbcy_pr (:, :, :) ) my_rhs_pfc_ypencil = my_rhs_pfc_ypencil + acpc_ypencil end if if ( iviscous ) then !---------------------------------------------------------------------------------------------------------- ! X-pencil : Y-mom diffusion term (y-v1-1/7), \\mu * LL1(uy) at (i, j', k) !---------------------------------------------------------------------------------------------------------- !call Get_x_2nd_derivative_C2C_3D(fl%qy, acpc, dm, dm%iAccuracy, dm%ibcx(:, 2) ) appc = ZERO acpc = ZERO call Get_x_1der_C2P_3D ( fl % qy , appc , dm , dm % iAccuracy , dm % ibcx_qy (:), dm % fbcx_qy (:, :, :) ) call reconstruct_symmetry_ibc ( dm % ibcx_qy (:), mbc ) call Get_x_1der_P2C_3D ( appc , acpc , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) if (. not . dm % is_thermo ) then fl % my_rhs = fl % my_rhs + fl % rre * acpc else fl % my_rhs = fl % my_rhs + m_cpc * fl % rre * acpc end if !write(*,*) 'visy-11', fl%rre * acpc(4, 1:4, 4) !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom diffusion term (y-v1-2/7), \\mu * LL2(uy) at (i, j', k) !---------------------------------------------------------------------------------------------------------- !call Get_y_2nd_derivative_P2P_3D(qy_ypencil, acpc_ypencil, dm, dm%iAccuracy, dm%ibcy(:, 2)) call Get_y_1der_P2C_3D ( qy_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:)) !, dm%fbcy_qy) call reconstruct_symmetry_ibc ( dm % ibcy_qy (:), mbc ) fbcy (:,:,:) = ZERO call Get_y_1der_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD ), fbcy ) if ( dm % ibcy_qy ( 1 ) == IBC_DIRICHLET . and . dm % dcpc % yst ( 2 ) == 1 ) acpc_ypencil (:, 1 , :) = ZERO if ( dm % ibcy_qy ( 2 ) == IBC_DIRICHLET . and . dm % dcpc % yen ( 2 ) == dm % dcpc % ysz ( 2 )) acpc_ypencil (:, dm % dcpc % ysz ( 2 ), :) = ZERO ! check, how to deal with wall bc if ( . not . dm % is_thermo ) then my_rhs_ypencil = my_rhs_ypencil + fl % rre * acpc_ypencil else my_rhs_ypencil = my_rhs_ypencil + m_cpc_ypencil * fl % rre * acpc_ypencil end if !write(*,*) 'visy-22', fl%rre * acpc_ypencil(4, 1:4, 4) !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Y-mom diffusion term (y-v1-3/7), \\mu * LL3(uy) at (i, j', k) !---------------------------------------------------------------------------------------------------------- !call Get_z_2nd_derivative_C2C_3D(qy_zpencil, acpc_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 2)) call Get_z_1der_C2P_3D ( qy_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy (:), dm % fbcz_qy (:, :, :)) call reconstruct_symmetry_ibc ( dm % ibcz_qy (:), mbc ) call Get_z_1der_P2C_3D ( acpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) if ( . not . dm % is_thermo ) my_rhs_zpencil = my_rhs_zpencil + fl % rre * acpc_zpencil if ( dm % is_thermo ) my_rhs_zpencil = my_rhs_zpencil + m_cpc_zpencil * fl % rre * acpc_zpencil !write(*,*) 'visy-33', fl%rre * acpc_zpencil(4, 1:4, 4) if ( dm % is_thermo ) then !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom gravity force in y direction !---------------------------------------------------------------------------------------------------------- if ( fl % igravity == i . or . fl % igravity == - i ) then call Get_y_midp_C2P_3D ( dDens_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_Th (:), dm % fbcy_ftp (:, :, :)% d ) my_rhs_pfc_ypencil = my_rhs_pfc_ypencil + fl % fgravity ( i ) * acpc_ypencil end if !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom diffusion term (y-v2/7), \\mu&#94;y * 1/3 * d (div)/dy at (i, j', k) !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcy_qx (:), mbc ) call Get_y_1der_C2P_3D ( div_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) ! to check if it needs bc of div my_rhs_ypencil = my_rhs_ypencil + one_third_rre * m_cpc_ypencil * acpc_ypencil !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom diffusion term (y-v3/7), 2d\\mu/dy * (-1/3 * div(u)) +  2d\\mu/dy * dv/dy !---------------------------------------------------------------------------------------------------------- !fbcy = ZERO ! check call reconstruct_symmetry_ibc ( dm % ibcy_qx (:), mbc ) call Get_y_midp_C2P_3D ( div_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) ! to check if it needs bc of div my_rhs_ypencil = my_rhs_ypencil - two_third_rre * dmdy_cpc_ypencil * acpc_ypencil call Get_y_1der_P2P_3D ( qy_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_qy (:, :, :) ) my_rhs_ypencil = my_rhs_ypencil + two_rre * dmdy_cpc_ypencil * acpc_ypencil !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom diffusion term (y-v4/7), d(mu&#94;y)/dx * d(qx&#94;x)/dy at (i, j', k) !---------------------------------------------------------------------------------------------------------- call Get_y_1der_C2P_3D ( qx_ccc_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx (:), dm % fbcy_qx (:, :, :) ) my_rhs_ypencil = my_rhs_ypencil + fl % rre * dmdx_cpc_ypencil * acpc_ypencil !---------------------------------------------------------------------------------------------------------- ! X-pencil : Y-mom diffusion term (y-v5/7), d(mu&#94;y)/dx * d(qy&#94;x))/dx at (i, j', k) !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2C_3D ( fl % qy , acpc , dm , dm % iAccuracy , dm % ibcx_qy (:), dm % fbcx_qy ) fl % my_rhs = fl % my_rhs + fl % rre * dmdx_cpc * acpc !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Y-mom diffusion term (y-v6/7), d(mu&#94;y)/dz * d(qz&#94;z)/dy at (i, j', k) !---------------------------------------------------------------------------------------------------------- call Get_y_1der_C2P_3D ( qz_ccc_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_qz (:), dm % fbcy_qz (:, :, :) ) my_rhs_ypencil = my_rhs_ypencil + fl % rre * dmdz_cpc_ypencil * acpc_ypencil !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Y-mom diffusion term (y-v7/7), d(mu&#94;y)/dz * d(qy)/dz at (i, j', k) !---------------------------------------------------------------------------------------------------------- call Get_z_1der_C2C_3D ( qy_zpencil , acpc_zpencil , dm , dm % iAccuracy , dm % ibcz_qy (:), dm % fbcz_qy ) my_rhs_zpencil = my_rhs_zpencil + fl % rre * dmdz_cpc_zpencil * acpc_zpencil end if end if !---------------------------------------------------------------------------------------------------------- ! y-mom: convert all terms to x-pencil !---------------------------------------------------------------------------------------------------------- call transpose_y_to_x ( my_rhs_ypencil , acpc , dm % dcpc ) fl % my_rhs = fl % my_rhs + acpc call transpose_z_to_y ( my_rhs_zpencil , acpc_ypencil , dm % dcpc ) call transpose_y_to_x ( acpc_ypencil , acpc , dm % dcpc ) fl % my_rhs = fl % my_rhs + acpc ! bc value call transpose_x_to_y ( fl % my_rhs , acpc_ypencil , dm % dcpc ) if ( dm % ibcy_qy ( 1 ) == IBC_DIRICHLET . and . dm % dcpc % yst ( 2 ) == 1 ) then acpc_ypencil (:, 1 , :) = ZERO my_rhs_pfc_ypencil (:, 1 , :) = ZERO end if if ( dm % ibcy_qy ( 2 ) == IBC_DIRICHLET . and . dm % dcpc % yen ( 2 ) == dm % dcpc % ysz ( 2 )) then acpc_ypencil (:, dm % dcpc % ysz ( 2 ), :) = ZERO my_rhs_pfc_ypencil (:, dm % dcpc % ysz ( 2 ), :) = ZERO end if call transpose_y_to_x ( acpc_ypencil , fl % my_rhs , dm % dcpc ) call transpose_y_to_x ( my_rhs_pfc_ypencil , my_rhs_pfc , dm % dcpc ) !write(*,*) nrank,  'test-6' !========================================================================================================== ! the RHS of Z momentum equation !========================================================================================================== fl % mz_rhs = ZERO mz_rhs_ypencil = ZERO mz_rhs_zpencil = ZERO mz_rhs_pfc = ZERO mz_rhs_pfc_ypencil = ZERO mz_rhs_pfc_zpencil = ZERO accp = ZERO accp_ypencil = ZERO accp_zpencil = ZERO i = 3 if ( iconvection ) then !---------------------------------------------------------------------------------------------------------- ! X-pencil : Z-mom convection term (z-c1/3), d(gx&#94;z * qz&#94;x)/dx at (i, j, k') !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcx_qx (:), mbc , dm % ibcx_qz (:)) if ( . not . dm % is_thermo ) then call Get_x_1der_P2C_3D ( - qx_pcp * qz_pcp , accp , dm , dm % iAccuracy , mbc (:, JBC_PROD )) !, -dm%fbcx_qx * dm%fbcx_qz) else call Get_x_1der_P2C_3D ( - gx_pcp * qz_pcp , accp , dm , dm % iAccuracy , mbc (:, JBC_PROD )) !, -dm%fbcx_gx * dm%fbcx_qz) end if fl % mz_rhs = fl % mz_rhs + accp !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Z-mom convection term (z-c2/3), d(gy&#94;z * qz&#94;y)/dy at (i, j, k') !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcy_qy (:), mbc , dm % ibcy_qz (:)) if ( . not . dm % is_thermo ) then call Get_y_1der_P2C_3D ( - qy_cpp_ypencil * qz_cpp_ypencil , accp_ypencil , dm , dm % iAccuracy , mbc (:, JBC_PROD )) !, -dm%fbcy_qy * dm%fbcy_qz) else call Get_y_1der_P2C_3D ( - gy_cpp_ypencil * qz_cpp_ypencil , accp_ypencil , dm , dm % iAccuracy , mbc (:, JBC_PROD )) !, -dm%fbcy_qy * dm%fbcy_qz) end if mz_rhs_ypencil = mz_rhs_ypencil + accp_ypencil !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Z-mom convection term (y-c3/3), d(gz * qz)/dz at (i, j, k') !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcz_qz (:), mbc , dm % ibcz_qz (:)) if ( . not . dm % is_thermo ) then call Get_z_1der_C2P_3D ( - qz_ccc_zpencil * qz_ccc_zpencil , accp_zpencil , dm , dm % iAccuracy , mbc (:, JBC_PROD ), - dm % fbcz_qz * dm % fbcz_qz ) else call Get_z_1der_C2P_3D ( - gz_ccc_zpencil * qz_ccc_zpencil , accp_zpencil , dm , dm % iAccuracy , mbc (:, JBC_PROD ), - dm % fbcz_gz * dm % fbcz_gz ) end if mz_rhs_zpencil = mz_rhs_zpencil + accp_zpencil #ifdef DEBUG_STEPS accp_test = fl % mz_rhs call transpose_y_to_x ( mz_rhs_ypencil , accp , dm % dccp ) accp_test = accp_test + accp call transpose_z_to_y ( mz_rhs_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , accp , dm % dccp ) accp_test = accp_test + accp call wrt_3d_pt_debug ( accp_test , dm % dccp , fl % iteration , isub , 'ConZ@bf st' ) ! debug_ww #endif end if if ( ipressure ) then !---------------------------------------------------------------------------------------------------------- ! z-pencil : pressure gradient in z direction, d(sigma_1 p) !---------------------------------------------------------------------------------------------------------- call Get_z_1der_C2P_3D ( - pres_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_pr (:), - dm % fbcz_pr (:, :, :) ) mz_rhs_pfc_zpencil = mz_rhs_pfc_zpencil + accp_zpencil end if if ( iviscous ) then !---------------------------------------------------------------------------------------------------------- ! X-pencil : Z-mom diffusion term (z-v1-1/7), \\mu * L11(uz) at (i, j, k') !---------------------------------------------------------------------------------------------------------- !call Get_x_2nd_derivative_C2C_3D(fl%qz, accp, dm, dm%iAccuracy, dm%ibcx(:, 3) ) call Get_x_1der_C2P_3D ( fl % qz , apcp , dm , dm % iAccuracy , dm % ibcx_qz (:), dm % fbcx_qz (:, :, :)) call reconstruct_symmetry_ibc ( dm % ibcx_qz (:), mbc ) call Get_x_1der_P2C_3D ( apcp , accp , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) if ( . not . dm % is_thermo ) then fl % mz_rhs = fl % mz_rhs + fl % rre * accp else fl % mz_rhs = fl % mz_rhs + m_ccp * fl % rre * accp end if !write(*,*) 'visz-11', fl%rre * accp(4, 1:4, 4) !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Z-mom diffusion term (z-v1-2/1), \\mu * L22(uz) at (i, j, k') !---------------------------------------------------------------------------------------------------------- !call Get_y_2nd_derivative_C2C_3D( qz_ypencil, accp_ypencil, dm, dm%iAccuracy, dm%ibcy(:, 3), dm%fbcy_qz(:, :, :)) call Get_y_1der_C2P_3D ( qz_ypencil , acpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz (:), dm % fbcy_qz (:, :, :)) call reconstruct_symmetry_ibc ( dm % ibcy_qz (:), mbc ) fbcy = zero call Get_y_1der_P2C_3D ( acpp_ypencil , accp_ypencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) !, fbcy) if ( . not . dm % is_thermo ) then mz_rhs_ypencil = mz_rhs_ypencil + fl % rre * accp_ypencil else mz_rhs_ypencil = mz_rhs_ypencil + m_ccp_ypencil * fl % rre * accp_ypencil end if !write(*,*) 'visz-22', fl%rre * accp_ypencil(4, 1:4, 4) !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Z-mom diffusion term (z-v1-3/7), \\mu * L33(uz) at (i, j, k') !---------------------------------------------------------------------------------------------------------- !call Get_z_2nd_derivative_P2P_3D(qz_zpencil, accp_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 3)) call Get_z_1der_P2C_3D ( qz_zpencil , accc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:)) call reconstruct_symmetry_ibc ( dm % ibcz_qz (:), mbc ) fbcz (:,:,:) = ZERO call Get_z_1der_C2P_3D ( accc_zpencil , accp_zpencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD ), fbcz ) if ( dm % ibcz_qz ( 1 ) == IBC_DIRICHLET ) accp_zpencil (:, :, 1 ) = ZERO if ( dm % ibcz_qz ( 2 ) == IBC_DIRICHLET ) accp_zpencil (:, :, dm % dpcc % xsz ( 1 )) = ZERO ! check, how to deal with wall bc if ( . not . dm % is_thermo ) then mz_rhs_zpencil = mz_rhs_zpencil + fl % rre * accp_zpencil else mz_rhs_zpencil = mz_rhs_zpencil + m_ccp_zpencil * fl % rre * accp_zpencil end if !write(*,*) 'visz-33', fl%rre * accp_zpencil(4, 1:4, 4) if ( dm % is_thermo ) then !---------------------------------------------------------------------------------------------------------- ! z-pencil : Z-mom gravity force in z direction !---------------------------------------------------------------------------------------------------------- if ( fl % igravity == i . or . fl % igravity == - i ) then call Get_z_midp_C2P_3D ( dDens_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_Th (:), dm % fbcz_ftp (:, :, :)% d ) mz_rhs_pfc_zpencil = mz_rhs_pfc_zpencil + fl % fgravity ( i ) * accp_zpencil end if !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Z-mom diffusion term (z-v2/7), \\mu * 1/3 * d (div)/dz at (i, j, k') !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcz_qz (:), mbc ) call Get_z_1der_C2P_3D ( div_zpencil , accp_zpencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD ), fbcz ) mz_rhs_zpencil = mz_rhs_zpencil + one_third_rre * m_ccp_zpencil * accp_zpencil !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Z-mom diffusion term (z-v3/7), 2d\\mu/dz * (-1/3 * div(u)) +  2d\\mu/dz * dw/dz !---------------------------------------------------------------------------------------------------------- call reconstruct_symmetry_ibc ( dm % ibcz_qz (:), mbc ) call Get_z_midp_C2P_3D ( div_zpencil , accp_zpencil , dm , dm % iAccuracy , mbc (:, JBC_GRAD )) mz_rhs_zpencil = mz_rhs_zpencil - two_third_rre * dmdz_ccp_zpencil * accp_zpencil call Get_z_1der_P2P_3D ( qz_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_qz (:, :, :) ) mz_rhs_zpencil = mz_rhs_zpencil + two_rre * dmdz_ccp_zpencil * accp_zpencil !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Z-mom diffusion term (z-v4/7), d(mu&#94;z)/dx * d(qx&#94;x)/dz at (i, j, k') !---------------------------------------------------------------------------------------------------------- call Get_z_1der_C2P_3D ( qx_ccc_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx (:), dm % fbcz_qx (:, :, :) ) mz_rhs_zpencil = mz_rhs_zpencil + fl % rre * dmdx_ccp_zpencil * accp_zpencil !---------------------------------------------------------------------------------------------------------- ! X-pencil : Z-mom diffusion term (z-v5/7), d(mu&#94;z)/dx * d(qz)/dx at (i, j, k') !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2C_3D ( fl % qz , accp , dm , dm % iAccuracy , dm % ibcx_qz (:), dm % fbcx_qz ) fl % mz_rhs = fl % mz_rhs + fl % rre * dmdx_ccp * accp !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Z-mom diffusion term (z-v6/7), d(mu&#94;z)/dy * d(qy&#94;y)/dz at (i, j, k') !---------------------------------------------------------------------------------------------------------- call Get_z_1der_C2P_3D ( qy_ccc_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy (:), dm % fbcz_qy (:, :, :) ) mz_rhs_zpencil = mz_rhs_zpencil + fl % rre * dmdy_ccp_zpencil * accp_zpencil !---------------------------------------------------------------------------------------------------------- ! Y-pencil : Z-mom diffusion term (z-v7/7), d(mu&#94;z)/dy * d(qz)/dy at (i, j, k') !---------------------------------------------------------------------------------------------------------- call Get_y_1der_C2C_3D ( qz_ypencil , accp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz (:), dm % fbcy_qz ) mz_rhs_ypencil = mz_rhs_ypencil + fl % rre * dmdy_ccp_ypencil * accp_ypencil end if end if !---------------------------------------------------------------------------------------------------------- ! z-mom: convert all terms to x-pencil !---------------------------------------------------------------------------------------------------------- call transpose_y_to_x ( mz_rhs_ypencil , accp , dm % dccp ) fl % mz_rhs = fl % mz_rhs + accp call transpose_z_to_y ( mz_rhs_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , accp , dm % dccp ) fl % mz_rhs = fl % mz_rhs + accp call transpose_z_to_y ( mz_rhs_pfc_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , mz_rhs_pfc , dm % dccp ) !========================================================================================================== ! x-pencil : to build up rhs in total, in all directions !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! x-pencil : x-momentum !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS !call wrt_3d_pt_debug(mx_rhs_pfc, dm%dccc, fl%iteration, isub, 'presure@bf st') ! debug_ww call wrt_3d_pt_debug ( fl % mx_rhs , dm % dpcc , fl % iteration , isub , 'ConVisX@bf st' ) ! debug_ww #endif call Calculate_momentum_fractional_step ( fl % mx_rhs0 , fl % mx_rhs , mx_rhs_pfc , dm % dpcc , dm , isub ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mx_rhs , dm % dpcc , fl % iteration , isub , 'ConVisPX@af st' ) ! debug_ww #endif !   x-pencil : flow drive terms (source terms) in periodic Streamwise flow if ( fl % idriven == IDRVF_X_MASSFLUX ) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , fl % mx_rhs , rhsx_bulk , \"mx_rhs\" ) !if(nrank==0) write(*,*) 'compensition', rhsx_bulk !write(*,*) 'rhsx:', fl%mx_rhs(:, 1, 1), fl%mx_rhs(:, 4, 4) fl % mx_rhs (:, :, :) = fl % mx_rhs (:, :, :) - rhsx_bulk else if ( fl % idriven == IDRVF_X_Cf ) then rhsx_bulk = - HALF * fl % drvfc * dm % tAlpha ( isub ) * dm % dt fl % mx_rhs (:, :, :) = fl % mx_rhs (:, :, :) - rhsx_bulk else end if #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mx_rhs , dm % dpcc , fl % iteration , isub , 'RHSX@total' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! x-pencil : y-momentum !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % my_rhs , dm % dcpc , fl % iteration , isub , 'ConVisY@bf st' ) ! debug_ww #endif call Calculate_momentum_fractional_step ( fl % my_rhs0 , fl % my_rhs , my_rhs_pfc , dm % dcpc , dm , isub ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % my_rhs , dm % dcpc , fl % iteration , isub , 'ConVisPY@af st' ) ! debug_ww call wrt_3d_pt_debug ( fl % my_rhs , dm % dcpc , fl % iteration , isub , 'RHSY@total' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! x-pencil : z-momentum !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mz_rhs , dm % dccp , fl % iteration , isub , 'ConVisZ@bf st' ) ! debug_ww #endif call Calculate_momentum_fractional_step ( fl % mz_rhs0 , fl % mz_rhs , mz_rhs_pfc , dm % dccp , dm , isub ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mz_rhs , dm % dccp , fl % iteration , isub , 'ConVisPZ@af st' ) ! debug_ww #endif !   x-pencil : flow drive terms (source terms) in periodic Streamwise flow if ( fl % idriven == IDRVF_Z_MASSFLUX ) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccp , fl % mz_rhs , rhsz_bulk , \"mz_rhs\" ) fl % mz_rhs (:, :, :) = fl % mz_rhs (:, :, :) - rhsz_bulk else if ( fl % idriven == IDRVF_Z_Cf ) then rhsz_bulk = - HALF * fl % drvfc * dm % tAlpha ( isub ) * dm % dt fl % mz_rhs (:, :, :) = fl % mz_rhs (:, :, :) - rhsz_bulk else end if #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mz_rhs , dm % dccp , fl % iteration , isub , 'RHSZ@total' ) ! debug_ww #endif return end subroutine Compute_momentum_rhs !========================================================================================================== !========================================================================================================== subroutine Correct_massflux ( ux , uy , uz , phi_ccc , dm , isub ) use udf_type_mod use input_general_mod use operations use parameters_constant_mod implicit none type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: isub real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ), intent ( inout ) :: ux real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ), intent ( inout ) :: uy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ), intent ( inout ) :: uz real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ), intent ( in ) :: phi_ccc real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: dphidx_pcc real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: dphidy_cpc real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: dphidz_ccp real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: phi_ccc_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: dphidy_cpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: dphidz_ccp_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: pphi_ccc_zpencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: dphidz_ccp_zpencil #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_mid_msg ( \"Correcting the velocity/mass flux ...\" ) #endif !---------------------------------------------------------------------------------------------------------- !   x-pencil, ux = ux - dt * alpha * d(phi_ccc)/dx !---------------------------------------------------------------------------------------------------------- dphidx_pcc = ZERO call Get_x_1der_C2P_3D ( phi_ccc , dphidx_pcc , dm , dm % iAccuracy , dm % ibcx_pr (:), dm % fbcx_pr (:, :, :) ) ux = ux - dm % dt * dm % tAlpha ( isub ) * dm % sigma2p * dphidx_pcc !---------------------------------------------------------------------------------------------------------- !   y-pencil, uy = uy - dt * alpha * d(phi_ccc)/dy !---------------------------------------------------------------------------------------------------------- phi_ccc_ypencil = ZERO dphidy_cpc_ypencil = ZERO dphidy_cpc = ZERO call transpose_x_to_y ( phi_ccc , phi_ccc_ypencil , dm % dccc ) call Get_y_1der_C2P_3D ( phi_ccc_ypencil , dphidy_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_pr (:), dm % fbcy_pr (:, :, :) ) call transpose_y_to_x ( dphidy_cpc_ypencil , dphidy_cpc , dm % dcpc ) uy = uy - dm % dt * dm % tAlpha ( isub ) * dm % sigma2p * dphidy_cpc !---------------------------------------------------------------------------------------------------------- !   z-pencil, uz = uz - dt * alpha * d(phi_ccc)/dz !---------------------------------------------------------------------------------------------------------- pphi_ccc_zpencil = ZERO dphidz_ccp_zpencil = ZERO dphidz_ccp_ypencil = ZERO dphidz_ccp = ZERO call transpose_y_to_z ( phi_ccc_ypencil , pphi_ccc_zpencil , dm % dccc ) call Get_z_1der_C2P_3D ( pphi_ccc_zpencil , dphidz_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_pr (:), dm % fbcz_pr (:, :, :) ) call transpose_z_to_y ( dphidz_ccp_zpencil , dphidz_ccp_ypencil , dm % dccp ) call transpose_y_to_x ( dphidz_ccp_ypencil , dphidz_ccp , dm % dccp ) uz = uz - dm % dt * dm % tAlpha ( isub ) * dm % sigma2p * dphidz_ccp return end subroutine Correct_massflux !========================================================================================================== subroutine solve_poisson ( fl , dm , isub ) use udf_type_mod use parameters_constant_mod use decomp_2d_poisson use decomp_extended_mod use continuity_eq_mod use typeconvert_mod use mpi_mod use io_visulisation_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl integer , intent ( in ) :: isub real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: div real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: rhs_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: rhs_zpencil real ( WP ), dimension ( dm % dccc % zst ( 1 ) : dm % dccc % zen ( 1 ), & dm % dccc % zst ( 2 ) : dm % dccc % zen ( 2 ), & dm % dccc % zst ( 3 ) : dm % dccc % zen ( 3 ) ) :: rhs_zpencil_ggg !integer :: i, j, k, jj, ii real ( WP ) :: coeff #ifdef DEBUG_STEPS integer , parameter :: nfil = 20 character ( 128 ) :: flnm logical :: file_exists integer :: n , i , j , k , jj , kk character ( 1 ) :: pntim if ( nrank == 0 ) & call Print_debug_mid_msg ( \"Calculating the RHS of Poisson Equation ...\" ) #endif !========================================================================================================== ! RHS of Poisson Eq. !========================================================================================================== fl % pcor = ZERO !---------------------------------------------------------------------------------------------------------- ! $d\\rho / dt$ at cell centre !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then call Calculate_drhodt ( fl , dm , isub ) end if !---------------------------------------------------------------------------------------------------------- ! $d(\\rho u_i)) / dx_i $ at cell centre !---------------------------------------------------------------------------------------------------------- div = ZERO if ( dm % is_thermo ) then call Get_divergence_vel ( fl % gx , fl % gy , fl % gz , div , dm ) else call Get_divergence_vel ( fl % qx , fl % qy , fl % qz , div , dm ) end if coeff = ONE / ( dm % tAlpha ( isub ) * dm % sigma2p * dm % dt ) fl % pcor = fl % pcor + div fl % pcor = fl % pcor * coeff #ifdef DEBUG_STEPS !call wrt_3d_pt_debug (fl%pcor, dm%dccc,   fl%iteration, isub, 'PhiRHS@bf fft') ! debug_ww !call wrt_3d_all_debug(fl%pcor, dm%dccc,   fl%iteration, isub, 'phirhs', 'bf_fft') ! debug_ww !call write_visu_any3darray(fl%pcor, 'rhs'//trim(int2str(isub)), 'debug', dm%dccc, dm, fl%iteration) ! write(pntim,'(i1.1)') nrank ! flnm = 'code1ww_phirhs_myid'//pntim//'.dat' ! open(nfil,file=trim(adjustl(flnm)) ) ! do j = 1, dm%dccc%xsz(2) !   jj = dm%dccc%xst(2) + j - 1 !   do k =1, dm%dccc%xsz(3) !     kk = dm%dccc%xst(3) + k - 1 !     do i = 1, dm%dccc%xsz(1) !       read(nfil, *) n, n, n, fl%pcor(i, j, k) !     end do !   end do ! end do ! close(nfil) ! call wrt_3d_all_debug(fl%pcor, dm%dccc,   fl%iteration, isub, 'phirhsRd', 'bf_fft') ! debug_ww #endif !========================================================================================================== !   convert RHS from xpencil gll to zpencil ggg !========================================================================================================== call transpose_x_to_y ( fl % pcor , rhs_ypencil , dm % dccc ) call transpose_y_to_z ( rhs_ypencil , rhs_zpencil , dm % dccc ) call zpencil_index_llg2ggg ( rhs_zpencil , rhs_zpencil_ggg , dm % dccc ) !========================================================================================================== !   solve Poisson !========================================================================================================== #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_mid_msg ( \"Solving the Poisson Equation ...\" ) !write(*,*) 'fft0-input', rhs_zpencil_ggg(:, 1, 1) #endif call poisson ( rhs_zpencil_ggg ) #ifdef DEBUG_STEPS !write(*,*) 'fft1-otput', rhs_zpencil_ggg(:, 1, 1) #endif !========================================================================================================== !   convert back RHS from zpencil ggg to xpencil gll !========================================================================================================== call zpencil_index_ggg2llg ( rhs_zpencil_ggg , rhs_zpencil , dm % dccc ) call transpose_z_to_y ( rhs_zpencil , rhs_ypencil , dm % dccc ) call transpose_y_to_x ( rhs_ypencil , fl % pcor , dm % dccc ) #ifdef DEBUG_STEPS !call wrt_3d_pt_debug (fl%pcor, dm%dccc,   fl%iteration, isub, 'phi@af fft') ! debug_ww !call wrt_3d_all_debug(fl%pcor, dm%dccc,   fl%iteration, isub, 'phi', 'af_fft') ! debug_ww !call write_visu_any3darray(fl%pcor, 'pcor'//trim(int2str(isub)), 'debug', dm%dccc, dm, fl%iteration) #endif return end subroutine !========================================================================================================== subroutine solve_poisson_x2z ( fl , dm , isub ) use udf_type_mod use parameters_constant_mod use decomp_2d_poisson use decomp_extended_mod use continuity_eq_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl integer , intent ( in ) :: isub real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: rhs real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: rhs_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: rhs_zpencil real ( WP ), dimension ( dm % dccc % zst ( 1 ) : dm % dccc % zen ( 1 ), & dm % dccc % zst ( 2 ) : dm % dccc % zen ( 2 ), & dm % dccc % zst ( 3 ) : dm % dccc % zen ( 3 ) ) :: rhs_zpencil_ggg !integer :: i, j, k, jj, ii !========================================================================================================== ! RHS of Poisson Eq. !========================================================================================================== fl % pcor_zpencil_ggg = ZERO !---------------------------------------------------------------------------------------------------------- ! $d\\rho / dt$ at cell centre !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then rhs = ZERO rhs_ypencil = ZERO rhs_zpencil = ZERO rhs_zpencil_ggg = ZERO call Calculate_drhodt ( fl , dm , isub ) call transpose_x_to_y ( fl % pcor , rhs_ypencil ) call transpose_y_to_z ( rhs_ypencil , rhs_zpencil ) call zpencil_index_llg2ggg ( rhs_zpencil , rhs_zpencil_ggg , dm % dccc ) fl % pcor_zpencil_ggg = fl % pcor_zpencil_ggg + rhs_zpencil_ggg end if !---------------------------------------------------------------------------------------------------------- ! $d(\\rho u_i)) / dx_i $ at cell centre !---------------------------------------------------------------------------------------------------------- rhs_zpencil_ggg = ZERO if ( dm % is_thermo ) then call Get_divergence_vel_x2z ( fl % gx , fl % gy , fl % gz , rhs_zpencil_ggg , dm ) else call Get_divergence_vel_x2z ( fl % qx , fl % qy , fl % qz , rhs_zpencil_ggg , dm ) end if fl % pcor_zpencil_ggg = fl % pcor_zpencil_ggg + rhs_zpencil_ggg fl % pcor_zpencil_ggg = fl % pcor_zpencil_ggg / ( dm % tAlpha ( isub ) * dm % sigma2p * dm % dt ) !========================================================================================================== !   solve Poisson !========================================================================================================== call poisson ( fl % pcor_zpencil_ggg ) !========================================================================================================== !   convert back RHS from zpencil ggg to xpencil gll !========================================================================================================== call zpencil_index_ggg2llg ( fl % pcor_zpencil_ggg , rhs_zpencil , dm % dccc ) call transpose_z_to_y ( rhs_zpencil , rhs_ypencil , dm % dccc ) call transpose_y_to_x ( rhs_ypencil , fl % pcor , dm % dccc ) return end subroutine !========================================================================================================== !> \\brief To update the provisional u or rho u. !> !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                         ! !______________________________________________________________________________! !> \\param[inout]  fl            flow field !> \\param[inout]  dm            domain !> \\param[in]     isub         RK sub-iteration !========================================================================================================== subroutine Solve_momentum_eq ( fl , dm , isub ) use udf_type_mod , only : t_flow , t_domain use typeconvert_mod use continuity_eq_mod use boundary_conditions_mod use parameters_constant_mod use mpi_mod use solver_tools_mod #ifdef DEBUG_STEPS use io_visulisation_mod use typeconvert_mod use wtformat_mod use operations #endif implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( inout ) :: dm integer , intent ( in ) :: isub !---------------------------------------------------------------------------------------------------------- ! to calculate the rhs of the momenturn equation in stepping method !---------------------------------------------------------------------------------------------------------- !call update_flow_bc_1dm_halo(dm, fl) call Compute_momentum_rhs ( fl , dm , isub ) !---------------------------------------------------------------------------------------------------------- ! to update intermediate (\\hat{q}) or (\\hat{g}) !---------------------------------------------------------------------------------------------------------- if ( . not . dm % is_thermo ) then fl % qx = fl % qx + fl % mx_rhs fl % qy = fl % qy + fl % my_rhs fl % qz = fl % qz + fl % mz_rhs else fl % gx = fl % gx + fl % mx_rhs fl % gy = fl % gy + fl % my_rhs fl % gz = fl % gz + fl % mz_rhs end if !call update_flow_bc_1dm_halo(dm, fl) #ifdef DEBUG_STEPS if ( . not . dm % is_thermo ) then call wrt_3d_pt_debug ( fl % qx , dm % dpcc , fl % iteration , isub , 'qx@bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % qy , dm % dcpc , fl % iteration , isub , 'qy@bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % qz , dm % dccp , fl % iteration , isub , 'qz@bf divg' ) ! debug_ww else call wrt_3d_pt_debug ( fl % gx , dm % dpcc , fl % iteration , isub , 'gx@bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % gy , dm % dcpc , fl % iteration , isub , 'gy@bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % gz , dm % dccp , fl % iteration , isub , 'gz@bf divg' ) ! debug_ww end if !call wrt_3d_all_debug(fl%qx, dm%dpcc,   fl%iteration, isub, 'ux', 'bf_divg') ! debug_ww !call wrt_3d_all_debug(fl%qy, dm%dcpc,   fl%iteration, isub, 'uy', 'bf_divg') ! debug_ww !call wrt_3d_all_debug(fl%qz, dm%dccp,   fl%iteration, isub, 'uz', 'bf_divg') ! debug_ww !call write_visu_any3darray(fl%qx, 'qx'//trim(int2str(isub)), 'debug', dm%dpcc, dm, fl%iteration) !call write_visu_any3darray(fl%qy, 'qy'//trim(int2str(isub)), 'debug', dm%dcpc, dm, fl%iteration) !call write_visu_any3darray(fl%qz, 'qz'//trim(int2str(isub)), 'debug', dm%dccp, dm, fl%iteration) #endif !in order for a high order spacial accuracy ! to use Alternating direction implicit method ! ref: Cui2013: Convergence analysis of high-order compact ! alternating direction implicit schemes for the two-dimensional ! time fractional equation !---------------------------------------------------------------------------------------------------------- ! to solve Poisson equation !---------------------------------------------------------------------------------------------------------- !if(nrank == 0) call Print_debug_mid_msg(\"  Solving Poisson Equation ...\") !call solve_poisson_x2z(fl, dm, isub) ! call solve_poisson ( fl , dm , isub ) ! test show above two methods gave the same results. #ifdef DEBUG_STEPS call write_visu_any3darray ( fl % pcor , 'pcor' // trim ( int2str ( isub )), 'debug' , dm % dccc , dm , fl % iteration ) #endif !---------------------------------------------------------------------------------------------------------- ! to update velocity/massflux correction !---------------------------------------------------------------------------------------------------------- !if(nrank == 0) call Print_debug_mid_msg(\"  Updating velocity/mass flux ...\") if ( . not . dm % is_thermo ) then call Correct_massflux ( fl % qx , fl % qy , fl % qz , fl % pcor , dm , isub ) else call Correct_massflux ( fl % gx , fl % gy , fl % gz , fl % pcor , dm , isub ) end if !---------------------------------------------------------------------------------------------------------- ! to update pressure !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_mid_msg ( \"Correcting the pressure term ...\" ) #endif fl % pres (:, :, :) = fl % pres (:, :, :) + fl % pcor (:, :, :) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % pres , dm % dccc , fl % iteration , isub , 'pr@updated' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! to apply bc !---------------------------------------------------------------------------------------------------------- !call update_flow_bc_1dm_halo(dm, fl) !---------------------------------------------------------------------------------------------------------- ! to update velocity from gx gy gz !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then call Calculate_velocity_from_massflux ( fl , dm ) !call update_g_rhou_bc(dm) end if #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % qx , dm % dpcc , fl % iteration , isub , 'ux@updated' ) ! debug_ww call wrt_3d_pt_debug ( fl % qy , dm % dcpc , fl % iteration , isub , 'uy@updated' ) ! debug_ww call wrt_3d_pt_debug ( fl % qz , dm % dccp , fl % iteration , isub , 'uz@updated' ) ! debug_ww #endif #ifdef DEBUG_STEPS ! call Find_maximum_absvar3d(fl%qx, \"at isub = \"//trim(int2str(isub))//\" maximum ux:\", wrtfmt1e) ! call Find_maximum_absvar3d(fl%qy, \"at isub = \"//trim(int2str(isub))//\" maximum uy:\", wrtfmt1e) ! call Find_maximum_absvar3d(fl%qz, \"at isub = \"//trim(int2str(isub))//\" maximum uz:\", wrtfmt1e) ! call Check_mass_conservation(fl, dm, \"isub\"//trim(int2str(isub))) #endif return end subroutine Solve_momentum_eq end module eq_momentum_mod","tags":"","url":"sourcefile/.eq_momentum.f90.html"},{"title":"test_algrithms.f90 – CHAPSim2","text":"Source Code ! ref: https://en.wikipedia.org/wiki/Burgers%27_equation module burgers_eq_mod use precision_mod use parameters_constant_mod integer , parameter :: ICASE_BURGERS1D = 11 integer , parameter :: ICASE_BURGERS1D_VISCOUS = 12 integer , parameter :: ICASE_BURGERS1D_INVISCID = 13 integer , parameter :: ICASE_BURGERS1D_WAVEPROPAGATION = 14 real ( WP ) :: alpha = ONE real ( WP ) :: beta = ZERO real ( WP ) :: nu ! udf variables integer :: icase = 11 ! which case integer :: idir = 1 ! which direction to test! private :: Compute_burgers_rhs private :: Validate_burgers_error public :: initialise_burgers_flow public :: Solve_burgers_eq_iteration public :: Plot_burgers_profile contains subroutine initialise_burgers_flow ( dm , ux , uy , uz , p ) use udf_type_mod , only : t_domain , t_flow use math_mod , only : sin_wp use parameters_constant_mod !, only : HALF, ZERO, SIXTEEN, TWO use input_general_mod implicit none type ( t_domain ), intent ( inout ) :: dm real ( WP ), intent ( inout ) :: ux (:, :, :), & uy (:, :, :), & uz (:, :, :), & p (:, :, :) real ( WP ) :: xc , yc , zc real ( WP ) :: xp , yp , zp integer ( 4 ) :: i , j , k real ( WP ) :: A , x0 , omega0 ux = ZERO uy = ZERO uz = ZERO p = ZERO dm % icase = icase !============================================================================== ! example 2 : input alpha * x + beta for inviscid Burgers' equation !========================================================================================================== if ( icase == ICASE_BURGERS1D ) then else if ( icase == ICASE_BURGERS1D_VISCOUS ) then !---------------------------------------------------------------------------------------------------------- !   diffusion equation:  du/dt = nu * d(u&#94;2)/dx = 0 !   For an initial condition of the form: u(x, t=0) = U e&#94;{i k x}, i = image unit, k = wavenumber !   The time developing solution is: u(x, t) = U * e&#94;{-nu k&#94;2 t} sin(k*t) !   For an example: !       e&#94;{ikx} = cos(kx) + i sin(kx) !       initial u(x, 0) = sin(pi * x), for 0< x < 2 !       result is : !---------------------------------------------------------------------------------------------------------- dm % ibcx_qx = IBC_PERIODIC dm % ibcy_qx = IBC_PERIODIC dm % ibcz_qx = IBC_PERIODIC nu = ONE do i = 1 , dm % np ( idir ) xp = dm % h ( idir ) * real ( i - 1 , WP ) if ( idir == 1 ) ux ( i , :, :) = - sin_wp ( PI * xp ) if ( idir == 2 ) uy (:, i , :) = - sin_wp ( PI * xp ) if ( idir == 3 ) uz (:, :, i ) = - sin_wp ( PI * xp ) end do else if ( icase == ICASE_BURGERS1D_INVISCID ) then !   inviscid Burgers equation:  du/dt + 1/2 * d(u&#94;2)/dx = 0 !alpha = ONE !beta  = ZERO do i = 1 , dm % np ( idir ) xp = dm % h ( idir ) * real ( i - 1 , WP ) if ( idir == 1 ) ux ( i , :, :) = alpha * xp + beta if ( idir == 2 ) uy (:, i , :) = alpha * xp + beta if ( idir == 3 ) uz (:, :, i ) = alpha * xp + beta end do if ( idir == 1 ) then dm % ibcx_qx = IBC_DIRICHLET dm % fbcx_qx ( 1 , :, :) = beta / ( ONE ) dm % fbcx_qx ( 2 , :, :) = ( alpha * dm % lxx + beta ) / ( ONE ) else if ( idir == 2 ) then dm % ibcy_qy = IBC_DIRICHLET dm % fbcy_qy (:, 1 , :) = beta / ( ONE ) dm % fbcy_qy (:, 2 , :) = ( alpha * dm % lyt + beta ) / ( ONE ) else if ( idir == 3 ) then dm % ibcz_qy = IBC_DIRICHLET dm % fbcz_qz (:, :, 1 ) = beta / ( ONE ) dm % fbcz_qz (:, :, 2 ) = ( alpha * dm % lzz + beta ) / ( ONE ) else end if else if ( icase == ICASE_BURGERS1D_WAVEPROPAGATION ) then ! ref: Fang2019 nu = HALF A = 5 0.d0 x0 = 1.5d0 omega0 = 0.838242d0 * dm % h1r ( idir ) do i = 1 , dm % np ( idir ) xp = dm % h ( idir ) * real ( i - 1 , WP ) if ( idir == 1 ) ux ( i , :, :) = exp ( - A * ( xp - x0 ) * ( xp - x0 )) * sin_wp ( omega0 * xp ) if ( idir == 2 ) uy (:, i , :) = exp ( - A * ( xp - x0 ) * ( xp - x0 )) * sin_wp ( omega0 * xp ) if ( idir == 3 ) uz (:, :, i ) = exp ( - A * ( xp - x0 ) * ( xp - x0 )) * sin_wp ( omega0 * xp ) !write(*,*) 'test', i, ux(i, dm%nc(2)/2, dm%nc(2)/2) end do else end if return end subroutine initialise_burgers_flow subroutine Compute_burgers_rhs ( fl , dm , isub ) use udf_type_mod use parameters_constant_mod use operations use input_general_mod use boundary_conditions_mod use decomp_2d implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( in ) :: dm integer ( 4 ), intent ( in ) :: isub integer :: i ! natural position as in staggered storage real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: qx_ccc real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qy_ccc_ypencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: mx_rhs ! rhs for momentum-x at (xp, yc, zc) real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: rhsx_dummy real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: my_rhs ! rhs for momentum-x at (xp, yc, zc) real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: rhsy_dummy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: mz_rhs ! rhs for momentum-x at (xp, yc, zc) real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: rhsz_dummy real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qy_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: my_rhs_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: qz_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qz_zpencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: mz_rhs_zpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: mz_rhs_ypencil integer :: mbc ( 2 , 3 ) if ( idir == 1 ) then ! xpencil fl % mx_rhs = ZERO !---------------------------------------------------------------------------------------------------------- ! for x-mom convection term : d(qx * qx)/dx at (i', j, k) if ( icase == ICASE_BURGERS1D_INVISCID ) then call Get_x_midp_P2C_3D ( fl % qx , qx_ccc , dm , dm % iAccuracy , dm % ibcx_qx (:)) call build_bc_symm_operation ( dm % ibcx_qx (:), mbc , dm % ibcx_qx (:)) call Get_x_1der_C2P_3D ( - qx_ccc * qx_ccc * HALF , mx_rhs , dm , dm % iAccuracy , mbc (:, 1 ), dm % fbcx_qx (:, :, :) * dm % fbcx_qx (:, :, :) * HALF ) fl % mx_rhs = fl % mx_rhs + mx_rhs end if !---------------------------------------------------------------------------------------------------------- if ( icase == ICASE_BURGERS1D_WAVEPROPAGATION ) then call Get_x_midp_P2C_3D ( fl % qx , qx_ccc , dm , dm % iAccuracy , dm % ibcx_qx (:)) call build_bc_symm_operation ( dm % ibcx_qx (:), mbc ) call Get_x_1der_C2P_3D ( - qx_ccc * nu , mx_rhs , dm , dm % iAccuracy , mbc (:, 2 ), dm % fbcx_qx (:, :, :) * nu ) fl % mx_rhs = fl % mx_rhs + mx_rhs end if !---------------------------------------------------------------------------------------------------------- ! for x-mom diffusion term , \\mu * Ljj(ux) at (i', j, k) if ( icase == ICASE_BURGERS1D_VISCOUS ) then !call Get_x_2der_P2P_3D( fl%qx, mx_rhs, dm, dm%iAccuracy, dm%ibcx(:, 1) ) call Get_x_1der_P2C_3D ( fl % qx , qx_ccc , dm , dm % iAccuracy , dm % ibcx_qx (:)) call build_bc_symm_operation ( dm % ibcx_qx (:), mbc ) call Get_x_1der_C2P_3D ( qx_ccc , mx_rhs , dm , dm % iAccuracy , mbc (:, 2 )) fl % mx_rhs = fl % mx_rhs + fl % rre * mx_rhs end if !---------------------------------------------------------------------------------------------------------- if ( icase == ICASE_BURGERS1D_WAVEPROPAGATION ) then call Get_x_midp_P2C_3D ( fl % qx , qx_ccc , dm , dm % iAccuracy , dm % ibcx_qx (:)) call build_bc_symm_operation ( dm % ibcx_qx (:), mbc ) call Get_x_1der_C2P_3D ( - qx_ccc * nu , mx_rhs , dm , dm % iAccuracy , mbc (:, 2 ), dm % fbcx_qx (:, :, :) * nu ) fl % mx_rhs = fl % mx_rhs + mx_rhs end if !---------------------------------------------------------------------------------------------------------- rhsx_dummy (:, :, :) = fl % mx_rhs (:, :, :) fl % mx_rhs (:, :, :) = dm % tGamma ( isub ) * fl % mx_rhs (:, :, :) + & dm % tZeta ( isub ) * fl % mx_rhs0 (:, :, :) fl % mx_rhs0 (:, :, :) = rhsx_dummy (:, :, :) ! do i = 1, dm%np(idir) !   write(*,*) i, fl%qx(i, dm%nc(2)/2, dm%nc(2)/2), dm%dt * fl%mx_rhs(i, dm%nc(2)/2, dm%nc(2)/2), fl%mx_rhs(i, dm%nc(2)/2, dm%nc(2)/2) ! end do fl % qx (:, :, :) = fl % qx (:, :, :) + dm % dt * fl % mx_rhs (:, :, :) else if ( idir == 2 ) then ! y pencil fl % my_rhs = ZERO my_rhs = ZERO my_rhs_ypencil = ZERO call transpose_x_to_y ( fl % qy , qy_ypencil , dm % dcpc ) !---------------------------------------------------------------------------------------------------------- ! for y-mom convection term : d(qy * qy)/dy at (i, j', k) if ( icase == ICASE_BURGERS1D_INVISCID ) then call Get_y_midp_P2C_3D ( qy_ypencil , qy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:)) call build_bc_symm_operation ( dm % ibcy_qy (:), mbc , dm % ibcy_qy (:)) call Get_y_1der_C2P_3D ( - qy_ccc_ypencil * qy_ccc_ypencil * HALF , my_rhs_ypencil , dm , dm % iAccuracy , mbc (:, 1 ), dm % fbcy_qy (:, :, :) * dm % fbcy_qy (:, :, :) * HALF ) call transpose_y_to_x ( my_rhs_ypencil , my_rhs ) fl % my_rhs = fl % my_rhs + my_rhs end if !---------------------------------------------------------------------------------------------------------- ! for x-mom diffusion term , \\mu * Ljj(ux) at (i', j, k) if ( icase == ICASE_BURGERS1D_VISCOUS ) then !call Get_y_2der_P2P_3D(qy_ypencil, my_rhs_ypencil, dm, dm%iAccuracy, dm%ibcy_qy(:), dm%fbcy_qy(:, :, :) ) call transpose_y_to_x ( my_rhs_ypencil , my_rhs ) fl % my_rhs = fl % my_rhs + fl % rre * my_rhs end if !---------------------------------------------------------------------------------------------------------- if ( icase == ICASE_BURGERS1D_WAVEPROPAGATION ) then call Get_y_midp_P2C_3D ( qy_ypencil , qy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:)) call build_bc_symm_operation ( dm % ibcy_qy (:), mbc ) call Get_y_1der_C2P_3D ( - qy_ccc_ypencil * nu , my_rhs_ypencil , dm , dm % iAccuracy , mbc (:, 2 ), dm % fbcy_qy (:, :, :) * nu ) call transpose_y_to_x ( my_rhs_ypencil , my_rhs ) fl % my_rhs = fl % my_rhs + my_rhs end if !---------------------------------------------------------------------------------------------------------- rhsy_dummy (:, :, :) = fl % my_rhs (:, :, :) fl % my_rhs (:, :, :) = dm % tGamma ( isub ) * fl % my_rhs (:, :, :) + & dm % tZeta ( isub ) * fl % my_rhs0 (:, :, :) fl % my_rhs0 (:, :, :) = rhsy_dummy (:, :, :) fl % qy (:, :, :) = fl % qy (:, :, :) + dm % dt * fl % my_rhs (:, :, :) else if ( idir == 3 ) then ! z pencil ! call transpose_x_to_y (fl%qz,       qz_ypencil, dm%dccp) ! call transpose_y_to_z (qz_ypencil,  qz_zpencil, dm%dccp) ! fl%mz_rhs = ZERO ! mz_rhs =  ZERO ! mz_rhs_zpencil = ZERO ! ! for x-mom convection term : d(qx * qx)/dx at (i', j, k) ! if(icase == ICASE_BURGERS .or. icase == ICASE_BURGERS1D_INVISCID) then !   do i = 1, 2 !     fbc(i) = dm%ibcz(i, 3) * dm%ibcz(i, 3) !   end do !   call Get_z_1der_P2P_3D(-qz_zpencil * qz_zpencil * HALF, mz_rhs_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 3), fbc(:)) !   call transpose_z_to_y (mz_rhs_zpencil,  mz_rhs_ypencil, dm%dccp) !   call transpose_y_to_x (mz_rhs_ypencil,  mz_rhs,         dm%dccp) !   fl%mz_rhs = fl%mz_rhs + mz_rhs ! end if ! ! for x-mom diffusion term , \\mu * Ljj(ux) at (i', j, k) ! if(icase == ICASE_BURGERS .or. icase == ICASE_BURGERS1D_VISCOUS) then !   call Get_z_2der_P2P_3D( qz_zpencil, mz_rhs_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 3)) !   call transpose_z_to_y (mz_rhs_zpencil,  mz_rhs_ypencil, dm%dccp) !   call transpose_y_to_x (mz_rhs_ypencil,  mz_rhs,         dm%dccp) !   fl%mz_rhs = fl%mz_rhs + fl%rre * mz_rhs ! end if ! rhsz_dummy(:, :, :) = fl%mz_rhs(:, :, :) ! fl%mz_rhs(:, :, :) = dm%tGamma(isub) * fl%mz_rhs(:, :, :) + & !                      dm%tZeta (isub) * fl%mz_rhs0(:, :, :) ! fl%mz_rhs0(:, :, :) = rhsz_dummy(:, :, :) ! fl%qz(:, :, :) = fl%qz(:, :, :) + dm%dt * fl%mz_rhs(:, :, :) else end if if ( icase == ICASE_BURGERS1D_INVISCID ) then if ( idir == 1 ) then if ( dm % dpcc % xst ( 1 ) == 1 ) fl % qx ( 1 , :, :) = beta / ( alpha * fl % time + ONE ) if ( dm % dpcc % xen ( 1 ) == dm % np ( 1 ) ) fl % qx ( dm % np ( 1 ), :, :) = ( alpha * dm % lxx + beta ) / ( alpha * fl % time + ONE ) else if ( idir == 2 ) then if ( dm % dcpc % xst ( 2 ) == 1 ) fl % qy (:, 1 , :) = beta / ( alpha * fl % time + ONE ) if ( dm % dcpc % xen ( 2 ) == dm % np ( 2 ) ) fl % qy (:, dm % np ( 2 ), :) = ( alpha * dm % lyt + beta ) / ( alpha * fl % time + ONE ) else if ( idir == 3 ) then if ( dm % dccp % xst ( 3 ) == 1 ) fl % qz (:, :, 1 ) = beta / ( alpha * fl % time + ONE ) if ( dm % dccp % xen ( 3 ) == dm % np ( 3 ) ) fl % qz (:, :, dm % np ( 3 )) = ( alpha * dm % lzz + beta ) / ( alpha * fl % time + ONE ) else end if end if return end subroutine Compute_burgers_rhs !========================================================================================================== subroutine Validate_burgers_error ( fl , dm ) use udf_type_mod , only : t_flow , t_domain use parameters_constant_mod use operations use math_mod use input_general_mod use mpi_mod use io_files_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( in ) :: dm integer :: i , j , k real ( WP ) :: xp , ux , uerr , uerr2 , uerrmax , wavenum real ( WP ) :: uerr2_work , uerrmax_work real ( WP ) :: dd integer :: nx , ny , nz integer :: wrt_unit character ( len = 128 ) :: filename1 integer :: nsz uerr2 = ZERO uerrmax = ZERO dd = dm % h ( idir ) if ( idir == 1 ) then wavenum = TWOPI / dm % lxx nx = dm % dpcc % xsz ( 1 ) ny = dm % dpcc % xsz ( 2 ) nz = dm % dpcc % xsz ( 3 ) else if ( idir == 2 ) then wavenum = TWOPI / dm % lyt nx = dm % dcpc % xsz ( 1 ) ny = dm % dcpc % xsz ( 2 ) nz = dm % dcpc % xsz ( 3 ) else if ( idir == 3 ) then wavenum = TWOPI / dm % lzz nx = dm % dccp % xsz ( 1 ) ny = dm % dccp % xsz ( 2 ) nz = dm % dccp % xsz ( 3 ) else wavenum = ZERO nx = 0 ny = 0 nz = 0 end if nsz = nx * ny * nz uerr = ZERO xp = ZERO do k = 1 , nz do j = 1 , ny do i = 1 , nx if ( idir == 1 ) xp = dd * real ( i - 1 , WP ) if ( idir == 2 ) xp = dd * real ( j - 1 , WP ) if ( idir == 3 ) xp = dd * real ( k - 1 , WP ) if ( icase == ICASE_BURGERS1D_VISCOUS ) then ux = - TWO / PI * exp ( - TWO * fl % rre * fl % time * wavenum * wavenum ) ! check else if ( icase == ICASE_BURGERS1D_INVISCID ) then ux = ( alpha * xp + beta ) / ( alpha * fl % time + ONE ) ! check else ux = ZERO end if if ( idir == 1 ) uerr = fl % qx ( i , j , k ) - ux if ( idir == 2 ) uerr = fl % qy ( i , j , k ) - ux if ( idir == 3 ) uerr = fl % qz ( i , j , k ) - ux uerr2 = uerr2 + uerr ** 2 if ( abs_wp ( uerr ) > uerrmax ) uerrmax = abs_wp ( uerr ) !if(k==d%nc(3)/2 .and. j == d%nc(2)/2) write(*,*) k, j, i, ux, fl%qx(i, j, k), uerr end do end do end do call mpi_barrier ( MPI_COMM_WORLD , ierror ) call mpi_allreduce ( uerr2 , uerr2_work , 1 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) call mpi_allreduce ( uerrmax , uerrmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) uerr2_work = sqrt_wp ( uerr2_work / real ( nsz , WP ) ) uerr2_work = sqrt_wp ( uerr2_work ) if ( nrank == 0 ) then filename1 = 'Validation_Burgers_error.dat' if (. not . file_exists ( trim ( filename1 ))) then open ( newunit = wrt_unit , file = trim ( filename1 ), action = \"write\" , status = \"new\" ) write ( wrt_unit , '(A)' ) 'Time, U(t), SD(uerr), Max(uerr)' else open ( newunit = wrt_unit , file = trim ( filename1 ), action = \"write\" , status = \"old\" , position = \"append\" ) end if ! data convert to cell centre data... write ( wrt_unit , '(1F10.4, 2ES17.7E3)' ) fl % time , uerr2_work , uerrmax_work close ( wrt_unit ) end if end subroutine !========================================================================================================== subroutine Plot_burgers_profile ( fl , dm , iter ) use udf_type_mod , only : t_flow , t_domain use parameters_constant_mod use input_general_mod use operations use math_mod use typeconvert_mod use mpi_mod use io_files_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iter integer :: i real ( WP ) :: dd real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qy_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: qz_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qz_zpencil integer :: wrt_unit character ( len = 128 ) :: filename if ( nrank == 0 ) then filename = 'Plot_Burgers_profile' // trim ( int2str ( iter )) // '.dat' if (. not . file_exists ( trim ( filename ))) then open ( newunit = wrt_unit , file = trim ( filename ), action = \"write\" , status = \"new\" ) write ( wrt_unit , '(A)' ) 'x qx' else open ( newunit = wrt_unit , file = trim ( filename ), action = \"write\" , status = \"old\" , position = \"append\" ) end if ! data convert to cell centre data... end if dd = dm % h ( idir ) if ( idir == 1 ) then do i = 1 , dm % np ( idir ) if ( nrank == 0 ) write ( wrt_unit , '(1F10.4, 2ES17.7E3)' ) dd * real ( i - 1 , WP ), fl % qx ( i , dm % nc ( 2 ) / 2 , dm % nc ( 3 ) / 2 ) end do else if ( idir == 2 ) then call transpose_x_to_y ( fl % qy , qy_ypencil , dm % dcpc ) do i = 1 , dm % np ( idir ) if ( nrank == 0 ) write ( wrt_unit , '(1F10.4, 2ES17.7E3)' ) dd * real ( i , WP ), qy_ypencil ( dm % nc ( 1 ) / 2 , i , dm % nc ( 3 ) / 2 ) end do else if ( idir == 3 ) then call transpose_x_to_y ( fl % qz , qz_ypencil , dm % dccp ) call transpose_y_to_z ( qz_ypencil , qz_zpencil , dm % dccp ) do i = 1 , dm % np ( idir ) if ( nrank == 0 ) write ( wrt_unit , '(1F10.4, 2ES17.7E3)' ) dd * real ( i , WP ), qz_zpencil ( dm % nc ( 1 ) / 2 , dm % nc ( 2 ) / 2 , i ) end do else end if if ( nrank == 0 ) close ( wrt_unit ) end subroutine !========================================================================================================== subroutine Solve_burgers_eq_iteration use parameters_constant_mod use mpi_mod use vars_df_mod use solver_tools_mod use thermo_info_mod use code_performance_mod use input_general_mod implicit none logical :: is_flow = . false . logical :: is_thermo = . false . integer :: i integer :: iter , isub integer :: iterfrom integer :: niter call Plot_burgers_profile ( flow ( 1 ), domain ( 1 ), 0 ) iterfrom = HUGE ( 0 ) niter = 0 do i = 1 , nxdomain if ( flow ( i )% iterfrom < iterfrom ) iterfrom = flow ( i )% iterfrom if ( flow ( i )% nIterFlowEnd > niter ) niter = flow ( i )% nIterFlowEnd if ( domain ( i )% is_thermo ) then if ( thermo ( i )% nIterThermoEnd > niter ) niter = thermo ( i )% nIterThermoEnd end if end do do iter = iterfrom + 1 , niter call call_cpu_time ( CPU_TIME_ITER_START , iterfrom , niter , iter ) do i = 1 , nxdomain !========================================================================================================== !      setting up 1/re, 1/re/prt, gravity, etc !========================================================================================================== call Update_Re ( iter , flow ( i )) if ( domain ( i )% is_thermo ) & call Update_PrGr ( flow ( i ), thermo ( i )) !========================================================================================================== !      setting up flow solver !========================================================================================================== if ( ( iter >= flow ( i )% nIterFlowStart ) . and . ( iter <= flow ( i )% nIterFlowEnd )) then is_flow = . true . flow ( i )% time = flow ( i )% time + domain ( i )% dt !call Check_cfl_diffusion ( flow(i), domain(i)) !call Check_cfl_convection(flow(i)%qx, flow(i)%qy, flow(i)%qz, domain(i)) end if !========================================================================================================== !     setting up thermo solver !========================================================================================================== if ( domain ( i )% is_thermo ) then if ( ( iter >= thermo ( i )% nIterThermoStart ) . and . ( iter <= thermo ( i )% nIterThermoEnd )) then is_thermo = . true . thermo ( i )% time = thermo ( i )% time + domain ( i )% dt end if end if !========================================================================================================== !     main solver !========================================================================================================== do isub = 1 , domain ( i )% nsubitr !if(is_thermo) call Solve_energy_eq  (flow(i), thermo(i), domain(i), isub) !if(is_flow)   call Solve_momentum_eq(flow(i), domain(i), isub) call Compute_burgers_rhs ( flow ( i ), domain ( i ), isub ) end do call Plot_burgers_profile ( flow ( i ), domain ( i ), iter ) call Validate_burgers_error ( flow ( i ), domain ( i )) !if( MOD(iter, domain(i)%visu_nfre) == 0 ) & end do end do call call_cpu_time ( CPU_TIME_CODE_END , iterfrom , niter ) call Finalise_mpi () stop 'End of the program' return end subroutine Solve_burgers_eq_iteration end module !========================================================================================================== !========================================================================================================== !> \\brief In-code independent test code for algorithms and schemes !> !> This subroutine is only called in the main program for testing. !> Please select the test options which you are interested in. !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     none          NA !> \\param[out]    none          NA !_______________________________________________________________________________ subroutine Test_algorithms () use vars_df_mod use burgers_eq_mod use tridiagonal_matrix_algorithm use mpi_mod use operations use boundary_conditions_mod use geometry_mod implicit none logical :: is_TDMA = . false . logical :: is_operations = . true . logical :: is_burgers = . false . integer :: n !if( (.not. is_TDMA) .and. (.not. is_operations) .and. (.not. is_burgers)) return if ( is_operations ) then call Test_interpolation ( domain ( 1 )) call Test_1st_derivative ( domain ( 1 )) !call Test_2nd_derivative(domain(1)) end if if ( is_TDMA ) then call Test_TDMA_cyclic call Test_TDMA_noncyclic end if if ( is_burgers ) then call Solve_burgers_eq_iteration end if call Finalise_mpi return end subroutine subroutine test_poisson ( dm ) use udf_type_mod use poisson_interface_mod use math_mod use operations use boundary_conditions_mod ! based on TGV3D mesh type ( t_domain ), intent ( inout ) :: dm real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: rhs , rhs0 , phi , phi0 real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: rhs_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: rhs_zpencil real ( WP ), dimension ( dm % dccc % zst ( 1 ) : dm % dccc % zen ( 1 ), & dm % dccc % zst ( 2 ) : dm % dccc % zen ( 2 ), & dm % dccc % zst ( 3 ) : dm % dccc % zen ( 3 ) ) :: rhs_zpencil_ggg real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: rhs_pcc integer :: i , j , k , ii , jj , kk real ( WP ) :: xc , yc , zc integer :: mbc ( 2 , 3 ) do i = 1 , dm % dccc % xsz ( 1 ) ii = dm % dccc % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) do j = 1 , dm % dccc % xsz ( 2 ) jj = dm % dccc % xst ( 2 ) + j - 1 !local2global_yid(j, dm%dccc) yc = dm % yc ( jj ) do k = 1 , dm % dccc % xsz ( 3 ) kk = dm % dccc % xst ( 3 ) + k - 1 zc = dm % h ( 3 ) * ( real ( kk - 1 , WP ) + HALF ) ! test x or y or z direction !rhs(i, j, k)  = -cos_wp(xc)! * cos_wp(xc) !phi0(i, j, k) = cos_wp(xc) !rhs0(i, j, k) = -cos_wp(xc) ! test 2 rhs ( i , j , k ) = TWO phi0 ( i , j , k ) = xc * xc - TWOPI * xc rhs0 ( i , j , k ) = rhs ( i , j , k ) end do end do end do call solve_fft_poisson ( rhs , dm ) phi = rhs !========================================================================================================== !   compact scheme from phi to rhs !========================================================================================================== dm % fbcx_pr ( 1 , :, :) = - TWOPI dm % fbcx_pr ( 2 , :, :) = TWOPI dm % fbcx_pr ( 3 , :, :) = dm % fbcx_pr ( 1 , :, :) dm % fbcx_pr ( 4 , :, :) = dm % fbcx_pr ( 2 , :, :) call Get_x_1der_C2P_3D ( phi , rhs_pcc , dm , dm % iAccuracy , dm % ibcx_pr (:), dm % fbcx_pr ) call build_bc_symm_operation ( dm % ibcx_pr (:), mbc ) call Get_x_1der_P2C_3D ( rhs_pcc , rhs , dm , dm % iAccuracy , mbc (:, 2 )) if ( nrank == 0 ) then do i = 1 , dm % dccc % xsz ( 1 ) ii = dm % dccc % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) write ( * , * ) 'output_dphidx' , i , rhs_pcc ( i , 8 , 8 ), TWO * xc - TWOPI end do do i = 1 , dm % dccc % xsz ( 1 ) ii = dm % dccc % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) write ( * , * ) 'output_rhs_phi_diff' , i , rhs0 ( i , 8 , 8 ), phi0 ( i , 8 , 8 ), rhs ( i , 8 , 8 ), phi ( i , 8 , 8 ) end do end if return end subroutine","tags":"","url":"sourcefile/test_algrithms.f90.html"},{"title":"modules.f90 – CHAPSim2","text":"Source Code !############################################################################## module mpi_mod !include \"mpif.h\" use MPI use decomp_2d use decomp_2d_mpi !use iso_fortran_env implicit none integer :: ierror integer :: nxdomain integer :: p_row ! y-dim integer :: p_col ! z-dim public :: initialise_mpi public :: Finalise_mpi contains !========================================================================================================== !> \\brief mpi initialisation. !> !> this initialisation is a simple one. !  only used before calling decomp_2d_init, !  where there is a complicted one used for 2-d decompoistion. !  nrank = myid !  nproc = size of processor !  both wil be replaced after calling decomp_2d_init !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d          domain type !========================================================================================================== subroutine initialise_mpi () implicit none call MPI_INIT ( IERROR ) call MPI_COMM_RANK ( MPI_COMM_WORLD , nrank , IERROR ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , nproc , IERROR ) return end subroutine initialise_mpi !========================================================================================================== !========================================================================================================== subroutine Finalise_mpi () implicit none call MPI_FINALIZE ( IERROR ) return end subroutine Finalise_mpi end module mpi_mod !========================================================================================================== module precision_mod use mpi_mod implicit none public integer , parameter :: I4 = selected_int_kind ( 4 ) integer , parameter :: I8 = selected_int_kind ( 8 ) integer , parameter :: I15 = selected_int_kind ( 15 ) integer , parameter :: S6P = selected_real_kind ( p = 6 , r = 37 ) integer , parameter :: D15P = selected_real_kind ( p = 15 , r = 307 ) integer , parameter :: Q33P = selected_real_kind ( p = 33 , r = 4931 ) !#ifdef DOUBLE_PREC integer , parameter :: WP = D15P integer , parameter :: MPI_REAL_WP = MPI_DOUBLE_PRECISION integer , parameter :: MPI_CPLX_WP = MPI_DOUBLE_COMPLEX ! #else !   integer, parameter :: WP = S6P !D15P !   integer, parameter :: MPI_REAL_WP = MPI_REAL !   integer, parameter :: MPI_CPLX_WP = MPI_COMPLEX ! #endif end module precision_mod !========================================================================================================== module parameters_constant_mod use precision_mod implicit none !---------------------------------------------------------------------------------------------------------- ! constants !---------------------------------------------------------------------------------------------------------- real ( WP ), parameter :: ZPONE = 0.1_WP real ( WP ), parameter :: EIGHTH = 0.125_WP real ( WP ), parameter :: ZPTWO = 0.2_WP real ( WP ), parameter :: QUARTER = 0.25_WP real ( WP ), parameter :: ZPTHREE = 0.3_WP real ( WP ), parameter :: ZPFOUR = 0.4_WP real ( WP ), parameter :: HALF = 0.5_WP real ( WP ), parameter :: ZPSIX = 0.6_WP real ( WP ), parameter :: ZPSEVEN = 0.7_WP real ( WP ), parameter :: ZPEIGHT = 0.8_WP real ( WP ), parameter :: ZPNINE = 0.9_WP real ( WP ), parameter :: ZERO = 0.0_WP real ( WP ), parameter :: ONE = 1.0_WP real ( WP ), parameter :: ONEPFIVE = 1.5_WP real ( WP ), parameter :: TWO = 2.0_WP real ( WP ), parameter :: TWOPFIVE = 2.5_WP real ( WP ), parameter :: THREE = 3.0_WP real ( WP ), parameter :: threepfive = 3.5_WP real ( WP ), parameter :: FOUR = 4.0_WP real ( WP ), parameter :: FIVE = 5.0_WP real ( WP ), parameter :: SIX = 6.0_WP real ( WP ), parameter :: SEVEN = 7.0_WP real ( WP ), parameter :: EIGHT = 8.0_WP real ( WP ), parameter :: NINE = 9.0_WP real ( WP ), parameter :: ONE_THIRD = 0.33333333333333333333_WP real ( WP ), parameter :: TWO_THIRD = 0.66666666666666666667_WP real ( WP ), parameter :: TEN = 1 0.0_WP real ( WP ), parameter :: ELEVEN = 1 1.0_WP real ( WP ), parameter :: TWELVE = 1 2.0_WP real ( WP ), parameter :: THIRTEEN = 1 3.0_WP real ( WP ), parameter :: FOURTEEN = 1 4.0_WP real ( WP ), parameter :: FIFTEEN = 1 5.0_WP real ( WP ), parameter :: SIXTEEN = 1 6.0_WP real ( WP ), parameter :: SEVENTEEN = 1 7.0_WP real ( WP ), parameter :: TWENTY = 2 0.0_WP real ( WP ), parameter :: TWENTYTWO = 2 2.0_WP real ( WP ), parameter :: TWENTYTHREE = 2 3.0_WP real ( WP ), parameter :: TWENTYFOUR = 2 4.0_WP real ( WP ), parameter :: TWENTYFIVE = 2 5.0_WP real ( WP ), parameter :: TWENTYSIX = 2 6.0_WP real ( WP ), parameter :: TWENTYSEVEN = 2 7.0_WP real ( WP ), parameter :: THIRTYTWO = 3 2.0_WP real ( WP ), parameter :: THIRTYFIVE = 3 5.0_WP real ( WP ), parameter :: THIRTYSIX = 3 6.0_WP real ( WP ), parameter :: THIRTYSEVEN = 3 7.0_WP real ( WP ), parameter :: FOURTYFIVE = 4 5.0_WP real ( WP ), parameter :: FIFTY = 5 0.0_WP real ( WP ), parameter :: SIXTY = 6 0.0_WP real ( WP ), parameter :: SIXTYTWO = 6 2.0_WP real ( WP ), parameter :: SIXTYTHREE = 6 3.0_WP real ( WP ), parameter :: EIGHTYSEVEN = 8 7.0_WP real ( WP ), parameter :: MINP = 1.0E-16_WP real ( WP ), parameter :: MAXP = 1.0E16_WP real ( WP ), parameter :: MAXVELO = 1.0E3_WP real ( WP ), parameter :: MINN = - 1.0E16_WP real ( WP ), parameter :: MAXN = - 1.0E-16_WP real ( WP ), parameter :: TRUNCERR = 1.0E-16_WP real ( WP ), parameter :: PI = 2.0_WP * ( DASIN ( 1.0_WP )) !3.14159265358979323846_WP !dacos( -ONE ) real ( WP ), parameter :: TWOPI = TWO * PI !6.28318530717958647692_WP!TWO * dacos( -ONE ) complex ( mytype ), parameter :: cx_one_one = cmplx ( one , one , kind = mytype ) real ( WP ), parameter , dimension ( 3 , 3 ) :: KRONECKER_DELTA = & reshape ( ( / & ONE , ZERO , ZERO , & ZERO , ONE , ZERO , & ZERO , ZERO , ONE / ), & ( / 3 , 3 / ) ) real ( WP ), parameter :: GRAVITY = 9.80665_WP !---------------------------------------------------------------------------------------------------------- ! fft lib !---------------------------------------------------------------------------------------------------------- integer , parameter :: FFT_2DECOMP_3DFFT = 3 , & FFT_FISHPACK_2DFFT = 2 , & MSTRET_3FMD = 1 , & MSTRET_TANH = 2 , & MSTRET_POWL = 3 !---------------------------------------------------------------------------------------------------------- ! case id !---------------------------------------------------------------------------------------------------------- integer , parameter :: ICASE_OTHERS = 0 , & ICASE_CHANNEL = 1 , & ICASE_PIPE = 2 , & ICASE_ANNULAR = 3 , & ICASE_TGV3D = 4 , & ICASE_TGV2D = 5 , & ICASE_BURGERS = 6 , & ICASE_ALGTEST = 7 !---------------------------------------------------------------------------------------------------------- ! flow initilisation !---------------------------------------------------------------------------------------------------------- integer , parameter :: INIT_RESTART = 0 , & INIT_INTERPL = 1 , & INIT_RANDOM = 2 , & INIT_INLET = 3 , & INIT_GVCONST = 4 , & INIT_POISEUILLE = 5 , & INIT_FUNCTION = 6 !---------------------------------------------------------------------------------------------------------- ! coordinates !---------------------------------------------------------------------------------------------------------- integer , parameter :: ICARTESIAN = 1 , & ICYLINDRICAL = 2 !---------------------------------------------------------------------------------------------------------- ! grid stretching !---------------------------------------------------------------------------------------------------------- integer , parameter :: ISTRET_NO = 0 , & ISTRET_CENTRE = 1 , & ISTRET_2SIDES = 2 , & ISTRET_BOTTOM = 3 , & ISTRET_TOP = 4 , & ISTRET_INPUT = 5 !---------------------------------------------------------------------------------------------------------- ! time scheme !---------------------------------------------------------------------------------------------------------- integer , parameter :: ITIME_RK3 = 3 , & ITIME_RK3_CN = 2 , & ITIME_AB2 = 1 , & ITIME_EULER = 0 !---------------------------------------------------------------------------------------------------------- ! BC !---------------------------------------------------------------------------------------------------------- ! warning : Don't change below order for BC types. integer , parameter :: IBC_INTERIOR = 0 , & ! basic and nominal, used in operations, bulk, 2 ghost layers IBC_PERIODIC = 1 , & ! basic and nominal, used in operations IBC_SYMMETRIC = 2 , & ! basic and nominal, used in operations IBC_ASYMMETRIC = 3 , & ! basic and nominal, used in operations IBC_DIRICHLET = 4 , & ! basic and nominal, used in operations IBC_NEUMANN = 5 , & ! basic and nominal, used in operations IBC_INTRPL = 6 , & ! basic only, for all others, used in operations IBC_CONVECTIVE = 7 , & ! nominal only, = IBC_DIRICHLET, dynamic fbc IBC_TURBGEN = 8 , & ! nominal only, = IBC_PERIODIC, bulk, 2 ghost layers, dynamic fbc IBC_PROFILE1D = 9 , & ! nominal only, = IBC_DIRICHLET, IBC_DATABASE = 10 , & ! nominal only, = IBC_PERIODIC, bulk, 2 ghost layers, dynamic fbc IBC_OTHERS = 11 ! interpolation integer , parameter :: NBC = 5 ! u, v, w, p, T integer , parameter :: NDIM = 3 integer , parameter :: IDIM ( 0 : 3 ) = ( / 0 , 1 , 2 , 3 / ) integer , parameter :: IPENCIL ( 3 ) = ( / 1 , 2 , 3 / ) integer , parameter :: JBC_SELF = 1 , & JBC_GRAD = 2 , & JBC_PROD = 3 integer , parameter :: SPACE_INTEGRAL = 0 , & SPACE_AVERAGE = 1 integer , parameter :: IG2Q = - 1 , & IQ2G = 1 !---------------------------------------------------------------------------------------------------------- ! numerical accuracy !---------------------------------------------------------------------------------------------------------- integer , parameter :: IACCU_CD2 = 1 , & IACCU_CD4 = 2 , & IACCU_CP4 = 3 , & IACCU_CP6 = 4 !---------------------------------------------------------------------------------------------------------- ! numerical scheme for viscous term !---------------------------------------------------------------------------------------------------------- integer , parameter :: IVIS_EXPLICIT = 1 , & IVIS_SEMIMPLT = 2 !---------------------------------------------------------------------------------------------------------- ! driven force in periodic flow !---------------------------------------------------------------------------------------------------------- integer , parameter :: IDRVF_NO = 0 , & IDRVF_X_MASSFLUX = 1 , & IDRVF_X_TAUW = 2 , & IDRVF_X_DPDX = 3 , & IDRVF_Z_MASSFLUX = 4 , & IDRVF_Z_TAUW = 5 , & IDRVF_Z_DPDZ = 6 !---------------------------------------------------------------------------------------------------------- ! BC for thermal !---------------------------------------------------------------------------------------------------------- integer , parameter :: THERMAL_BC_CONST_T = 0 , & THERMAL_BC_CONST_H = 1 !---------------------------------------------------------------------------------------------------------- ! working fluid media !---------------------------------------------------------------------------------------------------------- integer , parameter :: ISCP_WATER = 1 , & ISCP_CO2 = 2 , & ILIQUID_SODIUM = 3 , & ILIQUID_LEAD = 4 , & ILIQUID_BISMUTH = 5 , & ILIQUID_LBE = 6 , & ILIQUID_WATER = 7 ! to be updated !---------------------------------------------------------------------------------------------------------- ! physical property !---------------------------------------------------------------------------------------------------------- integer , parameter :: IPROPERTY_TABLE = 1 , & IPROPERTY_FUNCS = 2 !---------------------------------------------------------------------------------------------------------- ! database for physical property !---------------------------------------------------------------------------------------------------------- character ( len = 64 ), parameter :: INPUT_SCP_WATER = 'NIST_WATER_23.5MP.DAT' character ( len = 64 ), parameter :: INPUT_SCP_CO2 = 'NIST_CO2_8MP.DAT' real ( WP ), parameter :: TM0_Na = 37 1.0_WP ! unit: K, melting temperature at 1 atm for Na real ( WP ), parameter :: TM0_Pb = 60 0.6_WP ! unit: K, melting temperature at 1 atm for Lead real ( WP ), parameter :: TM0_BI = 54 4.6_WP ! unit: K, melting temperature at 1 atm for Bismuth real ( WP ), parameter :: TM0_LBE = 39 8.0_WP ! unit: K, melting temperature at 1 atm for LBE real ( WP ), parameter :: TM0_H2O = 27 3.15_WP ! unit: K, melting temperature at 1 atm for water real ( WP ), parameter :: TB0_Na = 115 5.0_WP ! unit: K, boling temperature at 1 atm for Na real ( WP ), parameter :: TB0_Pb = 202 1.0_WP ! unit: K, boling temperature at 1 atm for Lead real ( WP ), parameter :: TB0_BI = 183 1.0_WP ! unit: K, boling temperature at 1 atm for Bismuth real ( WP ), parameter :: TB0_LBE = 192 7.0_WP ! unit: K, boling temperature at 1 atm for LBE real ( WP ), parameter :: TB0_H2O = 37 3.15_WP ! unit: K, boling temperature at 1 atm for water real ( WP ), parameter :: HM0_Na = 11 3.0e3_WP ! unit: J / Kg, latent melting heat, enthalpy for Na real ( WP ), parameter :: HM0_Pb = 2 3.07e3_WP ! unit: J / Kg, latent melting heat, enthalpy for Lead real ( WP ), parameter :: HM0_BI = 5 3.3e3_WP ! unit: J / Kg, latent melting heat, enthalpy for Bismuth real ( WP ), parameter :: HM0_LBE = 3 8.6e3_WP ! unit: J / Kg, latent melting heat, enthalpy for LBE real ( WP ), parameter :: HM0_H2O = 33 4.0e3_WP ! unit: J / Kg, latent melting heat, enthalpy for water ! D = CoD(0) + CoD(1) * T real ( WP ), parameter :: CoD_Na ( 0 : 1 ) = ( / 101 4.0_WP , - 0.235_WP / ) real ( WP ), parameter :: CoD_Pb ( 0 : 1 ) = ( / 1144 1.0_WP , - 1.2795_WP / ) real ( WP ), parameter :: CoD_Bi ( 0 : 1 ) = ( / 1072 5.0_WP , - 1.22_WP / ) real ( WP ), parameter :: CoD_LBE ( 0 : 1 ) = ( / 1106 5.0_WP , 1.293_WP / ) ! K = CoK(0) + CoK(1) * T + CoK(2) * T&#94;2 real ( WP ), parameter :: CoK_Na ( 0 : 2 ) = ( / 10 4.0_WP , - 0.047_WP , 0.0_WP / ) real ( WP ), parameter :: CoK_Pb ( 0 : 2 ) = ( / 9.2_WP , 0.011_WP , 0.0_WP / ) real ( WP ), parameter :: CoK_Bi ( 0 : 2 ) = ( / 7.34_WP , 9.5E-3_WP , 0.0_WP / ) real ( WP ), parameter :: CoK_LBE ( 0 : 2 ) = ( / 3.284_WP , 1.617E-2_WP , - 2.305E-6_WP / ) ! B = 1 / (CoB - T) real ( WP ), parameter :: CoB_Na = 431 6.0_WP real ( WP ), parameter :: CoB_Pb = 894 2.0_WP real ( WP ), parameter :: CoB_BI = 879 1.0_WP real ( WP ), parameter :: CoB_LBE = 855 8.0_WP ! Cp = CoCp(-2) * T&#94;(-2) + CoCp(-1) * T&#94;(-1) + CoCp(0) + CoCp(1) * T + CoCp(2) * T&#94;2 real ( WP ), parameter :: CoCp_Na ( - 2 : 2 ) = ( /- 3.001e6_WP , 0.0_WP , 165 8.0_WP , - 0.8479_WP , 4.454E-4_WP / ) real ( WP ), parameter :: CoCp_Pb ( - 2 : 2 ) = ( /- 1.524e6_WP , 0.0_WP , 17 6.2_WP , - 4.923E-2_WP , 1.544E-5_WP / ) real ( WP ), parameter :: CoCp_Bi ( - 2 : 2 ) = ( / 7.183e6_WP , 0.0_WP , 11 8.2_WP , 5.934E-3_WP , 0.0_WP / ) real ( WP ), parameter :: CoCp_LBE ( - 2 : 2 ) = ( /- 4.56e5_WP , 0.0_WP , 16 4.8_WP , - 3.94E-2_WP , 1.25E-5_WP / ) ! H = HM0 + CoH(-1) * (1 / T - 1 / TM0) + CoH(0) + CoH(1) * (T - TM0) +  CoH(2) * (T&#94;2 - TM0&#94;2) +  CoH(3) * (T&#94;3- TM0&#94;3) real ( WP ), parameter :: CoH_Na ( - 1 : 3 ) = ( / 4.56e5_WP , 0.0_WP , 16 4.8_WP , - 1.97E-2_WP , 4.167E-4_WP / ) real ( WP ), parameter :: CoH_Pb ( - 1 : 3 ) = ( / 1.524e6_WP , 0.0_WP , 17 6.2_WP , - 2.4615E-2_WP , 5.147E-6_WP / ) real ( WP ), parameter :: CoH_Bi ( - 1 : 3 ) = ( /- 7.183e6_WP , 0.0_WP , 11 8.2_WP , 2.967E-3_WP , 0.0_WP / ) real ( WP ), parameter :: CoH_LBE ( - 1 : 3 ) = ( / 4.56e5_WP , 0.0_WP , 16 4.8_WP , - 1.97E-2_WP , 4.167E-4_WP / ) ! check, WRong from literature. ! M = vARies real ( WP ), parameter :: CoM_Na ( - 1 : 1 ) = ( / 55 6.835_WP , - 6.4406_WP , - 0.3958_WP / ) ! M = exp ( CoM(-1) / T + CoM(0) + CoM(1) * ln(T) ) real ( WP ), parameter :: CoM_Pb ( - 1 : 1 ) = ( / 106 9.0_WP , 4.55E-4_WP , 0.0_WP / ) ! M = CoM(0) * exp (CoM(-1) / T) real ( WP ), parameter :: CoM_Bi ( - 1 : 1 ) = ( / 78 0.0_WP , 4.456E-4_WP , 0.0_WP / ) ! M = CoM(0) * exp (CoM(-1) / T) real ( WP ), parameter :: CoM_LBE ( - 1 : 1 ) = ( / 75 4.1_WP , 4.94E-4_WP , 0.0_WP / ) ! M = CoM(0) * exp (CoM(-1) / T) end module parameters_constant_mod !========================================================================================================== module wtformat_mod !use iso_fortran_env implicit none character ( len = 19 ) :: wrtfmt1i = '(2X, A40, 1I8.1 )' character ( len = 19 ) :: wrtfmt1il = '(2X, A40, 1I15.1)' character ( len = 19 ) :: wrtfmt2i = '(2X, A40, 2I8.1,)' character ( len = 19 ) :: wrtfmt2il = '(2X, A40, 2I15.1)' character ( len = 19 ) :: wrtfmt3i = '(2X, A40, 3I8.1 )' character ( len = 19 ) :: wrtfmt4i = '(2X, A40, 4I8.1 )' character ( len = 19 ) :: wrtfmt1r = '(2X, A40, 1F14.7)' character ( len = 19 ) :: wrtfmt2r = '(2X, A40, 2F14.7)' character ( len = 19 ) :: wrtfmt3r = '(2X, A40, 3F14.7)' character ( len = 22 ) :: wrtfmt1el = '(2X, A40, 1ES23.15)' character ( len = 22 ) :: wrtfmt2el = '(2X, A40, 2ES23.15)' character ( len = 22 ) :: wrtfmt1e = '(2X, A40, 1ES16.8)' character ( len = 22 ) :: wrtfmt2e = '(2X, A40, 2ES16.8)' character ( len = 24 ) :: wrtfmt2ae = '(2X, 2(A15, 1ES23.15))' character ( len = 26 ) :: wrtfmt1i1r = '(2X, A40, 1I8.1, 1F14.7)' character ( len = 26 ) :: wrtfmt1il1r = '(2X, A40, 1I15.1, 1F14.7)' character ( len = 26 ) :: wrtfmt2i2r = '(2X, A40, 2I8.1, 2F14.7)' character ( len = 26 ) :: wrtfmt4i2r = '(2X, A20, 4I8.1, 2F14.7)' character ( len = 15 ) :: wrtfmt3l = '(2X, A40, 3L4)' character ( len = 15 ) :: wrtfmt1l = '(2X, A40, 1L4)' character ( len = 17 ) :: wrtfmt2s = '(2X, A40, 1A72)' character ( len = 17 ) :: wrtfmt3s = '(2X, A40, 2A15)' character ( len = 9 ) :: wrtfmt1s = '(2X, A80)' end module wtformat_mod !========================================================================================================== module udf_type_mod use parameters_constant_mod , only : NDIM , NBC , WP use mpi_mod implicit none !---------------------------------------------------------------------------------------------------------- !  fluid thermal property info !---------------------------------------------------------------------------------------------------------- type t_fluidThermoProperty real ( WP ) :: t ! temperature real ( WP ) :: d ! density real ( WP ) :: m ! dynviscosity real ( WP ) :: k ! thermconductivity real ( WP ) :: h ! enthalpy real ( WP ) :: rhoh ! mass enthalpy real ( WP ) :: cp ! specific heat capacity real ( WP ) :: b ! thermal expansion end type t_fluidThermoProperty !---------------------------------------------------------------------------------------------------------- !  parameters to calculate the fluid thermal property !---------------------------------------------------------------------------------------------------------- type t_fluid_parameter character ( len = 64 ) :: inputProperty integer :: ifluid integer :: ipropertyState integer :: nlist real ( WP ) :: TM0 real ( WP ) :: TB0 real ( WP ) :: HM0 real ( WP ) :: CoD ( 0 : 1 ) real ( WP ) :: CoK ( 0 : 2 ) real ( WP ) :: CoB real ( WP ) :: CoCp ( - 2 : 2 ) real ( WP ) :: CoH ( - 1 : 3 ) real ( WP ) :: CoM ( - 1 : 1 ) real ( WP ) :: dhmax ! undim real ( WP ) :: dhmin ! undim type ( t_fluidThermoProperty ) :: ftp0ref ! dim, reference state type ( t_fluidThermoProperty ) :: ftpini ! dim, initial state end type t_fluid_parameter !---------------------------------------------------------------------------------------------------------- !  domain info !---------------------------------------------------------------------------------------------------------- type t_domain logical :: is_periodic ( NDIM ) ! is this direction periodic bc? logical :: is_stretching ( NDIM ) ! is this direction of stretching grids? logical :: is_compact_scheme ! is compact scheme applied? logical :: is_thermo ! is thermal field considered? logical :: is_conv_outlet logical :: is_record_xoutlet logical :: is_read_xinlet logical :: is_mhd integer :: idom ! domain id integer :: icase ! case id integer :: icoordinate ! coordinate type integer :: ifft_lib integer :: icht integer :: iTimeScheme integer :: iviscous integer :: iAccuracy integer :: ckpt_nfre integer :: visu_nfre integer :: visu_idim integer :: visu_nskip ( NDIM ) integer :: stat_istart integer :: stat_nskip ( NDIM ) integer :: nsubitr integer :: istret , mstret integer :: ndbfre integer :: ndbend integer :: nc ( NDIM ) ! geometric cell number integer :: np_geo ( NDIM ) ! geometric points integer :: np ( NDIM ) ! calculated points integer :: proben ! global number of probed points ! integer  :: ibcx(2, NBC) ! real bc type, (5 variables, 2 sides), u, v, w, p, T ! integer  :: ibcy(2, NBC) ! real bc type, (5 variables, 2 sides) ! integer  :: ibcz(2, NBC) ! real bc type, (5 variables, 2 sides) integer :: ibcx_qx ( 2 ) integer :: ibcy_qx ( 2 ) integer :: ibcz_qx ( 2 ) integer :: ibcx_qy ( 2 ) integer :: ibcy_qy ( 2 ) integer :: ibcz_qy ( 2 ) integer :: ibcx_qz ( 2 ) integer :: ibcy_qz ( 2 ) integer :: ibcz_qz ( 2 ) integer :: ibcx_pr ( 2 ) integer :: ibcy_pr ( 2 ) integer :: ibcz_pr ( 2 ) integer :: ibcx_Tm ( 2 ) integer :: ibcy_Tm ( 2 ) integer :: ibcz_Tm ( 2 ) integer :: ibcx_ftp ( 2 ) integer :: ibcy_ftp ( 2 ) integer :: ibcz_ftp ( 2 ) integer :: ibcx_nominal ( 2 , NBC ) ! nominal (given) bc type, (5 variables, 2 sides), u, v, w, p, T integer :: ibcy_nominal ( 2 , NBC ) ! nominal (given) bc type, (5 variables, 2 sides) integer :: ibcz_nominal ( 2 , NBC ) ! nominal (given) bc type, (5 variables, 2 sides) real ( wp ) :: fbcx_const ( 2 , NBC ) ! bc values, (5 variables, 2 sides) real ( wp ) :: fbcy_const ( 2 , NBC ) ! bc values, (5 variables, 2 sides) real ( wp ) :: fbcz_const ( 2 , NBC ) ! bc values, (5 variables, 2 sides) real ( wp ) :: lxx real ( wp ) :: lyt real ( wp ) :: lyb real ( wp ) :: lzz real ( WP ) :: rstret real ( wp ) :: dt real ( wp ) :: h ( NDIM ) ! uniform dx real ( wp ) :: h1r ( NDIM ) ! uniform (dx)&#94;(-1) real ( wp ) :: h2r ( NDIM ) ! uniform (dx)&#94;(-2) real ( wp ) :: tGamma ( 0 : 3 ) real ( wp ) :: tZeta ( 0 : 3 ) real ( wp ) :: tAlpha ( 0 : 3 ) real ( wp ) :: sigma1p , sigma2p type ( DECOMP_INFO ) :: dccc ! eg, p type ( DECOMP_INFO ) :: dpcc ! eg, ux type ( DECOMP_INFO ) :: dcpc ! eg, uy type ( DECOMP_INFO ) :: dccp ! eg, uz type ( DECOMP_INFO ) :: dppc ! eg, <ux>&#94;y, <uy>&#94;x type ( DECOMP_INFO ) :: dpcp ! eg, <ux>&#94;z, <uz>&#94;x type ( DECOMP_INFO ) :: dcpp ! eg, <uy>&#94;z, <uz>&#94;y type ( DECOMP_INFO ) :: dppp type ( DECOMP_INFO ) :: d4cc type ( DECOMP_INFO ) :: d4pc type ( DECOMP_INFO ) :: dxcc type ( DECOMP_INFO ) :: dxpc type ( DECOMP_INFO ) :: dxcp ! node location, mapping real ( wp ), allocatable :: yMappingpt (:, :) ! j = 1, first coefficient in first deriviation. 1/h' ! j = 2, first coefficient in second deriviation 1/h'&#94;2 ! j = 3, second coefficient in second deriviation -h\"/h'&#94;3 ! cell centre location, mapping real ( wp ), allocatable :: yMappingcc (:, :) ! first coefficient in first deriviation. 1/h' ! first coefficient in second deriviation 1/h'&#94;2 ! second coefficient in second deriviation -h\"/h'&#94;3 real ( wp ), allocatable :: yp (:) real ( wp ), allocatable :: yc (:) real ( wp ), allocatable :: rc (:) ! =yc * is_cylindrical real ( wp ), allocatable :: rp (:) ! =yp * is_cylindrical real ( wp ), allocatable :: rci (:) ! reciprocal of raidus based on cell centre real ( wp ), allocatable :: rpi (:) ! reciprocal of raidus based on node point integer , allocatable :: ijnp_sym (:) integer , allocatable :: ijnc_sym (:) integer , allocatable :: knc_sym (:) ! knc_sym = knp_sym real ( wp ), allocatable :: fbcx_qx (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_qx (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_qx (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_gx (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_gx (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_gx (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qy (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_qy (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_qy (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_qyr (:, :, :) ! qy/r = ur bc at y dirction real ( wp ), allocatable :: fbcz_qyr (:, :, :) ! qy/r = ur bc at z dirction real ( wp ), allocatable :: fbcx_gy (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_gy (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_gy (:, :, :) ! variable bc !real(wp), allocatable :: fbcy_gyr(:, :, :) ! gy/r = rho * ur bc at y dirction !real(wp), allocatable :: fbcz_gyr(:, :, :) ! gy/r = rho * ur bc at z dirction real ( wp ), allocatable :: fbcx_qz (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_qz (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_qz (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_qzr (:, :, :) ! qz/r = u_theta bc at y dirction real ( wp ), allocatable :: fbcz_qzr (:, :, :) ! qz/r = u_theta bc at z dirction real ( wp ), allocatable :: fbcx_gz (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_gz (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_gz (:, :, :) ! variable bc !real(wp), allocatable :: fbcy_gzr(:, :, :) ! gz/r = rho * u_theta bc at y dirction !real(wp), allocatable :: fbcz_gzr(:, :, :) ! gz/r = rho * u_theta bc at z dirction real ( wp ), allocatable :: fbcx_pr (:, :, :) ! variable bc real ( wp ), allocatable :: fbcy_pr (:, :, :) ! variable bc real ( wp ), allocatable :: fbcz_pr (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qw (:, :, :) ! heat flux at wall x real ( wp ), allocatable :: fbcy_qw (:, :, :) ! heat flux at wall y real ( wp ), allocatable :: fbcz_qw (:, :, :) ! heat flux at wall z real ( wp ), allocatable :: fbcx_qx_outl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qx_outl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qy_outl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qy_outl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qz_outl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qz_outl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_pr_outl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_pr_outl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qx_inl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qx_inl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qy_inl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qy_inl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qz_inl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_qz_inl2 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_pr_inl1 (:, :, :) ! variable bc real ( wp ), allocatable :: fbcx_pr_inl2 (:, :, :) ! variable bc type ( t_fluidThermoProperty ), allocatable :: fbcx_ftp (:, :, :) ! undim, xbc state type ( t_fluidThermoProperty ), allocatable :: fbcy_ftp (:, :, :) ! undim, ybc state type ( t_fluidThermoProperty ), allocatable :: fbcz_ftp (:, :, :) ! undim, zbc state real ( WP ), allocatable :: probexyz (:, :) ! (1:3, xyz coord) logical , allocatable :: probe_is_in (:) integer , allocatable :: probexid (:, :) ! (1:3, local index) end type t_domain !---------------------------------------------------------------------------------------------------------- !  flow info !---------------------------------------------------------------------------------------------------------- type t_flow integer :: idriven integer :: igravity integer :: inittype integer :: iterfrom integer :: initReTo integer :: nIterFlowStart integer :: nIterFlowEnd integer :: iteration real ( WP ) :: time real ( WP ) :: ren real ( WP ) :: rre real ( WP ) :: init_velo3d ( NDIM ) real ( wp ) :: reninit real ( WP ) :: drvfc real ( WP ) :: fgravity ( NDIM ) real ( wp ) :: noiselevel real ( wp ) :: mcon ( 3 ) real ( wp ) :: tt_mass_change real ( wp ) :: tt_kinetic_energy real ( WP ), allocatable :: qx (:, :, :) ! qx = u_x,     axial direction real ( WP ), allocatable :: qy (:, :, :) ! qy = u_r * r, radial direction real ( WP ), allocatable :: qz (:, :, :) ! qz = u_theta, azimuthal direction real ( WP ), allocatable :: gx (:, :, :) ! gx = rho * q_x real ( WP ), allocatable :: gy (:, :, :) ! gy = rho * q_y real ( WP ), allocatable :: gz (:, :, :) ! gz = rho * q_z real ( WP ), allocatable :: gx0 (:, :, :) real ( WP ), allocatable :: gy0 (:, :, :) real ( WP ), allocatable :: gz0 (:, :, :) real ( WP ), allocatable :: pres (:, :, :) real ( WP ), allocatable :: pcor (:, :, :) real ( WP ), allocatable :: pcor_zpencil_ggg (:, :, :) real ( WP ), allocatable :: dDens (:, :, :) real ( WP ), allocatable :: drhodt (:, :, :) real ( WP ), allocatable :: mVisc (:, :, :) real ( WP ), allocatable :: dDensm1 (:, :, :) real ( WP ), allocatable :: dDensm2 (:, :, :) real ( WP ), allocatable :: mx_rhs (:, :, :) ! current step rhs in x real ( WP ), allocatable :: my_rhs (:, :, :) ! current step rhs in y real ( WP ), allocatable :: mz_rhs (:, :, :) ! current step rhs in z real ( WP ), allocatable :: mx_rhs0 (:, :, :) ! last step rhs in x real ( WP ), allocatable :: my_rhs0 (:, :, :) ! last step rhs in y real ( WP ), allocatable :: mz_rhs0 (:, :, :) ! last step rhs in z real ( WP ), allocatable :: fbcx_qx_rhs0 (:, :) ! real ( WP ), allocatable :: fbcx_qy_rhs0 (:, :) real ( WP ), allocatable :: fbcx_qz_rhs0 (:, :) real ( WP ), allocatable :: fbcx_gx_rhs0 (:, :) real ( WP ), allocatable :: fbcx_gy_rhs0 (:, :) real ( WP ), allocatable :: fbcx_gz_rhs0 (:, :) real ( WP ), allocatable :: lrfx (:, :, :) ! Lorentz force  ! real ( WP ), allocatable :: lrfy (:, :, :) ! Lorentz force real ( WP ), allocatable :: lrfz (:, :, :) ! Lorentz force real ( WP ), allocatable :: u_vector_mean (:, :, :, :) ! u, v, w real ( WP ), allocatable :: pr_mean (:, :, :) real ( WP ), allocatable :: uu_tensor6_mean (:, :, :, :) ! uu, vv, ww, uv, uw, vw end type t_flow !---------------------------------------------------------------------------------------------------------- !  thermo info !---------------------------------------------------------------------------------------------------------- type t_thermo integer :: ifluid integer :: inittype integer :: iterfrom integer :: iteration integer :: nIterThermoStart integer :: nIterThermoEnd real ( WP ) :: ref_l0 ! dim real ( WP ) :: ref_T0 ! '0' means dimensional real ( WP ) :: init_T0 ! dim real ( WP ) :: time real ( WP ) :: rPrRen real ( WP ) :: tt_enthalpy real ( WP ), allocatable :: rhoh (:, :, :) real ( WP ), allocatable :: hEnth (:, :, :) real ( WP ), allocatable :: kCond (:, :, :) real ( WP ), allocatable :: tTemp (:, :, :) real ( WP ), allocatable :: ene_rhs (:, :, :) ! current step rhs real ( WP ), allocatable :: ene_rhs0 (:, :, :) ! last step rhs real ( WP ), allocatable :: fbcx_rhoh_rhs0 (:, :) ! real ( WP ), allocatable :: t_mean (:, :, :) real ( WP ), allocatable :: tt_mean (:, :, :) type ( t_fluidThermoProperty ) :: ftp_ini ! undimensional end type t_thermo type ( t_fluid_parameter ) :: fluidparam ! dimensional !---------------------------------------------------------------------------------------------------------- !  mhd info !---------------------------------------------------------------------------------------------------------- type t_mhd logical :: is_NStuart logical :: is_NHartmn real ( WP ) :: NStuart real ( WP ) :: NHartmn real ( WP ) :: B_static ( 3 ) ! scaled B. real ( WP ), allocatable :: ep (:, :, :) ! electric potential, scalar real ( WP ), allocatable :: jx (:, :, :) ! current density in x real ( WP ), allocatable :: jy (:, :, :) ! current density in y real ( WP ), allocatable :: jz (:, :, :) ! current density in z real ( WP ), allocatable :: bx (:, :, :) ! magnetic field in x real ( WP ), allocatable :: by (:, :, :) ! current density in x real ( WP ), allocatable :: bz (:, :, :) ! current density in x integer :: ibcx_ep ( 2 ) integer :: ibcy_ep ( 2 ) integer :: ibcz_ep ( 2 ) integer :: ibcx_jx ( 2 ) integer :: ibcy_jx ( 2 ) integer :: ibcz_jx ( 2 ) integer :: ibcx_jy ( 2 ) integer :: ibcy_jy ( 2 ) integer :: ibcz_jy ( 2 ) integer :: ibcx_jz ( 2 ) integer :: ibcy_jz ( 2 ) integer :: ibcz_jz ( 2 ) integer :: ibcx_bx ( 2 ) integer :: ibcy_bx ( 2 ) integer :: ibcz_bx ( 2 ) integer :: ibcx_by ( 2 ) integer :: ibcy_by ( 2 ) integer :: ibcz_by ( 2 ) integer :: ibcx_bz ( 2 ) integer :: ibcy_bz ( 2 ) integer :: ibcz_bz ( 2 ) real ( WP ), allocatable :: fbcx_ep (:, :, :) real ( WP ), allocatable :: fbcy_ep (:, :, :) real ( WP ), allocatable :: fbcz_ep (:, :, :) real ( WP ), allocatable :: fbcx_jx (:, :, :) real ( WP ), allocatable :: fbcy_jx (:, :, :) real ( WP ), allocatable :: fbcz_jx (:, :, :) real ( WP ), allocatable :: fbcx_jy (:, :, :) real ( WP ), allocatable :: fbcy_jy (:, :, :) real ( WP ), allocatable :: fbcz_jy (:, :, :) real ( WP ), allocatable :: fbcx_jz (:, :, :) real ( WP ), allocatable :: fbcy_jz (:, :, :) real ( WP ), allocatable :: fbcz_jz (:, :, :) real ( WP ), allocatable :: fbcx_bx (:, :, :) real ( WP ), allocatable :: fbcy_bx (:, :, :) real ( WP ), allocatable :: fbcz_bx (:, :, :) real ( WP ), allocatable :: fbcx_by (:, :, :) real ( WP ), allocatable :: fbcy_by (:, :, :) real ( WP ), allocatable :: fbcz_by (:, :, :) real ( WP ), allocatable :: fbcx_bz (:, :, :) real ( WP ), allocatable :: fbcy_bz (:, :, :) real ( WP ), allocatable :: fbcz_bz (:, :, :) end type end module !========================================================================================================== !========================================================================================================== module vars_df_mod use udf_type_mod implicit none type ( t_domain ), allocatable , save :: domain (:) type ( t_flow ), allocatable , save :: flow (:) type ( t_thermo ), allocatable , save :: thermo (:) type ( t_mhd ), allocatable , save :: mhd (:) end module !========================================================================================================== module io_files_mod implicit none character ( 8 ) :: dir_code = '0_src' character ( 9 ) :: dir_data = '1_data' character ( 6 ) :: dir_visu = '2_visu' character ( 9 ) :: dir_moni = '3_monitor' character ( 9 ) :: dir_chkp = '4_check' public :: create_directory interface operator ( . f . ) module procedure file_exists end interface contains function file_exists ( filename ) result ( res ) implicit none character ( len =* ), intent ( in ) :: filename logical :: res ! Check if the file exists inquire ( file = trim ( filename ), exist = res ) end function subroutine create_directory implicit none call system ( 'mkdir -p ' // dir_code ) call system ( 'mkdir -p ' // dir_data ) call system ( 'mkdir -p ' // dir_visu ) call system ( 'mkdir -p ' // dir_moni ) call system ( 'mkdir -p ' // dir_chkp ) return end subroutine end module !========================================================================================================== module math_mod use precision_mod use parameters_constant_mod implicit none interface sqrt_wp module procedure sqrt_sp module procedure sqrt_dp end interface sqrt_wp interface tanh_wp module procedure tanh_sp module procedure tanh_dp end interface tanh_wp interface abs_wp module procedure abs_sp module procedure abs_dp end interface abs_wp interface abs_prec module procedure abs_sp module procedure abs_dp module procedure abs_csp module procedure abs_cdp end interface abs_prec interface sin_wp module procedure sin_sp module procedure sin_dp end interface sin_wp interface sin_prec module procedure sin_sp module procedure sin_dp end interface sin_prec interface cos_wp module procedure cos_sp module procedure cos_dp end interface cos_wp interface cos_prec module procedure cos_sp module procedure cos_dp end interface cos_prec interface tan_wp module procedure tan_sp module procedure tan_dp end interface tan_wp interface atan_wp module procedure atan_sp module procedure atan_dp end interface atan_wp contains ! abs elemental function abs_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = abs ( r ) end function elemental function abs_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = dabs ( r ) end function elemental function abs_csp ( r ) result ( d ) COMPLEX ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = abs ( r ) end function elemental function abs_cdp ( r ) result ( d ) COMPLEX ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = abs ( r ) end function ! sqrt pure function sqrt_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = sqrt ( r ) end function pure function sqrt_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = dsqrt ( r ) end function ! sin pure function sin_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = sin ( r ) end function pure function sin_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = dsin ( r ) end function ! cos pure function cos_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = cos ( r ) end function pure function cos_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = dcos ( r ) end function ! tanh pure function tanh_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = tanh ( r ) end function pure function tanh_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = dtanh ( r ) end function ! tan pure function tan_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = tan ( r ) end function pure function tan_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = tan ( r ) end function ! atan pure function atan_sp ( r ) result ( d ) real ( kind = S6P ), intent ( in ) :: r real ( kind = S6P ) :: d d = atan ( r ) end function pure function atan_dp ( r ) result ( d ) real ( kind = D15P ), intent ( in ) :: r real ( kind = D15P ) :: d d = atan ( r ) end function ! heaviside_step pure function heaviside_step ( r ) result ( d ) real ( kind = WP ), intent ( in ) :: r real ( kind = WP ) :: d d = ZERO if ( r > MINP ) then ! MINP = 1.0e-20 d = ONE else if ( r < MAXN ) then ! MAXN = -1.0e-20 d = ZERO else d = HALF end if end function end module math_mod !========================================================================================================== !========================================================================================================== module typeconvert_mod contains character ( len = 20 ) function int2str ( k ) implicit none integer , intent ( in ) :: k write ( int2str , * ) k int2str = trim ( adjustl ( int2str )) end function int2str character ( len = 20 ) function real2str ( r ) use precision_mod implicit none real ( wp ), intent ( in ) :: r write ( real2str , '(F10.4)' ) r real2str = trim ( adjustl ( real2str )) end function real2str end module typeconvert_mod module EvenOdd_mod implicit none contains logical function is_even ( number ) implicit none integer , intent ( in ) :: number ! Check if the number is even or odd if ( mod ( number , 2 ) == 0 ) then is_even = . true . else is_even = . false . end if end function end module !========================================================================================================== module flatten_index_mod implicit none interface flatten_index module procedure flatten_3d_to_1d module procedure flatten_2d_to_1d end interface contains function flatten_3d_to_1d ( i , j , k , Nx , Ny ) result ( n ) integer , intent ( in ) :: i , j , k , Nx , Ny integer :: n n = i + Nx * ( j - 1 ) + Nx * Ny * ( k - 1 ) end function function flatten_2d_to_1d ( i , j , Nx ) result ( n ) integer , intent ( in ) :: i , j , Nx integer :: n n = i + Nx * ( j - 1 ) end function end module flatten_index_mod","tags":"","url":"sourcefile/modules.f90.html"},{"title":"eq_scalar_transport.f90 – CHAPSim2","text":"Source Code ! module eq_scalar_transport_mod ! to check !   use operations !   use decomp_2d !   implicit none !   private :: Compute_transport_rhs !   private :: Calculate_transport_fractional_step !   !public  :: Solve_transport_eq ! contains ! !========================================================================================================== !   subroutine Calculate_transport_fractional_step(rhs0, rhs1, dm, isub) !     use parameters_constant_mod !     use udf_type_mod !     implicit none !     type(t_domain), intent(in) :: dm !     real(WP), dimension(dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3)), intent(inout) :: rhs0, rhs1 !     integer,  intent(in) :: isub !     real(WP), dimension(dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3)) :: rhs_dummy !   ! add explicit terms !     rhs_dummy(:, :, :) = rhs1(:, :, :) !     rhs1(:, :, :) = dm%tGamma(isub) * rhs1(:, :, :) + & !                     dm%tZeta (isub) * rhs0(:, :, :) !     rhs0(:, :, :) = rhs_dummy(:, :, :) !   ! times the time step !     rhs1(:, :, :) = dm%dt * rhs1(:, :, :) !     return !   end subroutine ! !========================================================================================================== !   subroutine Compute_transport_rhs(fl, tm, dm, isub) !     use operations !     use udf_type_mod !     use thermo_info_mod !     implicit none !     type(t_domain), intent(in) :: dm !     type(t_flow),   intent(in) :: fl !     type(t_thermo), intent(inout) :: tm !     integer,        intent(in) :: isub !     real(WP), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ) :: accc !     real(WP), dimension( dm%dccc%ysz(1), dm%dccc%ysz(2), dm%dccc%ysz(3) ) :: accc_ypencil !     real(WP), dimension( dm%dccc%zsz(1), dm%dccc%zsz(2), dm%dccc%zsz(3) ) :: accc_zpencil !     real(WP), dimension( dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3) ) :: apcc !     real(WP), dimension( dm%dccp%ysz(1), dm%dccp%ysz(2), dm%dccp%ysz(3) ) :: accp_ypencil !     real(WP), dimension( dm%dccp%zsz(1), dm%dccp%zsz(2), dm%dccp%zsz(3) ) :: accp_zpencil !     real(WP), dimension( dm%dcpc%ysz(1), dm%dcpc%ysz(2), dm%dcpc%ysz(3) ) :: acpc_ypencil !     real(WP), dimension( dm%dcpc%ysz(1), dm%dcpc%ysz(2), dm%dcpc%ysz(3) ) :: gy_ypencil !     real(WP), dimension( dm%dccp%zsz(1), dm%dccp%zsz(2), dm%dccp%zsz(3) ) :: gz_zpencil !     real(WP), dimension( dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dppc%xsz(3) ) :: hEnth_pcc !     real(WP), dimension( dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dppc%xsz(3) ) :: kCond_pcc !     real(WP), dimension( dm%dcpc%ysz(1), dm%dcpc%ysz(2), dm%dcpc%ysz(3) ) :: hEnth_cpc_ypencil !     real(WP), dimension( dm%dccp%zsz(1), dm%dccp%zsz(2), dm%dccp%zsz(3) ) :: hEnth_ccp_zpencil !     real(WP), dimension( dm%dccc%ysz(1), dm%dccc%ysz(2), dm%dccc%ysz(3) ) :: Ttemp_ccc_ypencil !     real(WP), dimension( dm%dccc%ysz(1), dm%dccc%ysz(2), dm%dccc%ysz(3) ) :: ene_rhs_ccc_ypencil !     real(WP), dimension( dm%dcpc%ysz(1), dm%dcpc%ysz(2), dm%dcpc%ysz(3) ) :: kCond_cpc_ypencil !     real(WP), dimension( dm%dccp%zsz(1), dm%dccp%zsz(2), dm%dccp%zsz(3) ) :: kCond_ccp_zpencil !     real(WP), dimension( dm%dccc%zsz(1), dm%dccc%zsz(2), dm%dccc%zsz(3) ) :: Ttemp_ccc_zpencil !     real(WP), dimension( dm%dccc%zsz(1), dm%dccc%zsz(2), dm%dccc%zsz(3) ) :: kCond_zpencil !     real(WP), dimension( dm%dccc%zsz(1), dm%dccc%zsz(2), dm%dccc%zsz(3) ) :: ene_rhs_ccc_zpencil !     real(WP) :: fbcx(2), fbcy(2), fbcz(2) !     integer  :: ibcx(2), ibcy(2), ibcz(2) !     integer  :: i ! !========================================================================================================== ! !   preparation ! !========================================================================================================== !     call transpose_x_to_y(fl%gy,        gy_ypencil,   dm%dcpc)   ! for d(g_y h)/dy !     call transpose_x_to_y(fl%gz,        accp_ypencil, dm%dccp)   ! intermediate, accp_ypencil = gz_ypencil !     call transpose_y_to_z(accp_ypencil, gz_zpencil,   dm%dccp)   ! for d(g_z h)/dz ! !---------------------------------------------------------------------------------------------------------- ! !    h --> h_pcc ! !      --> h_ypencil --> h_cpc_ypencil ! !                    --> h_zpencil --> h_ccp_zpencil ! !---------------------------------------------------------------------------------------------------------- !     call Get_x_midp_C2P_3D(tm%hEnth,     hEnth_pcc,         dm, dm%iAccuracy, dm%ibcx(:, 5), bm%ftpbcx_4cc(:, :, :)%h) ! for d(g_x h_pcc))/dy !     call transpose_x_to_y (tm%hEnth,     accc_ypencil, dm%dccc)                     !intermediate, accc_ypencil = hEnth_ypencil !     call Get_y_midp_C2P_3D(accc_ypencil, hEnth_cpc_ypencil, dm, dm%iAccuracy, dm%ibcy(:, 5), bm%ftpbcy_c4c(:, :, :)%h)! for d(g_y h_cpc)/dy !     call transpose_y_to_z (accc_ypencil, accc_zpencil, dm%dccc) !intermediate, accc_zpencil = hEnth_zpencil !     call Get_z_midp_C2P_3D(accc_zpencil, hEnth_ccp_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 5), bm%ftpbcz_cc4(:, :, :)%h) ! for d(g_z h_ccp)/dz ! !---------------------------------------------------------------------------------------------------------- ! !    k --> k_pcc ! !      --> k_ypencil --> k_cpc_ypencil ! !                    --> k_zpencil --> k_ccp_zpencil ! !---------------------------------------------------------------------------------------------------------- !     call Get_x_midp_C2P_3D(tm%kCond,      kCond_pcc,         dm, dm%iAccuracy, dm%ibcx(:, 5), dm%ftpbcx_4cc(:, :, :)%k) ! for d(k_pcc * (dT/dx) )/dx !     call transpose_x_to_y (tm%kCond,      accc_ypencil, dm%dccc)  ! for k d2(T)/dy&#94;2 !     call Get_y_midp_C2P_3D(accc_ypencil,  kCond_cpc_ypencil, dm, dm%iAccuracy, dm%ibcy(:, 5), dm%ftpbcy_c4c(:, :, :)%k) !     call transpose_y_to_z (accc_ypencil,  kCond_zpencil, dm%dccc) !     call Get_z_midp_C2P_3D(kCond_zpencil, kCond_ccp_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 5), dm%ftpbcz_cc4(:, :, :)%k) ! !---------------------------------------------------------------------------------------------------------- ! !    T --> T_ypencil --> T_zpencil ! !---------------------------------------------------------------------------------------------------------- !     call transpose_x_to_y (tm%Ttemp,      Ttemp_ccc_ypencil, dm%dccc)   ! for k d2(T)/dy&#94;2 !     call transpose_y_to_z (Ttemp_ccc_ypencil, Ttemp_ccc_zpencil, dm%dccc)   ! for k d2(T)/dz&#94;2 ! !========================================================================================================== ! ! the RHS of energy equation ! ! x-pencil : the RHS terms of energy (derivative) operating in the x direction ! !========================================================================================================== ! !---------------------------------------------------------------------------------------------------------- ! ! x-pencil : d (gx * h_pcc) / dx ! !---------------------------------------------------------------------------------------------------------- !     tm%ene_rhs = ZERO !     call Get_x_1der_P2C_3D( - fl%gx * hEnth_pcc, accc, dm, dm%iAccuracy, dm%ibcx(:, 1) ) ! accc = -d(gx * h)/dx !     tm%ene_rhs = tm%ene_rhs + accc ! !---------------------------------------------------------------------------------------------------------- ! ! x-pencil : d (T) / dx ! !---------------------------------------------------------------------------------------------------------- !     do i = 1, 2 !       if (dm%ibcx(i, 5) == IBC_NEUMANN) then !         ibcx(i) = IBC_INTERIOR !         fbcx(i) = ZERO !       else !         ibcx(i) = dm%ibcx(i, 5) !         !fbcx(i) = dm%fbcx_var(i, 5) !       end if !     end do !     call Get_x_1der_C2P_3D(tm%tTemp, apcc, dm, ibcx(:), fbcx(:) ) ! !---------------------------------------------------------------------------------------------------------- ! ! x-pencil : k_pcc * d (T) / dx ! !---------------------------------------------------------------------------------------------------------- !     apcc = apcc * kCond_pcc !     if (dm%ibcx_Tm(1) == IBC_NEUMANN) then !       !apcc(1, :, :) = dm%fbcx_var(1, 5) !     end if !     if (dm%ibcx_Tm(2) == IBC_NEUMANN) then !       !apcc(dm%dpcc%xen(1), :, :) = dm%fbcx_var(2, 5) !     end if ! !---------------------------------------------------------------------------------------------------------- ! ! x-pencil : d ( k_pcc * d (T) / dx ) dx ! !---------------------------------------------------------------------------------------------------------- !     call Get_x_1der_P2C_3D(apcc, accc, dm, dm%iAccuracy, dm%ibcx(:, 5) ) !     tm%ene_rhs = tm%ene_rhs + accc ! !========================================================================================================== ! ! the RHS of energy equation ! ! y-pencil : the RHS terms of energy (derivative) operating in the y direction ! !========================================================================================================== ! !---------------------------------------------------------------------------------------------------------- ! ! y-pencil : d (gy * h_cpc) / dy ! !---------------------------------------------------------------------------------------------------------- !     ene_rhs_ccc_ypencil = ZERO !     call Get_y_1der_P2C_3D( - gy_ypencil * hEnth_cpc_ypencil, accc_ypencil, dm, dm%iAccuracy, dm%ibcy_qy ) !     ene_rhs_ccc_ypencil = ene_rhs_ccc_ypencil + accc_ypencil ! !---------------------------------------------------------------------------------------------------------- ! ! y-pencil : d (T) / dy ! !---------------------------------------------------------------------------------------------------------- !     do i = 1, 2 !       if (dm%ibcy(i, 5) == IBC_NEUMANN) then !         ibcy(i) = IBC_INTERIOR !         fbcy(i) = ZERO !       else !         ibcy(i) = dm%ibcy(i, 5) !         !fbcy(i) = dm%fbcy_var(i, 5) !       end if !     end do !     call Get_y_1der_C2P_3D(Ttemp_ccc_ypencil, acpc_ypencil, dm, ibcy(:), fbcy(:) ) ! !---------------------------------------------------------------------------------------------------------- ! ! y-pencil : k_cpc * d (T) / dy ! !---------------------------------------------------------------------------------------------------------- !     acpc_ypencil = acpc_ypencil * kCond_cpc_ypencil !     if (dm%ibcy_Tm(1) == IBC_NEUMANN) then !       !acpc_ypencil(:, 1, :) = dm%fbcy_var(1, 5) !     end if !     if (dm%ibcy_Tm(2) == IBC_NEUMANN) then !       !acpc_ypencil(:, dm%dcpc%yen(2), :) = dm%fbcy_var(2, 5) !     end if ! !---------------------------------------------------------------------------------------------------------- ! ! y-pencil : d ( k_cpc * d (T) / dy ) dy ! !---------------------------------------------------------------------------------------------------------- !     call Get_y_1der_P2C_3D(acpc_ypencil, accc_ypencil, dm, dm%iAccuracy, dm%ibcy(:, 5) ) !     ene_rhs_ccc_ypencil = ene_rhs_ccc_ypencil + accc_ypencil !     call transpose_y_to_x(ene_rhs_ccc_ypencil, accc, dm%dccc) !     tm%ene_rhs = tm%ene_rhs + accc ! !========================================================================================================== ! ! the RHS of energy equation ! ! z-pencil : the RHS terms of energy (derivative) operating in the z direction ! !========================================================================================================== ! !---------------------------------------------------------------------------------------------------------- ! ! z-pencil : d (gz * h_ccp) / dz ! !---------------------------------------------------------------------------------------------------------- !     ene_rhs_ccc_zpencil = ZERO !     call Get_z_1der_P2C_3D( - gz_zpencil * hEnth_ccp_zpencil, accc_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 3) ) !     ene_rhs_ccc_zpencil = ene_rhs_ccc_zpencil + accc_zpencil ! !---------------------------------------------------------------------------------------------------------- ! ! z-pencil : d (T) / dz ! !---------------------------------------------------------------------------------------------------------- !     do i = 1, 2 !       if (dm%ibcz(i, 5) == IBC_NEUMANN) then !         ibcz(i) = IBC_INTERIOR !         fbcz(i) = ZERO !       else !         ibcz(i) = dm%ibcz(i, 5) !         !fbcz(i) = dm%fbcz_var(i, 5) !       end if !     end do !     call Get_z_1der_C2P_3D(Ttemp_ccc_zpencil, accp_zpencil, dm, ibcz(:), fbcz(:) ) ! !---------------------------------------------------------------------------------------------------------- ! ! z-pencil : k_ccp * d (T) / dz ! !---------------------------------------------------------------------------------------------------------- !     accp_zpencil = accp_zpencil * kCond_ccp_zpencil !     if (dm%ibcz_Tm(1) == IBC_NEUMANN) then !       !accp_zpencil(:, 1, :) = dm%fbcz_var(1, 5) !     end if !     if (dm%ibcz_Tm(2) == IBC_NEUMANN) then !       !accp_zpencil(:, :, dm%dccp%zen(3)) = dm%fbcz_var(2, 5) !     end if ! !---------------------------------------------------------------------------------------------------------- ! ! z-pencil : d ( k_ccp * d (T) / dz ) / dz ! !---------------------------------------------------------------------------------------------------------- !     call Get_z_1der_P2C_3D(accp_zpencil, accc_zpencil, dm, dm%iAccuracy, dm%ibcz(:, 5) ) !     ene_rhs_ccc_zpencil = ene_rhs_ccc_zpencil + accc_zpencil !     call transpose_z_to_y(ene_rhs_ccc_zpencil, ene_rhs_ccc_ypencil, dm%dccc) !     call transpose_y_to_x(ene_rhs_ccc_ypencil, accc,            dm%dccc) !     tm%ene_rhs = tm%ene_rhs + accc ! !========================================================================================================== ! ! time approaching ! !========================================================================================================== !     call Calculate_transport_fractional_step(tm%ene_rhs0, tm%ene_rhs, dm, isub) !     return !   end subroutine Compute_transport_rhs ! !========================================================================================================== ! !========================================================================================================== !   subroutine Solve_transport_eq(fl, tm, dm, isub) !     use udf_type_mod !     use thermo_info_mod !     use solver_tools_mod !     implicit none !     type(t_domain), intent(in)    :: dm !     type(t_flow),   intent(inout) :: fl !     type(t_thermo), intent(inout) :: tm !     integer,        intent(in)    :: isub ! !---------------------------------------------------------------------------------------------------------- ! !   calculate rhs of transport equation ! !---------------------------------------------------------------------------------------------------------- !     call Compute_transport_rhs(fl, tm, dm, isub) ! !---------------------------------------------------------------------------------------------------------- ! !   update rho * h ! !---------------------------------------------------------------------------------------------------------- !     tm%rhoh = tm%rhoh + tm%ene_rhs ! !---------------------------------------------------------------------------------------------------------- ! !   update other properties from rho * h ! !---------------------------------------------------------------------------------------------------------- !     call Update_thermal_properties(fl, tm, dm) ! !---------------------------------------------------------------------------------------------------------- ! !   No Need to apply b.c. ! !---------------------------------------------------------------------------------------------------------- !   return !   end subroutine ! end module eq_energy_mod","tags":"","url":"sourcefile/eq_scalar_transport.f90.html"},{"title":".operations.f90 – CHAPSim2","text":"Source Code !---------------------------------------------------------------------------------------------------------- !                      CHAPSim version 2.0.0 !                      -------------------------- ! This file is part of CHAPSim, a general-purpose CFD tool. ! ! This program is free software; you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation; either version 3 of the License, or (at your option) any later ! version. ! ! This program is disatributed in the hope that it will be useful, but WITHOUT ! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS ! FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more ! details. ! ! You should have received a copy of the GNU General Public License along with ! this program; if not, write to the Free Software Foundation, Inc., 51 Franklin ! Street, Fifth Floor, Boston, MA 02110-1301, USA. !---------------------------------------------------------------------------------------------------------- !========================================================================================================== !> \\file operations.f90 !> !> \\brief A general operation of derivative and interpolation in 1D. !> !========================================================================================================== module operations use precision_mod , only : WP implicit none private !---------------------------------------------------------------------------------------------------------- ! basic coefficients for TDMA of 1st deriviative ! to store coefficients for TDMA !     d1fC2C vs d1rC2C : !       f : coefficients in the LHS, unknown side. !       r : coefficients in the RHS, known side. ! eg, d1fC2C(5, 3, 5) !     First column: 1:2 for one side b.c. !                   4:5 for the other side b.c. !                   3   for interior !     Second column: 1 for coefficients of LHS f&#94;(1)_{i-1} !                    2 for coefficients of LHS f&#94;(1)_{i} !                    3 for coefficients of LHS f&#94;(1)_{i+1} !     Third column:  for b.c. flags !                 IBC_INTERIOR    = 0, & !                 IBC_PERIODIC    = 1, & !                 IBC_SYMMETRIC   = 2, & !                 IBC_ASYMMETRIC  = 3, & !                 IBC_DIRICHLET   = 4, & !                 IBC_NEUMANN     = 5, & !                 IBC_INTRPL      = 6, & !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! for 1st derivative !---------------------------------------------------------------------------------------------------------- ! collocated C2C real ( WP ), save , public :: d1fC2C ( 5 , 3 , 0 : 6 ) real ( WP ), save , public :: d1rC2C ( 5 , 4 , 0 : 6 ) ! collocated P2P real ( WP ), save :: d1fP2P ( 5 , 3 , 0 : 6 ) real ( WP ), save :: d1rP2P ( 5 , 4 , 0 : 6 ) ! staggered C2P real ( WP ), save , public :: d1fC2P ( 5 , 3 , 0 : 6 ) real ( WP ), save , public :: d1rC2P ( 5 , 4 , 0 : 6 ) ! staggered P2C real ( WP ), save :: d1fP2C ( 5 , 3 , 0 : 6 ) real ( WP ), save :: d1rP2C ( 5 , 4 , 0 : 6 ) !---------------------------------------------------------------------------------------------------------- ! for 2nd derivative !---------------------------------------------------------------------------------------------------------- ! collocated C2C real ( WP ), save , public :: d2fC2C ( 5 , 3 , 0 : 6 ) real ( WP ), save , public :: d2rC2C ( 5 , 4 , 0 : 6 ) ! one more value used. ! collocated P2P real ( WP ), save :: d2fP2P ( 5 , 3 , 0 : 6 ) real ( WP ), save :: d2rP2P ( 5 , 4 , 0 : 6 ) !---------------------------------------------------------------------------------------------------------- ! for iterpolation !---------------------------------------------------------------------------------------------------------- ! interpolation P2C real ( WP ), save :: m1fP2C ( 5 , 3 , 0 : 6 ) real ( WP ), save :: m1rP2C ( 5 , 4 , 0 : 6 ) ! interpolation C2P real ( WP ), save , public :: m1fC2P ( 5 , 3 , 0 : 6 ) real ( WP ), save , public :: m1rC2P ( 5 , 4 , 0 : 6 ) !---------------------------------------------------------------------------------------------------------- ! coefficients array for TDMA of 1st deriviative ! to store coefficients array for TDMA !---------------------------------------------------------------------------------------------------------- type t_xtdma_lhs !---------------------------------------------------------------------------------------------------------- !   x : pre-processed TDMA LHS Matrix for 1st deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad1x_P2P (:, :, :) real ( WP ), allocatable :: bd1x_P2P (:, :, :) real ( WP ), allocatable :: cd1x_P2P (:, :, :) real ( WP ), allocatable :: dd1x_P2P (:, :, :) real ( WP ), allocatable :: ad1x_C2C (:, :, :) real ( WP ), allocatable :: bd1x_C2C (:, :, :) real ( WP ), allocatable :: cd1x_C2C (:, :, :) real ( WP ), allocatable :: dd1x_C2C (:, :, :) real ( WP ), allocatable :: ad1x_P2C (:, :, :) real ( WP ), allocatable :: bd1x_P2C (:, :, :) real ( WP ), allocatable :: cd1x_P2C (:, :, :) real ( WP ), allocatable :: dd1x_P2C (:, :, :) real ( WP ), allocatable :: ad1x_C2P (:, :, :) real ( WP ), allocatable :: bd1x_C2P (:, :, :) real ( WP ), allocatable :: cd1x_C2P (:, :, :) real ( WP ), allocatable :: dd1x_C2P (:, :, :) !---------------------------------------------------------------------------------------------------------- !   x : pre-processed TDMA LHS Matrix for 2nd deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad2x_P2P (:, :, :) real ( WP ), allocatable :: bd2x_P2P (:, :, :) real ( WP ), allocatable :: cd2x_P2P (:, :, :) real ( WP ), allocatable :: dd2x_P2P (:, :, :) real ( WP ), allocatable :: ad2x_C2C (:, :, :) real ( WP ), allocatable :: bd2x_C2C (:, :, :) real ( WP ), allocatable :: cd2x_C2C (:, :, :) real ( WP ), allocatable :: dd2x_C2C (:, :, :) !---------------------------------------------------------------------------------------------------------- !   x : pre-processed TDMA LHS Matrix for mid-point interpolation !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: am1x_P2C (:, :, :) real ( WP ), allocatable :: bm1x_P2C (:, :, :) real ( WP ), allocatable :: cm1x_P2C (:, :, :) real ( WP ), allocatable :: dm1x_P2C (:, :, :) real ( WP ), allocatable :: am1x_C2P (:, :, :) real ( WP ), allocatable :: bm1x_C2P (:, :, :) real ( WP ), allocatable :: cm1x_C2P (:, :, :) real ( WP ), allocatable :: dm1x_C2P (:, :, :) end type t_xtdma_lhs type ( t_xtdma_lhs ), allocatable :: xtdma_lhs (:) !---------------------------------------------------------------------------------------------------------- ! y : pre-processed TDMA LHS Matrix for 1st deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad1y_P2P (:, :, :) real ( WP ), allocatable :: bd1y_P2P (:, :, :) real ( WP ), allocatable :: cd1y_P2P (:, :, :) real ( WP ), allocatable :: dd1y_P2P (:, :, :) real ( WP ), allocatable :: ad1y_C2C (:, :, :) real ( WP ), allocatable :: bd1y_C2C (:, :, :) real ( WP ), allocatable :: cd1y_C2C (:, :, :) real ( WP ), allocatable :: dd1y_C2C (:, :, :) real ( WP ), allocatable :: ad1y_P2C (:, :, :) real ( WP ), allocatable :: bd1y_P2C (:, :, :) real ( WP ), allocatable :: cd1y_P2C (:, :, :) real ( WP ), allocatable :: dd1y_P2C (:, :, :) real ( WP ), allocatable :: ad1y_C2P (:, :, :) real ( WP ), allocatable :: bd1y_C2P (:, :, :) real ( WP ), allocatable :: cd1y_C2P (:, :, :) real ( WP ), allocatable :: dd1y_C2P (:, :, :) !---------------------------------------------------------------------------------------------------------- ! y : pre-processed TDMA LHS Matrix for 2nd deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad2y_P2P (:, :, :) real ( WP ), allocatable :: bd2y_P2P (:, :, :) real ( WP ), allocatable :: cd2y_P2P (:, :, :) real ( WP ), allocatable :: dd2y_P2P (:, :, :) real ( WP ), allocatable :: ad2y_C2C (:, :, :) real ( WP ), allocatable :: bd2y_C2C (:, :, :) real ( WP ), allocatable :: cd2y_C2C (:, :, :) real ( WP ), allocatable :: dd2y_C2C (:, :, :) !---------------------------------------------------------------------------------------------------------- ! y : pre-processed TDMA LHS Matrix for mid-point interpolation !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: am1y_P2C (:, :, :) real ( WP ), allocatable :: bm1y_P2C (:, :, :) real ( WP ), allocatable :: cm1y_P2C (:, :, :) real ( WP ), allocatable :: dm1y_P2C (:, :, :) real ( WP ), allocatable :: am1y_C2P (:, :, :) real ( WP ), allocatable :: bm1y_C2P (:, :, :) real ( WP ), allocatable :: cm1y_C2P (:, :, :) real ( WP ), allocatable :: dm1y_C2P (:, :, :) !---------------------------------------------------------------------------------------------------------- ! z : pre-processed TDMA LHS Matrix for 1st deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad1z_P2P (:, :, :) real ( WP ), allocatable :: bd1z_P2P (:, :, :) real ( WP ), allocatable :: cd1z_P2P (:, :, :) real ( WP ), allocatable :: dd1z_P2P (:, :, :) real ( WP ), allocatable :: ad1z_C2C (:, :, :) real ( WP ), allocatable :: bd1z_C2C (:, :, :) real ( WP ), allocatable :: cd1z_C2C (:, :, :) real ( WP ), allocatable :: dd1z_C2C (:, :, :) real ( WP ), allocatable :: ad1z_P2C (:, :, :) real ( WP ), allocatable :: bd1z_P2C (:, :, :) real ( WP ), allocatable :: cd1z_P2C (:, :, :) real ( WP ), allocatable :: dd1z_P2C (:, :, :) real ( WP ), allocatable :: ad1z_C2P (:, :, :) real ( WP ), allocatable :: bd1z_C2P (:, :, :) real ( WP ), allocatable :: cd1z_C2P (:, :, :) real ( WP ), allocatable :: dd1z_C2P (:, :, :) !---------------------------------------------------------------------------------------------------------- ! z : pre-processed TDMA LHS Matrix for 2nd deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad2z_P2P (:, :, :) real ( WP ), allocatable :: bd2z_P2P (:, :, :) real ( WP ), allocatable :: cd2z_P2P (:, :, :) real ( WP ), allocatable :: dd2z_P2P (:, :, :) real ( WP ), allocatable :: ad2z_C2C (:, :, :) real ( WP ), allocatable :: bd2z_C2C (:, :, :) real ( WP ), allocatable :: cd2z_C2C (:, :, :) real ( WP ), allocatable :: dd2z_C2C (:, :, :) !---------------------------------------------------------------------------------------------------------- ! z : pre-processed TDMA LHS Matrix for mid-point interpolation !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: am1z_P2C (:, :, :) real ( WP ), allocatable :: bm1z_P2C (:, :, :) real ( WP ), allocatable :: cm1z_P2C (:, :, :) real ( WP ), allocatable :: dm1z_P2C (:, :, :) real ( WP ), allocatable :: am1z_C2P (:, :, :) real ( WP ), allocatable :: bm1z_C2P (:, :, :) real ( WP ), allocatable :: cm1z_C2P (:, :, :) real ( WP ), allocatable :: dm1z_C2P (:, :, :) !---------------------------------------------------------------------------------------------------------- ! processures !---------------------------------------------------------------------------------------------------------- private :: Prepare_compact_coefficients private :: Buildup_TDMA_LHS_array public :: Prepare_LHS_coeffs_for_operations private :: Prepare_TDMA_interp_P2C_RHS_array ! need fbc(1,2) for IBC_INTERIOR private :: Get_x_midp_P2C_1D private :: Get_y_midp_P2C_1D private :: Get_z_midp_P2C_1D public :: Get_x_midp_P2C_3D public :: Get_y_midp_P2C_3D public :: Get_z_midp_P2C_3D private :: Prepare_TDMA_interp_C2P_RHS_array ! need fbc(1,2,3,4) for Dirichlet, INTERIOR private :: Get_x_midp_C2P_1D private :: Get_y_midp_C2P_1D private :: Get_z_midp_C2P_1D public :: Get_x_midp_C2P_3D public :: Get_y_midp_C2P_3D public :: Get_z_midp_C2P_3D private :: Prepare_TDMA_1deri_C2C_RHS_array ! need fbc(1,2,3,4) for INTERIOR private :: Get_x_1st_derivative_C2C_1D private :: Get_y_1st_derivative_C2C_1D private :: Get_z_1st_derivative_C2C_1D public :: Get_x_1st_derivative_C2C_3D ! only used for thermal flow public :: Get_y_1st_derivative_C2C_3D ! only used for thermal flow public :: Get_z_1st_derivative_C2C_3D ! only used for thermal flow private :: Prepare_TDMA_1deri_P2P_RHS_array ! need fbc(1,2,3,4) for Neumann, INTERIOR private :: Get_x_1st_derivative_P2P_1D private :: Get_y_1st_derivative_P2P_1D private :: Get_z_1st_derivative_P2P_1D public :: Get_x_1st_derivative_P2P_3D public :: Get_y_1st_derivative_P2P_3D public :: Get_z_1st_derivative_P2P_3D private :: Prepare_TDMA_1deri_C2P_RHS_array ! need fbc(1,2,3,4) for Neumann, INTERIOR private :: Get_x_1st_derivative_C2P_1D private :: Get_y_1st_derivative_C2P_1D private :: Get_z_1st_derivative_C2P_1D public :: Get_x_1st_derivative_C2P_3D ! careful about Dirichlet BC, check public :: Get_y_1st_derivative_C2P_3D ! careful about Dirichlet BC, check public :: Get_z_1st_derivative_C2P_3D ! careful about Dirichlet BC, check private :: Prepare_TDMA_1deri_P2C_RHS_array ! need fbc(1,2) for INTERIOR private :: Get_x_1st_derivative_P2C_1D private :: Get_y_1st_derivative_P2C_1D private :: Get_z_1st_derivative_P2C_1D public :: Get_x_1st_derivative_P2C_3D public :: Get_y_1st_derivative_P2C_3D public :: Get_z_1st_derivative_P2C_3D private :: Prepare_TDMA_2deri_C2C_RHS_array ! need fbc to INTERIOR private :: Get_x_2nd_derivative_C2C_1D private :: Get_y_2nd_derivative_C2C_1D private :: Get_z_2nd_derivative_C2C_1D public :: Get_x_2nd_derivative_C2C_3D ! not used. public :: Get_y_2nd_derivative_C2C_3D ! not used. public :: Get_z_2nd_derivative_C2C_3D ! not used. private :: Prepare_TDMA_2deri_P2P_RHS_array ! need fbc for Neumann, interior private :: Get_x_2nd_derivative_P2P_1D private :: Get_y_2nd_derivative_P2P_1D private :: Get_z_2nd_derivative_P2P_1D public :: Get_x_2nd_derivative_P2P_3D ! not used. public :: Get_y_2nd_derivative_P2P_3D ! not used. public :: Get_z_2nd_derivative_P2P_3D ! not used. public :: Test_interpolation public :: Test_1st_derivative public :: Test_2nd_derivative contains !========================================================================================================== !> \\brief Assigned the cooefficients for the compact schemes !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role                                           ! !---------------------------------------------------------------------------------------------------------- !> \\param[in]     iaccu         the accuracy given by user !========================================================================================================== subroutine Prepare_compact_coefficients ( iaccu ) use parameters_constant_mod use input_general_mod use mpi_mod implicit none integer , intent ( in ) :: iaccu real ( WP ) :: alpha , a , b , c , d real ( WP ) :: alpha1 , a1 , b1 , c1 , d1 real ( WP ) :: alpha2 , a2 , b2 , c2 , d2 real ( WP ) :: alpha_itf , a_itf , b_itf , c_itf , d_itf ! for interface/interior/reduced to 4th CD integer :: n if ( nrank == 0 ) then call Print_debug_start_msg & ( \"Assigning coefficient matrix for the compact schemes ...\" ) !write(*, *) \"The given numerical accuracy =\", iaccu end if !---------------------------------------------------------------------------------------------------------- !   initialisation !---------------------------------------------------------------------------------------------------------- d1fC2C (:, :, :) = ZERO d1rC2C (:, :, :) = ZERO d1fP2P (:, :, :) = ZERO d1rP2P (:, :, :) = ZERO d1fC2P (:, :, :) = ZERO d1rC2P (:, :, :) = ZERO d1fP2C (:, :, :) = ZERO d1rP2C (:, :, :) = ZERO d2fC2C (:, :, :) = ZERO d2rC2C (:, :, :) = ZERO d2fP2P (:, :, :) = ZERO d2rP2P (:, :, :) = ZERO m1fC2P (:, :, :) = ZERO m1rC2P (:, :, :) = ZERO m1fP2C (:, :, :) = ZERO m1rP2C (:, :, :) = ZERO !========================================================================================================== ! Set 1 : P2P, C2P, periodic & symmetric & asymmetric !         1st derivative on collocated grids, C2C/P2P bulk coefficients ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) ! to solve below matrix: ! eq(1) : a +   b = 2  alpha + 1    O(h2) ! eq(2) : a +  4b = 6  alpha        O(h4) ! eq(3) : a + 16b = 10 alpha        O(h6) !========================================================================================================== alpha = ZERO a = ZERO b = ZERO c = ZERO alpha_itf = ZERO a_itf = FOUR * ONE_THIRD b_itf = - ONE_THIRD c_itf = ZERO if ( iaccu == IACCU_CD2 ) then ! eq(1) + alpha0 + b0, O(h2) alpha = ZERO a = ONE b = ZERO else if ( iaccu == IACCU_CD4 ) then ! eq(1-2) + alpha0, O(h4) alpha = ZERO a = FOUR * ONE_THIRD b = - ONE_THIRD else if ( iaccu == IACCU_CP4 ) then ! eq(1-2) + b0, O(h4) alpha = QUARTER a = ONEPFIVE b = ZERO else if ( iaccu == IACCU_CP6 ) then ! eq(1-2-3), O(h6) alpha = ONE_THIRD a = FOURTEEN / NINE b = ONE / NINE else ! default 2nd CD alpha = ZERO a = ONE b = ZERO end if !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2C : periodic b.c. ! d1fC2C : \"d1\"=first deriviative, \"f\"=f'  side, \"C2C\"= center 2 centre ! d1rC2C : \"d1\"=first deriviative, \"r\"=rhs side, \"C2C\"= center 2 centre ! [ 1    alpha                   alpha][f'_1]=[a/2 * (f_{2}   - f_{n})/h   + b/4 * (f_{3}   - f_{n-1})/h] ! [      alpha 1     alpha            ][f'_2] [a/2 * (f_{3}   - f_{1})/h   + b/4 * (f_{4}   - f_{n})/h  ] ! [            alpha 1     alpha      ][f'_i] [a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                  alpha 1     alpha][f'_4] [a/2 * (f_{n}   - f_{n-2})/h + b/4 * (f_{1}   - f_{n-3})/h] ! [alpha                   alpha 1    ][f'_5] [a/2 * (f_{1}   - f_{n-1})/h + b/4 * (f_{2}   - f_{n-2})/h] !---------------------------------------------------------------------------------------------------------- d1fC2C ( 1 : 5 , 1 , IBC_PERIODIC ) = alpha d1fC2C ( 1 : 5 , 2 , IBC_PERIODIC ) = ONE d1fC2C ( 1 : 5 , 3 , IBC_PERIODIC ) = alpha d1rC2C ( 1 : 5 , 1 , IBC_PERIODIC ) = a * HALF ! a/2 d1rC2C ( 1 : 5 , 2 , IBC_PERIODIC ) = b * QUARTER ! b/4 d1rC2C ( 1 : 5 , 3 , IBC_PERIODIC ) = c ! not used !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, interior !---------------------------------------------------------------------------------------------------------- d1fC2C ( 1 , 1 , IBC_INTERIOR ) = alpha_itf d1fC2C ( 1 , 2 , IBC_INTERIOR ) = ONE d1fC2C ( 1 , 3 , IBC_INTERIOR ) = alpha_itf d1rC2C ( 1 , 1 , IBC_INTERIOR ) = a_itf * HALF ! a/2 d1rC2C ( 1 , 2 , IBC_INTERIOR ) = b_itf * QUARTER ! b/4 d1rC2C ( 1 , 3 , IBC_INTERIOR ) = c_itf ! not used d1fC2C ( 5 , :, IBC_INTERIOR ) = d1fC2C ( 1 , :, IBC_INTERIOR ) d1rC2C ( 5 , :, IBC_INTERIOR ) = d1rC2C ( 1 , :, IBC_INTERIOR ) d1fC2C ( 2 : 4 , :, IBC_INTERIOR ) = d1fC2C ( 2 : 4 , :, IBC_PERIODIC ) d1rC2C ( 2 : 4 , :, IBC_INTERIOR ) = d1rC2C ( 2 : 4 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2P : periodic b.c.  Same as C2C !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_PERIODIC ) = d1fC2C (:, :, IBC_PERIODIC ) d1rP2P (:, :, IBC_PERIODIC ) = d1rC2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, interior !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_INTERIOR ) = d1fC2C (:, :, IBC_INTERIOR ) d1rP2P (:, :, IBC_INTERIOR ) = d1rC2C (:, :, IBC_INTERIOR ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2C : symmetric b.c. ! [ 1-alpha  alpha                          ][f'_1]=[a/2 * (f_{2}   - f_{1})/h   + b/4 * (f_{3}   - f_{2})/h  ] ! [          alpha 1     alpha              ][f'_2] [a/2 * (f_{3}   - f_{1})/h   + b/4 * (f_{4}   - f_{1})/h  ] ! [                alpha 1     alpha        ][f'_i] [a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                      alpha 1     alpha  ][f'_4] [a/2 * (f_{n}   - f_{n-2})/h + b/4 * (f_{n}   - f_{n-3})/h] ! [                            alpha 1-alpha][f'_5] [a/2 * (f_{n}   - f_{n-1})/h + b/4 * (f_{n-1} - f_{n-2})/h] !---------------------------------------------------------------------------------------------------------- d1fC2C ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_SYMMETRIC ) = ONE - alpha d1fC2C ( 1 , 3 , IBC_SYMMETRIC ) = alpha d1fC2C ( 5 , 1 , IBC_SYMMETRIC ) = d1fC2C ( 1 , 3 , IBC_SYMMETRIC ) d1fC2C ( 5 , 2 , IBC_SYMMETRIC ) = d1fC2C ( 1 , 2 , IBC_SYMMETRIC ) d1fC2C ( 5 , 3 , IBC_SYMMETRIC ) = d1fC2C ( 1 , 1 , IBC_SYMMETRIC ) d1fC2C ( 2 : 4 , :, IBC_SYMMETRIC ) = d1fC2C ( 2 : 4 , :, IBC_PERIODIC ) d1rC2C (:, :, IBC_SYMMETRIC ) = d1rC2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2C : asymmetric b.c. ! [ 1+alpha  alpha                          ][f'_1]=[a/2 * (f_{2}   + f_{1})/h   + b/4 * (f_{3}   + f_{2})/h  ] ! [          alpha 1     alpha              ][f'_2] [a/2 * (f_{3}   - f_{1})/h   + b/4 * (f_{4}   + f_{1})/h  ] ! [                alpha 1     alpha        ][f'_i] [a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                      alpha 1     alpha  ][f'_4] [a/2 * (f_{n}   - f_{n-2})/h + b/4 * (-f_{n}   - f_{n-3})/h] ! [                            alpha 1+alpha][f'_5] [a/2 * (-f_{n}   - f_{n-1})/h + b/4 * (-f_{n-1} - f_{n-2})/h] !---------------------------------------------------------------------------------------------------------- d1fC2C ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_ASYMMETRIC ) = ONE + alpha d1fC2C ( 1 , 3 , IBC_ASYMMETRIC ) = alpha d1fC2C ( 5 , 1 , IBC_ASYMMETRIC ) = d1fC2C ( 1 , 3 , IBC_ASYMMETRIC ) d1fC2C ( 5 , 2 , IBC_ASYMMETRIC ) = d1fC2C ( 1 , 2 , IBC_ASYMMETRIC ) d1fC2C ( 5 , 3 , IBC_ASYMMETRIC ) = d1fC2C ( 1 , 1 , IBC_ASYMMETRIC ) d1fC2C ( 2 : 4 , :, IBC_ASYMMETRIC ) = d1fC2C ( 2 : 4 , :, IBC_PERIODIC ) d1rC2C (:, :, IBC_ASYMMETRIC ) = d1rC2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2P : symmetric b.c. ! [ 1  0                              ][f'_{1'}]=[a/2 * (f_{2'}   - f_{2'})/h   + b/4 * (f_{3'}   - f_{3'})/h  ] ! [    alpha 1     alpha              ][f'_{2'}] [a/2 * (f_{3'}   - f_{1'})/h   + b/4 * (f_{4'}   - f_{2'})/h  ] ! [          alpha 1     alpha        ][f'_{i'}] [a/2 * (f_{i'+1} - f_{i'-1})/h + b/4 * (f_{i'+2} - f_{i'-2})/h] ! [                alpha 1     alpha  ][f'_{4'}] [a/2 * (f_{n'}   - f_{n'-2})/h + b/4 * (f_{n'-1} - f_{n'-3})/h] ! [                      0     1      ][f'_{5'}] [a/2 * (f_{n'-1} - f_{n'-1})/h + b/4 * (f_{n'-2} - f_{n'-2})/h] !---------------------------------------------------------------------------------------------------------- d1fP2P ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used d1fP2P ( 1 , 2 , IBC_SYMMETRIC ) = ONE d1fP2P ( 1 , 3 , IBC_SYMMETRIC ) = ZERO d1fP2P ( 5 , 1 , IBC_SYMMETRIC ) = d1fP2P ( 1 , 3 , IBC_SYMMETRIC ) d1fP2P ( 5 , 2 , IBC_SYMMETRIC ) = d1fP2P ( 1 , 2 , IBC_SYMMETRIC ) d1fP2P ( 5 , 3 , IBC_SYMMETRIC ) = d1fP2P ( 1 , 1 , IBC_SYMMETRIC ) d1fP2P ( 2 : 4 , :, IBC_SYMMETRIC ) = d1fP2P ( 2 : 4 , :, IBC_PERIODIC ) d1rP2P (:, :, IBC_SYMMETRIC ) = d1rP2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2P : asymmetric b.c. ! [ 1  2alpha                          ][f'_{1'}]=[a/2 * (f_{2'}   + f_{2'})/h   + b/4 * (f_{3'}   + f_{3'})/h  ] ! [    alpha 1     alpha               ][f'_{2'}] [a/2 * (f_{3'}   - f_{1'})/h   + b/4 * (f_{4'}   + f_{2'})/h  ] ! [          alpha 1     alpha         ][f'_{i'}] [a/2 * (f_{i'+1} - f_{i'-1})/h + b/4 * (f_{i'+2} - f_{i'-2})/h] ! [                alpha 1      alpha  ][f'_{4'}] [a/2 * (f_{n'}   - f_{n'-2})/h + b/4 * (-f_{n'-1} - f_{n'-3})/h] ! [                      2alpha 1      ][f'_{5'}] [a/2 * (-f_{n'-1} - f_{n'-1})/h + b/4 * (-f_{n'-2} - f_{n'-2})/h] !---------------------------------------------------------------------------------------------------------- d1fP2P ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used d1fP2P ( 1 , 2 , IBC_ASYMMETRIC ) = ONE d1fP2P ( 1 , 3 , IBC_ASYMMETRIC ) = TWO * alpha d1fP2P ( 5 , 1 , IBC_ASYMMETRIC ) = d1fP2P ( 1 , 3 , IBC_ASYMMETRIC ) d1fP2P ( 5 , 2 , IBC_ASYMMETRIC ) = d1fP2P ( 1 , 2 , IBC_ASYMMETRIC ) d1fP2P ( 5 , 3 , IBC_ASYMMETRIC ) = d1fP2P ( 1 , 1 , IBC_ASYMMETRIC ) d1fP2P ( 2 : 4 , :, IBC_ASYMMETRIC ) = d1fP2P ( 2 : 4 , :, IBC_PERIODIC ) d1rP2P (:, :, IBC_ASYMMETRIC ) = d1rP2P (:, :, IBC_PERIODIC ) !========================================================================================================== ! Set 2: no bc required !       C2C : no specified, Neumann !       P2P : no specified, Dirichlet B.C. ! 1st derivative on collocated grids, C2C/P2P coefficients : Dirichlet B.C. ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) ! it is: ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2/2 * (f_{3} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i] [ a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4] [a2/2 * (f_{n} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n}/h  - b1 * f_{n-1}/h - c1 * f_{n-2}/h] ! First layer BC: ! eq(1): a + b +  c =  0               O(h0) ! eq(2):     b + 2c =  alpha + 1       O(h1) ! eq(3):     b + 4c = 2alpha           O(h2) ! eq(4):     b + 8c = 3alpha           O(h3) !========================================================================================================== alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! eq(1-2)+alpha0+c0, O(h1) alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO ! 2nd layer = same as bulk with CD2 alpha2 = ZERO a2 = ONE b2 = ZERO else if ( iaccu == IACCU_CD4 ) then ! eq(1-3)+alpha0, O(h2) alpha1 = ZERO a1 = - ONEPFIVE b1 = TWO c1 = - HALF ! 2nd layer = same as bulk with CD2 alpha2 = ZERO a2 = ONE b2 = ZERO else if ( iaccu == IACCU_CP4 ) then ! eq(1-3)+c0, O(h2) alpha1 = ONE a1 = - TWO b1 = TWO c1 = ZERO ! 2nd layer = same as bulk with CP4 alpha2 = QUARTER a2 = ONEPFIVE b2 = ZERO else if ( iaccu == IACCU_CP6 ) then ! eq(1-4), O(h3) alpha1 = TWO a1 = - TWOPFIVE b1 = TWO c1 = HALF ! 2nd layer = same as bulk with CP4 alpha2 = QUARTER a2 = ONEPFIVE b2 = ZERO else ! default 2nd CD alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO ! 2nd layer = same as bulk with CD2 alpha2 = ZERO a2 = ONE b2 = ZERO end if !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2C : no specified, Neumann ! P2P : no specified, Dirichlet B.C. ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2/2 * (f_{3} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i] [ a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4] [a2/2 * (f_{n} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n}/h  - b1 * f_{n-1}/h - c1 * f_{n-2}/h] !---------------------------------------------------------------------------------------------------------- d1fC2C ( 1 , 1 , IBC_INTRPL ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_INTRPL ) = ONE d1fC2C ( 1 , 3 , IBC_INTRPL ) = alpha1 d1rC2C ( 1 , 1 , IBC_INTRPL ) = a1 d1rC2C ( 1 , 2 , IBC_INTRPL ) = b1 d1rC2C ( 1 , 3 , IBC_INTRPL ) = c1 d1fC2C ( 5 , 1 , IBC_INTRPL ) = d1fC2C ( 1 , 3 , IBC_INTRPL ) d1fC2C ( 5 , 2 , IBC_INTRPL ) = d1fC2C ( 1 , 2 , IBC_INTRPL ) d1fC2C ( 5 , 3 , IBC_INTRPL ) = d1fC2C ( 1 , 1 , IBC_INTRPL ) d1rC2C ( 5 , 1 , IBC_INTRPL ) = - d1rC2C ( 1 , 1 , IBC_INTRPL ) d1rC2C ( 5 , 2 , IBC_INTRPL ) = - d1rC2C ( 1 , 2 , IBC_INTRPL ) d1rC2C ( 5 , 3 , IBC_INTRPL ) = - d1rC2C ( 1 , 3 , IBC_INTRPL ) d1fC2C ( 2 , 1 , IBC_INTRPL ) = alpha2 d1fC2C ( 2 , 2 , IBC_INTRPL ) = ONE d1fC2C ( 2 , 3 , IBC_INTRPL ) = alpha2 d1rC2C ( 2 , 1 , IBC_INTRPL ) = a2 * HALF d1rC2C ( 2 , 2 , IBC_INTRPL ) = b2 * QUARTER ! zero d1rC2C ( 2 , 3 , IBC_INTRPL ) = c2 ! not used d1fC2C ( 4 , 1 , IBC_INTRPL ) = d1fC2C ( 2 , 3 , IBC_INTRPL ) d1fC2C ( 4 , 2 , IBC_INTRPL ) = d1fC2C ( 2 , 2 , IBC_INTRPL ) d1fC2C ( 4 , 3 , IBC_INTRPL ) = d1fC2C ( 2 , 1 , IBC_INTRPL ) d1rC2C ( 4 , 1 , IBC_INTRPL ) = d1rC2C ( 2 , 1 , IBC_INTRPL ) d1rC2C ( 4 , 2 , IBC_INTRPL ) = d1rC2C ( 2 , 2 , IBC_INTRPL ) d1rC2C ( 4 , 3 , IBC_INTRPL ) = d1rC2C ( 2 , 3 , IBC_INTRPL ) d1fC2C ( 3 , 1 : 3 , IBC_INTRPL ) = d1fC2C ( 3 , 1 : 3 , IBC_PERIODIC ) d1rC2C ( 3 , 1 : 3 , IBC_INTRPL ) = d1rC2C ( 3 , 1 : 3 , IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2P : no specified !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_INTRPL ) = d1fC2C (:, :, IBC_INTRPL ) d1rP2P (:, :, IBC_INTRPL ) = d1rC2C (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2C : neumann !---------------------------------------------------------------------------------------------------------- d1fC2C (:, :, IBC_NEUMANN ) = d1fC2C (:, :, IBC_INTRPL ) d1rC2C (:, :, IBC_NEUMANN ) = d1rC2C (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2P : Dirichlet !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_DIRICHLET ) = d1fP2P (:, :, IBC_INTRPL ) d1rP2P (:, :, IBC_DIRICHLET ) = d1rP2P (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2P : NEUMANN ! [ 1     0                                 ][f'_1]=[known] ! [alpha2 1      alpha2                     ][f'_2] [a2/2 * (f_{3} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i] [ a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4] [a2/2 * (f_{n} - f_{n-2})/h] ! [                            0      1     ][f'_5] [known] !---------------------------------------------------------------------------------------------------------- d1fP2P ( 1 , 1 , IBC_NEUMANN ) = ZERO ! not used d1fP2P ( 1 , 2 , IBC_NEUMANN ) = ONE d1fP2P ( 1 , 3 , IBC_NEUMANN ) = ZERO d1rP2P ( 1 , 1 , IBC_NEUMANN ) = ZERO d1rP2P ( 1 , 2 , IBC_NEUMANN ) = ZERO d1rP2P ( 1 , 3 , IBC_NEUMANN ) = ZERO d1fP2P ( 5 , 1 , IBC_NEUMANN ) = d1fP2P ( 1 , 3 , IBC_NEUMANN ) d1fP2P ( 5 , 2 , IBC_NEUMANN ) = d1fP2P ( 1 , 2 , IBC_NEUMANN ) d1fP2P ( 5 , 3 , IBC_NEUMANN ) = d1fP2P ( 1 , 1 , IBC_NEUMANN ) d1rP2P ( 5 , 1 , IBC_NEUMANN ) = - d1rP2P ( 1 , 1 , IBC_NEUMANN ) d1rP2P ( 5 , 2 , IBC_NEUMANN ) = - d1rP2P ( 1 , 2 , IBC_NEUMANN ) d1rP2P ( 5 , 3 , IBC_NEUMANN ) = - d1rP2P ( 1 , 3 , IBC_NEUMANN ) d1fP2P ( 2 , 1 , IBC_NEUMANN ) = alpha2 d1fP2P ( 2 , 2 , IBC_NEUMANN ) = ONE d1fP2P ( 2 , 3 , IBC_NEUMANN ) = alpha2 d1rP2P ( 2 , 1 , IBC_NEUMANN ) = a2 * HALF d1rP2P ( 2 , 2 , IBC_NEUMANN ) = b2 * QUARTER ! not used d1rP2P ( 2 , 3 , IBC_NEUMANN ) = c2 d1fP2P ( 4 , 1 , IBC_NEUMANN ) = d1fP2P ( 2 , 3 , IBC_NEUMANN ) d1fP2P ( 4 , 2 , IBC_NEUMANN ) = d1fP2P ( 2 , 2 , IBC_NEUMANN ) d1fP2P ( 4 , 3 , IBC_NEUMANN ) = d1fP2P ( 2 , 1 , IBC_NEUMANN ) d1rP2P ( 4 , 1 , IBC_NEUMANN ) = d1rP2P ( 2 , 1 , IBC_NEUMANN ) d1rP2P ( 4 , 2 , IBC_NEUMANN ) = d1rP2P ( 2 , 2 , IBC_NEUMANN ) d1rP2P ( 4 , 3 , IBC_NEUMANN ) = d1rP2P ( 2 , 3 , IBC_NEUMANN ) d1fP2P ( 3 , 1 : 3 , IBC_NEUMANN ) = d1fP2P ( 3 , 1 : 3 , IBC_PERIODIC ) d1rP2P ( 3 , 1 : 3 , IBC_NEUMANN ) = d1rP2P ( 3 , 1 : 3 , IBC_PERIODIC ) !========================================================================================================== ! Set 3: Dirichlet for C2C (unique), check is involved bc value necessary? !!! !       influence all 1st_deri_C2C with Dirichlet BC. ! 1st derivative on collocated grids, C2C/P2P coefficients : Dirichlet B.C. ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) ! f'{1} + alpha f'{2} = 1/h (a * f{1'} + b * f{1} + c * f{2} + d * f{3}) ! up to 4th order, to solve below equations: !    a +   b + c   +  d = 0 !   -a +  2c +       4d = 2alpha + 2    !O(h1) !    a +  4c +      16d = 8alpha        !O(h2) !   -a +  8c +      64d = 24alpha       !O(h3) !    a + 16c +     256d = 64alpha       !O(h4) !========================================================================================================== alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! degrade to 2nd CD (1st cell), 2nd CD (2nd cell) alpha1 = ZERO a1 = ZERO b1 = - ONE c1 = ONE d1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO else if ( iaccu == IACCU_CD4 ) then ! degrade to 3rd CD (1st cell), 2nd CD (2nd cell), chech stencil ! method 1 = with bc value, a/=0 ! alpha1 = ZERO !     a1 = - SIXTEEN / FIFTEEN !     b1 = ONE / TWO !     c1 = TWO_THIRD !     d1 = - ONE / TEN ! method 2 = without bc value, a=0 alpha1 = ZERO a1 = ZERO b1 = - THREE / TWO c1 = TWO d1 = - HALF alpha2 = ZERO a2 = ONE b2 = ZERO else if ( iaccu == IACCU_CP4 ) then ! degrade to 3rd CP (1st cell), 4th CP (2nd cell) ! method 1 = with bc value, a/=0 ! alpha1 = TWO_THIRD !     a1 = - THIRTYTWO / FOURTYFIVE !     b1 = - ONE / TWO !     c1 = TEN / NINE !     d1 = ONE * ZPONE ! method 2 = without bc value, a=0 alpha1 = ONE a1 = ZERO b1 = - TWO c1 = TWO d1 = ZERO alpha2 = QUARTER a2 = ONEPFIVE b2 = ZERO else if ( iaccu == IACCU_CP6 ) then ! degrade to 4th CP (1st cell), 4th CP (2nd cell) ! method 1 = with bc value, a/=0 ! alpha1 = TWO_THIRD !     a1 = - THIRTYTWO / FOURTYFIVE !     b1 = - ONE / TWO !     c1 = TEN / NINE !     d1 = ONE * ZPONE ! method 2 = without bc value, a=0, same as INTPL alpha1 = TWO a1 = ZERO b1 = - TWOPFIVE c1 = TWO d1 = HALF alpha2 = QUARTER a2 = ONEPFIVE b2 = ZERO else ! default 2nd CD alpha1 = ZERO a1 = ZERO b1 = - ONE c1 = ONE d1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO end if !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2C : Dirchlet ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1'}/h  + b1 * f_{1}/h + c1 * f_{2}/h + d1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2/2 * (f_{3} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i] [ a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4] [a2/2 * (f_{n} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n'+1}/h -b1 * f_{n}/h  - c1 * f_{n-1}/h - d1 * f_{n-2}/h] !---------------------------------------------------------------------------------------------------------- d1fC2C ( 1 , 1 , IBC_DIRICHLET ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_DIRICHLET ) = ONE d1fC2C ( 1 , 3 , IBC_DIRICHLET ) = alpha1 d1rC2C ( 1 , 1 , IBC_DIRICHLET ) = a1 d1rC2C ( 1 , 2 , IBC_DIRICHLET ) = b1 d1rC2C ( 1 , 3 , IBC_DIRICHLET ) = c1 d1rC2C ( 1 , 4 , IBC_DIRICHLET ) = d1 d1fC2C ( 5 , 1 , IBC_DIRICHLET ) = d1fC2C ( 1 , 3 , IBC_DIRICHLET ) d1fC2C ( 5 , 2 , IBC_DIRICHLET ) = d1fC2C ( 1 , 2 , IBC_DIRICHLET ) d1fC2C ( 5 , 3 , IBC_DIRICHLET ) = d1fC2C ( 1 , 1 , IBC_DIRICHLET ) d1rC2C ( 5 , 1 , IBC_DIRICHLET ) = - d1rC2C ( 1 , 1 , IBC_DIRICHLET ) d1rC2C ( 5 , 2 , IBC_DIRICHLET ) = - d1rC2C ( 1 , 2 , IBC_DIRICHLET ) d1rC2C ( 5 , 3 , IBC_DIRICHLET ) = - d1rC2C ( 1 , 3 , IBC_DIRICHLET ) d1rC2C ( 5 , 4 , IBC_DIRICHLET ) = - d1rC2C ( 1 , 4 , IBC_DIRICHLET ) d1fC2C ( 2 , 1 , IBC_DIRICHLET ) = alpha2 d1fC2C ( 2 , 2 , IBC_DIRICHLET ) = ONE d1fC2C ( 2 , 3 , IBC_DIRICHLET ) = alpha2 d1rC2C ( 2 , 1 , IBC_DIRICHLET ) = a2 * HALF d1rC2C ( 2 , 2 , IBC_DIRICHLET ) = b2 * QUARTER ! not used d1rC2C ( 2 , 3 , IBC_DIRICHLET ) = c2 d1fC2C ( 4 , 1 , IBC_DIRICHLET ) = d1fC2C ( 2 , 3 , IBC_DIRICHLET ) d1fC2C ( 4 , 2 , IBC_DIRICHLET ) = d1fC2C ( 2 , 2 , IBC_DIRICHLET ) d1fC2C ( 4 , 3 , IBC_DIRICHLET ) = d1fC2C ( 2 , 1 , IBC_DIRICHLET ) d1rC2C ( 4 , 1 , IBC_DIRICHLET ) = d1rC2C ( 2 , 1 , IBC_DIRICHLET ) d1rC2C ( 4 , 2 , IBC_DIRICHLET ) = d1rC2C ( 2 , 2 , IBC_DIRICHLET ) d1rC2C ( 4 , 3 , IBC_DIRICHLET ) = d1rC2C ( 2 , 3 , IBC_DIRICHLET ) d1fC2C ( 3 , 1 : 3 , IBC_DIRICHLET ) = d1fC2C ( 3 , 1 : 3 , IBC_PERIODIC ) d1rC2C ( 3 , 1 : 3 , IBC_DIRICHLET ) = d1rC2C ( 3 , 1 : 3 , IBC_PERIODIC ) !========================================================================================================== ! 1st derivative on staggered grids P2C and C2P : Periodic or Symmetric B.C. ! P2C ==> ! alpha * f'_{i-1} +  f'_i +  alpha * f'_{i+1}  = a/(h ) * ( f_{i'+1} - f_{i'} ) + & !                                                 b/(3h) * ( f_{i'+2} - f_{i'-1} ) ! C2P ==> ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(h ) * ( f_{i}   - f_{i-1} ) + & !                                                 b/(3h) * ( f_{i+1} - f_{i-2} ) ! eq(1) : a +   b = 2   alpha + 1  !O(h2) ! eq(2) : a +  9b = 24  alpha      !O(h4) ! eq(3) : a + 81b = 160 alpha      !O(h6) !========================================================================================================== alpha = ZERO a = ZERO b = ZERO c = ZERO ! interface is a default CD4 alpha_itf = ZERO a_itf = NINE * EIGHTH b_itf = - ONE * EIGHTH c_itf = ZERO if ( iaccu == IACCU_CD2 ) then alpha = ZERO a = ONE b = ZERO else if ( iaccu == IACCU_CD4 ) then alpha = ZERO a = NINE * EIGHTH b = - ONE * EIGHTH else if ( iaccu == IACCU_CP4 ) then alpha = ONE / TWENTYTWO a = TWELVE / ELEVEN b = ZERO else if ( iaccu == IACCU_CP6 ) then alpha = NINE / SIXTYTWO a = SIXTYTHREE / SIXTYTWO b = SEVENTEEN / SIXTYTWO else ! default 2nd CD alpha = ZERO a = ONE b = ZERO end if !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P, P2C: periodic b.c. : staggered ! [ 1    alpha                   alpha][f'_1']=[a * (f_{1}   - f_{n})/h   + b/3 * (f_{2}   - f_{n-1})/h] ! [      alpha 1     alpha            ][f'_2'] [a * (f_{1}   - f_{1})/h   + b/3 * (f_{3}   - f_{n})/h  ] ! [            alpha 1     alpha      ][f'_i'] [a * (f_{i}   - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h] ! [                  alpha 1     alpha][f'_4'] [a * (f_{n-1} - f_{n-2})/h + b/3 * (f_{n}   - f_{n-3})/h] ! [alpha                   alpha 1    ][f'_5'] [a * (f_{n}   - f_{n-1})/h + b/3 * (f_{1}   - f_{n-2})/h] !---------------------------------------------------------------------------------------------------------- d1fC2P ( 1 : 5 , 1 , IBC_PERIODIC ) = alpha d1fC2P ( 1 : 5 , 2 , IBC_PERIODIC ) = ONE d1fC2P ( 1 : 5 , 3 , IBC_PERIODIC ) = alpha d1rC2P ( 1 : 5 , 1 , IBC_PERIODIC ) = a ! a d1rC2P ( 1 : 5 , 2 , IBC_PERIODIC ) = b * ONE_THIRD ! b/3 d1rC2P ( 1 : 5 , 3 , IBC_PERIODIC ) = c ! not used !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P : interior !---------------------------------------------------------------------------------------------------------- d1fC2P ( 1 , 1 , IBC_INTERIOR ) = alpha_itf d1fC2P ( 1 , 2 , IBC_INTERIOR ) = ONE d1fC2P ( 1 , 3 , IBC_INTERIOR ) = alpha_itf d1rC2P ( 1 , 1 , IBC_INTERIOR ) = a_itf d1rC2P ( 1 , 2 , IBC_INTERIOR ) = b_itf * ONE_THIRD ! b/3 d1rC2P ( 1 , 3 , IBC_INTERIOR ) = c_itf ! not used d1fC2P ( 5 , :, IBC_INTERIOR ) = d1fC2P ( 1 , :, IBC_INTERIOR ) d1rC2P ( 5 , :, IBC_INTERIOR ) = d1rC2P ( 1 , :, IBC_INTERIOR ) d1fC2P ( 2 : 4 , :, IBC_INTERIOR ) = d1fC2P ( 2 : 4 , :, IBC_PERIODIC ) d1rC2P ( 2 : 4 , :, IBC_INTERIOR ) = d1rC2P ( 2 : 4 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : periodic b.c.  Same as C2P !---------------------------------------------------------------------------------------------------------- d1fP2C (:, :, IBC_PERIODIC ) = d1fC2P (:, :, IBC_PERIODIC ) d1rP2C (:, :, IBC_PERIODIC ) = d1rC2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : interior.  Same as C2P !---------------------------------------------------------------------------------------------------------- d1fP2C (:, :, IBC_INTERIOR ) = d1fC2P (:, :, IBC_INTERIOR ) d1rP2C (:, :, IBC_INTERIOR ) = d1rC2P (:, :, IBC_INTERIOR ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P : symmetric b.c. ! [ 1     0                        ][f'_1]=[a * (f_{1}   - f_{1})/h   + b/3 * (f_{2}   - f_{2})/h   ] ! [ alpha 1     alpha              ][f'_2] [a * (f_{2}   - f_{1})/h   + b/3 * (f_{3}   - f_{1})/h   ] ! [       alpha 1     alpha        ][f'_i] [a * (f_{i}   - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h ] ! [             alpha 1     alpha  ][f'_4] [a * (f_{n-1} - f_{n-2})/h + b/3 * (f_{n-1} - f_{n-3})/h ] ! [                   0     1      ][f'_5] [a * (f_{n-1} - f_{n-1})/h + b/3 * (f_{n-2} - f_{n-2})/h ] !---------------------------------------------------------------------------------------------------------- d1fC2P ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_SYMMETRIC ) = ONE d1fC2P ( 1 , 3 , IBC_SYMMETRIC ) = ZERO d1fC2P ( 5 , 1 , IBC_SYMMETRIC ) = d1fC2P ( 1 , 3 , IBC_SYMMETRIC ) d1fC2P ( 5 , 2 , IBC_SYMMETRIC ) = d1fC2P ( 1 , 2 , IBC_SYMMETRIC ) d1fC2P ( 5 , 3 , IBC_SYMMETRIC ) = d1fC2P ( 1 , 1 , IBC_SYMMETRIC ) d1fC2P ( 2 : 4 , :, IBC_SYMMETRIC ) = d1fC2P ( 2 : 4 , :, IBC_PERIODIC ) d1rC2P (:, :, IBC_SYMMETRIC ) = d1rC2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P : asymmetric b.c. ! [ 1     2alpha                   ][f'_1]=[a * (f_{1}   + f_{1})/h   + b/3 * (f_{2}   + f_{2})/h   ] ! [ alpha 1     alpha              ][f'_2] [a * (f_{2}   - f_{1})/h   + b/3 * (f_{3}   + f_{1})/h   ] ! [       alpha 1     alpha        ][f'_i] [a * (f_{i}   - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h ] ! [             alpha 1     alpha  ][f'_4] [a * (f_{n-1} - f_{n-2})/h + b/3 * (-f_{n-1} - f_{n-3})/h ] ! [                   2alpha     1 ][f'_5] [a * (-f_{n-1} - f_{n-1})/h + b/3 * (-f_{n-2} - f_{n-2})/h ] !---------------------------------------------------------------------------------------------------------- d1fC2P ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_ASYMMETRIC ) = ONE d1fC2P ( 1 , 3 , IBC_ASYMMETRIC ) = TWO * alpha d1fC2P ( 5 , 1 , IBC_ASYMMETRIC ) = d1fC2P ( 1 , 3 , IBC_ASYMMETRIC ) d1fC2P ( 5 , 2 , IBC_ASYMMETRIC ) = d1fC2P ( 1 , 2 , IBC_ASYMMETRIC ) d1fC2P ( 5 , 3 , IBC_ASYMMETRIC ) = d1fC2P ( 1 , 1 , IBC_ASYMMETRIC ) d1fC2P ( 2 : 4 , :, IBC_ASYMMETRIC ) = d1fC2P ( 2 : 4 , :, IBC_PERIODIC ) d1rC2P (:, :, IBC_ASYMMETRIC ) = d1rC2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : symmetric b.c. ! [ 1-alpha  alpha                          ][f_1]=[a * (f_{2'}   - f_{1'})/h   + b/3 * (f_{3'}   - f_{2'})/h    ] ! [          alpha 1     alpha              ][f_2] [a * (f_{3'}   - f_{2'})/h   + b/3 * (f_{4'}   - f_{1'})/h    ] ! [                alpha 1     alpha        ][f_i] [a * (f_{i+1}  - f_{i-1})/h  + b/3 * (f_{i+2}  - f_{i-2})/h   ] ! [                      alpha 1     alpha  ][f_4] [a * (f_{n'}   - f_{n'-1})/h + b/3 * (f_{n'+1} - f_{n'-2})/h  ] ! [                            alpha 1-alpha][f_5] [a * (f_{n'+1} - f_{n'})/h   + b/3 * (f_{n'}   - f_{n'-1'})/h ] !---------------------------------------------------------------------------------------------------------- d1fP2C ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used d1fP2C ( 1 , 2 , IBC_SYMMETRIC ) = ONE - alpha d1fP2C ( 1 , 3 , IBC_SYMMETRIC ) = alpha d1fP2C ( 5 , 1 , IBC_SYMMETRIC ) = d1fP2C ( 1 , 3 , IBC_SYMMETRIC ) d1fP2C ( 5 , 2 , IBC_SYMMETRIC ) = d1fP2C ( 1 , 2 , IBC_SYMMETRIC ) d1fP2C ( 5 , 3 , IBC_SYMMETRIC ) = d1fP2C ( 1 , 1 , IBC_SYMMETRIC ) d1fP2C ( 2 : 4 , :, IBC_SYMMETRIC ) = d1fP2C ( 2 : 4 , :, IBC_PERIODIC ) d1rP2C (:, :, IBC_SYMMETRIC ) = d1rP2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : asymmetric b.c. ! [ 1+alpha  alpha                          ][f_1]=[a * (f_{2'}   - f_{1'})/h   + b/3 * (f_{3'}   + f_{2'})/h    ] ! [          alpha 1     alpha              ][f_2] [a * (f_{3'}   - f_{2'})/h   + b/3 * (f_{4'}   - f_{1'})/h    ] ! [                alpha 1     alpha        ][f_i] [a * (f_{i+1}  - f_{i-1})/h  + b/3 * (f_{i+2}  - f_{i-2})/h   ] ! [                      alpha 1     alpha  ][f_4] [a * (f_{n'}   - f_{n'-1})/h + b/3 * (f_{n'+1} - f_{n'-2})/h  ] ! [                            alpha 1+alpha][f_5] [a * (f_{n'+1} - f_{n'})/h   + b/3 * (-f_{n'}   - f_{n'-1'})/h ] !---------------------------------------------------------------------------------------------------------- d1fP2C ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used d1fP2C ( 1 , 2 , IBC_ASYMMETRIC ) = ONE + alpha d1fP2C ( 1 , 3 , IBC_ASYMMETRIC ) = alpha d1fP2C ( 5 , 1 , IBC_ASYMMETRIC ) = d1fP2C ( 1 , 3 , IBC_ASYMMETRIC ) d1fP2C ( 5 , 2 , IBC_ASYMMETRIC ) = d1fP2C ( 1 , 2 , IBC_ASYMMETRIC ) d1fP2C ( 5 , 3 , IBC_ASYMMETRIC ) = d1fP2C ( 1 , 1 , IBC_ASYMMETRIC ) d1fP2C ( 2 : 4 , :, IBC_ASYMMETRIC ) = d1fP2C ( 2 : 4 , :, IBC_PERIODIC ) d1rP2C (:, :, IBC_ASYMMETRIC ) = d1rP2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P : no specified, interpolation ! [ 1     alpha1                            ][f'_1']=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2'] [a2 * (f_{2} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i'] [a *  (f_{i} - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4'] [a2 * (f_{n-1} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5'] [-a1 * f_{n-1}/h  - b1 * f_{n-2}/h - c1 * f_{n-3}/h] ! eq(1): a +   b +    c = 0               !O(h1) ! eq(2): a + 3 b +  5 c = 2  alpha + 2    !O(h2) ! eq(3): a + 9 b + 25 c = 8  alpha        !O(h3) ! eq(4): a + 27b + 125c = 24 alpha        !O(h4) !---------------------------------------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! eq(1-2)+alpha0+c0, O(h2) alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CD4 ) then ! eq(1-3)+alpha0, O(h3) alpha1 = ZERO a1 = - TWO b1 = THREE c1 = - ONE alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP4 ) then ! eq(1-4), O(h4), no solution for c=0. alpha1 = TWENTYTHREE a1 = - TWENTYFIVE b1 = TWENTYSIX c1 = - ONE alpha2 = ONE / TWENTYTWO a2 = TWELVE / ELEVEN b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP6 ) then ! eq(1-4), O(h4) alpha1 = TWENTYTHREE a1 = - TWENTYFIVE b1 = TWENTYSIX c1 = - ONE alpha2 = ONE / TWENTYTWO a2 = TWELVE / ELEVEN b2 = ZERO ! not used c2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used end if d1fC2P ( 1 , 1 , IBC_INTRPL ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_INTRPL ) = ONE d1fC2P ( 1 , 3 , IBC_INTRPL ) = alpha1 d1rC2P ( 1 , 1 , IBC_INTRPL ) = a1 d1rC2P ( 1 , 2 , IBC_INTRPL ) = b1 d1rC2P ( 1 , 3 , IBC_INTRPL ) = c1 d1fC2P ( 5 , 1 , IBC_INTRPL ) = d1fC2P ( 1 , 3 , IBC_INTRPL ) d1fC2P ( 5 , 2 , IBC_INTRPL ) = d1fC2P ( 1 , 2 , IBC_INTRPL ) d1fC2P ( 5 , 3 , IBC_INTRPL ) = d1fC2P ( 1 , 1 , IBC_INTRPL ) d1rC2P ( 5 , 1 , IBC_INTRPL ) = - d1rC2P ( 1 , 1 , IBC_INTRPL ) d1rC2P ( 5 , 2 , IBC_INTRPL ) = - d1rC2P ( 1 , 2 , IBC_INTRPL ) d1rC2P ( 5 , 3 , IBC_INTRPL ) = - d1rC2P ( 1 , 3 , IBC_INTRPL ) d1fC2P ( 2 , 1 , IBC_INTRPL ) = alpha2 d1fC2P ( 2 , 2 , IBC_INTRPL ) = ONE d1fC2P ( 2 , 3 , IBC_INTRPL ) = alpha2 d1rC2P ( 2 , 1 , IBC_INTRPL ) = a2 d1rC2P ( 2 , 2 , IBC_INTRPL ) = b2 * ONE_THIRD ! not used d1rC2P ( 2 , 3 , IBC_INTRPL ) = c2 ! not used d1fC2P ( 4 , 1 , IBC_INTRPL ) = d1fC2P ( 2 , 1 , IBC_INTRPL ) d1fC2P ( 4 , 2 , IBC_INTRPL ) = d1fC2P ( 2 , 2 , IBC_INTRPL ) d1fC2P ( 4 , 3 , IBC_INTRPL ) = d1fC2P ( 2 , 3 , IBC_INTRPL ) d1rC2P ( 4 , 1 , IBC_INTRPL ) = d1rC2P ( 2 , 1 , IBC_INTRPL ) d1rC2P ( 4 , 2 , IBC_INTRPL ) = d1rC2P ( 2 , 2 , IBC_INTRPL ) d1rC2P ( 4 , 3 , IBC_INTRPL ) = d1rC2P ( 2 , 3 , IBC_INTRPL ) d1fC2P ( 3 , :, IBC_INTRPL ) = d1fC2P ( 3 , :, IBC_PERIODIC ) d1rC2P ( 3 , :, IBC_INTRPL ) = d1rC2P ( 3 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P : neumann ! [ 1     0                                 ][f'_1']=[known] ! [alpha2 1      alpha2                     ][f'_2'] [a2 * (f_{2} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i'] [a *  (f_{i} - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4'] [a2 * (f_{n-1} - f_{n-2})/h] ! [                            0      1     ][f'_5'] [known] !---------------------------------------------------------------------------------------------------------- d1fC2P ( 1 , 1 , IBC_NEUMANN ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_NEUMANN ) = ONE d1fC2P ( 1 , 3 , IBC_NEUMANN ) = ZERO d1rC2P ( 1 , 1 , IBC_NEUMANN ) = ZERO ! not used d1rC2P ( 1 , 2 , IBC_NEUMANN ) = ZERO ! not used d1rC2P ( 1 , 3 , IBC_NEUMANN ) = ZERO ! not used d1fC2P ( 5 , 1 , IBC_NEUMANN ) = d1fC2P ( 1 , 3 , IBC_NEUMANN ) d1fC2P ( 5 , 2 , IBC_NEUMANN ) = d1fC2P ( 1 , 2 , IBC_NEUMANN ) d1fC2P ( 5 , 3 , IBC_NEUMANN ) = d1fC2P ( 1 , 1 , IBC_NEUMANN ) d1rC2P ( 5 , 1 , IBC_NEUMANN ) = d1rC2P ( 1 , 1 , IBC_NEUMANN ) d1rC2P ( 5 , 2 , IBC_NEUMANN ) = d1rC2P ( 1 , 2 , IBC_NEUMANN ) d1rC2P ( 5 , 3 , IBC_NEUMANN ) = d1rC2P ( 1 , 3 , IBC_NEUMANN ) d1fC2P ( 2 , 1 , IBC_NEUMANN ) = alpha2 d1fC2P ( 2 , 2 , IBC_NEUMANN ) = ONE d1fC2P ( 2 , 3 , IBC_NEUMANN ) = alpha2 d1rC2P ( 2 , 1 , IBC_NEUMANN ) = a2 d1rC2P ( 2 , 2 , IBC_NEUMANN ) = b2 * ONE_THIRD ! not used d1rC2P ( 2 , 3 , IBC_NEUMANN ) = c2 ! not used d1fC2P ( 4 , 1 , IBC_NEUMANN ) = d1fC2P ( 2 , 1 , IBC_NEUMANN ) d1fC2P ( 4 , 2 , IBC_NEUMANN ) = d1fC2P ( 2 , 2 , IBC_NEUMANN ) d1fC2P ( 4 , 3 , IBC_NEUMANN ) = d1fC2P ( 2 , 3 , IBC_NEUMANN ) d1rC2P ( 4 , 1 , IBC_NEUMANN ) = d1rC2P ( 2 , 1 , IBC_NEUMANN ) d1rC2P ( 4 , 2 , IBC_NEUMANN ) = d1rC2P ( 2 , 2 , IBC_NEUMANN ) d1rC2P ( 4 , 3 , IBC_NEUMANN ) = d1rC2P ( 2 , 3 , IBC_NEUMANN ) d1fC2P ( 3 , :, IBC_NEUMANN ) = d1fC2P ( 3 , :, IBC_PERIODIC ) d1rC2P ( 3 , :, IBC_NEUMANN ) = d1rC2P ( 3 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! C2P : Dirichlet ! [ 1     alpha1                            ][f'_1']=[a1 * f_{1'}/h + b1 * f_{1}/h  + c1 * f_{2}/h + d1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2'] [a2 * (f_{2} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i'] [a *  (f_{i} - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4'] [a2 * (f_{n-1} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5'] [-a1 * f_{n'}/h - b1 * f_{n-1}/h  - c1 * f_{n-2}/h - d1 * f_{n-3}/h] !---------------------------------------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! degrade to 1st CD, check other accuracy in this set. Check!!! alpha1 = ZERO a1 = ZERO ! not used. b1 = - ONE ! check. If a default asymmetric is used to achive dirichlet 0, a1=2, b1=0. c1 = ONE d1 = ZERO ! method 2 not to use the Dirichlet B.C. value, tested it and it is wrong. ! alpha1 = ZERO !     a1 = - EIGHT * ONE_THIRD !     b1 = THREE !     c1 = - ONE_THIRD !     d1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CD4 ) then ! degrade to 2nd CD ! method 1 to use the Dirichlet B.C. value, check is this necessary? !!! ! alpha1 = ZERO !     a1 = - EIGHT * ONE_THIRD !     b1 = THREE !     c1 = - ONE_THIRD !     d1 = ZERO ! method 2 not to use the Dirichlet B.C. value alpha1 = ZERO a1 = ZERO b1 = - TWO c1 = THREE d1 = - ONE alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP4 ) then ! degrade to 3rd CP ! method 1 to use the Dirichlet B.C. value, check is this necessary? !!! ! alpha1 = THREE !     a1 = - EIGHT * ONE_THIRD !     b1 = ZERO !     c1 = EIGHT * ONE_THIRD !     d1 = ZERO ! method 2 not to use the Dirichlet B.C. value alpha1 = TWENTYTHREE a1 = ZERO b1 = - TWENTYFIVE c1 = TWENTYSIX d1 = - ONE alpha2 = ONE / TWENTYTWO a2 = TWELVE / ELEVEN b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP6 ) then ! degrade to 4th CP ! method 1 to use the Dirichlet B.C. value, check is this necessary? !!! ! alpha1 = FIFTEEN !     a1 = - SIXTEEN / FIFTEEN !     b1 = - FIFTEEN !     c1 = FIFTY * ONE_THIRD !     d1 = - THREE * ZPTWO alpha1 = TWENTYTHREE a1 = ZERO b1 = - TWENTYFIVE c1 = TWENTYSIX d1 = - ONE alpha2 = ONE / TWENTYTWO a2 = TWELVE / ELEVEN b2 = ZERO ! not used c2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = ZERO b1 = - ONE c1 = ONE d1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used end if d1fC2P ( 1 , 1 , IBC_DIRICHLET ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_DIRICHLET ) = ONE d1fC2P ( 1 , 3 , IBC_DIRICHLET ) = alpha1 d1rC2P ( 1 , 1 , IBC_DIRICHLET ) = a1 d1rC2P ( 1 , 2 , IBC_DIRICHLET ) = b1 d1rC2P ( 1 , 3 , IBC_DIRICHLET ) = c1 d1rC2P ( 1 , 4 , IBC_DIRICHLET ) = d1 d1fC2P ( 5 , 1 , IBC_DIRICHLET ) = d1fC2P ( 1 , 3 , IBC_DIRICHLET ) d1fC2P ( 5 , 2 , IBC_DIRICHLET ) = d1fC2P ( 1 , 2 , IBC_DIRICHLET ) d1fC2P ( 5 , 3 , IBC_DIRICHLET ) = d1fC2P ( 1 , 1 , IBC_DIRICHLET ) d1rC2P ( 5 , 1 , IBC_DIRICHLET ) = - d1rC2P ( 1 , 1 , IBC_DIRICHLET ) d1rC2P ( 5 , 2 , IBC_DIRICHLET ) = - d1rC2P ( 1 , 2 , IBC_DIRICHLET ) d1rC2P ( 5 , 3 , IBC_DIRICHLET ) = - d1rC2P ( 1 , 3 , IBC_DIRICHLET ) d1rC2P ( 5 , 4 , IBC_DIRICHLET ) = - d1rC2P ( 1 , 4 , IBC_DIRICHLET ) d1fC2P ( 2 , 1 , IBC_DIRICHLET ) = alpha2 d1fC2P ( 2 , 2 , IBC_DIRICHLET ) = ONE d1fC2P ( 2 , 3 , IBC_DIRICHLET ) = alpha2 d1rC2P ( 2 , 1 , IBC_DIRICHLET ) = a2 d1rC2P ( 2 , 2 , IBC_DIRICHLET ) = b2 * ONE_THIRD ! not used d1rC2P ( 2 , 3 , IBC_DIRICHLET ) = c2 ! not used d1fC2P ( 4 , 1 , IBC_DIRICHLET ) = d1fC2P ( 2 , 1 , IBC_DIRICHLET ) d1fC2P ( 4 , 2 , IBC_DIRICHLET ) = d1fC2P ( 2 , 2 , IBC_DIRICHLET ) d1fC2P ( 4 , 3 , IBC_DIRICHLET ) = d1fC2P ( 2 , 3 , IBC_DIRICHLET ) d1rC2P ( 4 , 1 , IBC_DIRICHLET ) = d1rC2P ( 2 , 1 , IBC_DIRICHLET ) d1rC2P ( 4 , 2 , IBC_DIRICHLET ) = d1rC2P ( 2 , 2 , IBC_DIRICHLET ) d1rC2P ( 4 , 3 , IBC_DIRICHLET ) = d1rC2P ( 2 , 3 , IBC_DIRICHLET ) d1fC2P ( 3 , :, IBC_DIRICHLET ) = d1fC2P ( 3 , :, IBC_PERIODIC ) d1rC2P ( 3 , :, IBC_DIRICHLET ) = d1rC2P ( 3 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : no specified = Dirichlet B.C. ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1'}/h  + b1 * f_{2'}/h + c1 * f_{3'}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2 * (f_{3'} - f_{2'})/h  ] ! [       alpha  1      alpha               ][f'_i] [a *  (f_{i'+1} - f_{i'})/h + b/3 * (f_{i'+2} - f_{i'-1})/h] ! [                     alpha2 1      alpha2][f'_4] [a2 * (f_{n'} - f_{n'-1})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n'+1}/h  - b1 * f_{n'}/h - c1 * f_{n'-1}/h] ! eq(1): a +   b +    c = 0               !O(h1) ! eq(2):-a +   b +  3 c = 2  alpha + 2    !O(h2) ! eq(3): a +   b +  9 c = 8  alpha        !O(h3) ! eq(4):-a +   b +  27c = 24 alpha        !O(h4) !---------------------------------------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! eq(1-2)+alpha0+c0, O(h2) alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CD4 ) then ! eq(1-3)+alpha0, O(h3) alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP4 ) then ! eq(1-3)+c0, O(h3) alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO alpha2 = ONE / TWENTYTWO a2 = TWELVE / ELEVEN b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP6 ) then ! eq(1-4), O(h4) alpha1 = - ONE a1 = - ONE b1 = TWO c1 = - ONE alpha2 = ONE / TWENTYTWO a2 = TWELVE / ELEVEN b2 = ZERO ! not used c2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = - ONE b1 = ONE c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used end if d1fP2C ( 1 , 1 , IBC_INTRPL ) = alpha1 ! not used d1fP2C ( 1 , 2 , IBC_INTRPL ) = ONE d1fP2C ( 1 , 3 , IBC_INTRPL ) = alpha1 d1rP2C ( 1 , 1 , IBC_INTRPL ) = a1 d1rP2C ( 1 , 2 , IBC_INTRPL ) = b1 d1rP2C ( 1 , 3 , IBC_INTRPL ) = c1 d1fP2C ( 5 , 1 , IBC_INTRPL ) = d1fP2C ( 1 , 3 , IBC_INTRPL ) d1fP2C ( 5 , 2 , IBC_INTRPL ) = d1fP2C ( 1 , 2 , IBC_INTRPL ) d1fP2C ( 5 , 3 , IBC_INTRPL ) = d1fP2C ( 1 , 1 , IBC_INTRPL ) d1rP2C ( 5 , 1 , IBC_INTRPL ) = - d1rP2C ( 1 , 1 , IBC_INTRPL ) d1rP2C ( 5 , 2 , IBC_INTRPL ) = - d1rP2C ( 1 , 2 , IBC_INTRPL ) d1rP2C ( 5 , 3 , IBC_INTRPL ) = - d1rP2C ( 1 , 3 , IBC_INTRPL ) d1fP2C ( 2 : 4 , :, IBC_INTRPL ) = d1fP2C ( 2 : 4 , :, IBC_PERIODIC ) d1rP2C ( 2 : 4 , :, IBC_INTRPL ) = d1rP2C ( 2 : 4 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : no specified = Dirichlet B.C. = Neumann !---------------------------------------------------------------------------------------------------------- d1fP2C (:, :, IBC_DIRICHLET ) = d1fP2C (:, :, IBC_INTRPL ) d1rP2C (:, :, IBC_DIRICHLET ) = d1rP2C (:, :, IBC_INTRPL ) d1fP2C (:, :, IBC_NEUMANN ) = d1fP2C (:, :, IBC_INTRPL ) d1rP2C (:, :, IBC_NEUMANN ) = d1rP2C (:, :, IBC_INTRPL ) !========================================================================================================== !interpolation. P2C and C2P Periodic or Symmetric B.C. ! P2C : i_max = nc ! alpha * f_{i-1} + f_i + alpha * f_{i+1} =    a/2 * ( f_{i'}   + f_{i'+1} ) + & !                                              b/2 * ( f_{i'+2} + f_{i'-1} ) ! C2P : i'_max = np ! alpha * f_{i'-1} + f_i' + alpha * f_{i'+1} = a/2 * ( f_{i}   + f_{i-1} ) + & !                                              b/2 * ( f_{i+1} + f_{i-2} ) ! eq(1): a +   b = 2  alpha + 1   !O(h2) ! eq(2): a + 9 b = 8  alpha       !O(h4) ! eq(3): a + 81b = 32 alpha       !O(h6) !========================================================================================================== alpha = ZERO a = ONE b = ZERO c = ZERO ! interface = default CD4 alpha_itf = ZERO a_itf = NINE * EIGHTH b_itf = - ONE * EIGHTH c_itf = ZERO if ( iaccu == IACCU_CD2 ) then alpha = ZERO a = ONE b = ZERO else if ( iaccu == IACCU_CD4 ) then alpha = ZERO a = NINE * EIGHTH b = - ONE * EIGHTH else if ( iaccu == IACCU_CP4 ) then alpha = ONE / SIX a = FOUR * ONE_THIRD b = ZERO else if ( iaccu == IACCU_CP6 ) then alpha = THREE * ZPONE a = ONEPFIVE b = ONE * ZPONE else ! default 2nd CD alpha = ZERO a = ONE b = ZERO end if !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P: periodic & symmetric ! [ 1    alpha                   alpha][f_1']=[a/2 * (f_{1}   + f_{n})   + b/2 * (f_{2}   + f_{n-1})] ! [      alpha 1     alpha            ][f_2'] [a/2 * (f_{3}   + f_{n})   + b/2 * (f_{2}   + f_{1})  ] ! [            alpha 1     alpha      ][f_i'] [a/2 * (f_{i}   + f_{i-1}) + b/2 * (f_{i+1} + f_{i-2})] ! [                  alpha 1     alpha][f_4'] [a/2 * (f_{n}   + f_{n-3}) + b/2 * (f_{n-1} + f_{n-2})] ! [alpha                   alpha 1    ][f_5'] [a/2 * (f_{1}   + f_{n-2}) + b/2 * (f_{n}   + f_{n-1})] !----------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !interpolation. C2P for periodic b.c. !---------------------------------------------------------------------------------------------------------- m1fC2P ( 1 : 5 , 1 , IBC_PERIODIC ) = alpha m1fC2P ( 1 : 5 , 2 , IBC_PERIODIC ) = ONE m1fC2P ( 1 : 5 , 3 , IBC_PERIODIC ) = alpha m1rC2P ( 1 : 5 , 1 , IBC_PERIODIC ) = a * HALF m1rC2P ( 1 : 5 , 2 , IBC_PERIODIC ) = b * HALF m1rC2P ( 1 : 5 , 3 , IBC_PERIODIC ) = c ! not used !---------------------------------------------------------------------------------------------------------- ! interpolation : ! C2P : interior !---------------------------------------------------------------------------------------------------------- m1fC2P ( 1 , 1 , IBC_INTERIOR ) = alpha_itf m1fC2P ( 1 , 2 , IBC_INTERIOR ) = ONE m1fC2P ( 1 , 3 , IBC_INTERIOR ) = alpha_itf m1rC2P ( 1 , 1 , IBC_INTERIOR ) = a_itf * HALF ! a/2 m1rC2P ( 1 , 2 , IBC_INTERIOR ) = b_itf * HALF ! b/4 m1rC2P ( 1 , 3 , IBC_INTERIOR ) = c_itf ! not used m1fC2P ( 5 , :, IBC_INTERIOR ) = m1fC2P ( 1 , :, IBC_INTERIOR ) m1rC2P ( 5 , :, IBC_INTERIOR ) = m1rC2P ( 1 , :, IBC_INTERIOR ) m1fC2P ( 2 : 4 , :, IBC_INTERIOR ) = m1fC2P ( 2 : 4 , :, IBC_PERIODIC ) m1rC2P ( 2 : 4 , :, IBC_INTERIOR ) = m1rC2P ( 2 : 4 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- !interpolation. P2C for periodic b.c. !---------------------------------------------------------------------------------------------------------- m1fP2C (:, :, IBC_PERIODIC ) = m1fC2P (:, :, IBC_PERIODIC ) m1rP2C (:, :, IBC_PERIODIC ) = m1rC2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! interpolation : ! P2C : interior !---------------------------------------------------------------------------------------------------------- m1fP2C (:, :, IBC_INTERIOR ) = m1fC2P (:, :, IBC_INTERIOR ) m1rP2C (:, :, IBC_INTERIOR ) = m1rC2P (:, :, IBC_INTERIOR ) !---------------------------------------------------------------------------------------------------------- !interpolation. C2P. symmetric, orthogonal, eg. u in y direction. !---------------------------------------------------------------------------------------------------------- m1fC2P ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_SYMMETRIC ) = ONE m1fC2P ( 1 , 3 , IBC_SYMMETRIC ) = alpha + alpha m1fC2P ( 5 , 1 , IBC_SYMMETRIC ) = m1fC2P ( 1 , 3 , IBC_SYMMETRIC ) m1fC2P ( 5 , 2 , IBC_SYMMETRIC ) = m1fC2P ( 1 , 2 , IBC_SYMMETRIC ) m1fC2P ( 5 , 3 , IBC_SYMMETRIC ) = m1fC2P ( 1 , 1 , IBC_SYMMETRIC ) m1fC2P ( 2 : 4 , :, IBC_SYMMETRIC ) = m1fC2P ( 2 : 4 , :, IBC_PERIODIC ) m1rC2P (:, :, IBC_SYMMETRIC ) = m1rC2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- !interpolation. C2P. asymmetric, orthogonal, eg. v in y direction. !---------------------------------------------------------------------------------------------------------- m1fC2P ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_ASYMMETRIC ) = ONE m1fC2P ( 1 , 3 , IBC_ASYMMETRIC ) = ZERO m1fC2P ( 5 , 1 , IBC_ASYMMETRIC ) = m1fC2P ( 1 , 3 , IBC_ASYMMETRIC ) m1fC2P ( 5 , 2 , IBC_ASYMMETRIC ) = m1fC2P ( 1 , 2 , IBC_ASYMMETRIC ) m1fC2P ( 5 , 3 , IBC_ASYMMETRIC ) = m1fC2P ( 1 , 1 , IBC_ASYMMETRIC ) m1fC2P ( 2 : 4 , :, IBC_ASYMMETRIC ) = m1fC2P ( 2 : 4 , :, IBC_PERIODIC ) m1rC2P (:, :, IBC_ASYMMETRIC ) = m1rC2P (:, :, IBC_PERIODIC ) m1rC2P ( 1 , :, IBC_ASYMMETRIC ) = ZERO ! double safe, not necessary m1rC2P ( 5 , :, IBC_ASYMMETRIC ) = ZERO !---------------------------------------------------------------------------------------------------------- !interpolation. P2C. symmetric, orthogonal, eg. u in y direction. !---------------------------------------------------------------------------------------------------------- m1fP2C ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used m1fP2C ( 1 , 2 , IBC_SYMMETRIC ) = ONE + alpha m1fP2C ( 1 , 3 , IBC_SYMMETRIC ) = alpha m1fP2C ( 5 , 1 , IBC_SYMMETRIC ) = m1fP2C ( 1 , 3 , IBC_SYMMETRIC ) m1fP2C ( 5 , 2 , IBC_SYMMETRIC ) = m1fP2C ( 1 , 2 , IBC_SYMMETRIC ) m1fP2C ( 5 , 3 , IBC_SYMMETRIC ) = m1fP2C ( 1 , 1 , IBC_SYMMETRIC ) m1fP2C ( 2 : 4 , :, IBC_SYMMETRIC ) = m1fP2C ( 2 : 4 , :, IBC_PERIODIC ) m1rP2C (:, :, IBC_SYMMETRIC ) = m1rP2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- !interpolation. P2C. asymmetric, orthogonal, eg. v in y direction. !---------------------------------------------------------------------------------------------------------- m1fP2C ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used m1fP2C ( 1 , 2 , IBC_ASYMMETRIC ) = ONE - alpha m1fP2C ( 1 , 3 , IBC_ASYMMETRIC ) = alpha m1fP2C ( 5 , 1 , IBC_ASYMMETRIC ) = m1fP2C ( 1 , 3 , IBC_ASYMMETRIC ) m1fP2C ( 5 , 2 , IBC_ASYMMETRIC ) = m1fP2C ( 1 , 2 , IBC_ASYMMETRIC ) m1fP2C ( 5 , 3 , IBC_ASYMMETRIC ) = m1fP2C ( 1 , 1 , IBC_ASYMMETRIC ) m1fP2C ( 2 : 4 , :, IBC_ASYMMETRIC ) = m1fP2C ( 2 : 4 , :, IBC_PERIODIC ) m1rP2C (:, :, IBC_ASYMMETRIC ) = m1rP2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! interpolation. P2C: Dirichlet = no specified = Neumann ! [ 1    alpha1                          ][f_1']=[a1 * f_{1'} + b1 * f_{2'} + c1 * f_{3'}  ] ! [      alpha2 1     alpha2             ][f_2'] [a2/2 * (f_{2'}   + f_{3'})] ! [             alpha 1      alpha       ][f_i'] [a/2  * (f_{i'}   + f_{i'+1}) + b/2 * (f_{i'+2} + f_{i'-1})] ! [                   alpha2 1     alpha2][f_4'] [a2/2 * (f_{n'-1}   + f_{n'})] ! [                          alpha1 1    ][f_5'] [a1   * f_{n'+1} + b1 * f_{n'} + c1 * f_{n'-1}] ! eq(1): a + b +   c =   alpha + 1   !O(h1) ! eq(2):-a + b + 3 c = 2 alpha       !O(h2) ! eq(3): a + b + 9 c = 4 alpha       !O(h3) ! eq(4):-a + b + 27c = 8 alpha       !O(h4) !----------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! eq(1-2)+alpha0+c0, O(h2) alpha1 = ZERO a1 = HALF b1 = HALF c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CD4 ) then ! eq(1-3)+alpha0, O(h3) alpha1 = ZERO a1 = THREE * EIGHTH b1 = THREE * QUARTER c1 = - ONE * EIGHTH alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP4 ) then ! eq(1-3)+c0, O(h3) alpha1 = ONE_THIRD a1 = ONE_THIRD b1 = ONE c1 = ZERO alpha2 = ONE / SIX a2 = FOUR * ONE_THIRD b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP6 ) then ! eq(1-4), O(h4) alpha1 = ONE a1 = QUARTER b1 = ONEPFIVE c1 = QUARTER alpha2 = ONE / SIX a2 = FOUR * ONE_THIRD b2 = ZERO ! not used c2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = HALF b1 = HALF c1 = ONE alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used end if !P2C m1fP2C ( 1 , 1 , IBC_INTRPL ) = ZERO ! not used m1fP2C ( 1 , 2 , IBC_INTRPL ) = ONE m1fP2C ( 1 , 3 , IBC_INTRPL ) = alpha1 m1rP2C ( 1 , 1 , IBC_INTRPL ) = a1 m1rP2C ( 1 , 2 , IBC_INTRPL ) = b1 m1rP2C ( 1 , 3 , IBC_INTRPL ) = c1 m1fP2C ( 5 , 1 , IBC_INTRPL ) = m1fP2C ( 1 , 3 , IBC_INTRPL ) m1fP2C ( 5 , 2 , IBC_INTRPL ) = m1fP2C ( 1 , 2 , IBC_INTRPL ) m1fP2C ( 5 , 3 , IBC_INTRPL ) = m1fP2C ( 1 , 1 , IBC_INTRPL ) m1rP2C ( 5 , 1 , IBC_INTRPL ) = m1rP2C ( 1 , 1 , IBC_INTRPL ) m1rP2C ( 5 , 2 , IBC_INTRPL ) = m1rP2C ( 1 , 2 , IBC_INTRPL ) m1rP2C ( 5 , 3 , IBC_INTRPL ) = m1rP2C ( 1 , 3 , IBC_INTRPL ) m1fP2C ( 2 : 4 , :, IBC_INTRPL ) = m1fP2C ( 2 : 4 , :, IBC_PERIODIC ) m1rP2C ( 2 : 4 , :, IBC_INTRPL ) = m1rP2C ( 2 : 4 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! interpolation. P2C: Dirichlet = no specified = Neumann !---------------------------------------------------------------------------------------------------------- m1fP2C (:, :, IBC_DIRICHLET ) = m1fP2C (:, :, IBC_INTRPL ) m1rP2C (:, :, IBC_DIRICHLET ) = m1rP2C (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! interpolation. P2C: Dirichlet = no specified = Neumann !---------------------------------------------------------------------------------------------------------- m1fP2C (:, :, IBC_NEUMANN ) = m1fP2C (:, :, IBC_INTRPL ) m1rP2C (:, :, IBC_NEUMANN ) = m1rP2C (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P: No specified = neumann ! [ 1    alpha1                          ][f_1']=[a1 * f_{1} + b1 * f_{2} + c1 * f_{3}  ] ! [      alpha2 1     alpha2             ][f_2'] [a2/2 * (f_{2}   + f_{1})] ! [             alpha 1      alpha       ][f_i'] [a/2 * (f_{i}   + f_{i-1}) + b/2 * (f_{i+1} + f_{i-2})] ! [                   alpha2 1     alpha2][f_4'] [a2/2 * (f_{n-1}   + f_{n-2})] ! [                          alpha1 1    ][f_5'] [a1 * f_{n-1} + b1 * f_{n-2} + c1 * f_{n-3}] ! eq(1): a +   b +    c =   alpha + 1   !O(h1) ! eq(2): a + 3 b +  5 c = 2 alpha       !O(h2) ! eq(3): a + 9 b + 25 c = 4 alpha       !O(h3) ! eq(4): a + 27b + 125c = 8 alpha       !O(h4) !----------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 ) then ! eq(1-2)+alpha0+c0, O(h2) alpha1 = ZERO a1 = ONEPFIVE b1 = - HALF c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CD4 ) then ! eq(1-3)+alpha0, O(h3) alpha1 = ZERO a1 = FIFTEEN * EIGHTH b1 = - FIVE * QUARTER c1 = THREE * EIGHTH alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP4 ) then ! eq(1-3)+c0, O(h3) alpha1 = THREE a1 = THREE b1 = ONE c1 = ZERO alpha2 = ONE / SIX a2 = FOUR * ONE_THIRD b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP6 ) then ! eq(1-4), O(h4) alpha1 = FIVE a1 = FIFTEEN * QUARTER b1 = TWOPFIVE c1 = - QUARTER alpha2 = ONE / SIX a2 = FOUR * ONE_THIRD b2 = ZERO ! not used c2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = ONEPFIVE b1 = - HALF c1 = ZERO alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used end if m1fC2P ( 1 , 1 , IBC_INTRPL ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_INTRPL ) = ONE m1fC2P ( 1 , 3 , IBC_INTRPL ) = alpha1 m1rC2P ( 1 , 1 , IBC_INTRPL ) = a1 m1rC2P ( 1 , 2 , IBC_INTRPL ) = b1 m1rC2P ( 1 , 3 , IBC_INTRPL ) = c1 m1fC2P ( 5 , 1 , IBC_INTRPL ) = m1fC2P ( 1 , 3 , IBC_INTRPL ) m1fC2P ( 5 , 2 , IBC_INTRPL ) = m1fC2P ( 1 , 2 , IBC_INTRPL ) m1fC2P ( 5 , 3 , IBC_INTRPL ) = m1fC2P ( 1 , 1 , IBC_INTRPL ) m1rC2P ( 5 , 1 , IBC_INTRPL ) = m1rC2P ( 1 , 1 , IBC_INTRPL ) m1rC2P ( 5 , 2 , IBC_INTRPL ) = m1rC2P ( 1 , 2 , IBC_INTRPL ) m1rC2P ( 5 , 3 , IBC_INTRPL ) = m1rC2P ( 1 , 3 , IBC_INTRPL ) m1fC2P ( 2 , 1 , IBC_INTRPL ) = alpha2 m1fC2P ( 2 , 2 , IBC_INTRPL ) = ONE m1fC2P ( 2 , 3 , IBC_INTRPL ) = alpha2 m1rC2P ( 2 , 1 , IBC_INTRPL ) = a2 * HALF m1rC2P ( 2 , 2 , IBC_INTRPL ) = ZERO ! not used m1rC2P ( 2 , 3 , IBC_INTRPL ) = ZERO ! not used m1fC2P ( 4 , 1 , IBC_INTRPL ) = m1fC2P ( 2 , 1 , IBC_INTRPL ) m1fC2P ( 4 , 2 , IBC_INTRPL ) = m1fC2P ( 2 , 2 , IBC_INTRPL ) m1fC2P ( 4 , 3 , IBC_INTRPL ) = m1fC2P ( 2 , 3 , IBC_INTRPL ) m1rC2P ( 4 , 1 , IBC_INTRPL ) = m1rC2P ( 2 , 1 , IBC_INTRPL ) m1rC2P ( 4 , 2 , IBC_INTRPL ) = m1rC2P ( 2 , 2 , IBC_INTRPL ) m1rC2P ( 4 , 3 , IBC_INTRPL ) = m1rC2P ( 2 , 3 , IBC_INTRPL ) m1fC2P ( 3 , :, IBC_INTRPL ) = m1fC2P ( 3 , :, IBC_PERIODIC ) m1rC2P ( 3 , :, IBC_INTRPL ) = m1rC2P ( 3 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P: No specified = neumann !---------------------------------------------------------------------------------------------------------- m1fC2P (:, :, IBC_NEUMANN ) = m1fC2P (:, :, IBC_INTRPL ) m1rC2P (:, :, IBC_NEUMANN ) = m1rC2P (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P: Dirichlet ! [ 1    0                              ][f_1']=known ! [      alpha2 1     alpha2             ][f_2'] [a2/2 * (f_{2}   + f_{1})] ! [             alpha 1      alpha       ][f_i'] [a/2 * (f_{i}   + f_{i-1}) + b/2 * (f_{i+1} + f_{i-2})] ! [                   alpha2 1     alpha2][f_4'] [a2/2 * (f_{n-1}   + f_{n-2})] ! [                          0     1    ][f_5'] known !----------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO if ( iaccu == IACCU_CD2 . or . iaccu == IACCU_CD4 ) then ! degrade to 2nd CD alpha1 = ZERO a1 = ZERO ! not used b1 = ZERO ! not used c1 = ZERO ! not used alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used else if ( iaccu == IACCU_CP4 . or . iaccu == IACCU_CP6 ) then ! degrade to 3rd CP alpha1 = ZERO a1 = ZERO ! not used b1 = ZERO ! not used c1 = ZERO ! not used alpha2 = ONE / SIX a2 = FOUR * ONE_THIRD b2 = ZERO ! not used c2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = ZERO ! not used b1 = ZERO ! not used c1 = ZERO ! not used alpha2 = ZERO a2 = ONE b2 = ZERO ! not used c2 = ZERO ! not used end if m1fC2P ( 1 , 1 , IBC_DIRICHLET ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_DIRICHLET ) = ONE m1fC2P ( 1 , 3 , IBC_DIRICHLET ) = alpha1 m1rC2P ( 1 , 1 , IBC_DIRICHLET ) = a1 m1rC2P ( 1 , 2 , IBC_DIRICHLET ) = b1 m1rC2P ( 1 , 3 , IBC_DIRICHLET ) = c1 m1fC2P ( 5 , 1 , IBC_DIRICHLET ) = m1fC2P ( 1 , 3 , IBC_DIRICHLET ) m1fC2P ( 5 , 2 , IBC_DIRICHLET ) = m1fC2P ( 1 , 2 , IBC_DIRICHLET ) m1fC2P ( 5 , 3 , IBC_DIRICHLET ) = m1fC2P ( 1 , 1 , IBC_DIRICHLET ) m1rC2P ( 5 , 1 , IBC_DIRICHLET ) = m1rC2P ( 1 , 1 , IBC_DIRICHLET ) m1rC2P ( 5 , 2 , IBC_DIRICHLET ) = m1rC2P ( 1 , 2 , IBC_DIRICHLET ) m1rC2P ( 5 , 3 , IBC_DIRICHLET ) = m1rC2P ( 1 , 3 , IBC_DIRICHLET ) m1fC2P ( 2 , 1 , IBC_DIRICHLET ) = alpha2 m1fC2P ( 2 , 2 , IBC_DIRICHLET ) = ONE m1fC2P ( 2 , 3 , IBC_DIRICHLET ) = alpha2 m1rC2P ( 2 , 1 , IBC_DIRICHLET ) = a2 * HALF m1rC2P ( 2 , 2 , IBC_DIRICHLET ) = ZERO ! not used m1rC2P ( 2 , 3 , IBC_DIRICHLET ) = ZERO ! not used m1fC2P ( 4 , 1 , IBC_DIRICHLET ) = m1fC2P ( 2 , 1 , IBC_DIRICHLET ) m1fC2P ( 4 , 2 , IBC_DIRICHLET ) = m1fC2P ( 2 , 2 , IBC_DIRICHLET ) m1fC2P ( 4 , 3 , IBC_DIRICHLET ) = m1fC2P ( 2 , 3 , IBC_DIRICHLET ) m1rC2P ( 4 , 1 , IBC_DIRICHLET ) = m1rC2P ( 2 , 1 , IBC_DIRICHLET ) m1rC2P ( 4 , 2 , IBC_DIRICHLET ) = m1rC2P ( 2 , 2 , IBC_DIRICHLET ) m1rC2P ( 4 , 3 , IBC_DIRICHLET ) = m1rC2P ( 2 , 3 , IBC_DIRICHLET ) m1fC2P ( 3 , :, IBC_DIRICHLET ) = m1fC2P ( 3 , :, IBC_PERIODIC ) m1rC2P ( 3 , :, IBC_DIRICHLET ) = m1rC2P ( 3 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P and C2C, periodic, symmetric, asymmetric !---------------------------------------------------------------------------------------------------------- alpha = ZERO a = ONE b = ZERO c = ZERO ! not used d = ZERO ! not used alpha_itf = ZERO a_itf = FOUR * ONE_THIRD b_itf = - ONE_THIRD c_itf = ZERO d_itf = ZERO if ( iaccu == IACCU_CD2 ) then alpha = ZERO a = ONE b = ZERO else if ( iaccu == IACCU_CD4 ) then alpha = ZERO a = FOUR * ONE_THIRD b = - ONE_THIRD else if ( iaccu == IACCU_CP4 ) then alpha = ONE * ZPONE a = SIX * ZPTWO b = ZERO else if ( iaccu == IACCU_CP6 ) then alpha = TWO / ELEVEN a = TWELVE / ELEVEN b = THREE / ELEVEN else ! default 2nd CD alpha = ZERO a = ONE b = ZERO end if !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative C2C, periodic !---------------------------------------------------------------------------------------------------------- d2fC2C ( 1 : 5 , 1 , IBC_PERIODIC ) = alpha d2fC2C ( 1 : 5 , 2 , IBC_PERIODIC ) = ONE d2fC2C ( 1 : 5 , 3 , IBC_PERIODIC ) = alpha d2rC2C ( 1 : 5 , 1 , IBC_PERIODIC ) = a d2rC2C ( 1 : 5 , 2 , IBC_PERIODIC ) = b * QUARTER d2rC2C ( 1 : 5 , 3 , IBC_PERIODIC ) = c ! not used d2rC2C ( 1 : 5 , 4 , IBC_PERIODIC ) = d ! not used !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P , interior !---------------------------------------------------------------------------------------------------------- d2fC2C ( 1 , 1 , IBC_INTERIOR ) = alpha_itf d2fC2C ( 1 , 2 , IBC_INTERIOR ) = ONE d2fC2C ( 1 , 3 , IBC_INTERIOR ) = alpha_itf d2rC2C ( 1 , 1 , IBC_INTERIOR ) = a_itf d2rC2C ( 1 , 2 , IBC_INTERIOR ) = b_itf * QUARTER d2rC2C ( 1 , 3 , IBC_INTERIOR ) = c_itf ! not used d2rC2C ( 1 , 4 , IBC_INTERIOR ) = d_itf ! not used d2fC2C ( 5 , :, IBC_INTERIOR ) = d2fC2C ( 1 , :, IBC_INTERIOR ) d2rC2C ( 5 , :, IBC_INTERIOR ) = d2rC2C ( 1 , :, IBC_INTERIOR ) d2fC2C ( 2 : 4 , :, IBC_INTERIOR ) = d2fC2C ( 2 : 4 , :, IBC_PERIODIC ) d2rC2C ( 2 : 4 , :, IBC_INTERIOR ) = d2rC2C ( 2 : 4 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P , periodic !---------------------------------------------------------------------------------------------------------- d2fP2P (:, :, IBC_PERIODIC ) = d2fC2C (:, :, IBC_PERIODIC ) d2rP2P (:, :, IBC_PERIODIC ) = d2rC2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P , interior !---------------------------------------------------------------------------------------------------------- d2fP2P (:, :, IBC_INTERIOR ) = d2fC2C (:, :, IBC_INTERIOR ) d2rP2P (:, :, IBC_INTERIOR ) = d2rC2C (:, :, IBC_INTERIOR ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative C2C, symmetric !---------------------------------------------------------------------------------------------------------- d2fC2C ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used d2fC2C ( 1 , 2 , IBC_SYMMETRIC ) = ONE + alpha d2fC2C ( 1 , 3 , IBC_SYMMETRIC ) = alpha d2fC2C ( 5 , 1 , IBC_SYMMETRIC ) = d2fC2C ( 1 , 3 , IBC_SYMMETRIC ) d2fC2C ( 5 , 2 , IBC_SYMMETRIC ) = d2fC2C ( 1 , 2 , IBC_SYMMETRIC ) d2fC2C ( 5 , 3 , IBC_SYMMETRIC ) = d2fC2C ( 1 , 1 , IBC_SYMMETRIC ) d2fC2C ( 2 : 4 , :, IBC_SYMMETRIC ) = d2fC2C ( 2 : 4 , :, IBC_PERIODIC ) d2rC2C (:, :, IBC_SYMMETRIC ) = d2rC2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative C2C, asymmetric !---------------------------------------------------------------------------------------------------------- d2fC2C ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used d2fC2C ( 1 , 2 , IBC_ASYMMETRIC ) = ONE - alpha d2fC2C ( 1 , 3 , IBC_ASYMMETRIC ) = alpha d2fC2C ( 5 , 1 , IBC_ASYMMETRIC ) = d2fC2C ( 1 , 3 , IBC_ASYMMETRIC ) d2fC2C ( 5 , 2 , IBC_ASYMMETRIC ) = d2fC2C ( 1 , 2 , IBC_ASYMMETRIC ) d2fC2C ( 5 , 3 , IBC_ASYMMETRIC ) = d2fC2C ( 1 , 1 , IBC_ASYMMETRIC ) d2fC2C ( 2 : 4 , :, IBC_ASYMMETRIC ) = d2fC2C ( 2 : 4 , :, IBC_PERIODIC ) d2rC2C (:, :, IBC_ASYMMETRIC ) = d2rC2C (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P, symmetric !---------------------------------------------------------------------------------------------------------- d2fP2P ( 1 , 1 , IBC_SYMMETRIC ) = ZERO ! not used d2fP2P ( 1 , 2 , IBC_SYMMETRIC ) = ONE d2fP2P ( 1 , 3 , IBC_SYMMETRIC ) = alpha + alpha d2fP2P ( 5 , 1 , IBC_SYMMETRIC ) = d2fP2P ( 1 , 3 , IBC_SYMMETRIC ) d2fP2P ( 5 , 2 , IBC_SYMMETRIC ) = d2fP2P ( 1 , 2 , IBC_SYMMETRIC ) d2fP2P ( 5 , 3 , IBC_SYMMETRIC ) = d2fP2P ( 1 , 1 , IBC_SYMMETRIC ) d2fP2P ( 2 : 4 , :, IBC_SYMMETRIC ) = d2fP2P ( 2 : 4 , :, IBC_PERIODIC ) d2rP2P (:, :, IBC_SYMMETRIC ) = d2rP2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P, asymmetric !---------------------------------------------------------------------------------------------------------- d2fP2P ( 1 , 1 , IBC_ASYMMETRIC ) = ZERO ! not used d2fP2P ( 1 , 2 , IBC_ASYMMETRIC ) = ONE d2fP2P ( 1 , 3 , IBC_ASYMMETRIC ) = ZERO d2fP2P ( 5 , 1 , IBC_ASYMMETRIC ) = d2fP2P ( 1 , 3 , IBC_ASYMMETRIC ) d2fP2P ( 5 , 2 , IBC_ASYMMETRIC ) = d2fP2P ( 1 , 2 , IBC_ASYMMETRIC ) d2fP2P ( 5 , 3 , IBC_ASYMMETRIC ) = d2fP2P ( 1 , 1 , IBC_ASYMMETRIC ) d2fP2P ( 2 : 4 , :, IBC_ASYMMETRIC ) = d2fP2P ( 2 : 4 , :, IBC_PERIODIC ) d2rP2P (:, :, IBC_ASYMMETRIC ) = d2rP2P (:, :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P, no specified = dirichlet = neumann !---------------------------------------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO d2 = ZERO if ( iaccu == IACCU_CD2 . or . iaccu == IACCU_CD4 ) then alpha1 = ZERO a1 = TWO b1 = - FIVE c1 = FOUR d1 = - ONE alpha2 = ZERO a2 = ONE b2 = ZERO c2 = ZERO ! not used d2 = ZERO ! not used else if ( iaccu == IACCU_CP4 . or . iaccu == IACCU_CP6 ) then ! degrade to 3rd CP alpha1 = ELEVEN a1 = THIRTEEN b1 = - TWENTYSEVEN c1 = FIFTEEN d1 = - ONE alpha2 = ONE * ZPONE a2 = SIX * ZPTWO b2 = ZERO c2 = ZERO ! not used d2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = TWO b1 = - FIVE c1 = FOUR d1 = - ONE alpha2 = ZERO a2 = ONE b2 = ZERO c2 = ZERO ! not used d2 = ZERO ! not used end if d2fP2P ( 1 , 1 , IBC_INTRPL ) = ZERO ! not used d2fP2P ( 1 , 2 , IBC_INTRPL ) = ONE d2fP2P ( 1 , 3 , IBC_INTRPL ) = alpha1 d2rP2P ( 1 , 1 , IBC_INTRPL ) = a1 d2rP2P ( 1 , 2 , IBC_INTRPL ) = b1 d2rP2P ( 1 , 3 , IBC_INTRPL ) = c1 d2rP2P ( 1 , 4 , IBC_INTRPL ) = d1 d2fP2P ( 5 , 1 , IBC_INTRPL ) = d2fP2P ( 1 , 3 , IBC_INTRPL ) d2fP2P ( 5 , 2 , IBC_INTRPL ) = d2fP2P ( 1 , 2 , IBC_INTRPL ) d2fP2P ( 5 , 3 , IBC_INTRPL ) = d2fP2P ( 1 , 1 , IBC_INTRPL ) d2rP2P ( 5 , 1 , IBC_INTRPL ) = d2rP2P ( 1 , 1 , IBC_INTRPL ) d2rP2P ( 5 , 2 , IBC_INTRPL ) = d2rP2P ( 1 , 2 , IBC_INTRPL ) d2rP2P ( 5 , 3 , IBC_INTRPL ) = d2rP2P ( 1 , 3 , IBC_INTRPL ) d2rP2P ( 5 , 4 , IBC_INTRPL ) = d2rP2P ( 1 , 4 , IBC_INTRPL ) d2fP2P ( 2 , 1 , IBC_INTRPL ) = alpha2 d2fP2P ( 2 , 2 , IBC_INTRPL ) = ONE d2fP2P ( 2 , 3 , IBC_INTRPL ) = alpha2 d2rP2P ( 2 , 1 , IBC_INTRPL ) = a2 d2rP2P ( 2 , 2 , IBC_INTRPL ) = ZERO ! not used d2rP2P ( 2 , 3 , IBC_INTRPL ) = ZERO ! not used d2rP2P ( 2 , 4 , IBC_INTRPL ) = ZERO ! not used d2fP2P ( 4 , 1 , IBC_INTRPL ) = d2fP2P ( 2 , 1 , IBC_INTRPL ) d2fP2P ( 4 , 2 , IBC_INTRPL ) = d2fP2P ( 2 , 2 , IBC_INTRPL ) d2fP2P ( 4 , 3 , IBC_INTRPL ) = d2fP2P ( 2 , 3 , IBC_INTRPL ) d2rP2P ( 4 , 1 , IBC_INTRPL ) = d2rP2P ( 2 , 1 , IBC_INTRPL ) d2rP2P ( 4 , 2 , IBC_INTRPL ) = d2rP2P ( 2 , 2 , IBC_INTRPL ) d2rP2P ( 4 , 3 , IBC_INTRPL ) = d2rP2P ( 2 , 3 , IBC_INTRPL ) d2rP2P ( 4 , 4 , IBC_INTRPL ) = d2rP2P ( 2 , 4 , IBC_INTRPL ) d2fP2P ( 3 , :, IBC_INTRPL ) = d2fP2P ( 3 , :, IBC_PERIODIC ) d2rP2P ( 3 , :, IBC_INTRPL ) = d2rP2P ( 3 , :, IBC_PERIODIC ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P, no specified = dirichlet !---------------------------------------------------------------------------------------------------------- d2fP2P (:, :, IBC_DIRICHLET ) = d2fP2P (:, :, IBC_INTRPL ) d2rP2P (:, :, IBC_DIRICHLET ) = d2rP2P (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative P2P, no specified = neumann !---------------------------------------------------------------------------------------------------------- d2fP2P (:, :, IBC_NEUMANN ) = d2fP2P (:, :, IBC_INTRPL ) d2rP2P (:, :, IBC_NEUMANN ) = d2rP2P (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative C2C, no specified =  neumann = P2C unspecified !---------------------------------------------------------------------------------------------------------- d2fC2C (:, :, IBC_INTRPL ) = d2fP2P (:, :, IBC_INTRPL ) d2rC2C (:, :, IBC_INTRPL ) = d2rP2P (:, :, IBC_INTRPL ) d2fC2C (:, :, IBC_NEUMANN ) = d2fC2C (:, :, IBC_INTRPL ) d2rC2C (:, :, IBC_NEUMANN ) = d2rC2C (:, :, IBC_INTRPL ) !---------------------------------------------------------------------------------------------------------- ! 2nd diriviative C2C, Dirchilet !---------------------------------------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO d2 = ZERO if ( iaccu == IACCU_CD2 . or . iaccu == IACCU_CD4 ) then alpha1 = ZERO a1 = SIXTEEN * ZPTWO b1 = - FIVE c1 = TWO d1 = - ONE * ZPTWO alpha2 = ZERO a2 = ONE b2 = ZERO c2 = ZERO ! not used d2 = ZERO ! not used else if ( iaccu == IACCU_CP4 . or . iaccu == IACCU_CP6 ) then ! degrade to 3rd CP alpha1 = HALF a1 = SIXTEEN * ZPTWO b1 = - NINE * HALF c1 = ONE d1 = THREE * ZPONE alpha2 = ONE * ZPONE a2 = SIX * ZPTWO b2 = ZERO c2 = ZERO ! not used d2 = ZERO ! not used else ! default 2nd CD alpha1 = ZERO a1 = SIXTEEN / SEVEN b1 = - TWENTYFIVE / SEVEN c1 = TEN / SEVEN d1 = - ONE / SEVEN alpha2 = ZERO a2 = ONE b2 = ZERO c2 = ZERO ! not used d2 = ZERO ! not used end if d2fC2C ( 1 , 1 , IBC_DIRICHLET ) = ZERO ! not used d2fC2C ( 1 , 2 , IBC_DIRICHLET ) = ONE d2fC2C ( 1 , 3 , IBC_DIRICHLET ) = alpha1 d2rC2C ( 1 , 1 , IBC_DIRICHLET ) = a1 d2rC2C ( 1 , 2 , IBC_DIRICHLET ) = b1 d2rC2C ( 1 , 3 , IBC_DIRICHLET ) = c1 d2rC2C ( 1 , 4 , IBC_DIRICHLET ) = d1 d2fC2C ( 5 , 1 , IBC_DIRICHLET ) = d2fC2C ( 1 , 3 , IBC_DIRICHLET ) d2fC2C ( 5 , 2 , IBC_DIRICHLET ) = d2fC2C ( 1 , 2 , IBC_DIRICHLET ) d2fC2C ( 5 , 3 , IBC_DIRICHLET ) = d2fC2C ( 1 , 1 , IBC_DIRICHLET ) d2rC2C ( 5 , 1 , IBC_DIRICHLET ) = d2rC2C ( 1 , 1 , IBC_DIRICHLET ) d2rC2C ( 5 , 2 , IBC_DIRICHLET ) = d2rC2C ( 1 , 2 , IBC_DIRICHLET ) d2rC2C ( 5 , 3 , IBC_DIRICHLET ) = d2rC2C ( 1 , 3 , IBC_DIRICHLET ) d2rC2C ( 5 , 4 , IBC_DIRICHLET ) = d2rC2C ( 1 , 4 , IBC_DIRICHLET ) d2fC2C ( 2 , 1 , IBC_DIRICHLET ) = alpha2 d2fC2C ( 2 , 2 , IBC_DIRICHLET ) = ONE d2fC2C ( 2 , 3 , IBC_DIRICHLET ) = alpha2 d2rC2C ( 2 , 1 , IBC_DIRICHLET ) = a2 d2rC2C ( 2 , 2 , IBC_DIRICHLET ) = ZERO ! not used d2rC2C ( 2 , 3 , IBC_DIRICHLET ) = ZERO ! not used d2rC2C ( 2 , 4 , IBC_DIRICHLET ) = ZERO ! not used d2fC2C ( 4 , 1 , IBC_DIRICHLET ) = d2fC2C ( 2 , 1 , IBC_DIRICHLET ) d2fC2C ( 4 , 2 , IBC_DIRICHLET ) = d2fC2C ( 2 , 2 , IBC_DIRICHLET ) d2fC2C ( 4 , 3 , IBC_DIRICHLET ) = d2fC2C ( 2 , 3 , IBC_DIRICHLET ) d2rC2C ( 4 , 1 , IBC_DIRICHLET ) = d2rC2C ( 2 , 1 , IBC_DIRICHLET ) d2rC2C ( 4 , 2 , IBC_DIRICHLET ) = d2rC2C ( 2 , 2 , IBC_DIRICHLET ) d2rC2C ( 4 , 3 , IBC_DIRICHLET ) = d2rC2C ( 2 , 3 , IBC_DIRICHLET ) d2rC2C ( 4 , 4 , IBC_DIRICHLET ) = d2rC2C ( 2 , 4 , IBC_DIRICHLET ) d2fC2C ( 3 , :, IBC_DIRICHLET ) = d2fC2C ( 3 , :, IBC_PERIODIC ) d2rC2C ( 3 , :, IBC_DIRICHLET ) = d2rC2C ( 3 , :, IBC_PERIODIC ) if ( nrank == 0 ) call Print_debug_end_msg return end subroutine Prepare_compact_coefficients !========================================================================================================== !> \\brief Assigning the sparse matrix in the LHS of the compact scheme, and !> calculating the geometry-only dependent variables for the TDMA scheme. !> !> This subroutine is called once locally. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role                                           ! !---------------------------------------------------------------------------------------------------------- !> \\param[in]     n             the number of unknown array !> \\param[in]     bc            the boundary condition at two ends of the unknown !> \\param[in]     coeff         the basic TDMA coefficients defined above. !> \\param[out]    a             the coefficients for TDMA !> \\param[out]    b             a_i * x_(i-1) + b_i * x_(i) + c_i * x_(i+1) !> \\param[out]    c             = RHS !> \\param[out]    d             An assisting coeffients for the TDMA scheme. !---------------------------------------------------------------------------------------------------------- subroutine Buildup_TDMA_LHS_array ( n , is_periodic , coeff , a , b , c , d ) use tridiagonal_matrix_algorithm use parameters_constant_mod implicit none integer , intent ( in ) :: n logical , intent ( in ) :: is_periodic real ( WP ), intent ( in ) :: coeff ( 5 , 3 , 0 : 6 ) real ( WP ), intent ( out ) :: a ( n , 0 : 6 , 0 : 6 ), & b ( n , 0 : 6 , 0 : 6 ), & c ( n , 0 : 6 , 0 : 6 ), & d ( n , 0 : 6 , 0 : 6 ) integer :: i , j a (:, :, :) = ZERO b (:, :, :) = ZERO c (:, :, :) = ZERO d (:, :, :) = ZERO do j = 0 , 6 do i = 0 , 6 if ( j == IBC_PERIODIC . and . i /= IBC_PERIODIC ) cycle if ( j /= IBC_PERIODIC . and . i == IBC_PERIODIC ) cycle a ( 1 , i , j ) = coeff ( 1 , 1 , i ) a ( 2 , i , j ) = coeff ( 2 , 1 , i ) a ( 3 : n - 2 , i , j ) = coeff ( 3 , 1 , IBC_PERIODIC ) a ( n - 1 , i , j ) = coeff ( 4 , 1 , j ) a ( n , i , j ) = coeff ( 5 , 1 , j ) b ( 1 , i , j ) = coeff ( 1 , 2 , i ) b ( 2 , i , j ) = coeff ( 2 , 2 , i ) b ( 3 : n - 2 , i , j ) = coeff ( 3 , 2 , IBC_PERIODIC ) b ( n - 1 , i , j ) = coeff ( 4 , 2 , j ) b ( n , i , j ) = coeff ( 5 , 2 , j ) c ( 1 , i , j ) = coeff ( 1 , 3 , i ) c ( 2 , i , j ) = coeff ( 2 , 3 , i ) c ( 3 : n - 2 , i , j ) = coeff ( 3 , 3 , IBC_PERIODIC ) c ( n - 1 , i , j ) = coeff ( 4 , 3 , j ) c ( n , i , j ) = coeff ( 5 , 3 , j ) if ( is_periodic ) then call Preprocess_TDMA_coeffs ( a ( 1 : n - 1 , i , j ), & b ( 1 : n - 1 , i , j ), & c ( 1 : n - 1 , i , j ), & d ( 1 : n - 1 , i , j ), & n - 1 ) else call Preprocess_TDMA_coeffs ( a (:, i , j ), & b (:, i , j ), & c (:, i , j ), & d (:, i , j ), & n ) end if end do end do return end subroutine Buildup_TDMA_LHS_array !========================================================================================================== !> \\brief Preparing coefficients for TDMA calculation. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain !>         all    once           all !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role                                           ! !---------------------------------------------------------------------------------------------------------- !========================================================================================================== subroutine Prepare_LHS_coeffs_for_operations use vars_df_mod , only : domain use mpi_mod use parameters_constant_mod implicit none integer :: i , nsz !========================================================================================================== !   building up the basic lhs coeffients for compact schemes, based on the given !   accuracy !========================================================================================================== call Prepare_compact_coefficients !---------------------------------------------------------------------------------------------------------- !   building up the full size lhs coeffients for compact schemes !---------------------------------------------------------------------------------------------------------- !========================================================================================================== ! y-direction, with nc unknows !========================================================================================================== i = 2 nsz = domain ( 1 )% nc ( i ) !---------------------------------------------------------------------------------------------------------- !   1st derivative in y direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad1y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); ad1y_C2C (:, :, :) = ZERO allocate ( bd1y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); bd1y_C2C (:, :, :) = ZERO allocate ( cd1y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); cd1y_C2C (:, :, :) = ZERO allocate ( dd1y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); dd1y_C2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fC2C , & ad1y_C2C , bd1y_C2C , cd1y_C2C , dd1y_C2C ) allocate ( ad1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); ad1y_P2C (:, :, :) = ZERO allocate ( bd1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); bd1y_P2C (:, :, :) = ZERO allocate ( cd1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); cd1y_P2C (:, :, :) = ZERO allocate ( dd1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); dd1y_P2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fP2C , & ad1y_P2C , bd1y_P2C , cd1y_P2C , dd1y_P2C ) !---------------------------------------------------------------------------------------------------------- !   mid-point interpolation in y direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( am1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); am1y_P2C (:, :, :) = ZERO allocate ( bm1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); bm1y_P2C (:, :, :) = ZERO allocate ( cm1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); cm1y_P2C (:, :, :) = ZERO allocate ( dm1y_P2C ( nsz , 0 : 6 , 0 : 6 ) ); dm1y_P2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), m1fP2C , & am1y_P2C , bm1y_P2C , cm1y_P2C , dm1y_P2C ) !---------------------------------------------------------------------------------------------------------- !   2nd order deriviative in y direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad2y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); ad2y_C2C (:, :, :) = ZERO allocate ( bd2y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); bd2y_C2C (:, :, :) = ZERO allocate ( cd2y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); cd2y_C2C (:, :, :) = ZERO allocate ( dd2y_C2C ( nsz , 0 : 6 , 0 : 6 ) ); dd2y_C2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d2fC2C , & ad2y_C2C , bd2y_C2C , cd2y_C2C , dd2y_C2C ) !========================================================================================================== ! y-direction, with np unknows !========================================================================================================== nsz = domain ( 1 )% np ( i ) !---------------------------------------------------------------------------------------------------------- !   1st derivative in y direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad1y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); ad1y_P2P (:, :, :) = ZERO allocate ( bd1y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); bd1y_P2P (:, :, :) = ZERO allocate ( cd1y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); cd1y_P2P (:, :, :) = ZERO allocate ( dd1y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); dd1y_P2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fP2P , & ad1y_P2P , bd1y_P2P , cd1y_P2P , dd1y_P2P ) allocate ( ad1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); ad1y_C2P (:, :, :) = ZERO allocate ( bd1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); bd1y_C2P (:, :, :) = ZERO allocate ( cd1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); cd1y_C2P (:, :, :) = ZERO allocate ( dd1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); dd1y_C2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fC2P , & ad1y_C2P , bd1y_C2P , cd1y_C2P , dd1y_C2P ) !---------------------------------------------------------------------------------------------------------- !   mid-point interpolation in y direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( am1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); am1y_C2P (:, :, :) = ZERO allocate ( bm1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); bm1y_C2P (:, :, :) = ZERO allocate ( cm1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); cm1y_C2P (:, :, :) = ZERO allocate ( dm1y_C2P ( nsz , 0 : 6 , 0 : 6 ) ); dm1y_C2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), m1fC2P , & am1y_C2P , bm1y_C2P , cm1y_C2P , dm1y_C2P ) !---------------------------------------------------------------------------------------------------------- ! 2nd order deriviative in y direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad2y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); ad2y_P2P (:, :, :) = ZERO allocate ( bd2y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); bd2y_P2P (:, :, :) = ZERO allocate ( cd2y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); cd2y_P2P (:, :, :) = ZERO allocate ( dd2y_P2P ( nsz , 0 : 6 , 0 : 6 ) ); dd2y_P2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d2fP2P , & ad2y_P2P , bd2y_P2P , cd2y_P2P , dd2y_P2P ) !========================================================================================================== ! z-direction, with nc unknows !========================================================================================================== i = 3 nsz = domain ( 1 )% nc ( i ) !---------------------------------------------------------------------------------------------------------- !   1st derivative in z direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad1z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); ad1z_C2C (:, : ,:) = ZERO allocate ( bd1z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); bd1z_C2C (:, : ,:) = ZERO allocate ( cd1z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); cd1z_C2C (:, : ,:) = ZERO allocate ( dd1z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); dd1z_C2C (:, : ,:) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fC2C , & ad1z_C2C , bd1z_C2C , cd1z_C2C , dd1z_C2C ) allocate ( ad1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); ad1z_P2C (:, :, :) = ZERO allocate ( bd1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); bd1z_P2C (:, :, :) = ZERO allocate ( cd1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); cd1z_P2C (:, :, :) = ZERO allocate ( dd1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); dd1z_P2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fP2C , & ad1z_P2C , bd1z_P2C , cd1z_P2C , dd1z_P2C ) !---------------------------------------------------------------------------------------------------------- !   mid-point interpolation in z direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( am1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); am1z_P2C (:, :, :) = ZERO allocate ( bm1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); bm1z_P2C (:, :, :) = ZERO allocate ( cm1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); cm1z_P2C (:, :, :) = ZERO allocate ( dm1z_P2C ( nsz , 0 : 6 , 0 : 6 ) ); dm1z_P2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), m1fP2C , & am1z_P2C , bm1z_P2C , cm1z_P2C , dm1z_P2C ) ! do j = 1, 6 !   write(*, *) 'bc type= ', j !   do k = 1, 5 !     write(*,*) k, m1fP2C(k, 1, j), m1fP2C(k, 2, j), m1fP2C(k, 3, j) !   end do ! end do ! do j = 1, nsz !   write(*, *) 'periodic', j, am1z_P2C ( j, 1, 1 ), & !                              bm1z_P2C ( j, 1, 1 ), & !                              cm1z_P2C ( j, 1, 1 ), & !                              dm1z_P2C ( j, 1, 1 ) !   write(*, *) 'symmetry', j, am1z_P2C ( j, 2, 2 ), & !                              bm1z_P2C ( j, 2, 2 ), & !                              cm1z_P2C ( j, 2, 2 ), & !                              dm1z_P2C ( j, 2, 2 ) !   write(*, *) 'dirichle', j, am1z_P2C ( j, 4, 4 ), & !                              bm1z_P2C ( j, 4, 4 ), & !                              cm1z_P2C ( j, 4, 4 ), & !                              dm1z_P2C ( j, 4, 4 ) ! end do !---------------------------------------------------------------------------------------------------------- !   2nd order deriviative in z direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad2z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); ad2z_C2C (:, :, :) = ZERO allocate ( bd2z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); bd2z_C2C (:, :, :) = ZERO allocate ( cd2z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); cd2z_C2C (:, :, :) = ZERO allocate ( dd2z_C2C ( nsz , 0 : 6 , 0 : 6 ) ); dd2z_C2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d2fC2C , & ad2z_C2C , bd2z_C2C , cd2z_C2C , dd2z_C2C ) !========================================================================================================== ! z-direction, with np unknows !========================================================================================================== nsz = domain ( 1 )% np ( i ) !---------------------------------------------------------------------------------------------------------- ! 1st derivative in z direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad1z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); ad1z_P2P (:, :, :) = ZERO allocate ( bd1z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); bd1z_P2P (:, :, :) = ZERO allocate ( cd1z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); cd1z_P2P (:, :, :) = ZERO allocate ( dd1z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); dd1z_P2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fP2P , & ad1z_P2P , bd1z_P2P , cd1z_P2P , dd1z_P2P ) allocate ( ad1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); ad1z_C2P (:, :, :) = ZERO allocate ( bd1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); bd1z_C2P (:, :, :) = ZERO allocate ( cd1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); cd1z_C2P (:, :, :) = ZERO allocate ( dd1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); dd1z_C2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d1fC2P , & ad1z_C2P , bd1z_C2P , cd1z_C2P , dd1z_C2P ) !---------------------------------------------------------------------------------------------------------- ! mid-point interpolation in z direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( am1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); am1z_C2P (:, :, :) = ZERO allocate ( bm1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); bm1z_C2P (:, :, :) = ZERO allocate ( cm1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); cm1z_C2P (:, :, :) = ZERO allocate ( dm1z_C2P ( nsz , 0 : 6 , 0 : 6 ) ); dm1z_C2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), m1fC2P , & am1z_C2P , bm1z_C2P , cm1z_C2P , dm1z_C2P ) !---------------------------------------------------------------------------------------------------------- ! 2nd order deriviative in z direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad2z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); ad2z_P2P (:, :, :) = ZERO allocate ( bd2z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); bd2z_P2P (:, :, :) = ZERO allocate ( cd2z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); cd2z_P2P (:, :, :) = ZERO allocate ( dd2z_P2P ( nsz , 0 : 6 , 0 : 6 ) ); dd2z_P2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( 1 )% is_periodic ( i ), d2fP2P , & ad2z_P2P , bd2z_P2P , cd2z_P2P , dd2z_P2P ) !========================================================================================================== ! x-direction !========================================================================================================== allocate ( xtdma_lhs ( nxdomain ) ) do i = 1 , nxdomain !========================================================================================================== ! x-direction, with nc unknows !========================================================================================================== nsz = domain ( i )% nc ( 1 ) !---------------------------------------------------------------------------------------------------------- ! 1st derivative in x direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( i )% ad1x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% ad1x_C2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bd1x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bd1x_C2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cd1x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cd1x_C2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dd1x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dd1x_C2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), d1fC2C , & xtdma_lhs ( i )% ad1x_C2C , & xtdma_lhs ( i )% bd1x_C2C , & xtdma_lhs ( i )% cd1x_C2C , & xtdma_lhs ( i )% dd1x_C2C ) allocate ( xtdma_lhs ( i )% ad1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% ad1x_P2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bd1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bd1x_P2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cd1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cd1x_P2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dd1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dd1x_P2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), d1fP2C , & xtdma_lhs ( i )% ad1x_P2C , & xtdma_lhs ( i )% bd1x_P2C , & xtdma_lhs ( i )% cd1x_P2C , & xtdma_lhs ( i )% dd1x_P2C ) !---------------------------------------------------------------------------------------------------------- ! 2nd order deriviative in x direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( i )% ad2x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% ad2x_C2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bd2x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bd2x_C2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cd2x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cd2x_C2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dd2x_C2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dd2x_C2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), d2fC2C , & xtdma_lhs ( i )% ad2x_C2C , & xtdma_lhs ( i )% bd2x_C2C , & xtdma_lhs ( i )% cd2x_C2C , & xtdma_lhs ( i )% dd2x_C2C ) !---------------------------------------------------------------------------------------------------------- ! mid-point interpolation in x direction with nc unknows !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( i )% am1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% am1x_P2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bm1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bm1x_P2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cm1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cm1x_P2C (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dm1x_P2C ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dm1x_P2C (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), m1fP2C , & xtdma_lhs ( i )% am1x_P2C , & xtdma_lhs ( i )% bm1x_P2C , & xtdma_lhs ( i )% cm1x_P2C , & xtdma_lhs ( i )% dm1x_P2C ) !========================================================================================================== ! x-direction, with np unknows !========================================================================================================== nsz = domain ( i )% np ( 1 ) !---------------------------------------------------------------------------------------------------------- ! 1st derivative in x direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( i )% ad1x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% ad1x_P2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bd1x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bd1x_P2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cd1x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cd1x_P2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dd1x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dd1x_P2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), d1fP2P , & xtdma_lhs ( i )% ad1x_P2P , & xtdma_lhs ( i )% bd1x_P2P , & xtdma_lhs ( i )% cd1x_P2P , & xtdma_lhs ( i )% dd1x_P2P ) allocate ( xtdma_lhs ( i )% ad1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% ad1x_C2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bd1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bd1x_C2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cd1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cd1x_C2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dd1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dd1x_C2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), d1fC2P , & xtdma_lhs ( i )% ad1x_C2P , & xtdma_lhs ( i )% bd1x_C2P , & xtdma_lhs ( i )% cd1x_C2P , & xtdma_lhs ( i )% dd1x_C2P ) !---------------------------------------------------------------------------------------------------------- ! 2nd order deriviative in x direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( i )% ad2x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% ad2x_P2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bd2x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bd2x_P2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cd2x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cd2x_P2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dd2x_P2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dd2x_P2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), d2fP2P , & xtdma_lhs ( i )% ad2x_P2P , & xtdma_lhs ( i )% bd2x_P2P , & xtdma_lhs ( i )% cd2x_P2P , & xtdma_lhs ( i )% dd2x_P2P ) !---------------------------------------------------------------------------------------------------------- ! mid-point interpolation in x direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( i )% am1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% am1x_C2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% bm1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% bm1x_C2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% cm1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% cm1x_C2P (:, :, :) = ZERO allocate ( xtdma_lhs ( i )% dm1x_C2P ( nsz , 0 : 6 , 0 : 6 ) ); xtdma_lhs ( i )% dm1x_C2P (:, :, :) = ZERO call Buildup_TDMA_LHS_array ( nsz , domain ( i )% is_periodic ( 1 ), m1fC2P , & xtdma_lhs ( i )% am1x_C2P , & xtdma_lhs ( i )% bm1x_C2P , & xtdma_lhs ( i )% cm1x_C2P , & xtdma_lhs ( i )% dm1x_C2P ) end do return end subroutine Prepare_LHS_coeffs_for_operations !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for interpolation. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the interpolation. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       given pencil     needed         specified   private !---------------------------------------------------------------------------------------------------------- !>  index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! interpolation. P2C: periodic ! [ 1     alpha                       alpha] [f_1] = [a/2 * ( f_{1'}   + f_{2'}   ) + b/2 * ( f_{3'}   + f_{n'}   ) ] ! [       alpha  1      alpha              ] [f_2]   [a/2 * ( f_{2'}   + f_{3'}   ) + b/2 * ( f_{4'}   + f_{1'}   ) ] ! [              alpha  1      alpha       ] [f_i]   [a/2 * ( f_{i'}   + f_{i'+1} ) + b/2 * ( f_{i'+2} + f_{i'-1} ) ] ! [                     alpha  1      alpha] [f_4]   [a/2 * ( f_{n'-1} + f_{n'}   ) + b/2 * ( f_{1'}   + f_{n'-2} ) ] ! [alpha                       alpha  1    ] [f_5]   [a/2 * ( f_{n'}   + f_{1'}   ) + b/2 * ( f_{2'}   + f_{n'-1} ) ] !---------------------------------------------------------------------------------------------------------- ! interpolation. P2C: Dirichlet ! [ 1     alpha1                              ] [f_1] = [a1 *  f_{1'}   + b1 * f_{2'} + c1 * f_{3'}                       ] ! [alpha2 1      alpha2                       ] [f_2]   [a2/2 * ( f_{2'}   + f_{3'}   )                                 ] ! [              alpha  1       alpha         ] [f_i]   [a/2 * ( f_{i'}   + f_{i'+1} ) + b/2 * ( f_{i'+2} + f_{i'-1} ) ] ! [                     alpha2  1       alpha2] [f_4]   [a2/2 * ( f_{n'-1} + f_{n'}   )                                 ] ! [                             alpha1  1     ] [f_5]   [a1 *  f_{n'+1}   + b1 * f_{n'}  + c1 * f_{n'-1}                  ] !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is nc !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_interp_P2C_RHS_array ( fi , fo , nc , coeff , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers, nc real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: i , m , l fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , nc - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i - 1 ) + fi ( i + 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for either perirodic or non-periodic of nc !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(nc'-1)-(nc-1)-(nc')-(nc)-(nc'+1)|-(nc+1)-(nc'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_interp_P2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 1 ) + fi ( i + 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0' = nc = np fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( nc ) + fi ( i + 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 2 ) + fi ( i + 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( 2 ) + fi ( i + 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 l = 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i - 1 ) + fi ( i + 2 ) ) !---------------------------------------------------------------------------------------------------------- !   i = nc - 1 !---------------------------------------------------------------------------------------------------------- i = nc - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_PERIODIC ) then ! i + 2 = nc' + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i - 1 ) + fi ( 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i - 1 ) + fi ( i + 2 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = nc !---------------------------------------------------------------------------------------------------------- i = nc m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_interp_P2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i - 1 ) + fbc ( 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! i + 1 = nc' + 1 = 1 ! i + 2 = nc' + 2 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i - 1 ) + fi ( 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! i + 2 = nc' + 2 = nc' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i - 1 ) + fi ( nc ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! i + 2 = nc' + 2 = nc' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i - 1 ) - fi ( nc ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 1 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- ! nothing. return end subroutine Prepare_TDMA_interp_P2C_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for interpolation. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the interpolation. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P: periodic ! [ 1    alpha                   alpha][f_1']=[a/2 * (f_{1}   + f_{n})   + b/2 * (f_{2}   + f_{n-1})] ! [      alpha 1     alpha            ][f_2'] [a/2 * (f_{2}   + f_{1})   + b/2 * (f_{3}   + f_{n})  ] ! [            alpha 1     alpha      ][f_i'] [a/2 * (f_{i}   + f_{i-1}) + b/2 * (f_{i+1} + f_{i-2})] ! [                  alpha 1     alpha][f_4'] [a/2 * (f_{n-1} + f_{n-2}) + b/2 * (f_{n}   + f_{n-3})] ! [alpha                   alpha 1    ][f_5'] [a/2 * (f_{1}   + f_{n-2}) + b/2 * (f_{n}   + f_{n-1})] !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P: Dirichlet ! [ 1    alpha1                          ][f_1']=[a1 * f_{1} + b1 * f_{2} + c1 * f_{3}  ] ! [      alpha2 1     alpha2             ][f_2'] [a2/2 * (f_{2}   + f_{1})] ! [             alpha 1      alpha       ][f_i'] [a/2 * (f_{i}   + f_{i-1}) + b/2 * (f_{i+1} + f_{i-2})] ! [                   alpha2 1     alpha2][f_4'] [a2/2 * (f_{n-1}   + f_{n-2})] ! [                          alpha1 1    ][f_5'] [a1 * f_{n-1} + b1 * f_{n-2} + c1 * f_{n-3}] !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is np !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_interp_C2P_RHS_array ( fi , fo , np , coeff , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers, np real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) ! used for Dirichlet B.C. (1||2) & interior (3, 1,|| 2, 4) integer :: i , m , l fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , np - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 1 ) + fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for non-periodic: !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np'|)-(np)-(np'+1)-(np+1)-(np'+2)--- !   for periodic, nc = np !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np')-(np)-(np'+1|)-(np+1)-(np'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_interp_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fbc ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fbc ( 3 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = np !-1 = np - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( np ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( np - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 !-1 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_interp_C2P_RHS_array' ) fo ( i ) = fbc ( m ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 m = 1 l = 2 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_interp_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = np fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( np ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( 1 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( 1 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i ) + fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np - 1 !---------------------------------------------------------------------------------------------------------- i = np - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_interp_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! np     = np - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 1 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 1 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i ) + fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np !---------------------------------------------------------------------------------------------------------- i = np m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_interp_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fbc ( 2 ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 4 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! np + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! np     = np - 1 ! np + 1 = np - 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( np - 1 ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 2 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( - fi ( np - 1 ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 2 ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_interp_C2P_RHS_array' ) fo ( i ) = fbc ( m ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 3 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- ! nothing return end subroutine Prepare_TDMA_interp_C2P_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! 1st derivative on collocated grids, C2C/P2P coefficients : Periodic or Symmetric B.C. ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative. C2C or P2P: periodic ! [ 1    alpha                   alpha][f'_1]=[a/2 * (f_{2}   - f_{n})/h   + b/4 * (f_{3}   - f_{n-1})/h] ! [      alpha 1     alpha            ][f'_2] [a/2 * (f_{3}   - f_{1})/h   + b/4 * (f_{4}   - f_{n})/h  ] ! [            alpha 1     alpha      ][f'_i] [a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                  alpha 1     alpha][f'_4] [a/2 * (f_{n}   - f_{n-2})/h + b/4 * (f_{1}   - f_{n-3})/h] ! [alpha                   alpha 1    ][f'_5] [a/2 * (f_{1}   - f_{n-1})/h + b/4 * (f_{2}   - f_{n-2})/h] !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : C2C or P2P : Dirichlet B.C. ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2/2 * (f_{3} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i] [ a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4] [a2/2 * (f_{n} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n}/h  - b1 * f_{n-1}/h - c1 * f_{n-2}/h] !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is np !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     dd            1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_C2C_RHS_array ( fi , fo , nc , coeff , dd , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) ! used for Dirichlet B.C. or interior integer :: i , m , l fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , nc - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for non-periodic or periodic !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(nc'-1)-(nc-1)-(nc')-(nc)-(nc'+1|)-(nc+1)-(nc'+2)--- !  interior bc !    3-1|| ---||2-4 !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fbc ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fbc ( 3 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = nc !-1 = nc - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( nc ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( nc - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 !-1 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0 = 1 !-1 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) + fi ( 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if ( present ( fbc )) then !call Print_error_msg('Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_1deri_C2C_RHS_array') fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * fbc ( m ) + & coeff ( l , 2 , ibc ( m ) ) * fi ( i ) + & coeff ( l , 3 , ibc ( m ) ) * fi ( i + 1 ) + & coeff ( l , 4 , ibc ( m ) ) * fi ( i + 2 ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 m = 1 l = 2 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( nc ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( 1 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) + fi ( 1 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np - 1 !---------------------------------------------------------------------------------------------------------- i = nc - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then !i + 2 = nc + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then !i + 2 = nc + 1 = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( nc ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then !i + 2 = nc + 1 = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( nc ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = nc !---------------------------------------------------------------------------------------------------------- i = nc m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 4 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! nc + 1 = 1 ! nc + 2 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! nc + 1 = nc ! nc + 2 = nc - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( nc ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( nc - 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! nc + 1 = nc ! nc + 2 = nc - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( - fi ( nc ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( nc - 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if ( present ( fbc )) then !call Print_error_msg('Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_1deri_C2C_RHS_array') fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * fbc ( m ) + & coeff ( l , 2 , ibc ( m ) ) * fi ( i ) + & coeff ( l , 3 , ibc ( m ) ) * fi ( i - 1 ) + & coeff ( l , 4 , ibc ( m ) ) * fi ( i - 2 ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 2 ) end if else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 2 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd return end subroutine Prepare_TDMA_1deri_C2C_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! 1st derivative on collocated grids, C2C/P2P coefficients : Periodic or Symmetric B.C. ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative. C2C or P2P: periodic ! [ 1    alpha                   alpha][f'_1]=[a/2 * (f_{2}   - f_{n})/h   + b/4 * (f_{3}   - f_{n-1})/h] ! [      alpha 1     alpha            ][f'_2] [a/2 * (f_{3}   - f_{1})/h   + b/4 * (f_{4}   - f_{n})/h  ] ! [            alpha 1     alpha      ][f'_i] [a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                  alpha 1     alpha][f'_4] [a/2 * (f_{n}   - f_{n-2})/h + b/4 * (f_{1}   - f_{n-3})/h] ! [alpha                   alpha 1    ][f'_5] [a/2 * (f_{1}   - f_{n-1})/h + b/4 * (f_{2}   - f_{n-2})/h] !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : C2C or P2P : Dirichlet B.C. ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2/2 * (f_{3} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i] [ a/2 * (f_{i+1} - f_{i-1})/h + b/4 * (f_{i+2} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4] [a2/2 * (f_{n} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n}/h  - b1 * f_{n-1}/h - c1 * f_{n-2}/h] !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is np !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     dd            1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_P2P_RHS_array ( fi , fo , np , coeff , dd , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) ! used for IBC_NEUMANN or interior integer :: m , l , i fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , np - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for periodic !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np')-(np)-(np'+1|)-(np+1)-(np'+2)--- !   for non-periodic !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np'|)-(np)-(np'+1)-(np+1)-(np'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fbc ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fbc ( 3 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0' = np' !-1' = np' - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( np ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( np - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0' = 2' !-1' = 3' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( 2 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( 3 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0' = 2' !-1' = 3' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( 2 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) + fi ( 3 ) ) else if ( ibc ( m ) == IBC_NEUMANN ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN' ) fo ( i ) = fbc ( m ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 m = 1 l = 2 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0' = np' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( np ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0' = 2' !write(*,*) 'bcp2p1', coeff( l, 1:2, ibc(m) ) !write(*,*) coeff( l, 1, ibc(m) ), fi(i + 1), fi(i - 1), coeff( l, 2, ibc(m) ), fi(i + 2), fi(2    ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) + fi ( 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np - 1 !---------------------------------------------------------------------------------------------------------- i = np - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then !np' + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then !np' + 1 = np' - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then !np' + 1 = np' - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 1 ) - fi ( i - 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np !---------------------------------------------------------------------------------------------------------- i = np m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 4 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! np' + 1 = 1' ! np' + 2 = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! np' + 1 = np' - 1 ! np' + 2 = np' - 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( np - 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! np' + 1 = np' - 1 ! np' + 2 = np' - 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( - fi ( np - 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_NEUMANN ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN' ) fo ( i ) = fbc ( m ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 2 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd !---------------------------------------------------------------------------------------------------------- !   direct bc, correction !---------------------------------------------------------------------------------------------------------- do m = 1 , 2 if ( ibc ( m ) == IBC_NEUMANN ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN' ) if ( m == 1 ) fo ( 1 ) = fbc ( m ) if ( m == 2 ) fo ( np ) = fbc ( m ) end if end do return end subroutine Prepare_TDMA_1deri_P2P_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! 1st derivative on staggered grids C2P ! C2P ==> ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(h ) * ( f_{i}   - f_{i-1} ) + & !                                                 b/(3h) * ( f_{i+1} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative. C2P: periodic ! [ 1    alpha                   alpha][f_1']=[a/2 * (f_{1}   + f_{n})   + b/2 * (f_{2}   + f_{n-1})] ! [      alpha 1     alpha            ][f_2'] [a/2 * (f_{2}   + f_{1})   + b/2 * (f_{3}   + f_{n})  ] ! [            alpha 1     alpha      ][f_i'] [a/2 * (f_{i}   + f_{i-1}) + b/2 * (f_{i+1} + f_{i-2})] ! [                  alpha 1     alpha][f_4'] [a/2 * (f_{n-1} + f_{n-2}) + b/2 * (f_{n}   + f_{n-3})] ! [alpha                   alpha 1    ][f_5'] [a/2 * (f_{1}   + f_{n-2}) + b/2 * (f_{n}   + f_{n-1})] !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : C2P : Dirichlet B.C. ! [ 1     alpha1                            ][f'_1']=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2'] [a2 * (f_{2} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i'] [a *  (f_{i} - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4'] [a2 * (f_{n-1} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5'] [-a1 * f_{n-1}/h  - b1 * f_{n-2}/h - c1 * f_{n-3}/h] !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is np !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     dd            1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_C2P_RHS_array ( fi , fo , np , coeff , dd , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers, np real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) ! used for IBC_NEUMANN, and interior integer :: i , m , l fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , np - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for non-periodic: !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np'|)-(np)-(np'+1)-(np+1)-(np'+2)--- !   for periodic: !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np')-(np)-(np'+1|)-(np+1)-(np'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fbc ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fbc ( 3 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = np !-1 = np - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( np ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( np - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 !-1 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) + fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( 2 ) ) else if ( ibc ( m ) == IBC_NEUMANN ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN @ Prepare_TDMA_1deri_C2P_RHS_array' ) fo ( i ) = fbc ( m ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if ( present ( fbc )) then !call Print_error_msg('Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_1deri_C2P_RHS_array') fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * fbc ( m ) + & coeff ( l , 2 , ibc ( m ) ) * fi ( i ) + & coeff ( l , 3 , ibc ( m ) ) * fi ( i + 1 ) + & coeff ( l , 4 , ibc ( m ) ) * fi ( i + 2 ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 m = 1 l = 2 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = np fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( np ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( 1 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) + fi ( 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np - 1 !---------------------------------------------------------------------------------------------------------- i = np - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! np     = np - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 1 ) - fi ( i - 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np !---------------------------------------------------------------------------------------------------------- i = np m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_C2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 4 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! np + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! np     = np - 1 ! np + 1 = np - 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( np - 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( - fi ( np - 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 2 ) - fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_NEUMANN ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN' ) fo ( i ) = fbc ( m ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if ( present ( fbc )) then !call Print_error_msg('Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_1deri_C2P_RHS_array') fo ( i ) = coeff ( l , 1 , ibc ( m )) * fbc ( m ) + & coeff ( l , 2 , ibc ( m )) * fi ( i - 1 ) + & coeff ( l , 3 , ibc ( m )) * fi ( i - 2 ) + & coeff ( l , 4 , ibc ( m )) * fi ( i - 3 ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 3 ) end if else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 3 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd !---------------------------------------------------------------------------------------------------------- !   direct bc, correction !---------------------------------------------------------------------------------------------------------- do m = 1 , 2 if ( ibc ( m ) == IBC_NEUMANN ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN' ) if ( m == 1 ) fo ( 1 ) = fbc ( m ) if ( m == 2 ) fo ( np ) = fbc ( m ) end if end do return end subroutine Prepare_TDMA_1deri_C2P_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 ! 1st derivative on staggered grids P2C and C2P : Periodic or Symmetric B.C. ! P2C ==> ! alpha * f'_{i-1} +  f'_i +  alpha * f'_{i+1}  = a/(h ) * ( f_{i'+1} - f_{i'} ) + & !                                                 b/(3h) * ( f_{i'+2} - f_{i'-1} ) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative. P2C: Dirichlet ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1'}/h  + b1 * f_{2'}/h + c1 * f_{3'}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2 * (f_{3'} - f_{2'})/h  ] ! [       alpha  1      alpha               ][f'_i] [a *  (f_{i'+1} - f_{i'})/h + b/3 * (f_{i'+2} - f_{i'-1})/h] ! [                     alpha2 1      alpha2][f'_4] [a2 * (f_{n'} - f_{n'-1})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n'+1}/h  - b1 * f_{n'}/h - c1 * f_{n'-1}/h] !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is np !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     dd            1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_P2C_RHS_array ( fi , fo , nc , coeff , dd , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers, nc real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: i , l , m fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , nc - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 1 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for either perirodic or non-periodic of nc !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(nc'-1)-(nc-1)-(nc')-(nc)-(nc'+1)|-(nc+1)-(nc'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_P2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0' = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( nc ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i )) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) + fi ( 2 )) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 l = 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 1 ) ) !---------------------------------------------------------------------------------------------------------- !   i = nc - 1 !---------------------------------------------------------------------------------------------------------- i = nc - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_PERIODIC ) then ! i + 2 = nc' + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i - 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = nc !---------------------------------------------------------------------------------------------------------- i = nc m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_1deri_P2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) - fi ( i - 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! i + 1 = nc' + 1 = 1 ! i + 2 = nc' + 2 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 2 ) - fi ( i - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! i + 2 = nc' + 2 = nc' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( nc ) - fi ( i - 1 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! i + 2 = nc' + 2 = nc' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( nc ) - fi ( i - 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 1 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd return end subroutine Prepare_TDMA_1deri_P2C_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! 2nd derivative on collocated grids, C2C/P2P coefficients : Periodic or Symmetric B.C. ! alpha * f\"_{i-1} + f\"_i + alpha * f\"_{i+1} = a/(2h) * ( f_{i+1} - 2f_{i} + f(i-1) ) + & !                                              b/(4h) * ( f_{i+2} - 2f_{i} + f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is nc !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     dd            1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_2deri_C2C_RHS_array ( fi , fo , nc , coeff , dd , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: i , l , m fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , nc - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for non-periodic or periodic !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(nc'-1)-(nc-1)-(nc')-(nc)-(nc'+1|)-(nc+1)-(nc'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fbc ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fbc ( 3 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = nc !-1 = nc - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( nc ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( nc - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 !-1 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0 = 1 !-1 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) - fi ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) - fi ( 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if ( present ( fbc )) then !call Print_error_msg('Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_2deri_C2C_RHS_array') fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * fbc ( m ) + & coeff ( l , 2 , ibc ( m ) ) * fi ( i ) + & coeff ( l , 3 , ibc ( m ) ) * fi ( i + 1 ) + & coeff ( l , 4 , ibc ( m ) ) * fi ( i + 2 ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( l , 4 , IBC_INTRPL ) * fi ( i + 3 ) end if else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( l , 4 , IBC_INTRPL ) * fi ( i + 3 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 m = 1 l = 2 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0 = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( nc ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( 1 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) - fi ( 1 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np - 1 !---------------------------------------------------------------------------------------------------------- i = nc - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then !nc + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then !i + 2 = nc + 1 = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( nc ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then !i + 2 = nc + 1 = nc fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( nc ) - TWO * fi ( i ) + fi ( i - 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = nc !---------------------------------------------------------------------------------------------------------- i = nc m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_C2C_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fbc ( 2 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 4 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! nc + 1 = 1 ! nc + 2 = 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! nc + 1 = nc ! nc + 2 = nc - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( nc ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( nc - 1 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! nc + 1 = nc ! nc + 2 = nc - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( - fi ( nc ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( nc - 1 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_DIRICHLET ) then if ( present ( fbc )) then !call Print_error_msg('Lack of fbc info for IBC_DIRICHLET @ Prepare_TDMA_2deri_C2C_RHS_array') fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * fbc ( m ) + & coeff ( l , 2 , ibc ( m ) ) * fi ( i ) + & coeff ( l , 3 , ibc ( m ) ) * fi ( i - 1 ) + & coeff ( l , 4 , ibc ( m ) ) * fi ( i - 2 ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( l , 4 , IBC_INTRPL ) * fi ( i - 3 ) end if else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( l , 4 , IBC_INTRPL ) * fi ( i - 3 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd ! dd = (1/dx)&#94;2 return end subroutine Prepare_TDMA_2deri_C2C_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   private !---------------------------------------------------------------------------------------------------------- !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! 2nd derivative on collocated grids, C2C/P2P coefficients : Periodic or Symmetric B.C. ! alpha * f\"_{i-1} + f\"_i + alpha * f\"_{i+1} = a/(2h) * ( f_{i+1} - 2f_{i} + f(i-1) ) + & !                                              b/(4h) * ( f_{i+2} - 2f_{i} + f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     n             the number of unknowns, here is nc !> \\param[in]    ibc            the b.c. type at two ends of the unknown array !> \\param[in]    fbc            the b.c. values for the given ibc !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     coeff         the defined TDMA coefficients !> \\param[in]     dd            1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]     fi            the input variable to build up the RHS array !> \\param[out]    fo            the output RHS array !========================================================================================================== subroutine Prepare_TDMA_2deri_P2P_RHS_array ( fi , fo , np , coeff , dd , ibc , fbc ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 5 , 4 , 0 : 6 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: i , l , m fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , np - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !   for periodic !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np')-(np)-(np'+1|)-(np+1)-(np'+2)--- !   for non-periodic !   ---(-1')-(-1)-(0')-(0)-(|1')-(1)-(2')-(2)-(3')---(i')---(np'-1)-(np-1)-(np'|)-(np)-(np'+1)-(np+1)-(np'+2)--- !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- !   i = 1 !---------------------------------------------------------------------------------------------------------- i = 1 m = 1 l = 1 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fbc ( 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fbc ( 3 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0' = np' !-1' = np' - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( np ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( np - 1 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0' = 2' !-1' = 3' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( 2 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( 3 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0' = 2' !-1' = 3' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) - fi ( 2 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) - fi ( 3 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( l , 4 , IBC_INTRPL ) * fi ( i + 3 ) end if !---------------------------------------------------------------------------------------------------------- !   i = 2 !---------------------------------------------------------------------------------------------------------- i = 2 m = 1 l = 2 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fbc ( 1 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! 0' = np' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( np ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) + fi ( 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! 0' = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( i + 2 ) - TWO * fi ( i ) - fi ( 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np - 1 !---------------------------------------------------------------------------------------------------------- i = np - 1 m = 2 l = 4 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then !np' + 1 = 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 1 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then !np' + 1 = np' - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 1 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then !i + 2 = np + 1 = np - 1 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 1 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * ( fi ( i + 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   i = np !---------------------------------------------------------------------------------------------------------- i = np m = 2 l = 5 if ( ibc ( m ) == IBC_INTERIOR ) then if (. not . present ( fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ Prepare_TDMA_2deri_P2P_RHS_array' ) fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fbc ( 2 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fbc ( 4 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_PERIODIC ) then ! np' + 1 = 1' ! np' + 2 = 2' fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_SYMMETRIC ) then ! np' + 1 = np' - 1 ! np' + 2 = np' - 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( fi ( np - 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( fi ( np - 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else if ( ibc ( m ) == IBC_ASYMMETRIC ) then ! np' + 1 = nc' - 1 ! np' + 2 = nc' - 2 fo ( i ) = coeff ( l , 1 , ibc ( m ) ) * ( - fi ( np - 1 ) - TWO * fi ( i ) + fi ( i - 1 ) ) + & coeff ( l , 2 , ibc ( m ) ) * ( - fi ( np - 2 ) - TWO * fi ( i ) + fi ( i - 2 ) ) else fo ( i ) = coeff ( l , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( l , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( l , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( l , 4 , IBC_INTRPL ) * fi ( i - 3 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd ! dd = (1/dx)&#94;2 return end subroutine Prepare_TDMA_2deri_P2P_RHS_array !========================================================================================================== !> \\brief To caculate the mid-point interpolation in 1D. !> This subroutine is called as required to get the mid-point interpolation. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !_______________________________________________________________________________ subroutine Get_x_midp_C2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_midp_C2P_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Get_x_midp_C2P_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if end do ixsub = dm % idom nsz = size ( fo ) fo = ZERO call Prepare_TDMA_interp_C2P_RHS_array ( fi (:), fo (:), nsz , m1rC2P (:, :, :), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% am1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bm1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cm1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dm1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_midp_C2P_1D !========================================================================================================== subroutine Get_x_midp_P2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_midp_P2C_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom call Prepare_TDMA_interp_P2C_RHS_array ( fi (:), fo (:), nsz , m1rP2C (:, :, :), ibc (:), fbc ) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% am1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bm1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cm1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dm1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_midp_P2C_1D !========================================================================================================== subroutine Get_y_midp_C2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use tridiagonal_matrix_algorithm use udf_type_mod implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_midp_C2P_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Get_y_midp_C2P_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_interp_C2P_RHS_array ( fi (:), fo (:), nsz , m1rC2P (:, :, :), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & am1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & bm1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & cm1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & dm1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) ! stretching? No stretching conversion return end subroutine Get_y_midp_C2P_1D !========================================================================================================== subroutine Get_y_midp_P2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_midp_P2C_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_interp_P2C_RHS_array ( fi (:), fo (:), nsz , m1rP2C (:, :, :), ibc (:), fbc (:) ) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & am1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & bm1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & cm1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & dm1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_y_midp_P2C_1D !========================================================================================================== subroutine Get_z_midp_C2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_z_midp_C2P_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Get_z_midp_C2P_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_interp_C2P_RHS_array ( fi (:), fo (:), nsz , m1rC2P (:, :, :), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & am1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & bm1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & cm1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & dm1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_midp_C2P_1D !========================================================================================================== subroutine Get_z_midp_P2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc ) )) then call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_z_midp_P2C_1D, degragded to IBC_INTRPL.' ) ibc ( i ) = IBC_INTRPL end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_interp_P2C_RHS_array ( fi (:), fo (:), nsz , m1rP2C (:, :, :), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & am1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & bm1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & cm1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & dm1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_midp_P2C_1D !========================================================================================================== !> \\brief To caculate the 1st derivative in 1D. !> This subroutine is called as required to get the 1st derivative !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_1st_derivative_C2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Get_x_1st_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if end do ixsub = dm % idom nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo (:), nsz , d1rC2C (:, :, :), dm % h1r ( 1 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% ad1x_C2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bd1x_C2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cd1x_C2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dd1x_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_1st_derivative_C2C_1D !========================================================================================================== subroutine Get_x_1st_derivative_P2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_x_1st_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo (:), nsz , d1rP2P (:, :, :), dm % h1r ( 1 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% ad1x_P2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bd1x_P2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cd1x_P2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dd1x_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_1st_derivative_P2P_1D !========================================================================================================== subroutine Get_x_1st_derivative_C2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for DIRICHLET @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom call Prepare_TDMA_1deri_C2P_RHS_array ( fi (:), fo (:), nsz , d1rC2P (:, :, :), dm % h1r ( 1 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% ad1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bd1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cd1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dd1x_C2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_1st_derivative_C2P_1D !========================================================================================================== subroutine Get_x_1st_derivative_P2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz , ixsub integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_P2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom call Prepare_TDMA_1deri_P2C_RHS_array ( fi (:), fo (:), nsz , d1rP2C (:, :, :), dm % h1r ( 1 ), ibc (:), fbc (:) ) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% ad1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bd1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cd1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dd1x_P2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_1st_derivative_P2C_1D !========================================================================================================== ! y - Get_1st_derivative_1D !========================================================================================================== subroutine Get_y_1st_derivative_C2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_1st_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Get_y_1st_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo (:), nsz , d1rC2C (:, :, :), dm % h1r ( 2 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & ad1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & bd1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & cd1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & dd1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingcc (:, 1 ) return end subroutine Get_y_1st_derivative_C2C_1D !========================================================================================================== subroutine Get_y_1st_derivative_P2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_1st_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_y_1st_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo (:), nsz , d1rP2P (:, :, :), dm % h1r ( 2 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & ad1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & bd1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & cd1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & dd1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingpt (:, 1 ) return end subroutine Get_y_1st_derivative_P2P_1D !========================================================================================================== subroutine Get_y_1st_derivative_C2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for DIRICHLET @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_C2P_RHS_array ( fi (:), fo (:), nsz , d1rC2P (:, :, :), dm % h1r ( 2 ), ibc (:), fbc (:) ) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & ad1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & bd1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & cd1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & dd1y_C2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingpt (:, 1 ) return end subroutine Get_y_1st_derivative_C2P_1D !========================================================================================================== subroutine Get_y_1st_derivative_P2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_1st_derivative_P2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_P2C_RHS_array ( fi (:), fo (:), nsz , d1rP2C (:, :, :), dm % h1r ( 2 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & ad1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & bd1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & cd1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & dd1y_P2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingcc (:, 1 ) return end subroutine Get_y_1st_derivative_P2C_1D !========================================================================================================== ! z - Get_1st_derivative_1D !========================================================================================================== subroutine Get_z_1st_derivative_C2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_DIRICHLET @ Get_x_1st_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo (:), nsz , d1rC2C (:, :, :), dm % h1r ( 3 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & ad1z_C2C (:, ibc ( 1 ), ibc ( 2 )), & bd1z_C2C (:, ibc ( 1 ), ibc ( 2 )), & cd1z_C2C (:, ibc ( 1 ), ibc ( 2 )), & dd1z_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_1st_derivative_C2C_1D !========================================================================================================== subroutine Get_z_1st_derivative_P2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_z_1st_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_z_1st_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo (:), nsz , d1rP2P (:, :, :), dm % h1r ( 3 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & ad1z_P2P (:, ibc ( 1 ), ibc ( 2 )), & bd1z_P2P (:, ibc ( 1 ), ibc ( 2 )), & cd1z_P2P (:, ibc ( 1 ), ibc ( 2 )), & dd1z_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_1st_derivative_P2P_1D !========================================================================================================== subroutine Get_z_1st_derivative_C2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for DIRICHLET @ Get_x_1st_derivative_C2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_C2P_RHS_array ( fi (:), fo (:), nsz , d1rC2P (:, :, :), dm % h1r ( 3 ), ibc (:), fbc (:) ) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & ad1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & bd1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & cd1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & dd1z_C2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_1st_derivative_C2P_1D !========================================================================================================== subroutine Get_z_1st_derivative_P2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_z_1st_derivative_P2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_1deri_P2C_RHS_array ( fi (:), fo (:), nsz , d1rP2C (:, :, :), dm % h1r ( 3 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & ad1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & bd1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & cd1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & dd1z_P2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_1st_derivative_P2C_1D !========================================================================================================== !> \\brief To caculate the 2nd derivative in 1D. !> This subroutine is called as required to get the 2nd derivative !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_2nd_derivative_C2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz , ixsub integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_2nd_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for DIRICHLET @ Get_x_2nd_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom call Prepare_TDMA_2deri_C2C_RHS_array ( fi (:), fo (:), nsz , d2rC2C (:, :, :), dm % h2r ( 1 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% ad2x_C2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bd2x_C2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cd2x_C2C (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dd2x_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_2nd_derivative_C2C_1D !========================================================================================================== subroutine Get_x_2nd_derivative_P2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz , ixsub integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_x_2nd_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom call Prepare_TDMA_2deri_P2P_RHS_array ( fi (:), fo (:), nsz , d2rP2P (:, :, :), dm % h2r ( 1 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 1 ), fo (:), & xtdma_lhs ( ixsub )% ad2x_P2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% bd2x_P2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% cd2x_P2P (:, ibc ( 1 ), ibc ( 2 )), & xtdma_lhs ( ixsub )% dd2x_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_x_2nd_derivative_P2P_1D !========================================================================================================== ! y - Get_2nd_derivative_1D !========================================================================================================== subroutine Get_y_2nd_derivative_C2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz real ( WP ), allocatable :: fo1 (:) integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_2nd_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for DIRICHLET @ Get_y_2nd_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_2deri_C2C_RHS_array ( fi (:), fo (:), nsz , d2rC2C (:, :, :), dm % h2r ( 2 ), ibc (:), fbc (:) ) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & ad2y_C2C (:, ibc ( 1 ), ibc ( 2 )), & bd2y_C2C (:, ibc ( 1 ), ibc ( 2 )), & cd2y_C2C (:, ibc ( 1 ), ibc ( 2 )), & dd2y_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) if ( dm % is_stretching ( 2 )) then allocate ( fo1 ( nsz ) ); fo1 (:) = ZERO call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo1 (:), nsz , d1rC2C (:, :, :), dm % h1r ( 2 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo1 (:), & ad1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & bd1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & cd1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & dd1y_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) fo (:) = fo (:) * dm % yMappingcc (:, 2 ) + fo1 (:) * dm % yMappingcc (:, 3 ) deallocate ( fo1 ) end if return end subroutine Get_y_2nd_derivative_C2C_1D !========================================================================================================== subroutine Get_y_2nd_derivative_P2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz real ( WP ), allocatable :: fo1 (:) integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_y_2nd_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_2deri_P2P_RHS_array ( fi (:), fo (:), nsz , d2rP2P (:, :, :), dm % h2r ( 2 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo (:), & ad2y_P2P (:, ibc ( 1 ), ibc ( 2 )), & bd2y_P2P (:, ibc ( 1 ), ibc ( 2 )), & cd2y_P2P (:, ibc ( 1 ), ibc ( 2 )), & dd2y_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) if ( dm % is_stretching ( 2 )) then allocate ( fo1 ( nsz ) ); fo1 (:) = ZERO do i = 1 , 2 if ( ibc ( i ) == IBC_NEUMANN . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_NEUMANN @ Get_y_2nd_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo1 (:), nsz , d1rP2P (:, :, :), dm % h1r ( 2 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 2 ), fo1 (:), & ad1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & bd1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & cd1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & dd1y_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) fo (:) = fo (:) * dm % yMappingpt (:, 2 ) + fo1 (:) * dm % yMappingpt (:, 3 ) deallocate ( fo1 ) end if return end subroutine Get_y_2nd_derivative_P2P_1D !========================================================================================================== ! z - Get_2nd_derivative_1D !========================================================================================================== subroutine Get_z_2nd_derivative_C2C_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_z_2nd_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if if ( ibc ( i ) == IBC_DIRICHLET . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for DIRICHLET @ Get_z_2nd_derivative_C2C_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_2deri_C2C_RHS_array ( fi (:), fo (:), nsz , d2rC2C (:, :, :), dm % h2r ( 3 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & ad2z_C2C (:, ibc ( 1 ), ibc ( 2 )), & bd2z_C2C (:, ibc ( 1 ), ibc ( 2 )), & cd2z_C2C (:, ibc ( 1 ), ibc ( 2 )), & dd2z_C2C (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_2nd_derivative_C2C_1D !========================================================================================================== subroutine Get_z_2nd_derivative_P2P_1D ( fi , fo , dm , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) ibc = ibc0 do i = 1 , 2 if ( ibc ( i ) == IBC_INTERIOR . and . (. not . present ( fbc )) ) then ibc ( i ) = IBC_INTRPL call Print_warning_msg ( 'Lack of fbc info for IBC_INTERIOR @ Get_z_2nd_derivative_P2P_1D, degragded to IBC_INTRPL.' ) end if end do nsz = size ( fo ) fo = ZERO call Prepare_TDMA_2deri_P2P_RHS_array ( fi (:), fo (:), nsz , d2rP2P (:, :, :), dm % h2r ( 3 ), ibc (:), fbc (:)) if ( dm % is_compact_scheme ) & call Solve_TDMA ( dm % is_periodic ( 3 ), fo (:), & ad2z_P2P (:, ibc ( 1 ), ibc ( 2 )), & bd2z_P2P (:, ibc ( 1 ), ibc ( 2 )), & cd2z_P2P (:, ibc ( 1 ), ibc ( 2 )), & dd2z_P2P (:, ibc ( 1 ), ibc ( 2 )), & nsz ) return end subroutine Get_z_2nd_derivative_P2P_1D !========================================================================================================== !> \\brief To caculate the mid-point interpolation in 3D. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_midp_C2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use tridiagonal_matrix_algorithm use udf_type_mod implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_midp_C2P_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_midp_C2P_3D !========================================================================================================== subroutine Get_x_midp_P2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) !2 layer each side real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) integer :: k , j real ( WP ) :: fbc ( 4 ) !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_midp_P2C_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_midp_P2C_3D !========================================================================================================== subroutine Get_y_midp_C2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_midp_C2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_midp_C2P_3D !========================================================================================================== subroutine Get_y_midp_P2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) integer :: k , i real ( WP ) :: fbc ( 4 ) !---------------------------------------------------------------------------------------------------------- !  y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_midp_P2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_midp_P2C_3D !========================================================================================================== subroutine Get_z_midp_C2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_midp_C2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_midp_C2P_3D !========================================================================================================== subroutine Get_z_midp_P2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) integer :: j , i real ( WP ) :: fbc ( 4 ) !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_midp_P2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_midp_P2C_3D !========================================================================================================== !> \\brief To caculate the 1st-deriviate in 3D. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_1st_derivative_C2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1st_derivative_C2C_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1st_derivative_C2C_3D !========================================================================================================== subroutine Get_x_1st_derivative_P2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1st_derivative_P2P_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1st_derivative_P2P_3D !========================================================================================================== subroutine Get_x_1st_derivative_C2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1st_derivative_C2P_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1st_derivative_C2P_3D !========================================================================================================== subroutine Get_x_1st_derivative_P2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1st_derivative_P2C_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1st_derivative_P2C_3D !========================================================================================================== subroutine Get_y_1st_derivative_C2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1st_derivative_C2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1st_derivative_C2C_3D !========================================================================================================== subroutine Get_y_1st_derivative_P2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !!---------------------------------------------------------------------------------------------------------- !  y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1st_derivative_P2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1st_derivative_P2P_3D !========================================================================================================== subroutine Get_y_1st_derivative_C2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1st_derivative_C2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1st_derivative_C2P_3D !========================================================================================================== subroutine Get_y_1st_derivative_P2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1st_derivative_P2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1st_derivative_P2C_3D !========================================================================================================== subroutine Get_z_1st_derivative_C2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1st_derivative_C2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1st_derivative_C2C_3D !========================================================================================================== subroutine Get_z_1st_derivative_P2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1st_derivative_P2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1st_derivative_P2P_3D !========================================================================================================== subroutine Get_z_1st_derivative_C2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1st_derivative_C2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1st_derivative_C2P_3D !========================================================================================================== subroutine Get_z_1st_derivative_P2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1st_derivative_P2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1st_derivative_P2C_3D !========================================================================================================== !> \\brief To caculate the 2nd-deriviate in 3D. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_2nd_derivative_C2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_2nd_derivative_C2C_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_2nd_derivative_C2C_3D !========================================================================================================== subroutine Get_x_2nd_derivative_P2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  x-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_2nd_derivative_P2P_1D ( fi , fo , dm , ibc , fbc ) fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_2nd_derivative_P2P_3D !========================================================================================================== subroutine Get_y_2nd_derivative_C2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_2nd_derivative_C2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_2nd_derivative_C2C_3D !========================================================================================================== subroutine Get_y_2nd_derivative_P2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) ! not used. use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  y-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_2nd_derivative_P2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_2nd_derivative_P2P_3D !========================================================================================================== subroutine Get_z_2nd_derivative_C2C_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_2nd_derivative_C2C_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_2nd_derivative_C2C_3D !========================================================================================================== subroutine Get_z_2nd_derivative_P2P_3D ( fi3d , fo3d , dm , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  z-pencil calculation !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_2nd_derivative_P2P_1D ( fi , fo , dm , ibc , fbc ) fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_2nd_derivative_P2P_3D !========================================================================================================== !========================================================================================================== !> \\brief To test this subroutine for mid-point interpolation. !> !> This subroutine is called in \\ref Test_algorithms. Define the logicals to choose !> which test section is required. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !_______________________________________________________________________________ subroutine Test_interpolation ( dm ) use parameters_constant_mod use math_mod use EvenOdd_mod use udf_type_mod implicit none type ( t_domain ), intent ( inout ) :: dm real ( WP ) :: xc , yc , zc real ( WP ) :: xp , yp , zp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 4 ) real ( WP ) :: fbc ( 4 ) real ( WP ) :: scale , shift integer :: i , j , k real ( WP ), allocatable :: fxc (:), fyc (:), fzc (:) real ( WP ), allocatable :: fxp (:), fyp (:), fzp (:) real ( WP ), allocatable :: fgxc (:), fgyc (:), fgzc (:) real ( WP ), allocatable :: fgxp (:), fgyp (:), fgzp (:) if ( dm % ibcx_Th ( 1 , IBC_CCC ) == IBC_DIRICHLET ) then if ( is_even ( dm % np ( 1 ))) dm % np ( 1 ) = dm % np ( 1 ) + 1 end if if ( dm % ibcy_Th ( 1 , IBC_CCC ) == IBC_DIRICHLET ) then if ( is_even ( dm % np ( 2 ))) dm % np ( 2 ) = dm % np ( 2 ) + 1 end if if ( dm % ibcz_Th ( 1 , IBC_CCC ) == IBC_DIRICHLET ) then if ( is_even ( dm % np ( 3 ))) dm % np ( 3 ) = dm % np ( 3 ) + 1 end if allocate ( fxc ( dm % nc ( 1 )), fyc ( dm % nc ( 2 )), fzc ( dm % nc ( 3 )) ) allocate ( fxp ( dm % np ( 1 )), fyp ( dm % np ( 2 )), fzp ( dm % np ( 3 )) ) allocate ( fgxc ( dm % nc ( 1 )), fgyc ( dm % nc ( 2 )), fgzc ( dm % nc ( 3 )) ) allocate ( fgxp ( dm % np ( 1 )), fgyp ( dm % np ( 2 )), fgzp ( dm % np ( 3 )) ) dm % h ( 1 ) = TWOPI / dm % nc ( 1 ) dm % h ( 2 ) = TWOPI / dm % nc ( 2 ) dm % h ( 3 ) = TWOPI / dm % nc ( 3 ) open ( newunit = wrt_unit ( 4 ), file = 'test_interpolation.dat' , position = \"append\" ) write ( wrt_unit ( 4 ), * ) '# xbc type ' , dm % ibcx_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" write ( wrt_unit ( 4 ), * ) '# ybc type ' , dm % ibcy_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" write ( wrt_unit ( 4 ), * ) '# zbc type ' , dm % ibcz_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" open ( newunit = wrt_unit ( 1 ), file = 'test_interpolation_x.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_interpolation_y.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 3 ), file = 'test_interpolation_z.dat' , position = \"append\" ) do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO write ( * , * ) size ( dm % fbcx_pr (:, :, :), 1 ), size ( dm % fbcx_pr (:, :, :), 2 ) , size ( dm % fbcx_pr (:, :, :), 3 ) if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ZERO if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ZERO if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = sin_wp ( TWOPI * ONE_THIRD ) end if end do do i = 1 , 2 if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ZERO if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ZERO if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = sin_wp ( TWOPI * ONE_THIRD ) end if end do do i = 1 , 2 if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ZERO if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ZERO if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = sin_wp ( TWOPI * ONE_THIRD ) end if end do !---------------------------------------------------------------------------------------------------------- ! c2p !---------------------------------------------------------------------------------------------------------- do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcx_pr ( 1 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcx_pr ( 3 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcx_pr ( 2 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcx_pr ( 4 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcy_pr (:, 1 , :) = sin_wp ( dm % h ( 2 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcy_pr (:, 3 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcy_pr (:, 2 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcy_pr (:, 4 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcz_pr (:, :, 1 ) = sin_wp ( dm % h ( 3 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcz_pr (:, :, 3 ) = sin_wp ( dm % h ( 3 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcz_pr (:, :, 2 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcz_pr (:, :, 4 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if end do ! x direction, xc do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) fxc ( i ) = sin_wp ( xc / scale + shift ) end do ! x: c2p fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) ! do i = 1, 4 !   write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-intpbc-c2p ', i, lbcx(i), fbc(i), fbc(i), zero ! end do call Get_x_midp_C2P_1D ( fxc , fgxp , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = sin_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-interp-c2p ', i, xp, ref, fgxp(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-interp-c2p ' , dm % np ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-interp-c2p failed.\") write ( wrt_unit ( 1 ), * ) '# x-interp-c2p ' , dm % np ( 1 ), err_Linf , err_L2 do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = sin_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xp , ref , fgxp ( i ), err !test end do !end if ! y direction, yc do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) fyc ( j ) = sin_wp ( yc / scale + shift ) end do ! y: c2p fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_midp_C2P_1D ( fyc , fgyp , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = sin_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-interp-c2p ', j, yp, ref, fgyp(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-interp-c2p ' , dm % np ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-interp-c2p failed.\") write ( wrt_unit ( 2 ), * ) '# y-interp-c2p ' , dm % np ( 2 ), err_Linf , err_L2 do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = sin_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yp , ref , fgyp ( j ), err !test end do !end if ! z direction, zc do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) fzc ( k ) = sin_wp ( zc / scale + shift ) end do ! z: c2p fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_midp_C2P_1D ( fzc , fgzp , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = sin_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-interp-c2p ', k, zp, ref, fgzp(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-interp-c2p ' , dm % np ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-interp-c2p failed.\") write ( wrt_unit ( 3 ), * ) '# z-interp-c2p ' , dm % np ( 3 ), err_Linf , err_L2 do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = sin_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) write ( wrt_unit ( 3 ), * ) k , zp , ref , fgzp ( k ), err !test end do !end if !---------------------------------------------------------------------------------------------------------- ! p2c !---------------------------------------------------------------------------------------------------------- do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcx_pr ( 1 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 1 , WP ) ) / scale + shift ) dm % fbcx_pr ( 3 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 2 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcx_pr ( 2 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 1 , WP ) ) / scale + shift ) dm % fbcx_pr ( 4 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 2 , WP ) ) / scale + shift ) end if end if if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcy_pr (:, 1 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 1 , WP ) ) / scale + shift ) dm % fbcy_pr (:, 3 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 2 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcy_pr (:, 2 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 1 , WP ) ) / scale + shift ) dm % fbcy_pr (:, 4 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 2 , WP ) ) / scale + shift ) end if end if if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcz_pr (:, :, 1 ) = sin_wp ( dm % h ( 3 ) * ( real ( 0 - 1 , WP ) ) / scale + shift ) dm % fbcz_pr (:, :, 3 ) = sin_wp ( dm % h ( 3 ) * ( real ( - 1 - 1 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcz_pr (:, :, 2 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 1 , WP ) ) / scale + shift ) dm % fbcz_pr (:, :, 4 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 2 , WP ) ) / scale + shift ) end if end if end do ! x direction, xp do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) fxp ( i ) = sin_wp ( xp / scale + shift ) end do ! x: p2c fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_midp_P2C_1D ( fxp , fgxc , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_PCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = sin_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-interp-p2c ', i, xc, ref, fgxc(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-interp-p2c ' , dm % nc ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-interp-p2c failed.\") write ( wrt_unit ( 1 ), * ) '# x-interp-p2c ' , dm % nc ( 1 ), err_Linf , err_L2 do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = sin_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xc , ref , fgxc ( i ), err !test end do !end if ! y direction, yp do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) fyp ( j ) = sin_wp ( yp / scale + shift ) end do ! y: p2c fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_midp_P2C_1D ( fyp , fgyc , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = sin_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-interp-p2c ', j, yc, ref, fgyc(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-interp-p2c ' , dm % nc ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-interp-p2c failed.\") write ( wrt_unit ( 2 ), * ) '# y-interp-p2c ' , dm % nc ( 2 ), err_Linf , err_L2 do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = sin_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 write ( wrt_unit ( 2 ), * ) j , yc , ref , fgyc ( j ), err !test end do !end if ! z direction, zp do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) fzp ( k ) = sin_wp ( zp / scale + shift ) end do ! z: p2c fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_midp_P2C_1D ( fzp , fgzc , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_PPP ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = sin_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-interp-p2c ', k, zc, ref, fgzc(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-interp-p2c ' , dm % nc ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-interp-p2c failed.\") write ( wrt_unit ( 3 ), * ) '# z-interp-p2c ' , dm % nc ( 3 ), err_Linf , err_L2 do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = sin_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 write ( wrt_unit ( 3 ), * ) k , zc , ref , fgzc ( k ), err !test end do !end if ! test a combination ! input: f(yp) = sin(x/3) ! intpp2c: f(yc) = sin(x/3) ! 1stderic2p: f'(yp) = 1/3 cos(x/3) ! y direction, yp do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) fyp ( j ) = sin_wp ( yp / scale + shift ) end do ! intp p2c + 1st deri c2p fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_midp_P2C_1D ( fyp , fgyc , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_PPP ), fbc ) call Get_y_1st_derivative_C2P_1D ( fgyc , fgyp , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = ONE / scale * cos_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-interp-c2p ', j, yp, ref, fgyp(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-intP2C+derC2P ' , dm % np ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-intP2C+derC2P failed.\") write ( wrt_unit ( 2 ), * ) '# y-intP2C+derC2P ' , dm % np ( 2 ), err_Linf , err_L2 do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = ONE / scale * cos_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yp , ref , fgyp ( j ), err !test end do !end if ! ! test a combination !     ! input: f(yp) = sin(x/3) !     ! intpp2c: f(yc) = sin(x/3) !     ! input for deri: f(yc)= sin(x/3) * sin(x/3) !     ! 1stderic2p: f'(yp) = 2/3 sin(x/3) * cos(x/3) !     ! y direction, yp !     do j = 1, dm%np(2) !       yp = dm%h(2) * real(j - 1, WP) !yp = dm%yp(j) !       fyp(j) = sin_wp ( yp / scale + shift) !     end do !     ! intp p2c + 1st deri c2p !     fbc(1:4) = dm%fbcy_pr(1, 1:4, 1) !     call Get_y_midp_P2C_1D          (fyp,      fgyc, dm, dm%iAccuracy, dm%ibcy_Th(:, IBC_PPP), fbc) !     call Get_y_1st_derivative_C2P_1D(fgyc*fgyc,fgyp, dm, dm%iAccuracy, dm%ibcy_Th(:, IBC_CCC), fbc*fbc) !     err_Linf = ZERO !     err_L2   = ZERO !     do j = 1, dm%np(2) !       yp = dm%h(2) * real(j - 1, WP) !yp = dm%yp(j) !       ref = TWO/scale * cos_wp(yp / scale + shift)* sin_wp(yp / scale + shift) !       err = abs_wp(fgyp(j) - ref) !       if(err > err_Linf) err_Linf = err !       err_L2 = err_L2 + err**2 !       !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-interp-c2p ', j, yp, ref, fgyp(j), err !test !     end do !     err_L2 = sqrt_wp(err_L2 / dm%np(2)) !     write(wrt_unit(4), *) '# y-d(ff)dy ', dm%np(2), err_Linf, err_L2 !     !if(err_L2 > 1.0e-8_WP) then !       !call Print_warning_msg(\"Test y-d(ff)dy failed.\") !       write(wrt_unit(2), *) '# y-d(ff)dy ', dm%np(2), err_Linf, err_L2 !       do j = 1, dm%np(2) !         yp = dm%h(2) * real(j - 1, WP) !yp = dm%yp(j) !         ref = TWO/scale * cos_wp(yp / scale + shift)* sin_wp(yp / scale + shift) !         err = abs_wp(fgyp(j) - ref) !         write(wrt_unit(2),*) j, yp, ref, fgyp(j), err !test !       end do !     !end if close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) close ( wrt_unit ( 3 )) close ( wrt_unit ( 4 )) deallocate ( fxc ) deallocate ( fxp ) deallocate ( fgxc ) deallocate ( fgxp ) deallocate ( fyc ) deallocate ( fyp ) deallocate ( fgyc ) deallocate ( fgyp ) deallocate ( fzc ) deallocate ( fzp ) deallocate ( fgzc ) deallocate ( fgzp ) return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To test this subroutine for mid-point interpolation. !> !> This subroutine is called in \\ref Test_algorithms. Define the logicals to choose !> which test section is required. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !_______________________________________________________________________________ subroutine Test_1st_derivative ( dm ) use parameters_constant_mod use udf_type_mod use math_mod use EvenOdd_mod implicit none type ( t_domain ), intent ( inout ) :: dm integer :: i , j , k real ( WP ) :: xc , yc , zc real ( WP ) :: xp , yp , zp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 4 ) real ( WP ) :: scale , shift real ( WP ) :: fbc ( 4 ) real ( WP ), allocatable :: fxc (:), fyc (:), fzc (:) real ( WP ), allocatable :: fxp (:), fyp (:), fzp (:) real ( WP ), allocatable :: fgxc (:), fgyc (:), fgzc (:) real ( WP ), allocatable :: fgxp (:), fgyp (:), fgzp (:) dm % ibcx_Th (:, IBC_CCC ) = IBC_DIRICHLET ; if ( is_even ( dm % np ( 1 ))) dm % np ( 1 ) = dm % np ( 1 ) + 1 dm % ibcy_Th (:, IBC_CCC ) = IBC_DIRICHLET ; if ( is_even ( dm % np ( 2 ))) dm % np ( 2 ) = dm % np ( 2 ) + 1 dm % ibcz_Th (:, IBC_CCC ) = IBC_DIRICHLET ; if ( is_even ( dm % np ( 3 ))) dm % np ( 3 ) = dm % np ( 3 ) + 1 allocate ( fxc ( dm % nc ( 1 )), fyc ( dm % nc ( 2 )), fzc ( dm % nc ( 3 )) ) allocate ( fxp ( dm % np ( 1 )), fyp ( dm % np ( 2 )), fzp ( dm % np ( 3 )) ) allocate ( fgxc ( dm % nc ( 1 )), fgyc ( dm % nc ( 2 )), fgzc ( dm % nc ( 3 )) ) allocate ( fgxp ( dm % np ( 1 )), fgyp ( dm % np ( 2 )), fgzp ( dm % np ( 3 )) ) dm % h ( 1 ) = TWOPI / dm % nc ( 1 ) dm % h ( 2 ) = TWOPI / dm % nc ( 2 ) dm % h ( 3 ) = TWOPI / dm % nc ( 3 ) do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ZERO if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ZERO if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = sin_wp ( TWOPI * ONE_THIRD ) end if end do do i = 1 , 2 if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ZERO if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ZERO if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = sin_wp ( TWOPI * ONE_THIRD ) end if end do do i = 1 , 2 if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ZERO if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ZERO if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = sin_wp ( TWOPI * ONE_THIRD ) end if end do open ( newunit = wrt_unit ( 4 ), file = 'test_1st_derivative.dat' , position = \"append\" ) write ( wrt_unit ( 4 ), * ) '# xbc type ' , dm % ibcx_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" write ( wrt_unit ( 4 ), * ) '# ybc type ' , dm % ibcy_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" write ( wrt_unit ( 4 ), * ) '# zbc type ' , dm % ibcz_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" open ( newunit = wrt_unit ( 1 ), file = 'test_1st_derivative_x.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_1st_derivative_y.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 3 ), file = 'test_1st_derivative_z.dat' , position = \"append\" ) !---------------------------------------------------------------------------------------------------------- ! c2c !---------------------------------------------------------------------------------------------------------- do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcx_pr ( 1 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcx_pr ( 3 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcx_pr ( 2 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcx_pr ( 4 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcy_pr (:, 1 , :) = sin_wp ( dm % h ( 2 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcy_pr (:, 3 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcy_pr (:, 2 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcy_pr (:, 4 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcz_pr (:, :, 1 ) = sin_wp ( dm % h ( 3 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcz_pr (:, :, 3 ) = sin_wp ( dm % h ( 3 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcz_pr (:, :, 2 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcz_pr (:, :, 4 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if end do ! x direction, xc do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) fxc ( i ) = sin_wp ( xc / scale + shift ) end do ! x: c2c fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_1st_derivative_C2C_1D ( fxc , fgxc , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-1stder-c2c ', i, xc, ref, fgxc(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-1stder-c2c ' , dm % nc ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-1stder-c2c failed.\") write ( wrt_unit ( 1 ), * ) '# x-1stder-c2c ' , dm % nc ( 1 ), err_Linf , err_L2 do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xc , ref , fgxc ( i ), err !test end do !end if ! y direction, yc do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) fyc ( j ) = sin_wp ( yc / scale + shift ) end do ! y: c2c fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_1st_derivative_C2C_1D ( fyc , fgyc , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = ONE / scale * cos_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-1stder-c2c ', j, yc, ref, fgyc(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-1stder-c2c ' , dm % nc ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-1stder-c2c failed.\") write ( wrt_unit ( 2 ), * ) '# y-1stder-c2c ' , dm % nc ( 2 ), err_Linf , err_L2 do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = ONE / scale * cos_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yc , ref , fgyc ( j ), err !test end do !end if ! z direction, zc do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) fzc ( k ) = sin_wp ( zc / scale + shift ) end do ! z: c2c fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_1st_derivative_C2C_1D ( fzc , fgzc , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-1stder-c2c ', k, zc, ref, fgzc(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-1stder-c2c ' , dm % nc ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-1stder-c2c failed.\") write ( wrt_unit ( 3 ), * ) '# z-1stder-c2c ' , dm % nc ( 3 ), err_Linf , err_L2 do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) write ( wrt_unit ( 3 ), * ) k , zc , ref , fgzc ( k ), err !test end do !end if !---------------------------------------------------------------------------------------------------------- ! c2p !---------------------------------------------------------------------------------------------------------- ! x: c2p ! if (dm%ibcx(1, 5) == IBC_INTERIOR) then ! do i = 1, 4 !   write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-1stder-c2p ', i, lbcx(i), fbc(i), fbc(i), zero ! end do ! end if fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_1st_derivative_C2P_1D ( fxc , fgxp , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = ONE / scale * cos_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-1stder-c2p ', i, xp, ref, fgxp(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-1stder-c2p ' , dm % np ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-1stder-c2p failed.\") write ( wrt_unit ( 1 ), * ) '# x-1stder-c2p ' , dm % np ( 1 ), err_Linf , err_L2 do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = ONE / scale * cos_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xp , ref , fgxp ( i ), err !test end do !end if ! y: c2p fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_1st_derivative_C2P_1D ( fyc , fgyp , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = ONE / scale * cos_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-1stder-c2p ', j, yp, ref, fgyp(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-1stder-c2p ' , dm % np ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-1stder-c2p failed.\") write ( wrt_unit ( 2 ), * ) '# y-1stder-c2p ' , dm % np ( 2 ), err_Linf , err_L2 do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = ONE / scale * cos_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yp , ref , fgyp ( j ), err !test end do !end if ! z: c2p fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_1st_derivative_C2P_1D ( fzc , fgzp , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = ONE / scale * cos_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-1stder-c2p ', k, zp, ref, fgzp(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-1stder-c2p ' , dm % np ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-1stder-c2p failed.\") write ( wrt_unit ( 3 ), * ) '# z-1stder-c2p ' , dm % np ( 3 ), err_Linf , err_L2 do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = ONE / scale * cos_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 write ( wrt_unit ( 3 ), * ) k , zp , ref , fgzp ( k ), err !test end do !end if !---------------------------------------------------------------------------------------------------------- ! p2p !---------------------------------------------------------------------------------------------------------- do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcx_pr ( 1 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 1 , WP ) ) / scale + shift ) dm % fbcx_pr ( 3 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 2 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcx_pr ( 2 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 1 , WP ) ) / scale + shift ) dm % fbcx_pr ( 4 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 2 , WP ) ) / scale + shift ) end if end if if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcy_pr (:, 1 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 1 , WP ) ) / scale + shift ) dm % fbcy_pr (:, 3 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 2 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcy_pr (:, 2 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 1 , WP ) ) / scale + shift ) dm % fbcy_pr (:, 4 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 2 , WP ) ) / scale + shift ) end if end if if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcz_pr (:, :, 1 ) = sin_wp ( dm % h ( 3 ) * ( real ( 0 - 1 , WP ) ) / scale + shift ) dm % fbcz_pr (:, :, 3 ) = sin_wp ( dm % h ( 3 ) * ( real ( - 1 - 1 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcz_pr (:, :, 2 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 1 , WP ) ) / scale + shift ) dm % fbcz_pr (:, :, 4 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 2 , WP ) ) / scale + shift ) end if end if end do ! x direction, xp do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) fxp ( i ) = sin_wp ( xp / scale + shift ) end do ! x: p2p fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_1st_derivative_P2P_1D ( fxp , fgxp , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = ONE / scale * cos_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-1stder-p2p', i, xp, ref, fgxp(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-1stder-p2p ' , dm % np ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-1stder-p2p failed.\") write ( wrt_unit ( 1 ), * ) '# x-1stder-p2p ' , dm % np ( 1 ), err_Linf , err_L2 do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = ONE / scale * cos_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xp , ref , fgxp ( i ), err !test end do !end if ! y direction, yp do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) fyp ( j ) = sin_wp ( yp / scale + shift ) end do ! y: p2p fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_1st_derivative_P2P_1D ( fyp , fgyp , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = ONE / scale * cos_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-1stder-p2p ', j, yp, ref, fgyp(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-1stder-p2p ' , dm % np ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-1stder-p2p failed.\") write ( wrt_unit ( 2 ), * ) '# y-1stder-p2p ' , dm % np ( 2 ), err_Linf , err_L2 do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = ONE / scale * cos_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yp , ref , fgyp ( j ), err !test end do !end if ! z direction, zp do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) fzp ( k ) = sin_wp ( zp / scale + shift ) end do ! z: p2p fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_1st_derivative_P2P_1D ( fzp , fgzp , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_PPP ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = ONE / scale * cos_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-1stder-p2p ', k, zp, ref, fgzp(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-1stder-p2p ' , dm % np ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-1stder-p2p failed.\") write ( wrt_unit ( 3 ), * ) '# z-1stder-p2p ' , dm % np ( 3 ), err_Linf , err_L2 do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = ONE / scale * cos_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 write ( wrt_unit ( 3 ), * ) k , zp , ref , fgzp ( k ), err !test end do !end if !---------------------------------------------------------------------------------------------------------- ! p2c !---------------------------------------------------------------------------------------------------------- ! x: p2c fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_1st_derivative_P2C_1D ( fxp , fgxc , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_PCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-1stder-p2c ', i, xc, ref, fgxc(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-1stder-p2c ' , dm % nc ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-1stder-p2c failed.\") write ( wrt_unit ( 1 ), * ) '# x-1stder-p2c ' , dm % nc ( 1 ), err_Linf , err_L2 do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 write ( wrt_unit ( 1 ), * ) i , xc , ref , fgxc ( i ), err !test end do !end if ! y: p2c fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_1st_derivative_P2C_1D ( fyp , fgyc , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = ONE / scale * cos_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-1stder-p2c ', j, yc, ref, fgyc(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-1stder-p2c ' , dm % nc ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-1stder-p2c failed.\") write ( wrt_unit ( 2 ), * ) '# y-1stder-p2c ' , dm % nc ( 2 ), err_Linf , err_L2 do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = ONE / scale * cos_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yc , ref , fgyc ( j ), err !test end do !end if ! z: p2c fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_1st_derivative_P2C_1D ( fzp , fgzc , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_PPP ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-1stder-p2c ', k, zc, ref, fgzc(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-1stder-p2c ' , dm % nc ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-1stder-p2c failed.\") write ( wrt_unit ( 3 ), * ) '# z-1stder-p2c ' , dm % nc ( 3 ), err_Linf , err_L2 do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) write ( wrt_unit ( 3 ), * ) k , zc , ref , fgzc ( k ), err !test end do !end if close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) close ( wrt_unit ( 3 )) close ( wrt_unit ( 4 )) deallocate ( fxc ) deallocate ( fxp ) deallocate ( fgxc ) deallocate ( fgxp ) deallocate ( fyc ) deallocate ( fyp ) deallocate ( fgyc ) deallocate ( fgyp ) deallocate ( fzc ) deallocate ( fzp ) deallocate ( fgzc ) deallocate ( fgzp ) return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To test this subroutine for mid-point interpolation. !> !> This subroutine is called in \\ref Test_algorithms. Define the logicals to choose !> which test section is required. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !_______________________________________________________________________________ subroutine Test_2nd_derivative ( dm ) use parameters_constant_mod use udf_type_mod use math_mod use EvenOdd_mod implicit none type ( t_domain ), intent ( inout ) :: dm integer :: i , j , k real ( WP ) :: xc , yc , zc real ( WP ) :: xp , yp , zp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 4 ) real ( WP ) :: scale , shift real ( WP ) :: fbc ( 4 ) real ( WP ), allocatable :: fxc (:), fyc (:), fzc (:) real ( WP ), allocatable :: fxp (:), fyp (:), fzp (:) real ( WP ), allocatable :: fgxc (:), fgyc (:), fgzc (:) real ( WP ), allocatable :: fgxp (:), fgyp (:), fgzp (:) dm % ibcx_Th (:, IBC_CCC ) = IBC_DIRICHLET ; if ( is_even ( dm % np ( 1 ))) dm % np ( 1 ) = dm % np ( 1 ) + 1 dm % ibcy_Th (:, IBC_CCC ) = IBC_DIRICHLET ; if ( is_even ( dm % np ( 2 ))) dm % np ( 2 ) = dm % np ( 2 ) + 1 dm % ibcz_Th (:, IBC_CCC ) = IBC_DIRICHLET ; if ( is_even ( dm % np ( 3 ))) dm % np ( 3 ) = dm % np ( 3 ) + 1 allocate ( fxc ( dm % nc ( 1 )), fyc ( dm % nc ( 2 )), fzc ( dm % nc ( 3 )) ) allocate ( fxp ( dm % np ( 1 )), fyp ( dm % np ( 2 )), fzp ( dm % np ( 3 )) ) allocate ( fgxc ( dm % nc ( 1 )), fgyc ( dm % nc ( 2 )), fgzc ( dm % nc ( 3 )) ) allocate ( fgxp ( dm % np ( 1 )), fgyp ( dm % np ( 2 )), fgzp ( dm % np ( 3 )) ) dm % h ( 1 ) = TWOPI / dm % nc ( 1 ) dm % h ( 2 ) = TWOPI / dm % nc ( 2 ) dm % h ( 3 ) = TWOPI / dm % nc ( 3 ) do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ZERO if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcx_pr ( 1 , :, :) = ZERO if ( i == 2 ) dm % fbcx_pr ( 2 , :, :) = sin_wp ( TWOPI * ONE_THIRD ) end if end do do i = 1 , 2 if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ZERO if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcy_pr (:, 1 , :) = ZERO if ( i == 2 ) dm % fbcy_pr (:, 2 , :) = sin_wp ( TWOPI * ONE_THIRD ) end if end do do i = 1 , 2 if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_PERIODIC ) then scale = ONE shift = ZERO else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_SYMMETRIC ) then scale = ONE shift = PI * HALF else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_ASYMMETRIC ) then scale = TWO shift = ZERO else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_DIRICHLET ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ZERO if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = sin_wp ( TWOPI * ONE_THIRD ) else if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_NEUMANN ) then scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ONE_THIRD * cos_wp ( ZERO * ONE_THIRD ) if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = ONE_THIRD * cos_wp ( TWOPI * ONE_THIRD ) else scale = THREE shift = ZERO if ( i == 1 ) dm % fbcz_pr (:, :, 1 ) = ZERO if ( i == 2 ) dm % fbcz_pr (:, :, 2 ) = sin_wp ( TWOPI * ONE_THIRD ) end if end do open ( newunit = wrt_unit ( 4 ), file = 'test_2nd_derivative.dat' , position = \"append\" ) write ( wrt_unit ( 4 ), * ) '# xbc type ' , dm % ibcx_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" write ( wrt_unit ( 4 ), * ) '# ybc type ' , dm % ibcy_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" write ( wrt_unit ( 4 ), * ) '# zbc type ' , dm % ibcz_Th ( 1 : 2 , IBC_CCC ), \" err_inf, err_L2\" open ( newunit = wrt_unit ( 1 ), file = 'test_2nd_derivative_x.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_2nd_derivative_y.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 3 ), file = 'test_2nd_derivative_z.dat' , position = \"append\" ) !---------------------------------------------------------------------------------------------------------- ! c2c !---------------------------------------------------------------------------------------------------------- do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcx_pr ( 1 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcx_pr ( 3 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcx_pr ( 2 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcx_pr ( 4 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcy_pr (:, 1 , :) = sin_wp ( dm % h ( 2 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcy_pr (:, 3 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcy_pr (:, 2 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcy_pr (:, 4 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcz_pr (:, :, 1 ) = sin_wp ( dm % h ( 3 ) * ( real ( 0 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcz_pr (:, :, 3 ) = sin_wp ( dm % h ( 3 ) * ( real ( - 1 - 1 , WP ) + HALF ) / scale + shift ) else if ( i == 2 ) then dm % fbcz_pr (:, :, 2 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 1 - 1 , WP ) + HALF ) / scale + shift ) dm % fbcz_pr (:, :, 4 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 2 - 1 , WP ) + HALF ) / scale + shift ) end if end if end do ! x direction, xc do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) fxc ( i ) = sin_wp ( xc / scale + shift ) end do ! x: c2c fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_2nd_derivative_C2C_1D ( fxc , fgxc , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = - ( ONE / scale ) ** 2 * sin_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-2ndder-c2c ', i, xc, ref, fgxc(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-2ndder-c2c ' , dm % nc ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-2ndder-c2c failed.\") do i = 1 , dm % nc ( 1 ) xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) ref = - ( ONE / scale ) ** 2 * sin_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xc , ref , fgxc ( i ), err !test end do !end if ! y direction, yc do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) fyc ( j ) = sin_wp ( yc / scale + shift ) end do ! y: c2c fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_2nd_derivative_C2C_1D ( fyc , fgyc , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = - ( ONE / scale ) ** 2 * sin_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 ! !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-2ndder-c2c ', j, yc, ref, fgyc(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-2ndder-c2c ' , dm % nc ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-2ndder-c2c failed.\") do j = 1 , dm % nc ( 2 ) yc = dm % h ( 2 ) * ( real ( j - 1 , WP ) + HALF ) !yc = dm%yc(j) ref = - ( ONE / scale ) ** 2 * sin_wp ( yc / scale + shift ) err = abs_wp ( fgyc ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yc , ref , fgyc ( j ), err !test end do !end if ! z direction, zc do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) fzc ( k ) = sin_wp ( zc / scale + shift ) end do ! z: c2c fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_2nd_derivative_C2C_1D ( fzc , fgzc , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = - ( ONE / scale ) ** 2 * sin_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-2ndder-c2c ', k, zc, ref, fgzc(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % nc ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-2ndder-c2c ' , dm % nc ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-2ndder-c2c failed.\") do k = 1 , dm % nc ( 3 ) zc = dm % h ( 3 ) * ( real ( k - 1 , WP ) + HALF ) ref = - ( ONE / scale ) ** 2 * sin_wp ( zc / scale + shift ) err = abs_wp ( fgzc ( k ) - ref ) write ( wrt_unit ( 3 ), * ) k , zc , ref , fgzc ( k ), err !test end do !end if !---------------------------------------------------------------------------------------------------------- ! p2p !---------------------------------------------------------------------------------------------------------- do i = 1 , 2 if ( dm % ibcx_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcx_pr ( 1 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 1 , WP ) ) / scale + shift ) dm % fbcx_pr ( 3 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( - 2 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcx_pr ( 2 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 1 , WP ) ) / scale + shift ) dm % fbcx_pr ( 4 , :, :) = sin_wp ( dm % h ( 1 ) * ( real ( dm % nc ( 1 ) + 2 , WP ) ) / scale + shift ) end if end if if ( dm % ibcy_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcy_pr (:, 1 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 1 , WP ) ) / scale + shift ) dm % fbcy_pr (:, 3 , :) = sin_wp ( dm % h ( 2 ) * ( real ( - 2 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcy_pr (:, 2 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 1 , WP ) ) / scale + shift ) dm % fbcy_pr (:, 4 , :) = sin_wp ( dm % h ( 2 ) * ( real ( dm % nc ( 2 ) + 2 , WP ) ) / scale + shift ) end if end if if ( dm % ibcz_Th ( i , IBC_CCC ) == IBC_INTERIOR ) then scale = THREE shift = ZERO if ( i == 1 ) then dm % fbcz_pr (:, :, 1 ) = sin_wp ( dm % h ( 3 ) * ( real ( 0 - 1 , WP ) ) / scale + shift ) dm % fbcz_pr (:, :, 3 ) = sin_wp ( dm % h ( 3 ) * ( real ( - 1 - 1 , WP ) ) / scale + shift ) else if ( i == 2 ) then dm % fbcz_pr (:, :, 2 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 1 , WP ) ) / scale + shift ) dm % fbcz_pr (:, :, 4 ) = sin_wp ( dm % h ( 3 ) * ( real ( dm % nc ( 3 ) + 2 , WP ) ) / scale + shift ) end if end if end do ! x direction, xp do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) fxp ( i ) = sin_wp ( xp / scale + shift ) end do ! x: p2p fbc ( 1 : 4 ) = dm % fbcx_pr ( 1 : 4 , 1 , 1 ) call Get_x_2nd_derivative_P2P_1D ( fxp , fgxp , dm , dm % iAccuracy , dm % ibcx_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = - ( ONE / scale ) ** 2 * sin_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'x-2ndder-p2p ', i, xp, ref, fgxp(i), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 1 )) write ( wrt_unit ( 4 ), * ) '# x-2ndder-p2p ' , dm % np ( 1 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test x-2ndder-p2p failed.\") do i = 1 , dm % np ( 1 ) xp = dm % h ( 1 ) * real ( i - 1 , WP ) ref = - ( ONE / scale ) ** 2 * sin_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 1 ), * ) i , xp , ref , fgxp ( i ), err !test end do !end if ! y direction, yp do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) fyp ( j ) = sin_wp ( yp / scale + shift ) end do ! y: p2p fbc ( 1 : 4 ) = dm % fbcy_pr ( 1 , 1 : 4 , 1 ) call Get_y_2nd_derivative_P2P_1D ( fyp , fgyp , dm , dm % iAccuracy , dm % ibcy_Th (:, IBC_CCC ), fbc ) err_Linf = ZERO err_L2 = ZERO do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = - ( ONE / scale ) ** 2 * sin_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'y-2ndder-p2p ', j, yp, ref, fgyp(j), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 2 )) write ( wrt_unit ( 4 ), * ) '# y-2ndder-p2p ' , dm % np ( 2 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test y-2ndder-p2p failed.\") do j = 1 , dm % np ( 2 ) yp = dm % h ( 2 ) * real ( j - 1 , WP ) !yp = dm%yp(j) ref = - ( ONE / scale ) ** 2 * sin_wp ( yp / scale + shift ) err = abs_wp ( fgyp ( j ) - ref ) write ( wrt_unit ( 2 ), * ) j , yp , ref , fgyp ( j ), err !test end do !end if ! z direction, zp do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) fzp ( k ) = sin_wp ( zp / scale + shift ) end do ! z: p2p fbc ( 1 : 4 ) = dm % fbcz_pr ( 1 , 1 , 1 : 4 ) call Get_z_2nd_derivative_P2P_1D ( fzp , fgzp , dm , dm % iAccuracy , dm % ibcz_Th (:, IBC_PPP ), fbc ) err_Linf = ZERO err_L2 = ZERO do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = - ( ONE / scale ) ** 2 * sin_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 !write(wrt_unit,'(A,1I5.1,4ES13.5)') 'z-2ndder-p2p ', k, zp, ref, fgzp(k), err !test end do err_L2 = sqrt_wp ( err_L2 / dm % np ( 3 )) write ( wrt_unit ( 4 ), * ) '# z-2ndder-p2p ' , dm % np ( 3 ), err_Linf , err_L2 !if(err_L2 > 1.0e-8_WP) then !call Print_warning_msg(\"Test z-2ndder-p2p failed.\") do k = 1 , dm % np ( 3 ) zp = dm % h ( 3 ) * real ( k - 1 , WP ) ref = - ( ONE / scale ) ** 2 * sin_wp ( zp / scale + shift ) err = abs_wp ( fgzp ( k ) - ref ) write ( wrt_unit ( 3 ), * ) k , zp , ref , fgzp ( k ), err !test end do !end if close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) close ( wrt_unit ( 3 )) close ( wrt_unit ( 4 )) deallocate ( fxc ) deallocate ( fxp ) deallocate ( fgxc ) deallocate ( fgxp ) deallocate ( fyc ) deallocate ( fyp ) deallocate ( fgyc ) deallocate ( fgyp ) deallocate ( fzc ) deallocate ( fzp ) deallocate ( fgzc ) deallocate ( fgzp ) return end subroutine end module","tags":"","url":"sourcefile/.operations.f90.html"},{"title":"tools_general.f90 – CHAPSim2","text":"Source Code module print_msg_mod public :: Print_error_msg public :: Print_warning_msg public :: Print_note_msg public :: Print_debug_start_msg public :: Print_debug_mid_msg public :: Print_debug_end_msg public :: Print_3d_array contains !========================================================================================================== subroutine Print_error_msg ( msg ) !use iso_fortran_env implicit none character ( len =* ), intent ( IN ) :: msg write ( * , * ) 'ERROR: ' // msg error stop 'Execution terminated unexpectedly due to an error.' return end subroutine Print_error_msg !========================================================================================================== subroutine Print_warning_msg ( msg ) !use iso_fortran_env implicit none character ( len =* ), intent ( IN ) :: msg write ( * , * ) '>>>> WARNNING <<<< ' // msg return end subroutine Print_warning_msg !========================================================================================================== subroutine Print_note_msg ( msg ) !use iso_fortran_env implicit none character ( len =* ), intent ( IN ) :: msg write ( * , * ) '  [NOTE] ' // msg return end subroutine Print_note_msg !========================================================================================================== subroutine Print_debug_start_msg ( msg ) !use iso_fortran_env implicit none character ( len =* ), optional , intent ( IN ) :: msg write ( * , * ) \"==========================================================================================================\" if ( present ( msg )) write ( * , * ) msg return end subroutine Print_debug_start_msg !========================================================================================================== subroutine Print_debug_inline_msg ( msg ) !use iso_fortran_env implicit none character ( len =* ), intent ( IN ) :: msg write ( * , * ) \"    \" // msg return end subroutine Print_debug_inline_msg !========================================================================================================== subroutine Print_debug_mid_msg ( msg ) !use iso_fortran_env implicit none character ( len =* ), intent ( IN ) :: msg write ( * , * ) \"  ------ \" // msg // \" ------\" return end subroutine Print_debug_mid_msg !========================================================================================================== subroutine Print_debug_end_msg !use iso_fortran_env implicit none write ( * , * ) \"        ... done.\" return end subroutine Print_debug_end_msg !========================================================================================================== subroutine Print_3d_array ( var , nx , ny , nz , str ) use precision_mod !use iso_fortran_env implicit none integer , intent ( in ) :: nx , ny , nz real ( wp ), intent ( in ) :: var ( nx , ny , nz ) character ( len =* ), intent ( in ) :: str integer :: i , j , k write ( * , * ) str do k = 1 , nz do j = 1 , ny do i = 1 , nx write ( * , * ) k , j , i , var ( i , j , k ) end do end do end do return end subroutine Print_3d_array end module !========================================================================================================== module decomp_operation_mod implicit none contains function is_same_decomp ( a , b ) result ( f ) use decomp_2d type ( DECOMP_INFO ), intent ( in ) :: a , b logical :: f integer :: i f = . true . do i = 1 , 3 if ( a % xst ( i ) /= b % xst ( i )) f = . false . if ( a % xen ( i ) /= b % xen ( i )) f = . false . if ( a % yst ( i ) /= b % yst ( i )) f = . false . if ( a % yen ( i ) /= b % yen ( i )) f = . false . if ( a % zst ( i ) /= b % zst ( i )) f = . false . if ( a % zen ( i ) /= b % zen ( i )) f = . false . end do end function end module !========================================================================================================== module code_performance_mod use parameters_constant_mod use typeconvert_mod use mpi_mod use print_msg_mod implicit none integer , parameter :: CPU_TIME_CODE_START = 1 , & CPU_TIME_STEP_START = 2 , & CPU_TIME_ITER_START = 3 , & CPU_TIME_ITER_END = 4 , & CPU_TIME_STEP_END = 5 , & CPU_TIME_CODE_END = 6 real ( wp ), save :: t_code_start real ( wp ), save :: t_step_start real ( wp ), save :: t_iter_start real ( wp ), save :: t_iter_end real ( wp ), save :: t_step_end real ( wp ), save :: t_code_end integer :: cpu_nfre private :: Convert_sec_to_hms public :: call_cpu_time contains subroutine Convert_sec_to_hms ( s , hrs , mins , secs ) real ( wp ), intent ( in ) :: s integer , intent ( out ) :: hrs integer , intent ( out ) :: mins real ( wp ), intent ( out ) :: secs secs = s hrs = floor ( secs / SIXTY / SIXTY ) secs = secs - real ( hrs , WP ) * SIXTY * SIXTY mins = floor ( secs / SIXTY ) secs = secs - real ( mins , WP ) * SIXTY return end subroutine subroutine call_cpu_time ( itype , iterfrom , niter , iter ) integer , intent ( in ) :: itype integer , intent ( in ) :: iterfrom , niter integer , intent ( in ), optional :: iter integer :: hrs , mins real ( wp ) :: secs , t ( 4 ), t_work ( 4 ) real ( WP ) :: t_total , t_elaspsed , t_remaining , t_aveiter , t_this_iter , t_preparation , t_postprocessing real ( WP ) :: t_total0 , t_elaspsed0 , t_remaining0 , t_aveiter0 , t_this_iter0 , t_preparation0 , t_postprocessing0 !---------------------------------------------------------------------------------------------------------- if ( itype == CPU_TIME_CODE_START ) then call cpu_time ( t_code_start ) !---------------------------------------------------------------------------------------------------------- else if ( itype == CPU_TIME_STEP_START ) then call cpu_time ( t_step_start ) t_preparation = t_step_start - t_code_start !call mpi_barrier(MPI_COMM_WORLD, ierror) call mpi_allreduce ( t_preparation , t_preparation0 , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) if ( nrank == 0 ) call Print_debug_mid_msg ( \"Code Performance Info\" ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"    Time for code preparation : \" // & trim ( real2str ( t_preparation0 )) // ' s' ) !---------------------------------------------------------------------------------------------------------- else if ( itype == CPU_TIME_ITER_START ) then call cpu_time ( t_iter_start ) if ( nrank == 0 ) call Print_debug_start_msg ( \"Time Step = \" // trim ( int2str ( iter )) // & '/' // trim ( int2str ( niter ))) !trim(int2str(niter-iterfrom))) !---------------------------------------------------------------------------------------------------------- else if ( itype == CPU_TIME_ITER_END ) then if (. not . present ( iter )) call Print_error_msg ( \"Error in calculating CPU Time.\" ) call cpu_time ( t_iter_end ) t_this_iter = t_iter_end - t_iter_start t_elaspsed = t_iter_end - t_step_start t_aveiter = t_elaspsed / real ( iter - iterfrom , WP ) t_remaining = t_aveiter * real ( niter - iter , wp ) t ( 1 ) = t_this_iter t ( 2 ) = t_elaspsed t ( 3 ) = t_aveiter t ( 4 ) = t_remaining call mpi_allreduce ( t , t_work , 4 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) t_this_iter0 = t_work ( 1 ) t_elaspsed0 = t_work ( 2 ) t_aveiter0 = t_work ( 3 ) t_remaining0 = t_work ( 4 ) if ( nrank == 0 ) call Print_debug_mid_msg ( \"Code Performance Info\" ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"    Time for this time step : \" // & trim ( real2str ( t_this_iter0 )) // ' s' ) call Convert_sec_to_hms ( t_elaspsed0 , hrs , mins , secs ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"    Elaspsed Wallclock Time : \" // & trim ( int2str ( hrs )) // ' h ' // & trim ( int2str ( mins )) // ' m ' // & trim ( real2str ( secs )) // ' s ' ) call Convert_sec_to_hms ( t_remaining0 , hrs , mins , secs ) if ( nrank == 0 ) then call Print_debug_inline_msg ( \"    Remaning Wallclock Time : \" // & trim ( int2str ( hrs )) // ' h ' // & trim ( int2str ( mins )) // ' m ' // & trim ( real2str ( secs )) // ' s ' ) call Print_debug_inline_msg ( \"    Moving averaged time per iteration  : \" // & trim ( real2str ( t_aveiter0 )) // ' s' ) end if !---------------------------------------------------------------------------------------------------------- else if ( itype == CPU_TIME_STEP_END ) then call cpu_time ( t_step_end ) t_total = t_step_end - t_step_start t_aveiter = t_total / real ( niter - iterfrom , WP ) !call mpi_barrier(MPI_COMM_WORLD, ierror) t = ZERO t ( 1 ) = t_total t ( 2 ) = t_aveiter call mpi_allreduce ( t , t_work , 4 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) t_total0 = t_work ( 1 ) t_aveiter0 = t_work ( 2 ) call Convert_sec_to_hms ( t_total0 , hrs , mins , secs ) if ( nrank == 0 ) then call Print_debug_mid_msg ( \"Code Performance Info\" ) call Print_debug_inline_msg ( \"    Averaged time per iteration  : \" // & trim ( real2str ( t_aveiter0 )) // ' s' ) call Print_debug_inline_msg ( \"    Wallclock time of all iterations : \" // & trim ( int2str ( hrs )) // ' h ' // & trim ( int2str ( mins )) // ' m ' // & trim ( real2str ( secs )) // ' s ' ) end if !---------------------------------------------------------------------------------------------------------- else if ( itype == CPU_TIME_CODE_END ) then call cpu_time ( t_code_end ) t_total = t_code_end - t_code_start t_postprocessing = t_code_end - t_step_end t = ZERO t ( 1 ) = t_total t ( 2 ) = t_postprocessing call mpi_allreduce ( t , t_work , 4 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) t_total0 = t_work ( 1 ) t_postprocessing0 = t_work ( 2 ) call Convert_sec_to_hms ( t_total0 , hrs , mins , secs ) if ( nrank == 0 ) then call Print_debug_mid_msg ( \"Code Performance Info\" ) call Print_debug_inline_msg ( \"    Wallclock time for postprocessing : \" // & trim ( real2str ( t_postprocessing0 )) // ' s' ) call Print_debug_inline_msg ( \"    Total wallclock time of this run : \" // & trim ( int2str ( hrs )) // ' h ' // & trim ( int2str ( mins )) // ' m ' // & trim ( real2str ( secs )) // ' s ' ) call Print_debug_inline_msg ( \"CHAPSim Simulation is finished successfully.\" ) end if else end if return end subroutine end module module cubic_spline_interpolation public :: cubic_spline public :: spline_interpolation contains !********************************************************************************************************************************** subroutine cubic_spline ( n , x , y , b , c , d ) !--------------------------------------------------------------------- !     this subroutine calculates the coefficients b, c, d of a cubic !     spline to best approximate a discreet fonction given by n points ! !     inputs: !     n       number of given points !     x, y    vectors of dimension n, storing the coordinates !             of function f(x) ! !     outputs: !     b,c, d   vectors of dimension n, storing the coefficients !             of the cubic spline !     function: !     y =  x !     reference: !     forsythe, g.e. (1977) computer methods for mathematical !     computations. prentice - hall, inc. !--------------------------------------------------------------------- use precision_mod implicit none integer ( 4 ), intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ), y ( n ) real ( wp ), intent ( out ) :: b ( n ), c ( n ), d ( n ) integer ( 4 ) :: nm1 , i , l real ( wp ) :: t if ( n < 2 ) return if ( n < 3 ) then b ( 1 ) = ( y ( 2 ) - y ( 1 )) / ( x ( 2 ) - x ( 1 )) c ( 1 ) = 0.0_wp d ( 1 ) = 0.0_wp b ( 2 ) = b ( 1 ) c ( 2 ) = 0.0_wp d ( 2 ) = 0.0_wp return end if ! step 1: preparation !        build the tridiagonal system !        b (diagonal), d (upperdiagonal), c (second member) nm1 = n - 1 d ( 1 ) = x ( 2 ) - x ( 1 ) c ( 2 ) = ( y ( 2 ) - y ( 1 )) / d ( 1 ) do i = 2 , nm1 d ( i ) = x ( i + 1 ) - x ( i ) b ( i ) = 2.0_wp * ( d ( i - 1 ) + d ( i )) c ( i + 1 ) = ( y ( i + 1 ) - y ( i )) / d ( i ) c ( i ) = c ( i + 1 ) - c ( i ) end do ! step 2: end conditions !     conditions at limits !     third derivatives obtained by divided differences b ( 1 ) = - d ( 1 ) b ( n ) = - d ( n - 1 ) c ( 1 ) = 0.0_wp c ( n ) = 0.0_wp if ( n /= 3 ) then c ( 1 ) = c ( 3 ) / ( x ( 4 ) - x ( 2 )) - c ( 2 ) / ( x ( 3 ) - x ( 1 )) c ( n ) = c ( n - 1 ) / ( x ( n ) - x ( n - 2 )) - c ( n - 2 ) / ( x ( n - 1 ) - x ( n - 3 )) c ( 1 ) = c ( 1 ) * d ( 1 ) * d ( 1 ) / ( x ( 4 ) - x ( 1 )) c ( n ) = - c ( n ) * d ( n - 1 ) ** 2 / ( x ( n ) - x ( n - 3 )) end if ! step 3:     forward elimination do i = 2 , n t = d ( i - 1 ) / b ( i - 1 ) b ( i ) = b ( i ) - t * d ( i - 1 ) c ( i ) = c ( i ) - t * c ( i - 1 ) end do !step 4:     back substitution c ( n ) = c ( n ) / b ( n ) do l = 1 , nm1 i = n - l c ( i ) = ( c ( i ) - d ( i ) * c ( i + 1 )) / b ( i ) end do !step 5: coefficients of 3rd degree polynomial b ( n ) = ( y ( n ) - y ( nm1 )) / d ( nm1 ) + d ( nm1 ) * ( c ( nm1 ) + 2.0_wp * c ( n )) do i = 1 , nm1 b ( i ) = ( y ( i + 1 ) - y ( i )) / d ( i ) - d ( i ) * ( c ( i + 1 ) + 2.0_wp * c ( i )) d ( i ) = ( c ( i + 1 ) - c ( i )) / d ( i ) c ( i ) = 3.0_wp * c ( i ) end do c ( n ) = 3.0_wp * c ( n ) d ( n ) = d ( nm1 ) return end subroutine !********************************************************************************************************************************** function spline_interpolation ( n , yprofile , b , c , d , y ) result ( eval ) use precision_mod implicit none integer , intent ( in ) :: n real ( WP ), intent ( in ) :: yprofile ( n ) real ( wp ), intent ( in ) :: b ( n ), c ( n ), d ( n ) real ( WP ), intent ( in ) :: y real ( WP ) :: eval integer :: i , j , k real ( WP ) :: dy !* !  binary search for for i, such that x(i) <= u <= x(i + 1) !* i = 1 j = n + 1 do while ( j > i + 1 ) k = ( i + j ) / 2 if ( y < yprofile ( k )) then j = k else i = k end if end do !* !  evaluate spline interpolation !* dy = y - yprofile ( i ) eval = yprofile ( i ) + dy * ( b ( i ) + dy * ( c ( i ) + dy * d ( i ))) end function end module !========================================================================================================== !========================================================================================================== module random_number_generation_mod use precision_mod implicit none private public :: initialise_random_number public :: Generate_rvec_random public :: Generate_r_random contains subroutine initialise_random_number ( seed ) !******************************************************************************* ! !! random_initialise initialises the FORTRAN 90 random number seed. ! ! !  Discussion: ! !    If you don't initialise the random number generator, its behavior !    is not specified.  If you initialise it simply by: ! !      CALL random_seed ! !    its behavior is not specified.  On the DEC ALPHA, If that's all you !    do, the same random number sequence is returned.  In order to actually !    try to scramble up the random number generator a bit, this routine !    goes through the tedious process of getting the size of the random !    number seed, making up values based on the current time, and setting !    the random number seed. ! !  Modified: ! !    19 December 2001 ! !  Author: ! !    John Burkardt ! !  parameters: ! !    Input/output, integer seed. !    IF seed is zero on input, THEN you're asking this routine to come up !    with a seed value, whICh is RETURNed as output. !    IF seed is nonzero on input, THEN you're asking this routine to !    USE the input value of seed to initialise the random number generator, !    and seed is not changed on output. ! implicit none ! integer :: count integer :: count_max integer :: count_rate logical , parameter :: debug = . false . integer :: i integer :: seed integer , allocatable :: seed_vector (:) integer :: seed_size real ( wp ) :: t ! !  initialise the random number seed. ! call random_seed ! !  determine the size of the random number seed. ! call random_seed ( size = seed_size ) ! !  allocate a seed of the right size. ! allocate ( seed_vector ( seed_size ) ); seed_vector = 0 if ( seed /= 0 ) then if ( debug ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'random_initialise' write ( * , '(a, i20)' ) '  initialise random_number, user seed = ' , seed end if else call system_clock ( count , count_rate , count_max ) seed = count if ( debug ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'random_initialise' write ( * , '(a, i20)' ) '  initialise random_number, arbitrary seed = ' , & seed end if end if ! !  now set the seed. ! seed_vector ( 1 : seed_size ) = seed call random_seed ( put = seed_vector ( 1 : seed_size ) ) ! !  free up the seed space. ! deallocate ( seed_vector ) ! !  call the random number routine a bunch of times. !random_initialise do i = 1 , 100 call random_number ( harvest = t ) end do return end subroutine initialise_random_number !********************************************************************************************************************************** subroutine Generate_rvec_random ( alo , ahi , n , a ) ! !******************************************************************************* ! !! RVEC_random RETURNs a random REAL(WP) vector in a given range. ! ! !  ModIFied: ! !    04 Februray 2001 ! !  Author: ! !    John BurkARdt ! !  parameters: ! !    Input, REAL(WP) ALO, AHI, the range allowed for the entries. ! !    Input, integer N, the number of entries in the vector. ! !    Output, REAL(WP) A(N), the vector of randomly chosen values. ! implicit none ! integer n ! real ( wp ) a ( n ) real ( wp ) ahi real ( wp ) alo integer i ! do i = 1 , n call Generate_r_random ( alo , ahi , a ( i ) ) end do return end subroutine Generate_rvec_random !********************************************************************************************************************************** subroutine Generate_r_random ( rlo , rhi , r ) ! !******************************************************************************* ! !! R_random RETURNs a random REAL(WP) in a given range. ! ! !  ModIFied: ! !    06 April 2001 ! !  Author: ! !    John BurkARdt ! !  parameters: ! !    Input, REAL(WP) RLO, RHI, the minimum and maximum values. ! !    Output, REAL(WP) R, the randomly chosen value. ! implicit none ! real ( wp ) :: r real ( wp ) :: rhi real ( wp ) :: rlo real ( wp ) :: t ! !  pick t, a random number in (0, 1). ! call random_number ( harvest = t ) ! !  set r in ( rlo, rhi ). ! r = ( 1.0e+00 - t ) * rlo + t * rhi return end subroutine Generate_r_random end module random_number_generation_mod !module index_mod !public :: which_pencil !public :: local2global_3indices !public :: local2global_yid !contains !========================================================================================================== !   function which_pencil(dtmp) result(a) !     use parameters_constant_mod !     use decomp_2d !     use print_msg_mod !     implicit none !     type(DECOMP_INFO), intent(in) :: dtmp !     integer :: a ! ! this is wrong as it prefers the order of X, Y, Z !     if(dtmp%xst(1) == 1 .and. dtmp%xsz(1) == dtmp%xen(1)) then !       a = IPENCIL(1) !     else if(dtmp%yst(2) == 1 .and. dtmp%ysz(2) == dtmp%yen(2)) then !       a = IPENCIL(2) !     else if(dtmp%zst(3) == 1 .and. dtmp%zsz(3) == dtmp%zen(3)) then !       a = IPENCIL(3) !     else !       call Print_error_msg(\"Error in finding which pencil.\") !     end if !   end function !========================================================================================================== ! function local2global_3indices(a, dtmp) result(b) !   use decomp_2d !   use parameters_constant_mod !   use print_msg_mod !   implicit none !   type(DECOMP_INFO), intent(in) :: dtmp !   integer, intent(in)  :: a(3) !   integer :: b(3) !   if(which_pencil(dtmp) == IPENCIL(1)) then !     b(1) = dtmp%xst(1) + a(1) - 1 !     b(2) = dtmp%xst(2) + a(2) - 1 !     b(3) = dtmp%xst(3) + a(3) - 1 !   else if (which_pencil(dtmp) == IPENCIL(2)) then !     b(1) = dtmp%yst(1) + a(1) - 1 !     b(2) = dtmp%yst(2) + a(2) - 1 !     b(3) = dtmp%yst(3) + a(3) - 1 !   else if (which_pencil(dtmp) == IPENCIL(3)) then !     b(1) = dtmp%zst(1) + a(1) - 1 !     b(2) = dtmp%zst(2) + a(2) - 1 !     b(3) = dtmp%zst(3) + a(3) - 1 !   else !     call Print_error_msg(\"Error in local to global index conversion.\") !   end if ! end function ! function local2global_yid(a, dtmp) result(b) !   use decomp_2d !   use parameters_constant_mod !   use print_msg_mod !   implicit none !   type(DECOMP_INFO), intent(in) :: dtmp !   integer, intent(in)  :: a !   integer :: b !   if(which_pencil(dtmp) == IPENCIL(1)) then !     b = dtmp%xst(2) + a - 1 !   else if (which_pencil(dtmp) == IPENCIL(2)) then !     b = dtmp%yst(2) + a - 1 !   else if (which_pencil(dtmp) == IPENCIL(3)) then !     b = dtmp%zst(2) + a - 1 !   else !     call Print_error_msg(\"Error in local to global index conversion.\") !   end if ! end function !end module !========================================================================================================== module wrt_debug_field_mod public :: wrt_3d_all_debug public :: wrt_3d_pt_debug contains subroutine wrt_3d_pt_debug ( var , dtmp , iter , irk , loc ) use precision_mod use udf_type_mod use print_msg_mod use io_files_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( wp ), intent ( in ) :: var ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )) character ( * ), intent ( in ) :: loc integer , intent ( in ) :: iter , irk integer , parameter :: npt = 8 integer , parameter :: nfil = 20 integer :: nid ( 8 , 3 ), a ( 24 ) character ( 1 ) :: pntim character ( 128 ) :: flnm integer :: n , i , j , k , jj , kk ! based on x pencil a = ( / 1 , 1 , 1 , 1 , 8 , 8 , 8 , 8 , & 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , & 1 , 1 , 1 , 1 , 8 , 8 , 8 , 8 / ) nid = reshape ( a , ( / 8 , 3 / )) do n = 1 , npt write ( pntim , '(i1.1)' ) n flnm = 'chapsim2_p' // pntim // '.dat' do k = 1 , dtmp % xsz ( 3 ) kk = dtmp % xst ( 3 ) + k - 1 if ( kk == nid ( n , 3 )) then do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) if ( jj == nid ( n , 2 )) then do i = 1 , dtmp % xsz ( 1 ) if ( i == nid ( n , 1 )) then if ( file_exists ( trim ( adjustl ( flnm )))) then open ( nfil + n , file = trim ( adjustl ( flnm )), position = 'append' ) !write(nfil+n,*) '# iter = ', iter else open ( nfil + n , file = trim ( adjustl ( flnm )) ) !write(nfil+n,*) '# iter = ', iter end if write ( nfil + n , '(A20, 2I2.1, 3I4.1, 1ES27.19)' ) & trim ( loc ), iter , irk , i , jj , kk , var ( i , j , k ) close ( nfil + n ) end if end do end if end do end if end do end do return end subroutine !========================================================================================================== subroutine wrt_3d_all_debug ( var , dtmp , iter , str , loc ) use precision_mod use udf_type_mod use print_msg_mod use io_files_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( wp ), intent ( in ) :: var ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )) character ( * ), intent ( in ) :: str character ( * ), intent ( in ) :: loc integer , intent ( in ) :: iter integer , parameter :: nfil = 20 character ( 128 ) :: flnm integer :: i , j , k , jj , kk character ( 1 ) :: pntim write ( pntim , '(i1.1)' ) nrank flnm = 'chapsim2_' // trim ( str ) // '_at_' // trim ( loc ) // '_myid' // pntim // '.dat' if ( file_exists ( trim ( adjustl ( flnm )))) then open ( nfil , file = trim ( adjustl ( flnm )), position = 'append' ) write ( nfil , * ) '# iter = ' , iter else open ( nfil , file = trim ( adjustl ( flnm )) ) write ( nfil , * ) '# iter = ' , iter end if do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) do k = 1 , dtmp % xsz ( 3 ) kk = dtmp % xst ( 3 ) + k - 1 do i = 1 , dtmp % xsz ( 1 ) write ( nfil , '(3I4.1, 1ES27.19)' ) i , jj , kk , var ( i , j , k ) end do end do end do close ( nfil ) return end subroutine end module !============================================================================ !============================================================================ module cylindrical_rn_mod use udf_type_mod use parameters_constant_mod use print_msg_mod implicit none private :: transpose_to_y_pencil private :: transpose_to_z_pencil private :: transpose_from_z_pencil private :: transpose_from_y_pencil private :: get_dimensions public :: axis_estimating_radial_xpx !public :: estimate_azimuthal_xpx_on_axis public :: multiple_cylindrical_rn public :: multiple_cylindrical_rn_xx4 public :: multiple_cylindrical_rn_x4x contains !============================================================================ ! Estimate azimuthal component on the axis !============================================================================ ! subroutine estimate_azimuthal_xpx_on_axis(var, dtmp, pencil, dm) !   implicit none !   type(DECOMP_INFO), intent(in) :: dtmp !   type(t_domain), intent(in)    :: dm ! not used !   real(WP), intent(inout)      :: var(:, :, :) !   integer, intent(in)          :: pencil !   real(WP), dimension(dtmp%ysz(1), dtmp%ysz(2), dtmp%ysz(3)) :: var_ypencil !   real(WP), dimension(dtmp%zsz(1), dtmp%zsz(2), dtmp%zsz(3)) :: var_zpencil !   if (dm%icase /= ICASE_PIPE) return !   ! Transpose input data to z-pencil !   call transpose_to_z_pencil(var, var_zpencil, dtmp, pencil) !   ! Set the value on the axis to zero !   var_zpencil(:, :, 1) = ZERO !   ! Transpose back to the original pencil !   call transpose_from_z_pencil(var_zpencil, var, dtmp, pencil) ! end subroutine estimate_azimuthal_xpx_on_axis !============================================================================ ! Estimate radial component on the axis !============================================================================ subroutine axis_estimating_radial_xpx ( var , dtmp , pencil , dm , idir , is_reversed ) use math_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( inout ) :: var (:, :, :) integer , intent ( in ) :: pencil logical , optional , intent ( in ) :: is_reversed integer , intent ( in ) :: idir real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )) :: var_ypencil , var_ypencil1 real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )) :: var_zpencil , var_zpencil1 real ( WP ), dimension ( dtmp % zsz ( 1 )) :: uz , uy integer :: k , i real ( WP ) :: theta , sign ! only for axis value if ( dm % icase /= ICASE_PIPE . or . dm % icoordinate /= ICYLINDRICAL ) return ! if ( idir == IDIM ( 3 )) then ! for qz call transpose_to_y_pencil ( var , var_ypencil , dtmp , pencil ) var_ypencil (:, 1 , :) = ZERO ! zero qz at axis call transpose_from_y_pencil ( var_ypencil , var , dtmp , pencil ) else if ( idir == IDIM ( 1 )) then ! for ux, or scalars call transpose_to_z_pencil ( var , var_zpencil , dtmp , pencil ) if ( dtmp % zst ( 2 ) == 1 ) then ! for axis jj == 1 only do i = 1 , dtmp % zsz ( 1 ) theta = ZERO do k = 1 , dtmp % zsz ( 3 ) theta = theta + var_zpencil ( i , 1 , k ) end do var_zpencil ( i , 1 , :) = theta / real ( dtmp % zsz ( 3 ), WP ) end do end if call transpose_from_z_pencil ( var_zpencil , var , dtmp , pencil ) else if ( idir == IDIM ( 2 ) . or . idir == IDIM ( 0 )) then call transpose_to_y_pencil ( var , var_ypencil , dtmp , pencil ) call transpose_to_z_pencil ( var , var_zpencil , dtmp , pencil ) ! Assign a sign sign = ONE if ( present ( is_reversed )) then if ( is_reversed ) sign = - ONE end if ! Apply symmetry condition to find neighboring points do k = 1 , dtmp % zsz ( 3 ) var_zpencil1 (:, :, k ) = sign * var_zpencil (:, :, dm % knc_sym ( k )) end do ! Transpose back to y-pencil and get the multiple valued ur at axis call transpose_z_to_y ( var_zpencil1 , var_ypencil1 , dtmp ) var_ypencil (:, 1 , :) = ( var_ypencil1 (:, 2 , :) + var_ypencil (:, 2 , :)) * HALF ! Transpose to z-pencil for decomposition !call transpose_y_to_z(var_ypencil, var_zpencil, dtmp) ! below is eq(83) & (76) of https://doi.org/10.1016/j.jcp.2003.12.015 (Morinishi2004JCP) ! coorindates like: https://en.m.wikipedia.org/wiki/File:3D_coordinate_system.svg ! if(dtmp%zst(2) == 1) then ! for axis jj == 1 only !   if(idir == IDIM(2)) then ! for qy/r !     do i = 1, dtmp%zsz(1) !       uy(i) = ZERO !       uz(i) = ZERO !       do k = 1, dtmp%zsz(3) !         theta = dm%h(3) * real((k-1), WP) !         uz(i) = uz(i) + var_zpencil1(i, 1, k) * cos_wp(theta) !         uy(i) = uy(i) + var_zpencil1(i, 1, k) * sin_wp(theta) !       end do !       uy(i) = uy(i) * TWO / dtmp%zsz(3) !       uz(i) = uz(i) * TWO / dtmp%zsz(3) !       do k = 1, dtmp%zsz(3) !         theta = dm%h(3) * real((k-1), WP) !         var_zpencil1(i, 1, k) = uz(i) * cos_wp(theta) + uy(i) * sin_wp(theta) !       end do !     end do !   end if !   if(idir == IDIM(0)) then ! for qz/r only !     do i = 1, dtmp%zsz(1) !       uy(i) = ZERO !       uz(i) = ZERO !       do k = 1, dtmp%zsz(3) !         theta = dm%h(3) * real((k-1), WP) !         uz(i) = uz(i) - var_zpencil1(i, 1, k) * sin_wp(theta) !         uy(i) = uy(i) + var_zpencil1(i, 1, k) * cos_wp(theta) !       end do !       uy(i) = uy(i) * TWO / dtmp%zsz(3) !       uz(i) = uz(i) * TWO / dtmp%zsz(3) !       do k = 1, dtmp%zsz(3) !         theta = dm%h(3) * real((k-1), WP) !         var_zpencil1(i, 1, k) = - uz(i) * sin_wp(theta) + uy(i) * cos_wp(theta) !       end do !     end do !   endif ! end if ! Transpose back to the original pencil call transpose_from_y_pencil ( var_ypencil , var , dtmp , pencil ) else call Print_error_msg ( 'Invalid input for IDIM in axis_estimating_radial_xpx' ) end if return end subroutine axis_estimating_radial_xpx !============================================================================ ! Multiply cylindrical variable by r&#94;n !============================================================================ subroutine multiple_cylindrical_rn ( var , dtmp , r , n , pencil ) implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( inout ) :: var (:, :, :) real ( WP ), intent ( in ) :: r (:) integer , intent ( in ) :: n integer , intent ( in ) :: pencil integer :: i , j , k , jj , nx , ny , nz , nyst !logical :: is_axis ! Initialize dimensions based on pencil call get_dimensions ( dtmp , pencil , nx , ny , nz , nyst ) !is_axis = .false. do j = 1 , ny jj = nyst + j - 1 if ( r ( jj ) > ( MAXP * HALF )) then !is_axis = .true. if ( jj /= 1 ) call Print_error_msg ( \"Error: r(j) = 0 at j /= 1.\" ) else do k = 1 , nz do i = 1 , nx var ( i , j , k ) = var ( i , j , k ) * ( r ( jj ) ** n ) end do end do end if end do end subroutine multiple_cylindrical_rn !============================================================================ ! Multiply cylindrical variable by r&#94;n (specific for xx4 configuration) !============================================================================ subroutine multiple_cylindrical_rn_xx4 ( var , dtmp , r , n , pencil ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( inout ) :: var (:, :, :) real ( WP ), intent ( in ) :: r (:) integer , intent ( in ) :: n integer , intent ( in ) :: pencil integer :: i , j , jj , nx , ny , nz , nyst ! Initialize dimensions based on pencil call get_dimensions ( dtmp , pencil , nx , ny , nz , nyst ) if ( pencil /= IPENCIL ( 3 )) then call Print_warning_msg ( \"Warning: This is for z-pencil only.\" ) end if do j = 1 , ny jj = nyst + j - 1 if ( r ( jj ) > ( MAXP * HALF )) then if ( jj /= 1 ) call Print_error_msg ( \"Error: r(j) = 0 at j /= 1.\" ) else do i = 1 , nx var ( i , j , 1 ) = var ( i , j , 1 ) * ( r ( jj ) ** n ) var ( i , j , 2 ) = var ( i , j , 2 ) * ( r ( jj ) ** n ) var ( i , j , 3 ) = var ( i , j , 1 ) var ( i , j , 4 ) = var ( i , j , 2 ) end do end if end do end subroutine multiple_cylindrical_rn_xx4 !============================================================================ ! Multiply cylindrical variable by r&#94;n (specific for x4x configuration) !============================================================================ subroutine multiple_cylindrical_rn_x4x ( var , dtmp , r , n , pencil ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( inout ) :: var (:, :, :) real ( WP ), intent ( in ) :: r (:) integer , intent ( in ) :: n integer , intent ( in ) :: pencil integer :: i , k , jmax , nx , ny , nz , nyst ! Initialize dimensions based on pencil call get_dimensions ( dtmp , pencil , nx , ny , nz , nyst ) if ( pencil /= IPENCIL ( 2 )) then call Print_warning_msg ( \"Warning: This is for y-pencil only.\" ) end if do k = 1 , nz do i = 1 , nx if ( r ( 1 ) > ( MAXP * HALF )) then ! Axis handling using estimate_azimuthal_xpx_on_axis or axis_estimating_radial_xpx else var ( i , 1 , k ) = var ( i , 1 , k ) * ( r ( 1 ) ** n ) end if jmax = nyst + ny - 1 var ( i , 2 , k ) = var ( i , 2 , k ) * ( r ( jmax ) ** n ) var ( i , 3 , k ) = var ( i , 1 , k ) var ( i , 4 , k ) = var ( i , 2 , k ) end do end do end subroutine multiple_cylindrical_rn_x4x !============================================================================ ! Helper subroutine: Get dimensions based on pencil !============================================================================ subroutine get_dimensions ( dtmp , pencil , nx , ny , nz , nyst ) type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ) :: pencil integer , intent ( out ) :: nx , ny , nz , nyst select case ( pencil ) case ( IPENCIL ( 1 )) nx = dtmp % xsz ( 1 ) ny = dtmp % xsz ( 2 ) nz = dtmp % xsz ( 3 ) nyst = dtmp % xst ( 2 ) case ( IPENCIL ( 2 )) nx = dtmp % ysz ( 1 ) ny = dtmp % ysz ( 2 ) nz = dtmp % ysz ( 3 ) nyst = dtmp % yst ( 2 ) case ( IPENCIL ( 3 )) nx = dtmp % zsz ( 1 ) ny = dtmp % zsz ( 2 ) nz = dtmp % zsz ( 3 ) nyst = dtmp % zst ( 2 ) case default nx = 0 ny = 0 nz = 0 nyst = 0 end select end subroutine get_dimensions !============================================================================ ! Helper subroutine: Transpose input data to y-pencil !============================================================================ subroutine transpose_to_y_pencil ( var , var_ypencil , dtmp , pencil ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var (:, :, :) real ( WP ), intent ( out ) :: var_ypencil (:, :, :) integer , intent ( in ) :: pencil select case ( pencil ) case ( IPENCIL ( 1 )) call transpose_x_to_y ( var , var_ypencil , dtmp ) case ( IPENCIL ( 2 )) var_ypencil = var case ( IPENCIL ( 3 )) call transpose_z_to_y ( var , var_ypencil , dtmp ) case default ! Handle invalid pencil case (optional: add error handling) end select end subroutine transpose_to_y_pencil !============================================================================ ! Helper subroutine: Transpose input data to z-pencil !============================================================================ subroutine transpose_to_z_pencil ( var , var_zpencil , dtmp , pencil ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var (:, :, :) real ( WP ), intent ( out ) :: var_zpencil (:, :, :) integer , intent ( in ) :: pencil real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )) :: var_ypencil select case ( pencil ) case ( IPENCIL ( 1 )) call transpose_x_to_y ( var , var_ypencil , dtmp ) call transpose_y_to_z ( var_ypencil , var_zpencil , dtmp ) case ( IPENCIL ( 2 )) call transpose_y_to_z ( var , var_zpencil , dtmp ) case ( IPENCIL ( 3 )) var_zpencil = var case default ! Handle invalid pencil case (optional: add error handling) end select end subroutine transpose_to_z_pencil !============================================================================ ! Helper subroutine: Transpose data from z-pencil back to original pencil !============================================================================ subroutine transpose_from_z_pencil ( var_zpencil , var , dtmp , pencil ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var_zpencil (:, :, :) real ( WP ), intent ( out ) :: var (:, :, :) integer , intent ( in ) :: pencil real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )) :: var_ypencil select case ( pencil ) case ( IPENCIL ( 1 )) call transpose_z_to_y ( var_zpencil , var_ypencil , dtmp ) call transpose_y_to_x ( var_ypencil , var , dtmp ) case ( IPENCIL ( 2 )) call transpose_z_to_y ( var_zpencil , var , dtmp ) case ( IPENCIL ( 3 )) var = var_zpencil case default ! Handle invalid pencil case (optional: add error handling) end select end subroutine transpose_from_z_pencil !============================================================================ ! Helper subroutine: Transpose data from y-pencil back to original pencil !============================================================================ subroutine transpose_from_y_pencil ( var_ypencil , var , dtmp , pencil ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var_ypencil (:, :, :) real ( WP ), intent ( out ) :: var (:, :, :) integer , intent ( in ) :: pencil select case ( pencil ) case ( IPENCIL ( 1 )) call transpose_y_to_x ( var_ypencil , var , dtmp ) case ( IPENCIL ( 2 )) var = var_ypencil case ( IPENCIL ( 3 )) call transpose_y_to_z ( var_ypencil , var , dtmp ) case default ! Handle invalid pencil case (optional: add error handling) end select end subroutine transpose_from_y_pencil end module cylindrical_rn_mod !========================================================================================================== !========================================================================================================== subroutine profile_interpolation ( nin , yin , uin , nout , ycase , ucase ) use cubic_spline_interpolation use precision_mod use print_msg_mod implicit none integer , intent ( in ) :: nin real ( WP ), dimension ( nin ), intent ( in ) :: yin real ( WP ), dimension ( nin ), intent ( in ) :: uin integer , intent ( in ) :: nout real ( WP ), dimension ( nout ), intent ( in ) :: ycase real ( WP ), dimension ( nout ), intent ( out ) :: ucase integer :: i real ( WP ), allocatable :: cs_b (:), cs_c (:), cs_d (:) allocate ( cs_b ( nin )) allocate ( cs_c ( nin )) allocate ( cs_d ( nin )) call cubic_spline ( nin , yin , uin , cs_b , cs_c , cs_d ) do i = 1 , nout ucase ( i ) = spline_interpolation ( nin , uin , cs_b , cs_c , cs_d , ycase ( i )) end do deallocate ( cs_b ) deallocate ( cs_c ) deallocate ( cs_d ) return end subroutine !========================================================================================================== module find_max_min_ave_mod use print_msg_mod public :: Get_volumetric_average_3d_for_var_xcx public :: Find_maximum_absvar3d public :: Find_max_min_3d public :: Find_max_min_absvar3d contains !========================================================================================================== subroutine is_valid_number_3D ( var , varname ) use parameters_constant_mod use ieee_arithmetic implicit none real ( WP ), intent ( in ) :: var (:, :, :) character ( len =* ), intent ( in ) :: varname integer :: nx , ny , nz nx = size ( var , 1 ) ny = size ( var , 2 ) nz = size ( var , 3 ) ! Check for large numbers if ( maxval ( dabs ( var )) > 1.0e+10 ) then write ( * , * ) 'Large number detected (nrank=' , nrank , ') in ' , trim ( varname ) call Print_error_msg ( 'A large number is found. Stopping execution.' ) end if ! Check for NaN values if ( any ( ieee_is_nan ( var ))) then write ( * , * ) 'NaN detected (nrank=' , nrank , ') in ' , trim ( varname ) call Print_error_msg ( 'NaN is found. Stopping execution.' ) end if end subroutine is_valid_number_3D !========================================================================================================== subroutine Find_maximum_absvar3d ( var , varmax_work , dtmp , str , nxst0 ) use precision_mod use math_mod use mpi_mod use parameters_constant_mod use typeconvert_mod use wtformat_mod implicit none real ( WP ), intent ( in ) :: var (:, :, :) integer , intent ( in ), optional :: nxst0 type ( DECOMP_INFO ), intent ( in ) :: dtmp character ( len = * ), intent ( in ) :: str real ( WP ), intent ( out ) :: varmax_work real ( WP ) :: varmax integer :: idg ( 3 ), idl ( 3 ), idg_work ( 3 ) integer :: i , j , k , nx , ny , nz integer :: idgmax ( 3 ), nxst if ( present ( nxst0 )) then nxst = nxst0 else nxst = 1 end if nx = size ( var , 1 ) ny = size ( var , 2 ) nz = size ( var , 3 ) idgmax ( 1 ) = dtmp % xsz ( 1 ) idgmax ( 2 ) = dtmp % ysz ( 2 ) idgmax ( 3 ) = dtmp % zsz ( 3 ) varmax = ZERO idl = 0 idg = 0 do k = 1 , nz do j = 1 , ny do i = 1 , nx if ( abs_wp ( var ( i , j , k )) > varmax ) then varmax = abs_wp ( var ( i , j , k )) !idg = local2global_3indices(idl, dtmp) idg ( 1 ) = nxst + i - 1 idg ( 2 ) = dtmp % xst ( 2 ) + j - 1 idg ( 3 ) = dtmp % xst ( 3 ) + k - 1 end if end do end do end do !varmax = MAXVAL( abs_wp( var ) ) !call mpi_barrier(MPI_COMM_WORLD, ierror) call mpi_allreduce ( varmax , varmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) #ifdef DEBUG_STEPS if ( abs_wp ( varmax_work - varmax ) <= MINP ) then call mpi_send ( idg , 3 , MPI_INTEGER , 0 , 0 , MPI_COMM_WORLD , ierror ) end if if ( nrank == 0 ) then call mpi_recv ( idg_work , 3 , MPI_INTEGER , MPI_ANY_SOURCE , 0 , MPI_COMM_WORLD , MPI_STATUS_IGNORE , ierror ) !write (*, '(1X, A33, 1ES19.12)') 'maximum '//trim(str), varmax_work write ( * , '(3X, A33, 1ES19.12, A, 3(1I6.1, A6))' ) 'maximum ' // trim ( str ), varmax_work , ' at index' , & idg_work ( 1 ), '/' // int2str ( idgmax ( 1 )), & idg_work ( 2 ), '/' // int2str ( idgmax ( 2 )), & idg_work ( 3 ), '/' // int2str ( idgmax ( 3 )) end if #else if ( nrank == 0 ) then write ( * , wrtfmt1el ) 'maximum ' // trim ( str ), varmax_work end if #endif return end subroutine !========================================================================================================== subroutine Find_max_min_3d ( var , str , fmt ) use precision_mod use math_mod use mpi_mod use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: var (:, :, :) character ( len = * ), intent ( in ) :: str character ( len = * ), intent ( in ) :: fmt real ( WP ) :: varmax_work , varmin_work real ( WP ) :: varmax , varmin integer :: i , j , k , nx , ny , nz nx = size ( var , 1 ) ny = size ( var , 2 ) nz = size ( var , 3 ) varmax = MINN varmin = MAXP do k = 1 , nz do j = 1 , ny do i = 1 , nx if ( var ( i , j , k ) > varmax ) varmax = var ( i , j , k ) if ( var ( i , j , k ) < varmin ) varmin = var ( i , j , k ) end do end do end do !call mpi_barrier(MPI_COMM_WORLD, ierror) call mpi_allreduce ( varmax , varmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) call mpi_allreduce ( varmin , varmin_work , 1 , MPI_REAL_WP , MPI_MIN , MPI_COMM_WORLD , ierror ) if ( nrank == 0 ) then write ( * , fmt ) 'maximum ' // str , varmax_work , ' minimum ' // str , varmin_work end if ! #ifdef DEBUG_FFT !     if(varmax_work >   MAXVELO) call Print_error_msg('varmax_work >   MAXVELO') !     if(varmin_work < - MAXVELO) call Print_error_msg('varmax_work < - MAXVELO') ! #endif return end subroutine !   !========================================================================================================== !   subroutine Find_max_min_1d(var,  str, fmt) !     use precision_mod !     use math_mod !     use mpi_mod !     use parameters_constant_mod !     implicit none !     real(WP), intent(in)  :: var(:) !     character(len = *), intent(in) :: str !     character(len = *), intent(in), optional :: fmt !     real(WP):: varmax_work, varmin_work !     real(WP)   :: varmax, varmin !     integer :: i, nx !     nx = size(var, 1) !     varmax = MINN !     varmin = MAXP !     do i = 1, nx !       if( var(i)  > varmax) varmax = var(i) !       if( var(i)  < varmin) varmin = var(i) !     end do !     call mpi_barrier(MPI_COMM_WORLD, ierror) !     call mpi_allreduce(varmax, varmax_work, 1, MPI_REAL_WP, MPI_MAX, MPI_COMM_WORLD, ierror) !     call mpi_allreduce(varmin, varmin_work, 1, MPI_REAL_WP, MPI_MIN, MPI_COMM_WORLD, ierror) !     if(nrank == 0) then !       write (*, *) '        maximum '//str, varmax_work !       write (*, *) '        minimum '//str, varmin_work !     end if ! #ifdef DEBUG_FFT !     if(varmax_work >   MAXVELO) stop !     if(varmin_work < - MAXVELO) stop ! #endif !     return !   end subroutine !========================================================================================================== subroutine Find_max_min_absvar3d ( var , str , fmt ) use precision_mod use math_mod use mpi_mod use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: var (:, :, :) character ( len = * ), intent ( in ) :: str character ( len = * ), intent ( in ) :: fmt real ( WP ) :: varmax_work , varmin_work real ( WP ) :: varmax , varmin integer :: i , j , k , nx , ny , nz nx = size ( var , 1 ) ny = size ( var , 2 ) nz = size ( var , 3 ) varmax = MINN varmin = MAXP do k = 1 , nz do j = 1 , ny do i = 1 , nx if ( var ( i , j , k ) > varmax ) varmax = abs_wp ( var ( i , j , k ) ) if ( var ( i , j , k ) < varmin ) varmin = abs_wp ( var ( i , j , k ) ) end do end do end do !call mpi_barrier(MPI_COMM_WORLD, ierror) call mpi_allreduce ( varmax , varmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) call mpi_allreduce ( varmin , varmin_work , 1 , MPI_REAL_WP , MPI_MIN , MPI_COMM_WORLD , ierror ) if ( nrank == 0 ) then write ( * , fmt ) 'max. |' // str // '|' , varmax_work , ' min. |' // str // '|' , varmin_work end if ! #ifdef DEBUG_FFT !     if(varmax_work >   MAXVELO) call Print_error_msg('varmax_work >  MAXVELO') !     if(varmin_work < - MAXVELO) call Print_error_msg('varmax_work < -MAXVELO') ! #endif return end subroutine !========================================================================================================== subroutine Get_volumetric_average_3d_for_var_xcx ( dm , dtmp , var , fo_work , itype , str ) use mpi_mod use udf_type_mod use parameters_constant_mod use decomp_2d use wtformat_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var (:, :, :) real ( WP ), intent ( out ) :: fo_work integer , intent ( in ) :: itype character ( * ), optional , intent ( in ) :: str real ( WP ) :: vol , fo , vol_work , array ( 2 ), array_work ( 2 ) #ifdef DEBUG_STEPS real ( WP ) :: vol_real #endif integer :: i , j , k , jj real ( WP ) :: dx , dy , dz !---------------------------------------------------------------------------------------------------------- ! default: x-pencil ! use the chain rule to get integral in the stretching function ! integral(f(y), dy) = integral(f(y(s)), dy(s)) = integral(f(y(s)) * dy/ds, ds) !---------------------------------------------------------------------------------------------------------- vol = ZERO fo = ZERO dx = dm % h ( 1 ) dy = dm % h ( 2 ) dz = dm % h ( 3 ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !(j, dtmp) !dy = dm%yp(jj+1) - dm%yp(jj) if ( dm % is_stretching ( 2 )) & dy = dm % h ( 2 ) / dm % yMappingcc ( jj , 1 ) if ( dm % icoordinate == ICYLINDRICAL ) & dz = dm % h ( 3 ) * dm % rc ( jj ) do k = 1 , dtmp % xsz ( 3 ) do i = 1 , dtmp % xsz ( 1 ) fo = fo + var ( i , j , k ) * dy * dx * dz vol = vol + dy * dx * dz end do end do end do !call mpi_barrier(MPI_COMM_WORLD, ierror) array ( 1 ) = fo array ( 2 ) = vol call mpi_allreduce ( array , array_work , 2 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) fo_work = array_work ( 1 ) vol_work = array_work ( 2 ) if ( itype == SPACE_AVERAGE ) then fo_work = fo_work / vol_work else if ( itype == SPACE_INTEGRAL ) then ! do nothing end if #ifdef DEBUG_STEPS if ( nrank == 0 . and . present ( str )) then if ( itype == SPACE_AVERAGE ) then write ( * , wrtfmt1e ) \" volumetric average of \" // trim ( str ) // \" = \" , fo_work else write ( * , wrtfmt1e ) \" volumetric integeral of \" // trim ( str ) // \" = \" , fo_work end if end if #endif return end subroutine !========================================================================================================== subroutine Get_area_average_2d_for_fbcx ( dm , dtmp , var , fo_work , itype , str ) use mpi_mod use udf_type_mod use parameters_constant_mod use decomp_2d use wtformat_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var (:, :, :) real ( WP ), intent ( out ) :: fo_work ( 2 ) integer , intent ( in ) :: itype character ( 4 ), intent ( in ) :: str real ( WP ) :: area , fo ( 2 ), area_work , array ( 3 ), array_work ( 3 ) #ifdef DEBUG_STEPS real ( WP ) :: area_real #endif integer :: j , k , jj , nx , ny , nz real ( WP ) :: dy , dz !if(dtmp /= dm%dpcc) call Print_error_msg(\"Error: Get_area_average_2d_for_yz_pcc is for pcc only.\") if ( dtmp % xsz ( 1 ) /= dtmp % xen ( 1 )) call Print_error_msg ( \"Error. This is not x-pencil.\" ) ! x pencil only !---------------------------------------------------------------------------------------------------------- ! default: x-pencil ! use the chain rule to get integral in the stretching function ! integral(f(y), dy) = integral(f(y(s)), dy(s)) = integral(f(y(s)) * dy/ds, ds) !---------------------------------------------------------------------------------------------------------- area = ZERO fo = ZERO dy = dm % h ( 2 ) dz = dm % h ( 3 ) if ( str == 'varx' ) then nx = dtmp % xsz ( 1 ) else if ( str == 'fbcx' ) then nx = 2 else call Print_error_msg ( \"Error: Get_area_average_2d_for_fbcx is for varx or fbcx only.\" ) end if ny = dtmp % xsz ( 2 ) nz = dtmp % xsz ( 3 ) do j = 1 , ny jj = dtmp % xst ( 2 ) + j - 1 !(j, dtmp) !dy = dm%yp(jj+1) - dm%yp(jj) if ( dm % is_stretching ( 2 )) & dy = dm % h ( 2 ) / dm % yMappingcc ( jj , 1 ) if ( dm % icoordinate == ICYLINDRICAL ) then dz = dm % h ( 3 ) * dm % rc ( jj ) end if do k = 1 , nz fo ( 1 ) = fo ( 1 ) + var ( 1 , j , k ) * dy * dz fo ( 2 ) = fo ( 2 ) + var ( nx , j , k ) * dy * dz area = area + dy * dz end do end do array ( 1 : 2 ) = fo ( 1 : 2 ) array ( 3 ) = area call mpi_allreduce ( array , array_work , 3 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) fo_work ( 1 : 2 ) = array_work ( 1 : 2 ) area_work = array_work ( 3 ) if ( itype == SPACE_AVERAGE ) then fo_work (:) = fo_work (:) / area_work else if ( itype == SPACE_INTEGRAL ) then ! do nothing end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine Get_area_average_2d_for_fbcz ( dm , dtmp , var , fo_work , itype , str ) use mpi_mod use udf_type_mod use parameters_constant_mod use decomp_2d use wtformat_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var (:, :, :) real ( WP ), intent ( out ) :: fo_work ( 2 ) integer , intent ( in ) :: itype character ( 4 ), intent ( in ) :: str real ( WP ) :: area , fo ( 2 ), area_work , array ( 3 ), array_work ( 3 ) #ifdef DEBUG_STEPS real ( WP ) :: area_real #endif integer :: j , i , jj , nx , ny , nz real ( WP ) :: dy , dx !if(dtmp /= dm%dccp) call Print_error_msg(\"Error: Get_area_average_2d_for_yz_pcc is for ccp only.\") if ( dtmp % zsz ( 3 ) /= dtmp % zen ( 3 )) call Print_error_msg ( \"Error. This is not z-pencil.\" ) !---------------------------------------------------------------------------------------------------------- ! default: x-pencil ! use the chain rule to get integral in the stretching function ! integral(f(y), dy) = integral(f(y(s)), dy(s)) = integral(f(y(s)) * dy/ds, ds) !---------------------------------------------------------------------------------------------------------- area = ZERO fo = ZERO dy = dm % h ( 2 ) dx = dm % h ( 1 ) nx = dtmp % zsz ( 1 ) ny = dtmp % zsz ( 2 ) if ( str == 'varz' ) then nz = dtmp % zsz ( 3 ) else if ( str == 'fbcz' ) then nz = 2 else call Print_error_msg ( \"Error: Get_area_average_2d_for_fbcz is for varz or fbcz only.\" ) end if do j = 1 , ny jj = dtmp % zst ( 2 ) + j - 1 !(j, dtmp) if ( dm % is_stretching ( 2 )) & dy = dm % h ( 2 ) / dm % yMappingcc ( jj , 1 ) do i = 1 , nx fo ( 1 ) = fo ( 1 ) + var ( i , j , 1 ) * dy * dx fo ( 2 ) = fo ( 2 ) + var ( i , j , nz ) * dy * dx area = area + dy * dx end do end do array ( 1 : 2 ) = fo ( 1 : 2 ) array ( 3 ) = area call mpi_allreduce ( array , array_work , 3 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) fo_work ( 1 : 2 ) = array_work ( 1 : 2 ) area_work = array_work ( 3 ) if ( itype == SPACE_AVERAGE ) then fo_work (:) = fo_work (:) / area_work else if ( itype == SPACE_INTEGRAL ) then ! do nothing end if return end subroutine !========================================================================================================== subroutine Get_area_average_2d_for_fbcy ( dm , dtmp , var , fo_work , itype , str ) use mpi_mod use udf_type_mod use parameters_constant_mod use decomp_2d use wtformat_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var (:, :, :) real ( WP ), intent ( out ) :: fo_work ( 2 ) integer , intent ( in ) :: itype character ( 4 ), intent ( in ) :: str real ( WP ) :: area ( 2 ), fo ( 2 ), area_work ( 2 ), array ( 4 ), array_work ( 4 ) #ifdef DEBUG_STEPS real ( WP ) :: area_real #endif integer :: i , k , jj , ny , nz , nx real ( WP ) :: dz1 , dzn , dx !if(dtmp /= dm%dcpc) call Print_error_msg(\"Error: Get_area_average_2d_for_yz_pcc is for pcc only.\") if ( dtmp % ysz ( 2 ) /= dtmp % yen ( 2 )) call Print_error_msg ( \"Error. This is not y-pencil.\" ) !---------------------------------------------------------------------------------------------------------- ! default: x-pencil ! use the chain rule to get integral in the stretching function ! integral(f(y), dy) = integral(f(y(s)), dy(s)) = integral(f(y(s)) * dy/ds, ds) !---------------------------------------------------------------------------------------------------------- area = ZERO fo = ZERO nx = dtmp % ysz ( 1 ) if ( str == 'vary' ) then ny = dtmp % ysz ( 2 ) else if ( str == 'fbcy' ) then ny = 2 else call Print_error_msg ( \"Error: Get_area_average_2d_for_fbcy is for vary or fbcy only.\" ) end if nz = dtmp % ysz ( 3 ) dx = dm % h ( 1 ) dz1 = dm % h ( 3 ) dzn = dm % h ( 3 ) if ( dm % icoordinate == ICYLINDRICAL ) then dz1 = dm % h ( 3 ) * dm % rp ( 1 ) dzn = dm % h ( 3 ) * dm % rp ( ny ) end if do k = 1 , nz do i = 1 , nx fo ( 1 ) = fo ( 1 ) + var ( i , 1 , k ) * dx * dz1 fo ( 2 ) = fo ( 2 ) + var ( i , ny , k ) * dx * dzn area ( 1 ) = area ( 1 ) + dx * dz1 area ( 2 ) = area ( 2 ) + dx * dzn end do end do array ( 1 : 2 ) = fo ( 1 : 2 ) array ( 3 : 4 ) = area ( 1 : 2 ) call mpi_allreduce ( array , array_work , 4 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) fo_work ( 1 : 2 ) = array_work ( 1 : 2 ) area_work ( 1 : 2 ) = array_work ( 3 : 4 ) if ( itype == SPACE_AVERAGE ) then if ( dm % icase == ICASE_PIPE ) then fo_work ( 2 ) = fo_work ( 2 ) / area_work ( 2 ) fo_work ( 1 ) = ZERO else fo_work (:) = fo_work (:) / area_work (:) end if else if ( itype == SPACE_INTEGRAL ) then if ( dm % icase == ICASE_PIPE ) fo_work ( 1 ) = ZERO end if return end subroutine end module","tags":"","url":"sourcefile/tools_general.f90.html"},{"title":"eq_momentum2.f90 – CHAPSim2","text":"Source Code module eq_momentum_mod use operations use precision_mod use decomp_2d use print_msg_mod use wrt_debug_field_mod implicit none private :: Calculate_momentum_fractional_step private :: Compute_momentum_rhs private :: Correct_massflux private :: solve_poisson private :: gravity_decomposition_to_rz !private :: solve_poisson_x2z public :: Solve_momentum_eq contains !========================================================================================================== subroutine gravity_decomposition_to_rz ( dens , iforce , fgravity , fr_cpc_ypencil , ft_ccp_zpencil , dm ) use math_mod use udf_type_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( in ) :: dm INTEGER , intent ( in ) :: iforce real ( WP ), intent ( in ) :: fgravity real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )), intent ( in ) :: dens real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )), intent ( out ) :: fr_cpc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )), intent ( out ) :: ft_ccp_zpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: accc_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: acpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: accp_ypencil real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 )) :: acpp_ypencil real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 )) :: acpc_zpencil real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 )) :: acpp_zpencil , & fr_cpp_zpencil , & ft_cpp_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) :: fbcy_c4c integer :: k , j real ( WP ) :: theta if ( dm % icoordinate /= ICYLINDRICAL ) return !---------------------------------------------------------------------------------------------------------- !   density interpolation from ccc to cpp !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( dens , accc_ypencil , dm % dccc ) fbcy_c4c (:, :, :) = dm % fbcy_ftp (:, :, :)% d call Get_y_midp_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp , fbcy_c4c ) !call axis_estimating_radial_xpx(acpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(1)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'density' , acpc_ypencil ( 4 , 1 , 4 ), acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & acpc_ypencil ( 4 , 1 , 4 ) - acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call transpose_y_to_z ( acpc_ypencil , acpc_zpencil , dm % dcpc ) call Get_z_midp_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp ) ! assume z is periodic !---------------------------------------------------------------------------------------------------------- !   force: calculate in z-pencil !---------------------------------------------------------------------------------------------------------- if ( iforce == 2 . or . iforce == - 2 ) then acpp_zpencil = acpp_zpencil * fgravity do k = 1 , dm % dcpp % zsz ( 3 ) theta = dm % h ( 3 ) * REAL ( k , WP ) do j = 1 , dm % dccc % zsz ( 2 ) fr_cpp_zpencil (:, j , k ) = acpp_zpencil (:, j , k ) * sin_wp ( theta ) ft_cpp_zpencil (:, j , k ) = - acpp_zpencil (:, j , k ) * cos_wp ( theta ) end do end do else if ( iforce == 3 . or . iforce == - 3 ) then acpp_zpencil = acpp_zpencil * fgravity do k = 1 , dm % dcpp % zsz ( 3 ) theta = dm % h ( 3 ) * REAL ( k , WP ) do j = 1 , dm % dcpp % zsz ( 2 ) fr_cpp_zpencil (:, j , k ) = acpp_zpencil (:, j , k ) * cos_wp ( theta ) ft_cpp_zpencil (:, j , k ) = acpp_zpencil (:, j , k ) * sin_wp ( theta ) end do end do else call Print_error_msg ( 'gravity direction is not correct for cylindrical coordinates' ) end if !---------------------------------------------------------------------------------------------------------- !   back to momentum eq. !---------------------------------------------------------------------------------------------------------- call Get_z_midp_P2C_3D ( fr_cpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp ) call transpose_z_to_y ( acpc_zpencil , fr_cpc_ypencil , dm % dcpc ) call multiple_cylindrical_rn ( fr_cpc_ypencil , dm % dcpc , dm % rp , 1 , IPENCIL ( 2 )) ! fr * r call transpose_z_to_y ( ft_cpp_zpencil , acpp_ypencil , dm % dcpp ) call Get_y_midp_P2C_3D ( acpp_ypencil , accp_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp ) call transpose_y_to_z ( accp_ypencil , ft_ccp_zpencil , dm % dccp ) return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To calcuate the convection and diffusion terms in rhs of momentum eq. !> !> This subroutine is called everytime when calcuting the rhs of momentum eqs. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                         ! !______________________________________________________________________________! !> \\param[inout]  rhs0          the last iteration rhs !> \\param[inout]  rhs1          the current iteration rhs !> \\param[in]     rhs1_semi     the semi-implicit term !> \\param[in]     isub          the RK iteration to get correct Coefficient !_______________________________________________________________________________ subroutine Calculate_momentum_fractional_step ( rhs0 , rhs1 , rhs1_pfc , dtmp , dm , isub ) use parameters_constant_mod use udf_type_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( in ) :: rhs1_pfc real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: rhs0 , rhs1 integer , intent ( in ) :: isub real ( WP ) :: rhs_explicit_current , rhs_explicit_last , rhs_total integer :: i , j , k do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) do i = 1 , dtmp % xsz ( 1 ) ! add explicit terms : convection+viscous rhs rhs_explicit_current = rhs1 ( i , j , k ) ! not (* dt) rhs_explicit_last = rhs0 ( i , j , k ) ! not (* dt) rhs_total = dm % tGamma ( isub ) * rhs_explicit_current + & dm % tZeta ( isub ) * rhs_explicit_last rhs0 ( i , j , k ) = rhs_explicit_current ! not (* dt) ! add pressure gradient rhs_total = rhs_total + & dm % tAlpha ( isub ) * rhs1_pfc ( i , j , k ) ! times the time step rhs1 ( i , j , k ) = dm % dt * rhs_total ! * dt end do end do end do return end subroutine !========================================================================================================== !> \\brief To calcuate all rhs of momentum eq. !========================================================================================================== subroutine Compute_momentum_rhs ( fl , dm , isub ) use parameters_constant_mod use udf_type_mod use operations use solver_tools_mod use typeconvert_mod use boundary_conditions_mod use wrt_debug_field_mod use find_max_min_ave_mod use cylindrical_rn_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( inout ) :: dm integer , intent ( in ) :: isub !---------------------------------------------------------------------------------------------------------- ! result variables !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: mx_rhs_ypencil real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: mx_rhs_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: mx_rhs_pfc_xpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: my_rhs_ypencil real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: my_rhs_zpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: my_rhs_pfc_xpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: my_rhs_pfc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: mz_rhs_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: mz_rhs_zpencil real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: mz_rhs_pfc_xpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: mz_rhs_pfc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: mz_rhs_pfc_zpencil !---------------------------------------------------------------------------------------------------------- ! intermediate variables !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: pres_ypencil ! p-m2, common real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: pres_zpencil ! p-m3, common real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: div_ccc_xpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: div_ccc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: div_ccc_zpencil !---------------------------------------------------------------------------------------------------------- ! qx, gx !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: qxix_ccc_xpencil ! conv-x-m1, common real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: qxiy_ppc_ypencil ! conv-y-m1, common real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: qxiy_ppc_xpencil ! conv-x-m2, no-thermo real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: qxiz_pcp_zpencil ! conv-z-m1, common real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: qxiz_pcp_xpencil ! conv-x-m3, no-thermo real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: gxix_ccc_xpencil ! conv-x-m1, thermo real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: gxiy_ppc_xpencil ! conv-x-m2, <=> qxiy_ppc_xpencil real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: gxiz_pcp_xpencil ! conv-x-m3, <=> qxiz_pcp_xpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: qxdx_pcc_xpencil ! for div b.c., common real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qxdx_cpc_ypencil ! for div b.c., common real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qxdx_ccp_zpencil ! for div b.c., dommon real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: qxdx_ccc_xpencil ! diff-x-m1, common real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: qxdy_ppc_xpencil ! diff-x-m2, common real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: qxdy_ppc_ypencil ! diff-y-m1, common real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: qxdz_pcp_xpencil ! diff-x-m3, common real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: qxdz_pcp_zpencil ! diff-z-m1, common !---------------------------------------------------------------------------------------------------------- ! qy, gy !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: qyix_ppc_xpencil ! conv-x-m2, common real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: qyix_ppc_ypencil ! conv-y-m1, no-thermo real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qyiy_ccc_ypencil ! conv-y-m2, common real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qyiz_cpp_ypencil ! conv-y-m3, no-thermo real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qyiz_cpp_zpencil ! conv-z-m2, no-cly1 real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: gyix_ppc_ypencil ! conv-y-m1, <=> qyix_ppc_ypencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: gyiy_ccc_ypencil ! conv-y-m2, <=> qyiy_ccc_ypencil real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: gyiz_cpp_ypencil ! conv-y-m3, <=> qyiz_cpp_ypencil !real(WP), dimension( dm%dcpp%ysz(1), dm%dcpp%ysz(2), dm%dcpp%ysz(3) ) :: gyriz_cpp_ypencil ! conv-r-m3, <=> qyriz_cpp_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qyr_ypencil , qyr2_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: qyriy_ccc_zpencil ! diff-z-m3, cly real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qyriy_ccc_ypencil ! conv-y-m2, cly real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qyriz_cpp_ypencil ! conv-r-m3, no-thermal real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qyriz_cpp_zpencil ! conv-z-m2, cly1 real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: qydx_ppc_xpencil ! diff-x-m2, common real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: qydx_ppc_ypencil ! diff-y-m1, common real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qydz_cpp_ypencil ! diff-r-m3 real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qydz_cpp_zpencil ! diff-y-m3, no-cly2 real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qydy_ccc_ypencil ! diff-y-m2, no-cly1, div real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: qydy_pcc_xpencil ! for div b.c., common real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qydy_cpc_ypencil ! for div b.c., common real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qydy_ccp_zpencil ! for div b.c., common real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qyrdy_ccc_ypencil ! diff-y-m2, cly1 real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qyr2dz_cpp_zpencil ! diff-z-m2, cly2 real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qyrdz_cpp_ypencil , qyr2dz_cpp_ypencil ! diff-y-m3, cly3 !---------------------------------------------------------------------------------------------------------- ! qz, gz !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qz_zpencil real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: qzix_pcp_xpencil ! conv-x-m3, common real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: qzix_pcp_zpencil ! conv-z-m1, no-thermo, common real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qziy_cpp_ypencil ! conv-y-m3, common real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qziy_cpp_zpencil ! conv-z-m2, no-thermo, no-cly real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: qziz_ccc_zpencil ! conv-z-m3, common real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: gzix_pcp_zpencil ! conv-z-m1, <=> qzix_pcp_zpencil real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: gziy_cpp_zpencil ! conv-z-m2 real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: gziy_cpp_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: gziz_ccc_zpencil ! conv-z-m3, <=> qziz_ccc_zpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qziz_ccc_ypencil ! conv-r-m2, cly real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qzriy_cpp_ypencil ! conv-y-m3, conv-r-m3, diff-y-m3, diff-r-m3, common real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qzriy_cpp_zpencil ! diff-z-m2, cly ! real(WP), dimension( dm%dcpp%zsz(1), dm%dcpp%zsz(2), dm%dcpp%zsz(3) ) :: gzriy_cpp_zpencil ! conv-z-m2, real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: gziz_ccc_ypencil ! conv-r-m2, thermo+cly, real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: qzdx_pcp_xpencil ! diff-x-m3, common real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: qzdx_pcp_zpencil ! diff-z-m1, common real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: qzdy_cpp_ypencil ! diff-y-m3, no-cly real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: qzdy_cpp_zpencil ! diff-z-m2, no-cly real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: qzdz_ccc_ypencil ! diff-r-m2, cly real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: qzdz_ccc_zpencil ! diff-z-m3, common real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: qzdz_pcc_xpencil ! for div b.c. real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qzdz_cpc_ypencil ! for div b.c. real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: qzdz_ccp_zpencil ! for div b.c. real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: qzrdz_cpc_ypencil ! real(WP), dimension( dm%dcpp%ysz(1), dm%dcpp%ysz(2), dm%dcpp%ysz(3) ) :: qzrdy_cpp_ypencil ! diff-y-m3, diff-r-m3 ! real(WP), dimension( dm%dcpp%zsz(1), dm%dcpp%zsz(2), dm%dcpp%zsz(3) ) :: qzrdy_cpp_zpencil ! diff-z-m2, cly !---------------------------------------------------------------------------------------------------------- !   intermediate variables : if dm%is_thermo = true !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: mu_ccc_xpencil ! x-v1, thermal only real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: mu_ccc_ypencil ! y-v2, thermal only real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: mu_ccc_zpencil ! z-v3, thermal only real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: muiz_ccp_zpencil real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: muixy_ppc_xpencil ! diff-x-m2, thermal only real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: muixy_ppc_ypencil ! diff-y-m1, thermal only real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: muixz_pcp_xpencil ! diff-x-m3, thermal only real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: muixz_pcp_zpencil ! diff-z-m1, thermal only real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: muiyz_cpp_ypencil ! z-v2, z-v4, thermal only real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: muiyz_cpp_zpencil ! diff-z-m2, thermal only !---------------------------------------------------------------------------------------------------------- !   intermediate variables : if fl%igravity == i !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: dDens_ypencil ! d real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: dDens_zpencil ! d !---------------------------------------------------------------------------------------------------------- ! temporary variables !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: apcc_test real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: accp_test real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc_test #endif real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: apcc_xpencil , & apcc_xpencil1 , & apcc_xpencil2 , & apcc_xpencil3 real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc_xpencil real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: appc_xpencil , appc_xpencil1 real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: apcp_xpencil real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: appc_ypencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil , accc_ypencil1 real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: acpp_ypencil , acpp_ypencil1 real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil , acpc_ypencil1 real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: apcc_ypencil real ( WP ), dimension ( dm % dpcp % ysz ( 1 ), dm % dpcp % ysz ( 2 ), dm % dpcp % ysz ( 3 ) ) :: apcp_ypencil real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: apcp_zpencil real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: acpp_zpencil , acpp_zpencil1 real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil , accc_zpencil1 real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil , & accp_zpencil1 , & accp_zpencil2 , & accp_zpencil3 real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: acpc_zpencil , acpc_zpencil1 real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: apcc_zpencil real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: accp_xpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc_xpencil !---------------------------------------------------------------------------------------------------------- ! bc variables !---------------------------------------------------------------------------------------------------------- real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: fbcx_4cc real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: fbcx_div_4cc ! common real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: fbcx_mu_4cc ! thermo !real(WP), dimension( 4, dm%dppc%xsz(2), dm%dppc%xsz(3) ) :: fbcx_mu_4pc real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_c4c real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_c4c1 real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_div_c4c , fbcy_div_c4c1 real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_mu_c4c real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_cc4 real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_cc41 , fbcz_cc42 real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_div_cc4 real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_mu_cc4 real ( WP ), dimension ( 4 , dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: fbcx_4pc real ( WP ), dimension ( 4 , dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: fbcx_4cp real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), 4 ) :: fbcz_pc4 real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), 4 ) :: fbcz_cp4 real ( WP ), dimension ( dm % dppc % ysz ( 1 ), 4 , dm % dppc % ysz ( 3 ) ) :: fbcy_p4c real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), 4 , dm % dcpp % ysz ( 3 ) ) :: fbcy_c4p , fbcy_c4p1 !---------------------------------------------------------------------------------------------------------- ! others !---------------------------------------------------------------------------------------------------------- integer :: i , k real ( WP ) :: rhsx_bulk , rhsz_bulk integer :: ibcy ( 2 ), ibcz ( 2 ) !========================================================================================================== ! preparation of constants to be used. !========================================================================================================== #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_start_msg ( \"Compute_momentum_rhs at isub = \" // trim ( int2str ( isub ))) #endif !========================================================================================================== ! preparation of intermediate variables to be used - common ! Note: !      Due to bc treatment, please do interp first, then derivative to minumize numerical !      errors for Dirichlet B.C. !========================================================================================================== !---------------------------------------------------------------------------------------------------------- !    p --> p_ypencil --> p_zpencil !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( fl % pres , pres_ypencil , dm % dccc ) call transpose_y_to_z ( pres_ypencil , pres_zpencil , dm % dccc ) !---------------------------------------------------------------------------------------------------------- !   d --> d_ypencil --> d_zpencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo . and . fl % igravity /= 0 ) then call transpose_x_to_y ( fl % dDens , dDens_ypencil , dm % dccc ) call transpose_y_to_z ( dDens_ypencil , dDens_zpencil , dm % dccc ) end if !---------------------------------------------------------------------------------------------------------- !    qx !    | -[ipx]-> qxix_ccc_xpencil(common) !    | -[1dx]-> qxdx_ccc_xpencil(common) !    | -[x2y]-> qx_ypencil(temp) !               | -[ipy]-> qxiy_ppc_ypencil(common) -[y2x]-> qxiy_ppc_xpencil(no thermal)-[1dx]-> qxdx_cpc_xpencil(temp) -[x2y]-> qxdx_cpc_ypencil (for div bc) !               | -[1dy]-> qxdy_ppc_ypencil(common) -[y2x]-> qxdy_ppc_xpencil(common) !               | -[y2z]-> qx_zpencil(temp) !                          | -[ipz]-> qxiz_pcp_zpencil(common) -[z2x]-> qxiz_pcp_xpencil(no-thermal) !                                                            | -[1dx]-> qxdx_ccp_xpencil(temp) -[x2z]-> qxdx_ccp_zpencil (for div bc) !                          | -[1dz]-> qxdz_pcp_zpencil(common) -[z2y]-> qxdz_pcp_ypencil(temp) -[y2x]-> qxdz_pcp_xpencil(common) !---------------------------------------------------------------------------------------------------------- call Get_x_midp_P2C_3D ( fl % qx , qxix_ccc_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , dm % fbcx_qx ) call Get_x_1der_P2C_3D ( fl % qx , qxdx_ccc_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , dm % fbcx_qx ) ! call transpose_x_to_y ( fl % qx , apcc_ypencil , dm % dpcc ) !apcc_ypencil = qx_ypencil call Get_y_1der_C2P_3D ( apcc_ypencil , qxdy_ppc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx , dm % fbcy_qx ) ! #ifdef DEBUG_STEPS ! serial only if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qxdy_ppc_ypencil' , qxdy_ppc_ypencil ( 4 , 1 , 4 ), qxdy_ppc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qxdy_ppc_ypencil ( 4 , 1 , 4 ) + qxdy_ppc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif ! call transpose_y_to_x ( qxdy_ppc_ypencil , qxdy_ppc_xpencil , dm % dppc ) ! call Get_y_midp_C2P_3D ( apcc_ypencil , qxiy_ppc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx , dm % fbcy_qx ) ! for x-mom !call axis_estimating_radial_xpx(qxiy_ppc_ypencil, dm%dppc, IPENCIL(2), dm, IDIM(1)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qxiy_ppc_ypencil' , qxiy_ppc_ypencil ( 4 , 1 , 4 ), qxiy_ppc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qxiy_ppc_ypencil ( 4 , 1 , 4 ) - qxiy_ppc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif ! if (. not . dm % is_thermo ) then call transpose_y_to_x ( qxiy_ppc_ypencil , qxiy_ppc_xpencil , dm % dppc ) end if ! call transpose_y_to_z ( apcc_ypencil , apcc_zpencil , dm % dpcc ) !apcc_zpencil = qx_zpencil call Get_z_midp_C2P_3D ( apcc_zpencil , qxiz_pcp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx , dm % fbcz_qx ) ! if (. not . dm % is_thermo ) then call transpose_z_to_y ( qxiz_pcp_zpencil , apcp_ypencil , dm % dpcc ) ! apcp_ypencil = qxiz_pcp_ypencil call transpose_y_to_x ( apcp_ypencil , qxiz_pcp_xpencil , dm % dpcp ) end if ! call Get_z_1der_C2P_3D ( apcc_zpencil , qxdz_pcp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx , dm % fbcz_qx ) ! call transpose_z_to_y ( qxdz_pcp_zpencil , apcp_ypencil , dm % dpcp ) !qxdz_pcp_ypencil call transpose_y_to_x ( apcp_ypencil , qxdz_pcp_xpencil , dm % dpcp ) !---------------------------------------------------------------------------------------------------------- !   qx related b.c. !---------------------------------------------------------------------------------------------------------- if ( is_fbcy_velo_required ) then ! qxiy_ppc_ypencil --> qxdx_cpc_ypencil (for div. b.c.) call transpose_y_to_x ( qxiy_ppc_ypencil , appc_xpencil , dm % dppc ) if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4pc , appc_xpencil , dm % dppc ) else fbcx_4pc = MAXP end if ! call Get_x_1der_P2C_3D ( appc_xpencil , acpc_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , fbcx_4pc ) call transpose_x_to_y ( acpc_xpencil , qxdx_cpc_ypencil , dm % dcpc ) end if if ( is_fbcz_velo_required ) then ! qxiz_pcp_zpencil --> qxdx_ccp_zpencil (for div. b.c.) call transpose_z_to_y ( qxiz_pcp_zpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_x ( apcp_ypencil , apcp_xpencil , dm % dpcp ) if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4cp , apcp_xpencil , dm % dpcp ) else fbcx_4cp = MAXP end if call Get_x_1der_P2C_3D ( apcp_xpencil , accp_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , fbcx_4cp ) call transpose_x_to_y ( accp_xpencil , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , qxdx_ccp_zpencil , dm % dccp ) end if #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'qx preparation ... done.' ) #endif !---------------------------------------------------------------------------------------------------------- !    qy !    | -[ipx]-> qyix_ppc_xpencil(common) -[x2y]-> qyix_ppc_ypencil(no thermal) !    | -[1dx]-> qydx_ppc_xpencil(common) -[x2y]-> qydx_ppc_ypencil(common) !    | -[x2y]-> qy_ypencil(temp) !               | -[ipy]-> qyiy_ccc_ypencil !               | -[1dy]-> qydy_ccc_ypencil(no-cly, div) !               | -[y2z]-> qy_zpencil(temp) !                          | -[ipz]-> qyiz_cpp_zpencil(no-cly) -[z2y]-> qyiz_cpp_ypencil(no-thermal, cly) !                          | -[1dz]-> qydz_cpp_zpencil(no-cly) -[z2y]-> qydz_cpp_ypencil !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( fl % qy , qydx_ppc_xpencil , dm , dm % iAccuracy , dm % ibcx_qy , dm % fbcx_qy ) ! call transpose_x_to_y ( qydx_ppc_xpencil , qydx_ppc_ypencil , dm % dppc ) ! call Get_x_midp_C2P_3D ( fl % qy , qyix_ppc_xpencil , dm , dm % iAccuracy , dm % ibcx_qy , dm % fbcx_qy ) ! if (. not . dm % is_thermo ) then call transpose_x_to_y ( qyix_ppc_xpencil , qyix_ppc_ypencil , dm % dppc ) end if ! call transpose_x_to_y ( fl % qy , acpc_ypencil , dm % dcpc ) !acpc_ypencil = qy_ypencil #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qy_ypencil' , acpc_ypencil ( 4 , 1 , 4 ), acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & acpc_ypencil ( 4 , 1 , 4 ) - acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call Get_y_1der_P2C_3D ( acpc_ypencil , qydy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qy ) ! call Get_y_midp_P2C_3D ( acpc_ypencil , qyiy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qy ) ! call transpose_y_to_z ( acpc_ypencil , acpc_zpencil , dm % dcpc ) !acpc_zpencil = qy_zpencil call Get_z_1der_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy , dm % fbcz_qy ) ! acpp_zpencil = qydz call transpose_z_to_y ( acpp_zpencil , qydz_cpp_ypencil , dm % dcpp ) ! if ( dm % icoordinate == ICARTESIAN ) then qydz_cpp_zpencil = acpp_zpencil end if call Get_z_midp_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy , dm % fbcz_qy ) ! acpp_zpencil = qyiz ! if ( dm % icoordinate == ICARTESIAN ) then qyiz_cpp_zpencil = acpp_zpencil end if if (. not . dm % is_thermo ) then call transpose_z_to_y ( acpp_zpencil , qyiz_cpp_ypencil , dm % dcpp ) end if !---------------------------------------------------------------------------------------------------------- !   qy related b.c. !---------------------------------------------------------------------------------------------------------- if ( is_fbcx_velo_required ) then !qyix_ppc_xpencil --> qydy_pcc_xpencil  for div b.c. call transpose_x_to_y ( qyix_ppc_xpencil , appc_ypencil , dm % dppc ) if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_p4c , appc_ypencil , dm % dppc , dm , is_reversed = . true .) else fbcy_p4c = MAXP end if call Get_y_1der_P2C_3D ( appc_ypencil , apcc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , fbcy_p4c ) call transpose_y_to_x ( apcc_ypencil , qydy_pcc_xpencil , dm % dpcc ) end if if ( is_fbcy_velo_required ) then !qydy_cpc_ypencil for div b.c. !acpc_ypencil = qy_ypencil call Get_y_midp_P2C_3D ( acpc_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qy ) call Get_y_1der_C2P_3D ( accc_ypencil , qydy_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qy ) !write(*,*) 'qydy_cpc_ypencil', qydy_cpc_ypencil(4, 1, 1), qydy_cpc_ypencil(4, 1, dm%knc_sym(1)) ! not symmetric, correct end if if ( is_fbcz_velo_required ) then !qyiz_cpp_zpencil --> qydy_ccp_zpencil  for div b.c. !acpp_zpencil = qyiz_cpp_zpencil call transpose_z_to_y ( acpp_zpencil , acpp_ypencil , dm % dcpp ) if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_c4p , acpp_ypencil , dm % dcpp , dm , is_reversed = . true .) else fbcy_c4p = MAXP end if call Get_y_1der_P2C_3D ( acpp_ypencil , accp_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , fbcy_c4p ) call transpose_y_to_z ( accp_ypencil , qydy_ccp_zpencil , dm % dpcc ) end if #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'qy preparation ... done.' ) #endif !---------------------------------------------------------------------------------------------------------- !    qz !    | -[1dx]-> qzdx_pcp_xpencil(common) -[x2y]-> qzdx_pcp_ypencil(temp) -[y2z]-> qzdx_pcp_zpencil(common) !    | -[ipx]-> qzix_pcp_xpencil(common) -[x2y]-> qzix_pcp_ypencil(temp) -[y2z]-> qzix_pcp_zpencil(no-thermal) !    | -[x2y]-> qz_ypencil(temp) !               | -[1dy]-> qzdy_cpp_ypencil(no-cly) -[y2z]-> qzdy_cpp_zpencil !               | -[ipy]-> qziy_cpp_ypencil(no-cly) -[y2z]-> qziy_cpp_zpencil(no thermal) !               | -[y2z]-> qz_zpencil(temp) !                          | -[ipz]-> qziz_ccc_zpencil(common) !                          | -[1dz]-> qzdz_ccc_zpencil(common) -[y2z]-> qzdz_ccc_ypencil(cly) !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( fl % qz , qzdx_pcp_xpencil , dm , dm % iAccuracy , dm % ibcx_qz , dm % fbcx_qz ) call transpose_x_to_y ( qzdx_pcp_xpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_z ( apcp_ypencil , qzdx_pcp_zpencil , dm % dpcp ) call Get_x_midp_C2P_3D ( fl % qz , qzix_pcp_xpencil , dm , dm % iAccuracy , dm % ibcx_qz , dm % fbcx_qz ) !if(.not. dm%is_thermo) then call transpose_x_to_y ( qzix_pcp_xpencil , apcp_ypencil , dm % dpcp ) !qzix_pcp_ypencil call transpose_y_to_z ( apcp_ypencil , qzix_pcp_zpencil , dm % dpcp ) !end if call transpose_x_to_y ( fl % qz , accp_ypencil , dm % dccp ) ! qz_ypencil call Get_y_midp_C2P_3D ( accp_ypencil , qziy_cpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz , dm % fbcy_qz ) ! z-mom !call axis_estimating_radial_xpx(qziy_cpp_ypencil, dm%dcpp, IPENCIL(2), dm, IDIM(3)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qziy_cpp_ypencil' , qziy_cpp_ypencil ( 4 , 1 , 4 ), qziy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qziy_cpp_ypencil ( 4 , 1 , 4 ) + qziy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif ! call Get_y_1der_C2P_3D ( accp_ypencil , qzdy_cpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz , dm % fbcy_qz ) ! check ! !if(dm%icase == ICASE_PIPE) qzdy_cpp_ypencil(:, 1, :) = ZERO ! check , test #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qzdy_cpp_ypencil' , qzdy_cpp_ypencil ( 4 , 1 , 4 ), qzdy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qzdy_cpp_ypencil ( 4 , 1 , 4 ) - qzdy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif !qzdy_cpp_ypencil(:, 1, :) = ZERO ! check , test !write(*,*) 'qzdy_cpp_ypencil', qzdy_cpp_ypencil(4, 1, 1), qzdy_cpp_ypencil(4, 1, dm%knc_sym(1)) ! correct, symmetric ! call transpose_y_to_z ( qzdy_cpp_ypencil , qzdy_cpp_zpencil , dm % dcpp ) ! if ((. not . dm % is_thermo ) . or . ( dm % icoordinate == ICYLINDRICAL )) then call transpose_y_to_z ( qziy_cpp_ypencil , qziy_cpp_zpencil , dm % dcpp ) end if ! call transpose_y_to_z ( accp_ypencil , qz_zpencil , dm % dccp ) ! qz_zpencil call Get_z_midp_P2C_3D ( qz_zpencil , qziz_ccc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , dm % fbcz_qz ) call Get_z_1der_P2C_3D ( qz_zpencil , qzdz_ccc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , dm % fbcz_qz ) ! if ( dm % icoordinate == ICYLINDRICAL ) then call transpose_z_to_y ( qziz_ccc_zpencil , qziz_ccc_ypencil , dm % dccc ) call transpose_z_to_y ( qzdz_ccc_zpencil , qzdz_ccc_ypencil , dm % dccc ) end if !---------------------------------------------------------------------------------------------------------- !   qz related b.c. !---------------------------------------------------------------------------------------------------------- if ( is_fbcx_velo_required ) then !qzdz_pcc_xpencil for div b.c. if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_pc4 , qzix_pcp_zpencil , dm % dpcp ) else fbcz_pc4 = MAXP end if call Get_z_1der_P2C_3D ( qzix_pcp_zpencil , apcc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , fbcz_pc4 ) call transpose_z_to_y ( apcc_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , qzdz_pcc_xpencil , dm % dpcc ) end if if ( is_fbcy_velo_required ) then ! qzdz_cpc_ypencil for div b.c. call transpose_y_to_z ( qziy_cpp_ypencil , acpp_zpencil , dm % dcpp ) if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_cp4 , acpp_zpencil , dm % dcpp ) else fbcz_cp4 = MAXP end if call Get_z_1der_P2C_3D ( acpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , fbcz_cp4 ) !acpc_zpencil = qzdz call transpose_z_to_y ( acpc_zpencil , qzdz_cpc_ypencil , dm % dcpc ) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qzdz_cpc_ypencil' , qzdz_cpc_ypencil ( 4 , 1 , 4 ), qzdz_cpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qzdz_cpc_ypencil ( 4 , 1 , 4 ) + qzdz_cpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif end if if ( is_fbcz_velo_required ) then ! qzdz_ccp_zpencil for div b.c. call Get_z_1der_C2P_3D ( qziz_ccc_zpencil , qzdz_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , dm % fbcz_qz ) end if #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'qz preparation ... done.' ) #endif !========================================================================================================== ! preparation of intermediate variables to be used - thermal only !========================================================================================================== if (. not . dm % is_thermo ) then mu_ccc_xpencil = ONE ! x-v1, default for flow only mu_ccc_ypencil = ONE ! y-v2, default for flow only mu_ccc_zpencil = ONE ! z-v3, default for flow only muiz_ccp_zpencil = ONE muixy_ppc_xpencil = ONE ! y-v1, default for flow only muixy_ppc_ypencil = ONE ! x-v2, default for flow only muixz_pcp_xpencil = ONE ! z-v1, default for flow only muixz_pcp_zpencil = ONE ! x-v3, default for flow only muiyz_cpp_ypencil = ONE ! z-v2, default for flow only muiyz_cpp_zpencil = ONE ! y-v3, default for flow only fbcx_mu_4cc = ONE fbcy_mu_c4c = ONE fbcz_mu_cc4 = ONE end if if ( dm % is_thermo ) then !---------------------------------------------------------------------------------------------------------- !    gx !    | -[ipx]-> gxix_ccc_xpencil !    | -[x2y]-> gx_ypencil(temp) !               | -[ipy]-> gxiy_ppc_ypencil(temp) -[y2x]-> gxiy_ppc_xpencil !               | -[y2z]-> gx_zpencil(temp) !                          | -[ipz]-> gxiz_pcp_zpencil(temp) -[z2y]-> gxiz_pcp_ypencil(temp) -[y2x]-> gxiz_pcp_xpencil !---------------------------------------------------------------------------------------------------------- call Get_x_midp_P2C_3D ( fl % gx , gxix_ccc_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , dm % fbcx_gx ) ! call transpose_x_to_y ( fl % gx , apcc_ypencil , dm % dpcc ) !gx_ypencil call Get_y_midp_C2P_3D ( apcc_ypencil , appc_ypencil , dm , dm % iAccuracy , dm % ibcy_qx , dm % fbcy_gx ) !call axis_estimating_radial_xpx(appc_ypencil, dm%dppc, IPENCIL(2), dm, IDIM(1)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'gxiy_ppc_ypencil' , appc_ypencil ( 4 , 1 , 4 ), appc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & appc_ypencil ( 4 , 1 , 4 ) - appc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call transpose_y_to_x ( appc_ypencil , gxiy_ppc_xpencil , dm % dppc ) ! call transpose_y_to_z ( apcc_ypencil , apcc_zpencil , dm % dpcc ) !gx_zpencil call Get_z_midp_C2P_3D ( apcc_zpencil , apcp_zpencil , dm , dm % iAccuracy , dm % ibcz_qx , dm % fbcz_gx ) call transpose_z_to_y ( apcp_zpencil , apcp_ypencil , dm % dpcc ) !qxiz_pcp_ypencil call transpose_y_to_x ( apcp_ypencil , gxiz_pcp_xpencil , dm % dpcp ) #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'gx preparation ... done.' ) #endif !---------------------------------------------------------------------------------------------------------- !    gy !    | -[ipx]-> gyix_ppc_xpencil(temp) -[x2y]-> gyix_ppc_ypencil !    | -[x2y]-> gy_ypencil(temp) !               | -[ipy]-> gyiy_ccc_ypencil !               | -[y2z]-> gy_zpencil(temp) !                          | -[ipz]-> gyiz_cpp_zpencil(temp) -[z2y]-> gyiz_cpp_ypencil !---------------------------------------------------------------------------------------------------------- call Get_x_midp_C2P_3D ( fl % gy , appc_xpencil , dm , dm % iAccuracy , dm % ibcx_qy , dm % fbcx_gy ) call transpose_x_to_y ( appc_xpencil , gyix_ppc_ypencil , dm % dppc ) !write(*,*) 'gyix_ppc_ypencil', gyix_ppc_ypencil(4, 1, 1:4) call transpose_x_to_y ( fl % gy , acpc_ypencil , dm % dcpc ) !acpc_ypencil = gy_ypencil call Get_y_midp_P2C_3D ( acpc_ypencil , gyiy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_gy ) call transpose_y_to_z ( acpc_ypencil , acpc_zpencil , dm % dcpc ) !qy_zpencil call Get_z_midp_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy , dm % fbcz_gy ) call transpose_z_to_y ( acpp_zpencil , gyiz_cpp_ypencil , dm % dcpp ) !write(*,*) 'gyiz_cpp_ypencil', gyiz_cpp_ypencil(4, 1, 1:4) #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'gy preparation ... done.' ) #endif !---------------------------------------------------------------------------------------------------------- !    gz !    | -[ipx]-> gzix_pcp_xpencil(temp) -[x2y]-> gzix_pcp_ypencil(temp) -[y2z]-> gzix_pcp_zpencil !    | -[x2y]-> gz_ypencil(temp) !               | -[ipy]-> gziy_cpp_ypencil(temp) -[y2z]-> gziy_cpp_zpencil !               | -[y2z]-> gz_zpencil(temp) !                          | -[ipz]-> gziz_ccc_zpencil !---------------------------------------------------------------------------------------------------------- call Get_x_midp_C2P_3D ( fl % gz , apcp_xpencil , dm , dm % iAccuracy , dm % ibcx_qz , dm % fbcx_gz ) ! call transpose_x_to_y ( apcp_xpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_z ( apcp_ypencil , gzix_pcp_zpencil , dm % dpcp ) ! call transpose_x_to_y ( fl % gz , accp_ypencil , dm % dccp ) ! gz_ypencil call Get_y_midp_C2P_3D ( accp_ypencil , gziy_cpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz , dm % fbcy_gz ) !call axis_estimating_radial_xpx(acpp_ypencil, dm%dcpp, IPENCIL(2), dm, IDIM(3)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'gziy_cpp_ypencil' , gziy_cpp_ypencil ( 4 , 1 , 4 ), gziy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & gziy_cpp_ypencil ( 4 , 1 , 4 ) - gziy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call transpose_y_to_z ( gziy_cpp_ypencil , gziy_cpp_zpencil , dm % dcpp ) ! call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) ! gz_zpencil call Get_z_midp_P2C_3D ( accp_zpencil , gziz_ccc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , dm % fbcz_gz ) if ( dm % icoordinate == ICYLINDRICAL ) then call transpose_z_to_y ( gziz_ccc_zpencil , gziz_ccc_ypencil , dm % dccc ) end if #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'gz preparation ... done.' ) #endif !---------------------------------------------------------------------------------------------------------- !    m = mu_ccc_xpencil <need BCx> !             BCx:|-->mu_4cc_xpencil !    | -[ipx]-> muix_pcc_xpencil(temp) -[x2y]-> muix_pcc_ypencil(temp) !                                               | -[ipy]-> muixy_ppc_ypencil -[y2z]-> muixy_ppc_xpencil !                                               | -[y2z]-> muix_pcc_zpencil(temp) -[ipz]-> muixz_pcp_zpencil -[z2y]-> muixz_pcp_ypencil (temp) -[y2z]-> muixz_pcp_xpencil !    | -[x2y]-> mu_ccc_ypencil <need BCy> -[y2z]-> mu_ccc_zpencil <need BCz> !                                             BCz:|-[ipz]->mu_ccp_zpencil -> mu_cc4_zpencil !              | -[ipy]-> muiy_cpc_ypencil(temp) -[y2z]-> muiy_cpc_zpencil(temp) -[ipz]-> muiyz_cpp_zpencil -[z2y]-> muiyz_cpp_ypencil !                     BCy:|->mu_c4c_ypencil !---------------------------------------------------------------------------------------------------------- ! fbcy_c4c               ! fbcy_p4c ! &#94;z_________________    ! &#94;z_________________ ! |   |   |   |   |      ! |   |   |   |   | ! | O | O | O | O |      ! O   O   O   O   O ! |___|___|___|___|__    ! |___|___|___|___|__ ! |   |   |   |   |      ! |   |   |   |   | ! | O | O | O | O |      ! O   O   O   O   O ! |___|___|___|___|__>x  ! |___|___|___|___|__>x ! the interpolation for constant value is exact same. ignore the warning message if pops up. !---------------------------------------------------------------------------------------------------------- fbcx_4cc = MAXP fbcy_c4c = MAXP fbcz_cc4 = MAXP fbcx_4cc (:, :, :) = dm % fbcx_ftp (:, :, :)% m fbcy_c4c (:, :, :) = dm % fbcy_ftp (:, :, :)% m fbcz_cc4 (:, :, :) = dm % fbcz_ftp (:, :, :)% m #ifdef DEBUG_STEPS write ( * , * ) 'fbcy_m' , fbcy_c4c ( 1 , 1 : 4 , 1 ) #endif mu_ccc_xpencil = fl % mVisc call transpose_x_to_y ( mu_ccc_xpencil , mu_ccc_ypencil , dm % dccc ) call transpose_y_to_z ( mu_ccc_ypencil , mu_ccc_zpencil , dm % dccc ) ! call Get_y_midp_C2P_3D ( mu_ccc_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp , fbcy_c4c ) !call axis_estimating_radial_xpx(acpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(1)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'mu_cpc_ypencil' , acpc_ypencil ( 4 , 1 , 4 ), acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & acpc_ypencil ( 4 , 1 , 4 ) - acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call transpose_y_to_x ( acpc_ypencil , acpc_xpencil , dm % dcpc ) !acpc_xpencil = muiy_cpc_xpencil call get_fbcx_ftp_4pc ( fbcx_4cc , fbcx_4pc , dm ) call Get_x_midp_C2P_3D ( acpc_xpencil , muixy_ppc_xpencil , dm , dm % iAccuracy , dm % ibcx_ftp , fbcx_4pc ) ! call transpose_x_to_y ( muixy_ppc_xpencil , muixy_ppc_ypencil , dm % dppc ) ! call Get_x_midp_C2P_3D ( mu_ccc_xpencil , apcc_xpencil , dm , dm % iAccuracy , dm % ibcx_ftp , fbcx_4cc ) call transpose_x_to_y ( apcc_xpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_z ( apcc_ypencil , apcc_zpencil , dm % dpcc ) call Get_z_midp_C2P_3D ( apcc_zpencil , muixz_pcp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp ) !, fbcz_pc4) ! call transpose_z_to_y ( muixz_pcp_zpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_x ( apcp_ypencil , muixz_pcp_xpencil , dm % dpcp ) ! call transpose_y_to_z ( acpc_ypencil , acpc_zpencil , dm % dcpc ) !muiy_cpc_zpencil call Get_z_midp_C2P_3D ( acpc_zpencil , muiyz_cpp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp ) !, fbcz_cp4) ! call transpose_z_to_y ( muiyz_cpp_zpencil , muiyz_cpp_ypencil , dm % dcpp ) ! if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_mu_4cc , apcc_xpencil , dm % dpcc ) end if if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_mu_c4c , acpc_ypencil , dm % dcpc , dm , is_reversed = . false .) end if if ( is_fbcz_velo_required ) then call Get_z_midp_C2P_3D ( mu_ccc_zpencil , muiz_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp , fbcz_cc4 ) ! accp_zpencil = muiz_ccp_zpencil call extract_dirichlet_fbcz ( fbcz_mu_cc4 , accp_zpencil , dm % dccp ) end if #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'mu preparation ... done.' ) #endif end if !========================================================================================================== ! preparation of intermediate variables to be used - cylindrical only !========================================================================================================== if ( dm % icoordinate == ICYLINDRICAL ) then !---------------------------------------------------------------------------------------------------------- !    qy/r=qyr !    | -[x2y]-> qyr_ypencil(temp) !               | -[ipy]-> qyriy_ccc_ypencil-[y2z]->qyriy_ccc_zpencil !               | -[1dy]-> qyrdy_ccc_ypencil !               | -[y2z]-> qyr_zpencil(temp) !                          | -[ipz]-> qyriz_cpp_zpencil -[z2y]-> qyriz_cpp_ypencil (no-thermal) !                          | -[1dz]-> qyrdz_cpp_zpencil -[z2y]-> qyrdz_cpp_ypencil !     qy/r in r=0 is not zero, but qy is zero! qy/r = 0.5 * (qy/r + qy/r_sym) !---------------------------------------------------------------------------------------------------------- acpc_xpencil = fl % qy call multiple_cylindrical_rn ( acpc_xpencil , dm % dcpc , dm % rpi , 1 , IPENCIL ( 1 )) ! qr/r call transpose_x_to_y ( acpc_xpencil , qyr_ypencil , dm % dcpc ) ! acpc_ypencil = qyr_ypencil !qyr_ypencil(:, 1, :) = dm%fbcy_qyr(:, 1, :) call axis_estimating_radial_xpx ( qyr_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 2 ), is_reversed = . true .) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qyr_ypencil' , qyr_ypencil ( 4 , 1 , 4 ), qyr_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qyr_ypencil ( 4 , 1 , 4 ) - qyr_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif ! call Get_y_midp_P2C_3D ( qyr_ypencil , qyriy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qyr ) ! call transpose_y_to_z ( qyriy_ccc_ypencil , qyriy_ccc_zpencil , dm % dccc ) ! call Get_y_1der_P2C_3D ( qyr_ypencil , qyrdy_ccc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qyr ) ! check r treatment ! call transpose_y_to_z ( qyr_ypencil , acpc_zpencil , dm % dcpc ) call Get_z_midp_C2P_3D ( acpc_zpencil , qyriz_cpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy , dm % fbcz_qyr ) ! if (. not . dm % is_thermo ) call transpose_z_to_y ( qyriz_cpp_zpencil , qyriz_cpp_ypencil , dm % dcpp ) ! call Get_z_1der_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy , dm % fbcz_qyr ) call transpose_z_to_y ( acpp_zpencil , qyrdz_cpp_ypencil , dm % dcpp ) !write(*,*) 'qyrdz_cpp_ypencil', qyrdz_cpp_ypencil(4, 1, 1:4) ! all difference, check! ! acpc_xpencil = fl % qy call multiple_cylindrical_rn ( acpc_xpencil , dm % dcpc , dm % rpi , 2 , IPENCIL ( 1 )) ! qr/r&#94;2 call transpose_x_to_y ( acpc_xpencil , qyr2_ypencil , dm % dcpc ) ! acpc_ypencil = qr/r&#94;2_ypencil call axis_estimating_radial_xpx ( qyr2_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 2 ), is_reversed = . true .) !write(*,*) 'qyr2_ypencil', qyr2_ypencil(4, 1, 1:4) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qyr2_ypencil' , qyr2_ypencil ( 4 , 1 , 4 ), qyr2_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qyr2_ypencil ( 4 , 1 , 4 ) + qyr2_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif ! call transpose_y_to_z ( qyr2_ypencil , acpc_zpencil , dm % dcpc ) call Get_z_1der_C2P_3D ( acpc_zpencil , qyr2dz_cpp_zpencil , dm , dm % iAccuracy , dm % ibcz_qy , dm % fbcz_qyr ) ! to check, this bc is not used for peridoic z ! call transpose_z_to_y ( qyr2dz_cpp_zpencil , qyr2dz_cpp_ypencil , dm % dcpp ) !write(*,*) 'qyr2dz_cpp_ypencil', qyr2dz_cpp_ypencil(4, 1, 1:4) #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'qyr preparation ... done.' ) #endif !---------------------------------------------------------------------------------------------------------- !    qz/r=qzr !    | -[x2y]-> qzr_ypencil(temp) !               | -[ipy]-> qzriy_cpp_ypencil -[y2z]-> qzriy_cpp_zpencil !               | -[1dy]-> qzrdy_cpp_ypencil -[y2z]-> qzrdy_cpp_zpencil !               | -[y2z]-> qzr_zpencil(temp) -[ipz]-> qzriz_ccc_zpencil(temp) -[z2y]- qzriz_ccc_ypencil !---------------------------------------------------------------------------------------------------------- accp_xpencil = fl % qz call multiple_cylindrical_rn ( accp_xpencil , dm % dccp , dm % rci , 1 , IPENCIL ( 1 )) ! qz/r call transpose_x_to_y ( accp_xpencil , accp_ypencil , dm % dccp ) call Get_y_midp_C2P_3D ( accp_ypencil , qzriy_cpp_ypencil , dm , dm % iAccuracy , dm % ibcy_qz , dm % fbcy_qzr ) !call axis_estimating_radial_xpx(qzriy_cpp_ypencil, dm%dcpp, IPENCIL(2), dm, IDIM(0)) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qzriy_cpp_ypencil' , qzriy_cpp_ypencil ( 4 , 1 , 4 ), qzriy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qzriy_cpp_ypencil ( 4 , 1 , 4 ) + qzriy_cpp_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call transpose_y_to_z ( qzriy_cpp_ypencil , qzriy_cpp_zpencil , dm % dcpp ) ! if ( is_fbcy_velo_required ) then call Get_z_1der_P2C_3D ( qzriy_cpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz ) ! accc_zpencil = d(qz/r)/dz call transpose_z_to_y ( acpc_zpencil , qzrdz_cpc_ypencil , dm % dcpc ) end if #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qzrdz_cpc_ypencil' , qzrdz_cpc_ypencil ( 4 , 1 , 4 ), qzrdz_cpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & qzrdz_cpc_ypencil ( 4 , 1 , 4 ) + qzrdz_cpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if call Print_debug_mid_msg ( 'qzr preparation ... done.' ) #endif end if !========================================================================================================== ! preparation of div ! div = qxdx + 1/r * qydy + 1/r qzdz ! r * div = r * qxdx + qydy + qzdz !========================================================================================================== ! r * div_tmp = r * qxdx div_ccc_xpencil = ZERO accc_xpencil = qxdx_ccc_xpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accc_xpencil , dm % dccc , dm % rc , 1 , IPENCIL ( 1 )) div_ccc_xpencil = div_ccc_xpencil + accc_xpencil ! ! r * div_tmp = r * qxdx + qydy call transpose_y_to_x ( qydy_ccc_ypencil , accc_xpencil , dm % dccc ) div_ccc_xpencil = div_ccc_xpencil + accc_xpencil ! r * div_tmp = r * qxdx + qydy + qzdz call transpose_z_to_y ( qzdz_ccc_zpencil , accc_ypencil , dm % dccc ) call transpose_y_to_x ( accc_ypencil , accc_xpencil , dm % dccc ) div_ccc_xpencil = div_ccc_xpencil + accc_xpencil ! div_tmp = (r * div_tmp) / r if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div_ccc_xpencil , dm % dccc , dm % rci , 1 , IPENCIL ( 1 )) call transpose_x_to_y ( div_ccc_xpencil , div_ccc_ypencil , dm % dccc ) call transpose_y_to_z ( div_ccc_ypencil , div_ccc_zpencil , dm % dccc ) ! fbcx_div_4cc, qxdx + 1/r * qydy + 1/r qzdz if ( is_fbcx_velo_required ) then call Get_x_1der_P2P_3D ( fl % qx , qxdx_pcc_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , dm % fbcx_qx ) apcc_xpencil1 = qxdx_pcc_xpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcc_xpencil1 , dm % dpcc , dm % rc , 1 , IPENCIL ( 1 )) apcc_xpencil2 = qydy_pcc_xpencil apcc_xpencil3 = qzdz_pcc_xpencil apcc_xpencil = apcc_xpencil1 + apcc_xpencil2 + apcc_xpencil3 if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcc_xpencil , dm % dpcc , dm % rci , 1 , IPENCIL ( 1 )) call extract_dirichlet_fbcx ( fbcx_div_4cc , apcc_xpencil , dm % dpcc ) end if ! fbcy_div_c4c, qxdx + 1/r * qydy + 1/r qzdz if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_div_c4c1 , qxdx_cpc_ypencil , dm % dcpc , dm , is_reversed = . false .) fbcy_div_c4c = fbcy_div_c4c1 acpc_ypencil = qydy_cpc_ypencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( acpc_ypencil , dm % dcpc , dm % rpi , 1 , IPENCIL ( 2 )) ! (qydy)/r_cpc_ypencil call axis_estimating_radial_xpx ( acpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 2 ), is_reversed = . true .) #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) '(qydy)/r_cpc_ypencil' , acpc_ypencil ( 4 , 1 , 4 ), acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & acpc_ypencil ( 4 , 1 , 4 ) + acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif call extract_dirichlet_fbcy ( fbcy_div_c4c1 , acpc_ypencil , dm % dcpc , dm , is_reversed = . true .) fbcy_div_c4c = fbcy_div_c4c + fbcy_div_c4c1 if ( dm % icoordinate == ICYLINDRICAL ) then acpc_ypencil = qzrdz_cpc_ypencil else acpc_ypencil = qzdz_cpc_ypencil end if call extract_dirichlet_fbcy ( fbcy_div_c4c1 , acpc_ypencil , dm % dcpc , dm , is_reversed = . false .) fbcy_div_c4c = fbcy_div_c4c + fbcy_div_c4c1 end if ! fbcz_div_cc4 if ( is_fbcz_velo_required ) then accp_zpencil1 = qxdx_ccp_zpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_zpencil1 , dm % dccp , dm % rc , 1 , IPENCIL ( 3 )) accp_zpencil2 = qydy_ccp_zpencil accp_zpencil3 = qzdz_ccp_zpencil accp_zpencil = accp_zpencil1 + accp_zpencil2 + accp_zpencil3 if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_zpencil , dm % dccp , dm % rci , 1 , IPENCIL ( 3 )) call extract_dirichlet_fbcz ( fbcz_div_cc4 , accp_zpencil , dm % dccp ) end if #ifdef DEBUG_STEPS call Print_debug_mid_msg ( 'div preparation ... done.' ) #endif !========================================================================================================== ! The governing equation x is ! d(gx)/dt = -        d(gxix * qxix)/dx                               ! conv-x-m1 !            - 1/r  * d(gyix * qxiy)/dy                               ! conv-y-m1 !            - 1/r  * d(gzix * qxiz)/dz                               ! conv-z-m1 !            - dpdx                                                   ! p-m1 !            + d[ 2 * mu * (qxdx - 1/3 * div)]/dx                     ! diff-x-m1 !            + 1/r  * d[muixy * (qydx + r * qxdy)]/dy                  ! diff-y-m1 !            + 1/r  * d[muixz * (qzdx + 1/r*qxdz)]/dz                  ! diff-z-m1 !========================================================================================================== i = 1 fl % mx_rhs = ZERO mx_rhs_ypencil = ZERO mx_rhs_zpencil = ZERO mx_rhs_pfc_xpencil = ZERO !---------------------------------------------------------------------------------------------------------- ! X-mom convection term 1/3 at (i', j, k): ! conv-x-m1 = - d(gxix * qxix)/dx !---------------------------------------------------------------------------------------------------------- !------b.c.------ if ( is_fbcx_velo_required ) then if ( . not . dm % is_thermo ) then fbcx_4cc = dm % fbcx_qx else fbcx_4cc = dm % fbcx_gx end if fbcx_4cc = - fbcx_4cc * dm % fbcx_qx else fbcx_4cc = MAXP end if !------bulk------ if ( . not . dm % is_thermo ) then accc_xpencil = qxix_ccc_xpencil else accc_xpencil = gxix_ccc_xpencil end if accc_xpencil = - accc_xpencil * qxix_ccc_xpencil !------PDE------ call Get_x_1der_C2P_3D ( accc_xpencil , apcc_xpencil , dm , dm % iAccuracy , mbcx_cov1 , fbcx_4cc ) fl % mx_rhs = fl % mx_rhs + apcc_xpencil #ifdef DEBUG_STEPS write ( * , * ) 'conx-11' , apcc_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( apcc_xpencil , 'conx-11' ) #endif !---------------------------------------------------------------------------------------------------------- ! X-mom convection term 2/3 at (i', j, k): ! conv-y-m1 = - 1/r  * d(gyix * qxiy)/dy !---------------------------------------------------------------------------------------------------------- !------bulk------ if ( . not . dm % is_thermo ) then appc_ypencil = qyix_ppc_ypencil else appc_ypencil = gyix_ppc_ypencil end if appc_ypencil = - appc_ypencil * qxiy_ppc_ypencil !------b.c.------ if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_p4c , appc_ypencil , dm % dppc , dm , is_reversed = . true .) else fbcy_p4c = MAXP end if !------PDE------ call Get_y_1der_P2C_3D ( appc_ypencil , apcc_ypencil , dm , dm % iAccuracy , mbcy_cov1 , fbcy_p4c ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcc_ypencil , dm % dpcc , dm % rci , 1 , IPENCIL ( 2 )) mx_rhs_ypencil = mx_rhs_ypencil + apcc_ypencil #ifdef DEBUG_STEPS write ( * , * ) 'conx-12' , apcc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( appc_ypencil , 'conx-12' ) #endif !---------------------------------------------------------------------------------------------------------- ! X-mom convection term 3/3 at (i', j, k) : ! conv-z-m1 = - 1/r * d(gzix * qxiz)/dz !---------------------------------------------------------------------------------------------------------- !------bulk------ if ( . not . dm % is_thermo ) then apcp_zpencil = qzix_pcp_zpencil else apcp_zpencil = gzix_pcp_zpencil end if apcp_zpencil = - apcp_zpencil * qxiz_pcp_zpencil !------b.c.------ if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_pc4 , apcp_zpencil , dm % dpcp ) else fbcz_pc4 = MAXP end if !------PDE------ call Get_z_1der_P2C_3D ( apcp_zpencil , apcc_zpencil , dm , dm % iAccuracy , mbcz_cov1 , fbcz_pc4 ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcc_zpencil , dm % dpcc , dm % rci , 1 , IPENCIL ( 3 )) mx_rhs_zpencil = mx_rhs_zpencil + apcc_zpencil #ifdef DEBUG_STEPS write ( * , * ) 'conx-13' , apcc_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( apcc_zpencil , 'conx-13' ) #endif #ifdef DEBUG_STEPS apcc_test = fl % mx_rhs call transpose_y_to_x ( mx_rhs_ypencil , apcc_xpencil , dm % dpcc ) apcc_test = apcc_test + apcc_xpencil call transpose_z_to_y ( mx_rhs_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , apcc_xpencil , dm % dpcc ) apcc_test = apcc_test + apcc_xpencil call wrt_3d_pt_debug ( apcc_test , dm % dpcc , fl % iteration , isub , 'ConX@bf st' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! X-mom pressure gradient: ! p-m1 = - dpdx !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( - fl % pres * dm % sigma1p , apcc_xpencil , dm , dm % iAccuracy , dm % ibcx_pr , - dm % fbcx_pr ) mx_rhs_pfc_xpencil = mx_rhs_pfc_xpencil + apcc_xpencil #ifdef DEBUG_STEPS write ( * , * ) 'px-11' , apcc_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( apcc_xpencil , 'px-11' ) #endif !---------------------------------------------------------------------------------------------------------- ! X-mom gravity in x direction, X-pencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo . and . ( fl % igravity == i . or . fl % igravity == - i ) ) then fbcx_4cc (:, :, :) = dm % fbcx_ftp (:, :, :)% d call Get_x_midp_C2P_3D ( fl % dDens , apcc_xpencil , dm , dm % iAccuracy , dm % ibcx_ftp , fbcx_4cc ) mx_rhs_pfc_xpencil = mx_rhs_pfc_xpencil + fl % fgravity ( i ) * apcc_xpencil end if !---------------------------------------------------------------------------------------------------------- ! X-mom Lorentz Force in x direction, x-pencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_mhd ) then mx_rhs_pfc_xpencil = mx_rhs_pfc_xpencil + fl % lrfx end if !---------------------------------------------------------------------------------------------------------- ! X-mom diffusion term 1/3 at (i', j, k) ! diff-x-m1 = d[ 2 * mu * (qxdx - 1/3 * div)]/dx !---------------------------------------------------------------------------------------------------------- !------b.c.------ if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4cc , qxdx_pcc_xpencil , dm % dpcc ) fbcx_4cc = TWO * fbcx_mu_4cc * ( fbcx_4cc - ONE_THIRD * fbcx_div_4cc ) else fbcx_4cc = MAXP end if !------bulk------ accc_xpencil = TWO * mu_ccc_xpencil * ( qxdx_ccc_xpencil - ONE_THIRD * div_ccc_xpencil ) !------PDE------ call Get_x_1der_C2P_3D ( accc_xpencil , apcc_xpencil , dm , dm % iAccuracy , mbcx_tau1 , fbcx_4cc ) fl % mx_rhs = fl % mx_rhs + apcc_xpencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visx-11' , apcc_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( apcc_xpencil , 'visx-11' ) #endif !---------------------------------------------------------------------------------------------------------- ! X-mom diffusion term 2/3 at (i', j, k) ! diff-y-m1 = 1/r  * d[muixy * (qydx + r * qxdy)]/dy !---------------------------------------------------------------------------------------------------------- !------bulk------ appc_ypencil = qxdy_ppc_ypencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( appc_ypencil , dm % dppc , dm % rp , 1 , IPENCIL ( 2 )) appc_ypencil = ( appc_ypencil + qydx_ppc_ypencil ) * muixy_ppc_ypencil !------b.c.------ if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_p4c , appc_ypencil , dm % dppc , dm , is_reversed = . true .) else fbcy_p4c = MAXP end if !------PDE------ call Get_y_1der_P2C_3D ( appc_ypencil , apcc_ypencil , dm , dm % iAccuracy , mbcy_tau1 , fbcy_p4c ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcc_ypencil , dm % dpcc , dm % rci , 1 , IPENCIL ( 2 )) mx_rhs_ypencil = mx_rhs_ypencil + apcc_ypencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visx-12' , apcc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( apcc_ypencil , 'visx-12' ) #endif !---------------------------------------------------------------------------------------------------------- ! X-mom diffusion term 3/3 at (i', j, k) ! diff-z-m1 = 1/r * d[muixz * (qzdx + 1/r * qxdz)]/dz !---------------------------------------------------------------------------------------------------------- !------bulk------ apcp_zpencil = qxdz_pcp_zpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcp_zpencil , dm % dpcp , dm % rci , 1 , IPENCIL ( 3 )) apcp_zpencil = ( apcp_zpencil + qzdx_pcp_zpencil ) * muixz_pcp_zpencil !------b.c.------ if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_pc4 , apcp_zpencil , dm % dpcp ) else fbcz_pc4 = MAXP end if !------PDE------ call Get_z_1der_P2C_3D ( apcp_zpencil , apcc_zpencil , dm , dm % iAccuracy , mbcz_tau1 , fbcz_pc4 ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcc_zpencil , dm % dpcc , dm % rci , 1 , IPENCIL ( 3 )) mx_rhs_zpencil = mx_rhs_zpencil + apcc_zpencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visx-13' , apcc_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( apcc_zpencil , 'visx-13' ) #endif !========================================================================================================== ! the RHS of y-momentum equation ! d(gy)/dt = -        d(gxiy * qyix)/dx                             ! conv-x-m2 !            -        d(gyiy * qyriy)/dy                            ! conv-y-m2 !            -        d(gziy * qyriz)/dz                            ! conv-z-m2 !            + (gziz * qziz)&#94;y                                      ! conv-r-m2 !            - r * dpdy                                                 ! p-m2 !            + d[muixy * (qydx + r * qxdy)]/dx                      ! diff-x-m2 !            + d[r * 2 * mu * (qyrdy - 1/3 * div)]/dy               ! diff-y-m2 !            + d[muiyz * (qzdy + 1/r * qyrdz - qzriy]/dz            ! diff-z-m2 !            - [2 mu * (1/r * qzdz - 1/3 * div + 1/r * qyriy)]&#94;y    ! diff-r-m2 !========================================================================================================== i = 2 fl % my_rhs = ZERO my_rhs_ypencil = ZERO my_rhs_zpencil = ZERO my_rhs_pfc_xpencil = ZERO my_rhs_pfc_ypencil = ZERO mz_rhs_pfc_zpencil = ZERO !---------------------------------------------------------------------------------------------------------- ! Y-mom convection term 1/4 at (i, j', k) ! conv-x-m2 = - d(gxiy * qyix)/dx !---------------------------------------------------------------------------------------------------------- !------bulk------ if ( . not . dm % is_thermo ) then appc_xpencil = qxiy_ppc_xpencil else appc_xpencil = gxiy_ppc_xpencil end if appc_xpencil = - appc_xpencil * qyix_ppc_xpencil !------b.c.------ if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4pc , appc_xpencil , dm % dppc ) else fbcx_4pc = MAXP end if !------PDE------ call Get_x_1der_P2C_3D ( appc_xpencil , acpc_xpencil , dm , dm % iAccuracy , mbcx_cov2 , fbcx_4pc ) fl % my_rhs = fl % my_rhs + acpc_xpencil #ifdef DEBUG_STEPS write ( * , * ) 'cony-21' , acpc_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_xpencil , 'cony-21' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom convection term 2/4 at (i, j', k) ! conv-y-m2 = - d(gyiy * qyriy)/dy !---------------------------------------------------------------------------------------------------------- !------b.c.------ if ( is_fbcy_velo_required ) then if ( dm % icoordinate == ICYLINDRICAL ) then fbcy_c4c1 = dm % fbcy_qyr else fbcy_c4c1 = dm % fbcy_qy end if if ( . not . dm % is_thermo ) then fbcy_c4c = dm % fbcy_qy else fbcy_c4c = dm % fbcy_gy end if fbcy_c4c = - fbcy_c4c1 * fbcy_c4c else fbcy_c4c = MAXP end if !------bulk----- if ( dm % icoordinate == ICYLINDRICAL ) then accc_ypencil1 = qyriy_ccc_ypencil else accc_ypencil1 = qyiy_ccc_ypencil end if if ( . not . dm % is_thermo ) then accc_ypencil = qyiy_ccc_ypencil else accc_ypencil = gyiy_ccc_ypencil end if accc_ypencil = - accc_ypencil1 * accc_ypencil !------PDE----- calculation call Get_y_1der_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbcy_cov2 , fbcy_c4c ) my_rhs_ypencil = my_rhs_ypencil + acpc_ypencil #ifdef DEBUG_STEPS !write(*,*) 'cony-pp1', accc_ypencil1(1, 1:4, 1) !write(*,*) 'cony-pp2', accc_ypencil(1, 1:4, 1) write ( * , * ) 'cony-22' , acpc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_ypencil , 'cony-22' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom convection term 3/4 at (i, j', k) ! conv-z-m2 = - d(gziy * qyriz)/dz !---------------------------------------------------------------------------------------------------------- !------bulk----- if ( . not . dm % is_thermo ) then acpp_zpencil = qziy_cpp_zpencil else acpp_zpencil = gziy_cpp_zpencil end if if ( dm % icoordinate == ICYLINDRICAL ) then acpp_zpencil1 = qyriz_cpp_zpencil else acpp_zpencil1 = qyiz_cpp_zpencil end if acpp_zpencil = - acpp_zpencil1 * acpp_zpencil !------b.c.----- if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_cp4 , acpp_zpencil , dm % dcpp ) else fbcz_cp4 = MAXP end if !------PDE----- call Get_z_1der_P2C_3D ( acpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , mbcz_cov2 , fbcz_cp4 ) my_rhs_zpencil = my_rhs_zpencil + acpc_zpencil #ifdef DEBUG_STEPS write ( * , * ) 'cony-23' , acpc_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_zpencil , 'cony-23' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom convection term 4/4 at (i, j', k) ! conv-r-m2 = (gziz * qziz)&#94;y !---------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) then ! ------b.c.------ if ( is_fbcy_velo_required ) then !call Get_y_midp_C2P_3D(qziz_ccc_ypencil, acpc_ypencil, dm, dm%iAccuracy, dm%ibcy_qz, dm%fbcy_qz) !call axis_estimating_radial_xpx(acpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(3)) call Get_z_midp_P2C_3D ( qziy_cpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz ) call transpose_z_to_y ( acpc_zpencil , acpc_ypencil , dm % dcpc ) call extract_dirichlet_fbcy ( fbcy_c4c1 , acpc_ypencil , dm % dcpc , dm , is_reversed = . true .) !  check how to do this for interior b.c. #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'qziz_cpc_ypencil' , acpc_ypencil ( 4 , 1 , 4 ), acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) , & acpc_ypencil ( 4 , 1 , 4 ) + acpc_ypencil ( 4 , 1 , dm % knc_sym ( 4 )) write ( * , * ) 'fbcy_c4c1' , fbcy_c4c1 ( 4 , 1 , 4 ), fbcy_c4c1 ( 4 , 1 , dm % knc_sym ( 4 )) , & fbcy_c4c1 ( 4 , 1 , 4 ) + fbcy_c4c1 ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif if ( . not . dm % is_thermo ) then fbcy_c4c = fbcy_c4c1 else call Get_z_midp_P2C_3D ( gziy_cpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz ) call transpose_z_to_y ( acpc_zpencil , acpc_ypencil , dm % dcpc ) !call axis_estimating_radial_xpx(acpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(3)) call extract_dirichlet_fbcy ( fbcy_c4c , acpc_ypencil , dm % dcpc , dm , is_reversed = . true .) end if fbcy_c4c = fbcy_c4c * fbcy_c4c1 else fbcy_c4c = MAXP end if #ifdef DEBUG_STEPS if ( dm % icase == ICASE_PIPE ) then write ( * , * ) 'fbcy_c4c' , fbcy_c4c ( 4 , 1 , 4 ), fbcy_c4c ( 4 , 1 , dm % knc_sym ( 4 )) , & fbcy_c4c ( 4 , 1 , 4 ) + fbcy_c4c ( 4 , 1 , dm % knc_sym ( 4 )) end if #endif !------bulk----- if ( . not . dm % is_thermo ) then accc_ypencil = qziz_ccc_ypencil else accc_ypencil = gziz_ccc_ypencil end if accc_ypencil = accc_ypencil * qziz_ccc_ypencil !------PDE----- call Get_y_midp_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbcr_cov2 , fbcy_c4c ) call axis_estimating_radial_xpx ( acpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 2 ), is_reversed = . true .) my_rhs_ypencil = my_rhs_ypencil + acpc_ypencil #ifdef DEBUG_STEPS write ( * , * ) 'cony-24' , acpc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_ypencil , 'cony-24' ) #endif end if #ifdef DEBUG_STEPS acpc_test = fl % my_rhs call transpose_y_to_x ( my_rhs_ypencil , acpc_xpencil , dm % dcpc ) acpc_test = acpc_test + acpc_xpencil call transpose_z_to_y ( my_rhs_zpencil , acpc_ypencil , dm % dcpc ) call transpose_y_to_x ( acpc_ypencil , acpc_xpencil , dm % dcpc ) acpc_test = acpc_test + acpc_xpencil call wrt_3d_pt_debug ( acpc_test , dm % dcpc , fl % iteration , isub , 'ConY@bf st' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom pressure gradient in y direction, Y-pencil, d(sigma_1 p) ! p-m2 = - r * dpdy !---------------------------------------------------------------------------------------------------------- call Get_y_1der_C2P_3D ( - pres_ypencil * dm % sigma1p , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_pr , - dm % fbcy_pr ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( acpc_ypencil , dm % dcpc , dm % rp , 1 , IPENCIL ( 2 )) my_rhs_pfc_ypencil = my_rhs_pfc_ypencil + acpc_ypencil #ifdef DEBUG_STEPS write ( * , * ) 'py-21' , acpc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_ypencil , 'py-21' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom gravity in y direction ( not r direction ), Y-pencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo . and . ( fl % igravity == i . or . fl % igravity == - i ) ) then if ( dm % icoordinate == ICYLINDRICAL ) then call gravity_decomposition_to_rz ( fl % dDens , fl % igravity , fl % fgravity ( i ), acpc_ypencil , accp_zpencil , dm ) mz_rhs_pfc_zpencil = mz_rhs_pfc_zpencil + accp_zpencil else fbcy_c4c (:, :, :) = dm % fbcy_ftp (:, :, :)% d call Get_y_midp_C2P_3D ( dDens_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp , fbcy_c4c ) !call axis_estimating_radial_xpx(acpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(1)) acpc_ypencil = fl % fgravity ( i ) * acpc_ypencil end if my_rhs_pfc_ypencil = my_rhs_pfc_ypencil + acpc_ypencil end if !---------------------------------------------------------------------------------------------------------- ! Y-mom Lorentz Force in z direction, x-pencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_mhd ) then my_rhs_pfc_xpencil = my_rhs_pfc_xpencil + fl % lrfy if ( dm % icoordinate == ICYLINDRICAL ) then ! force cannot be defined in radial direction, it should be decomposed into r and z direction ! To do!!!!!!!! end if end if !---------------------------------------------------------------------------------------------------------- ! Y-mom diffusion term 1/4 at (i, j', k) ! diff-x-m2 = d[muixy * (qydx + r * qxdy)]/dx !---------------------------------------------------------------------------------------------------------- !------bulk----- appc_xpencil1 = qxdy_ppc_xpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( appc_xpencil1 , dm % dppc , dm % rp , 1 , IPENCIL ( 1 )) appc_xpencil = ( appc_xpencil1 + qydx_ppc_xpencil ) * muixy_ppc_xpencil !------b.c.----- if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4pc , appc_xpencil , dm % dppc ) else fbcx_4pc = MAXP end if !------PDE----- call Get_x_1der_P2C_3D ( appc_xpencil , acpc_xpencil , dm , dm % iAccuracy , mbcx_tau2 , fbcx_4pc ) fl % my_rhs = fl % my_rhs + acpc_xpencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visy-21' , acpc_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_xpencil , 'visy-21' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom diffusion term 2/4 at (i, j', k) ! diff-y-m2 = d[r * 2 * mu * (qyrdy - 1/3 * div)]/dy !---------------------------------------------------------------------------------------------------------- ! ------b.c.------ if ( is_fbcy_velo_required ) then if ( dm % icoordinate == ICYLINDRICAL ) then call Get_y_midp_P2C_3D ( qyr_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qyr ) call Get_y_1der_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qyr ) ! acpc_ypencil = d(qyr)/dy call extract_dirichlet_fbcy ( fbcy_c4c , acpc_ypencil , dm % dcpc , dm , is_reversed = . true .) ! fbcy_c4c = fbcy_dqyrdy_c4c else if ( dm % icoordinate == ICARTESIAN ) then call extract_dirichlet_fbcy ( fbcy_c4c , qydy_cpc_ypencil , dm % dcpc , dm , is_reversed = . true .) else end if fbcy_c4c = ( fbcy_c4c - ONE_THIRD * fbcy_div_c4c ) * TWO * fbcy_mu_c4c if ( dm % icoordinate == ICYLINDRICAL ) then call multiple_cylindrical_rn_x4x ( fbcy_c4c , dm % dcpc , dm % rp , 1 , IPENCIL ( 2 )) end if else fbcy_c4c = MAXP end if ! ------bulk----- if ( dm % icoordinate == ICYLINDRICAL ) then accc_ypencil1 = qyrdy_ccc_ypencil else if ( dm % icoordinate == ICARTESIAN ) then accc_ypencil1 = qydy_ccc_ypencil else end if accc_ypencil = ( accc_ypencil1 - ONE_THIRD * div_ccc_ypencil ) * TWO * mu_ccc_ypencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accc_ypencil , dm % dccc , dm % rc , 1 , IPENCIL ( 2 )) ! ------PDE----- call Get_y_1der_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbcy_tau2 , fbcy_c4c ) my_rhs_ypencil = my_rhs_ypencil + acpc_ypencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visy-pp' , fbcy_mu_c4c ( 1 , 1 : 4 , 1 ) write ( * , * ) 'visy-22' , acpc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_ypencil , 'visy-22' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom diffusion term 3/4 at (i, j', k) ! diff-z-m2 = d[muiyz * (qzdy + qyr2dz - qzriy]/dz !---------------------------------------------------------------------------------------------------------- !------bulk----- if ( dm % icoordinate == ICYLINDRICAL ) then ! acpp_zpencil = qyrdz_cpp_zpencil ! acpp_zpencil = d(qr/r)/dz ! call multiple_cylindrical_rn(acpp_zpencil, dm%dcpp, dm%rpi, 1, IPENCIL(3)) ! acpp_zpencil = 1/r * d(qr/r)/dz ! call axis_estimating_radial_xpx(acpp_zpencil1, dm%dcpp, IPENCIL(3), dm)    ! ! acpp_zpencil1 = qziy_cpp_zpencil ! acpp_zpencil1 = (qz)&#94;r ! call multiple_cylindrical_rn(acpp_zpencil1, dm%dcpp, dm%rpi, 1, IPENCIL(3)) ! acpp_zpencil1 = 1/r * (dz)&#94;r ! call estimate_azimuthal_xpx_on_axis(acpp_zpencil1, dm%dcpp, IPENCIL(3), dm) acpp_zpencil = qzdy_cpp_zpencil + qyr2dz_cpp_zpencil - qzriy_cpp_zpencil else acpp_zpencil = qzdy_cpp_zpencil + qydz_cpp_zpencil - ZERO end if acpp_zpencil = acpp_zpencil * muiyz_cpp_zpencil !------b.c.----- if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_cp4 , acpp_zpencil , dm % dcpp ) else fbcz_cp4 = MAXP end if !------PDE----- call Get_z_1der_P2C_3D ( acpp_zpencil , acpc_zpencil , dm , dm % iAccuracy , mbcz_tau2 , fbcz_cp4 ) my_rhs_zpencil = my_rhs_zpencil + acpc_zpencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visy-23' , acpc_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_zpencil , 'visy-23' ) #endif !---------------------------------------------------------------------------------------------------------- ! Y-mom diffusion term 4/4 at (i, j', k) ! diff-r-m2 = - [2 mu * (1/r * qzdz - 1/3 * div + 1/r * qyriy)]&#94;y !---------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) then !------b.c.------ if ( is_fbcy_velo_required ) then ! acpc_ypencil = qzdz_cpc_ypencil ! call multiple_cylindrical_rn(acpc_ypencil, dm%dcpc, dm%rpi, 1, IPENCIL(2)) ! call estimate_azimuthal_xpx_on_axis(acpc_ypencil, dm%dcpc, IPENCIL(2), dm) call extract_dirichlet_fbcy ( fbcy_c4c , qzrdz_cpc_ypencil , dm % dcpc , dm , is_reversed = . false .) ! fbcy_c4c = (1/r * qzdz)_c4c call extract_dirichlet_fbcy ( fbcy_c4c1 , qyr2_ypencil , dm % dcpc , dm , is_reversed = . true .) ! fbcy_c4c1 = (1/r * qyriy)_c4c fbcy_c4c = ( fbcy_c4c - ONE_THIRD * fbcy_div_c4c + fbcy_c4c1 ) * TWO * fbcy_mu_c4c else fbcy_c4c = MAXP end if !------bulk------ accc_ypencil = qzdz_ccc_ypencil call multiple_cylindrical_rn ( accc_ypencil , dm % dccc , dm % rci , 1 , IPENCIL ( 2 )) ! accc_ypencil = 1/r * d(qz)/dz accc_ypencil1 = qyriy_ccc_ypencil call multiple_cylindrical_rn ( accc_ypencil1 , dm % dccc , dm % rci , 1 , IPENCIL ( 2 )) !accc_ypencil1 = 1/r * (qr/r)&#94;r accc_ypencil = ( accc_ypencil - ONE_THIRD * div_ccc_ypencil + accc_ypencil1 ) * TWO * mu_ccc_ypencil !------PDE------ call Get_y_midp_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mbcr_tau2 , fbcy_c4c ) !call axis_estimating_radial_xpx ! not needed as b.c. for uy is specified. my_rhs_ypencil = my_rhs_ypencil - acpc_ypencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visy-24' , acpc_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( acpc_ypencil , 'visy-24' ) #endif end if !========================================================================================================== ! the RHS of z-momentum equation ! d(gz)/dt = -        d(gxiz * qzix)/dx                               ! conv-x-m3 !            - 1/r&#94;2  d(r * gyiz * qziy)/dy                           ! conv-y-m3 !            - 1/r  * d(gziz * qziz)/dz                               ! conv-z-m3 !            - 1/r * dpdz                                             ! p-m3 !            +         d[muixz * (qzdx + 1/r * qxdz)]/dx              ! diff-x-m3 !            + 1/r   * d[muiyz * (r * qzdy + qyrdz - qziy]/dy         ! diff-y-m3 !            + 1/r&#94;2 * d[2 * mu * (qzdz - r/3 * div + qyriy)]/dz      ! diff-z-m3 !            + 1/r   * [muiyz * (qzdy + 1/r2 * qydz - 1/r * qziy)]&#94;y  ! diff-r-m3 !conv-y-m3  + conv-r-m3 = conv-y-m2_new ! 1/r    d(gyiz * qziy)/dy + 1/r (gyriz * qziy)&#94;y = 1/r&#94;2 * d( r * qziy * gyiz)/dy !========================================================================================================== i = 3 fl % mz_rhs = ZERO mz_rhs_ypencil = ZERO mz_rhs_zpencil = ZERO mz_rhs_pfc_xpencil = ZERO mz_rhs_pfc_ypencil = ZERO !mz_rhs_pfc_zpencil = ZERO ! could get value from gravity_decomposition_to_rz !---------------------------------------------------------------------------------------------------------- ! Z-mom convection term 1/3 at (i, j, k') ! conv-x-m3 = - d(gxiz * qzix)/dx !---------------------------------------------------------------------------------------------------------- !------bulk------ if ( . not . dm % is_thermo ) then apcp_xpencil = qxiz_pcp_xpencil else apcp_xpencil = gxiz_pcp_xpencil end if apcp_xpencil = - apcp_xpencil * qzix_pcp_xpencil !------b.c.----- if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4cp , apcp_xpencil , dm % dpcp ) else fbcx_4cp = MAXP end if !------PDE------ call Get_x_1der_P2C_3D ( apcp_xpencil , accp_xpencil , dm , dm % iAccuracy , mbcx_cov3 , fbcx_4cp ) fl % mz_rhs = fl % mz_rhs + accp_xpencil #ifdef DEBUG_STEPS write ( * , * ) 'conz-31' , accp_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_xpencil , 'conz-31' ) #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom convection term 2/3 at (i, j, k') ! conv-y-m3 = - 1/r&#94;2 * d( r * qziy * gyiz)/dy !---------------------------------------------------------------------------------------------------------- !------bulk------ acpp_ypencil1 = qziy_cpp_ypencil if ( . not . dm % is_thermo ) then acpp_ypencil = qyiz_cpp_ypencil else acpp_ypencil = gyiz_cpp_ypencil end if acpp_ypencil = - acpp_ypencil * acpp_ypencil1 if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( acpp_ypencil , dm % dcpp , dm % rp , 1 , IPENCIL ( 2 )) !------b.c.----- if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_c4p , acpp_ypencil , dm % dcpp , dm , is_reversed = . true .) else fbcy_c4p = MAXP end if !------PDE------ call Get_y_1der_P2C_3D ( acpp_ypencil , accp_ypencil , dm , dm % iAccuracy , mbcy_cov3 , fbcy_c4p ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_ypencil , dm % dccp , dm % rci , 2 , IPENCIL ( 2 )) mz_rhs_ypencil = mz_rhs_ypencil + accp_ypencil #ifdef DEBUG_STEPS write ( * , * ) 'conz-32' , accp_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_ypencil , 'conz-32' ) #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom convection term 3/3 at (i, j, k') ! conv-z-m3 = 1/r  * d(gziz * qziz)/dz !---------------------------------------------------------------------------------------------------------- !------b.c.------ if ( is_fbcz_velo_required ) then if ( . not . dm % is_thermo ) then fbcz_cc4 = dm % fbcz_qz else fbcz_cc4 = dm % fbcz_gz end if fbcz_cc4 = - fbcz_cc4 * dm % fbcz_qz else fbcz_cc4 = MAXP end if !------bulk------ if ( . not . dm % is_thermo ) then accc_zpencil = qziz_ccc_zpencil else accc_zpencil = gziz_ccc_zpencil end if accc_zpencil = - accc_zpencil * qziz_ccc_zpencil !------PDE------ call Get_z_1der_C2P_3D ( accc_zpencil , accp_zpencil , dm , dm % iAccuracy , mbcz_cov3 , fbcz_cc4 ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_zpencil , dm % dccp , dm % rci , 1 , IPENCIL ( 3 )) mz_rhs_zpencil = mz_rhs_zpencil + accp_zpencil #ifdef DEBUG_STEPS write ( * , * ) 'conz-33' , accp_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_zpencil , 'conz-33' ) #endif ! !---------------------------------------------------------------------------------------------------------- ! ! Z-mom convection term 4/4 at (i, j, k') ! ! conv-r-m3 = - (gyriz * qzriy)&#94;y ! !---------------------------------------------------------------------------------------------------------- !     if(dm%icoordinate == ICYLINDRICAL) then !       !------bulk------ !       if ( .not. dm%is_thermo) then !         acpp_ypencil = qyriz_cpp_ypencil !       else !         acpp_ypencil = gyriz_cpp_ypencil !       end if !       acpp_ypencil = - acpp_ypencil * qzriy_cpp_ypencil !       !------b.c.----- !       if(is_fbcy_velo_required) then !         call extract_dirichlet_fbcy(fbcy_c4p, acpp_ypencil, dm%dcpp, dm) !       else !         fbcy_c4p = MAXP !       end if !       !------PDE------ !       call Get_y_midp_P2C_3D(acpp_ypencil, accp_ypencil, dm, dm%iAccuracy, mbcr_cov3, fbcy_c4p) !       mz_rhs_ypencil = mz_rhs_ypencil + accp_ypencil ! #ifdef DEBUG_STEPS !       write(*,*) 'conz-34', accp_ypencil(1, 1:4, 1) !       call is_valid_number_3D(accp_ypencil, 'conz-34') ! #endif !     end if #ifdef DEBUG_STEPS accp_test = fl % mz_rhs call transpose_y_to_x ( mz_rhs_ypencil , accp_xpencil , dm % dccp ) accp_test = accp_test + accp_xpencil call transpose_z_to_y ( mz_rhs_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , accp_xpencil , dm % dccp ) accp_test = accp_test + accp_xpencil call wrt_3d_pt_debug ( accp_test , dm % dccp , fl % iteration , isub , 'ConZ@bf st' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom pressure gradient in z direction, Z-pencil, d(sigma_1 p) ! p-m3 = -1/r * dpdz !---------------------------------------------------------------------------------------------------------- call Get_z_1der_C2P_3D ( - pres_zpencil * dm % sigma1p , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_pr , - dm % fbcz_pr ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_zpencil , dm % dccp , dm % rci , 1 , IPENCIL ( 3 )) mz_rhs_pfc_zpencil = mz_rhs_pfc_zpencil + accp_zpencil #ifdef DEBUG_STEPS write ( * , * ) 'pz-31' , mz_rhs_pfc_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( mz_rhs_pfc_zpencil , 'pz-31' ) #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom gravity in z direction, Z-pencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo . and . ( fl % igravity == i . or . fl % igravity == - i ) ) then if ( dm % icoordinate == ICYLINDRICAL ) then call gravity_decomposition_to_rz ( fl % dDens , fl % igravity , fl % fgravity ( i ), acpc_ypencil , accp_zpencil , dm ) my_rhs_pfc_ypencil = my_rhs_pfc_ypencil + accp_zpencil else fbcz_cc4 (:, :, :) = dm % fbcz_ftp (:, :, :)% d call Get_z_midp_C2P_3D ( dDens_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp , fbcz_cc4 ) accp_zpencil = fl % fgravity ( i ) * accp_zpencil end if mz_rhs_pfc_zpencil = mz_rhs_pfc_zpencil + accp_zpencil #ifdef DEBUG_STEPS write ( * , * ) 'pz-32' , mz_rhs_pfc_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( mz_rhs_pfc_zpencil , 'pz-32' ) #endif end if !---------------------------------------------------------------------------------------------------------- ! Z-mom Lorentz Force in z direction, x-pencil !---------------------------------------------------------------------------------------------------------- if ( dm % is_mhd ) then mz_rhs_pfc_xpencil = mz_rhs_pfc_xpencil + fl % lrfz #ifdef DEBUG_STEPS write ( * , * ) 'pz-33' , mz_rhs_pfc_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( mz_rhs_pfc_xpencil , 'pz-33' ) #endif end if !---------------------------------------------------------------------------------------------------------- ! Z-mom diffusion term 1/4  at (i, j, k') ! diff-x-m3 = d[muixz * (qzdx + 1/r * qxdz)]/dx !---------------------------------------------------------------------------------------------------------- !------bulk------ apcp_xpencil = qxdz_pcp_xpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( apcp_xpencil , dm % dpcp , dm % rci , 1 , IPENCIL ( 1 )) apcp_xpencil = ( qzdx_pcp_xpencil + apcp_xpencil ) * muixz_pcp_xpencil !------b.c.----- if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4cp , apcp_xpencil , dm % dpcp ) else fbcx_4cp = MAXP end if !------PDE------ call Get_x_1der_P2C_3D ( apcp_xpencil , accp_xpencil , dm , dm % iAccuracy , mbcx_tau3 , fbcx_4cp ) fl % mz_rhs = fl % mz_rhs + accp_xpencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visz-31' , accp_xpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_xpencil , 'visz-31' ) #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom diffusion term 2/4 at (i, j, k') ! diff-y-m3 = 1/r * d[muiyz * (r * qzdy + qyrdz - qziy]/dy !---------------------------------------------------------------------------------------------------------- !------bulk------ acpp_ypencil = qzdy_cpp_ypencil if ( dm % icoordinate == ICYLINDRICAL ) then call multiple_cylindrical_rn ( acpp_ypencil , dm % dcpp , dm % rp , 1 , IPENCIL ( 2 )) acpp_ypencil = acpp_ypencil + qyrdz_cpp_ypencil - qziy_cpp_ypencil else acpp_ypencil = acpp_ypencil + qydz_cpp_ypencil end if acpp_ypencil = acpp_ypencil * muiyz_cpp_ypencil !------b.c.----- if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_c4p , acpp_ypencil , dm % dcpp , dm , is_reversed = . true .) else fbcy_c4p = MAXP end if #ifdef DEBUG_STEPS if ( dm % icoordinate == ICYLINDRICAL ) then write ( * , * ) 'visz-32-interior' , qzdy_cpp_ypencil ( 1 , 1 : 2 , 1 ), & qyrdz_cpp_ypencil ( 1 , 1 : 2 , 1 ), qziy_cpp_ypencil ( 1 , 1 : 2 , 1 ) write ( * , * ) 'visz-32-fbc' , fbcy_c4p ( 1 , 1 , 1 ) end if #endif !------PDE------ call Get_y_1der_P2C_3D ( acpp_ypencil , accp_ypencil , dm , dm % iAccuracy , mbcy_tau3 , fbcy_c4p ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_ypencil , dm % dccp , dm % rci , 1 , IPENCIL ( 2 )) mz_rhs_ypencil = mz_rhs_ypencil + accp_ypencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visz-32' , accp_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_ypencil , 'visz-32' ) #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom diffusion term 3/4 at (i, j, k') ! diff-z-m3 = 1/r2 * d[2 * mu * (qzdz - r/3 * div + qyriy)]/dz !---------------------------------------------------------------------------------------------------------- !------b.c.------ if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_cc4 , qzdz_ccp_zpencil , dm % dccp ) if ( dm % icoordinate == ICYLINDRICAL ) then !call multiple_cylindrical_rn_xx4(fbcz_cc4, dm%dccp, dm%rci, 2, IPENCIL(3)) fbcz_cc41 = dm % fbcz_qyr fbcz_cc42 = fbcz_div_cc4 call multiple_cylindrical_rn_xx4 ( fbcz_cc42 , dm % dccp , dm % rc , 1 , IPENCIL ( 3 )) else fbcz_cc42 = fbcz_div_cc4 fbcz_cc41 = ZERO end if fbcz_cc4 = ( fbcz_cc4 - ONE_THIRD * fbcz_cc42 + fbcz_cc41 ) * TWO * fbcz_mu_cc4 else fbcz_cc4 = MAXP end if !------bulk------ if ( dm % icoordinate == ICYLINDRICAL ) then accc_zpencil = div_ccc_zpencil call multiple_cylindrical_rn ( accc_zpencil , dm % dccc , dm % rc , 1 , IPENCIL ( 3 )) accc_zpencil1 = qyriy_ccc_zpencil else accc_zpencil = div_ccc_zpencil accc_zpencil1 = ZERO end if accc_zpencil = ( qzdz_ccc_zpencil - ONE_THIRD * accc_zpencil + accc_zpencil1 ) * TWO * mu_ccc_zpencil !------PDE------ call Get_z_1der_C2P_3D ( accc_zpencil , accp_zpencil , dm , dm % iAccuracy , mbcz_tau3 , fbcz_cc4 ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_zpencil , dm % dccp , dm % rci , 2 , IPENCIL ( 3 )) mz_rhs_zpencil = mz_rhs_zpencil + accp_zpencil * fl % rre #ifdef DEBUG_STEPS write ( * , * ) 'visz-33' , accp_zpencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_zpencil , 'visz-33' ) #endif !---------------------------------------------------------------------------------------------------------- ! Z-mom diffusion term 4/4 at (i, j, k') ! diff-r-m3 = 1/r * [muiyz * (qzdy + 1/r2 * qydz - qzriy)]&#94;y  (method 1) !           = 1/r * [muiyz * (qzdy + 1/r2 * qydz)]&#94;y - 1/r&#94;2 * muiz * qz (method 2) !--------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) then ! method 1 !------bulk1------ acpp_ypencil = ( qzdy_cpp_ypencil + qyr2dz_cpp_ypencil - qzriy_cpp_ypencil ) * muiyz_cpp_ypencil !------b.c.----- if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_c4p , acpp_ypencil , dm % dcpp , dm , is_reversed = . true .) else fbcy_c4p = MAXP end if !------PDE------ call Get_y_midp_P2C_3D ( acpp_ypencil , accp_ypencil , dm , dm % iAccuracy , mbcr_tau3 , fbcy_c4p ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_ypencil , dm % dccp , dm % rci , 1 , IPENCIL ( 2 )) mz_rhs_ypencil = mz_rhs_ypencil + accp_ypencil * fl % rre ! method 2 ! !------bulk1------ ! acpp_ypencil = (qzdy_cpp_ypencil + qyr2dz_cpp_ypencil) * muiyz_cpp_ypencil ! !------b.c.1----- ! if(is_fbcy_velo_required) then !   call extract_dirichlet_fbcy(fbcy_c4p, acpp_ypencil, dm%dcpp, dm, is_reversed = .true.) ! else !   fbcy_c4p = MAXP ! end if ! !------PDE1------ ! call Get_y_midp_P2C_3D(acpp_ypencil, accp_ypencil, dm, dm%iAccuracy, mbcr_tau3, fbcy_c4p) ! call multiple_cylindrical_rn(accp_ypencil, dm%dccp, dm%rci, 1, IPENCIL(2)) ! mz_rhs_ypencil =  mz_rhs_ypencil + accp_ypencil * fl%rre ! !------bulk2------ ! accp_zpencil = muiz_ccp_zpencil * qz_zpencil ! call multiple_cylindrical_rn(accp_zpencil, dm%dccp, dm%rci, 2, IPENCIL(3)) ! mz_rhs_zpencil =  mz_rhs_zpencil + accp_zpencil * fl%rre #ifdef DEBUG_STEPS write ( * , * ) 'visz-34' , accp_ypencil ( 1 , 1 : 4 , 1 ) call is_valid_number_3D ( accp_ypencil , 'visz-34' ) #endif end if !---------------------------------------------------------------------------------------------------------- ! x-mom: convert all terms to rhs !---------------------------------------------------------------------------------------------------------- call transpose_y_to_x ( mx_rhs_ypencil , apcc_xpencil , dm % dpcc ) fl % mx_rhs = fl % mx_rhs + apcc_xpencil call transpose_z_to_y ( mx_rhs_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , apcc_xpencil , dm % dpcc ) fl % mx_rhs = fl % mx_rhs + apcc_xpencil !mx_rhs_pfc_xpencil, no need to transpose !---------------------------------------------------------------------------------------------------------- ! Y-mom: convert all terms to rhs !---------------------------------------------------------------------------------------------------------- call transpose_y_to_x ( my_rhs_ypencil , acpc_xpencil , dm % dcpc ) fl % my_rhs = fl % my_rhs + acpc_xpencil call transpose_z_to_y ( my_rhs_zpencil , acpc_ypencil , dm % dcpc ) call transpose_y_to_x ( acpc_ypencil , acpc_xpencil , dm % dcpc ) fl % my_rhs = fl % my_rhs + acpc_xpencil call transpose_y_to_x ( my_rhs_pfc_ypencil , acpc_xpencil , dm % dcpc ) my_rhs_pfc_xpencil = my_rhs_pfc_xpencil + acpc_xpencil !---------------------------------------------------------------------------------------------------------- ! Z-mom: convert all terms to rhs !---------------------------------------------------------------------------------------------------------- call transpose_y_to_x ( mz_rhs_ypencil , accp_xpencil , dm % dccp ) fl % mz_rhs = fl % mz_rhs + accp_xpencil call transpose_z_to_y ( mz_rhs_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , accp_xpencil , dm % dccp ) fl % mz_rhs = fl % mz_rhs + accp_xpencil call transpose_z_to_y ( mz_rhs_pfc_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , accp_xpencil , dm % dccp ) mz_rhs_pfc_xpencil = mz_rhs_pfc_xpencil + accp_xpencil !========================================================================================================== ! x-pencil : to build up rhs in total, in all directions !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! x-pencil : x-momentum !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mx_rhs , dm % dpcc , fl % iteration , isub , 'ConVisX@bf stepping' ) ! debug_ww #endif call Calculate_momentum_fractional_step ( fl % mx_rhs0 , fl % mx_rhs , mx_rhs_pfc_xpencil , dm % dpcc , dm , isub ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mx_rhs , dm % dpcc , fl % iteration , isub , 'ConVisPX@af stepping' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! x-pencil : y-momentum !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % my_rhs , dm % dcpc , fl % iteration , isub , 'ConVisY@bf stepping' ) ! debug_ww #endif call Calculate_momentum_fractional_step ( fl % my_rhs0 , fl % my_rhs , my_rhs_pfc_xpencil , dm % dcpc , dm , isub ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % my_rhs , dm % dcpc , fl % iteration , isub , 'ConVisPY@af stepping' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! x-pencil : z-momentum !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mz_rhs , dm % dccp , fl % iteration , isub , 'ConVisZ@bf stepping' ) ! debug_ww #endif call Calculate_momentum_fractional_step ( fl % mz_rhs0 , fl % mz_rhs , mz_rhs_pfc_xpencil , dm % dccp , dm , isub ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mz_rhs , dm % dccp , fl % iteration , isub , 'ConVisZ@af stepping' ) ! debug_ww #endif !========================================================================================================== ! x-pencil : flow drive terms (source terms) in periodic Streamwise flow !========================================================================================================== if ( fl % idriven == IDRVF_X_MASSFLUX ) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , fl % mx_rhs , rhsx_bulk , SPACE_AVERAGE , \"mx_rhs\" ) !call Get_volumetric_average_3d(.false., dm%ibcy(:, 1), dm%fbcy_var(:, :, :, 1), dm, dm%dpcc, fl%mx_rhs, rhsx_bulk, \"mx_rhs\") fl % mx_rhs = fl % mx_rhs - rhsx_bulk else if ( fl % idriven == IDRVF_X_TAUW . or . fl % idriven == IDRVF_X_DPDX ) then rhsx_bulk = - HALF * fl % drvfc * dm % tAlpha ( isub ) * dm % dt fl % mx_rhs = fl % mx_rhs - rhsx_bulk else if ( fl % idriven == IDRVF_Z_MASSFLUX ) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccp , fl % mz_rhs , rhsz_bulk , SPACE_AVERAGE , \"mz_rhs\" ) !call Get_volumetric_average_3d(.false., dm%ibcy(:, 3), dm%fbcy_var(:, :, :, 3), dm, dm%dccp, fl%mz_rhs, rhsz_bulk, \"mz_rhs\") fl % mz_rhs = fl % mz_rhs - rhsz_bulk else if ( fl % idriven == IDRVF_Z_TAUW . or . fl % idriven == IDRVF_Z_DPDZ ) then rhsz_bulk = - HALF * fl % drvfc * dm % tAlpha ( isub ) * dm % dt fl % mz_rhs = fl % mz_rhs - rhsz_bulk else end if #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % mx_rhs , dm % dpcc , fl % iteration , isub , 'RHSX@total' ) ! debug_ww call wrt_3d_pt_debug ( fl % my_rhs , dm % dpcc , fl % iteration , isub , 'RHSY@total' ) ! debug_ww call wrt_3d_pt_debug ( fl % mz_rhs , dm % dccp , fl % iteration , isub , 'RHSZ@total' ) ! debug_ww #endif return end subroutine Compute_momentum_rhs !========================================================================================================== !========================================================================================================== !========================================================================================================== !========================================================================================================== subroutine Correct_massflux ( fl , phi_ccc , dm , isub ) use udf_type_mod use input_general_mod use operations use parameters_constant_mod use cylindrical_rn_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: isub real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ), intent ( in ) :: phi_ccc real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: ux real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: uy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: uz real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: dphidx_pcc real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: dphidy_cpc real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: dphidz_ccp real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: phi_ccc_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: dphidy_cpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: dphidz_ccp_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: pphi_ccc_zpencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: dphidz_ccp_zpencil #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_inline_msg ( \"Updating the velocity/mass flux ...\" ) #endif if ( dm % is_thermo ) then ux = fl % gx uy = fl % gy uz = fl % gz else ux = fl % qx uy = fl % qy uz = fl % qz end if !---------------------------------------------------------------------------------------------------------- !   x-pencil, qx = qx - dt * alpha * d(phi_ccc)/dx !---------------------------------------------------------------------------------------------------------- dphidx_pcc = ZERO call Get_x_1der_C2P_3D ( phi_ccc , dphidx_pcc , dm , dm % iAccuracy , dm % ibcx_pr , dm % fbcx_pr ) ux = ux - dm % dt * dm % tAlpha ( isub ) * dm % sigma2p * dphidx_pcc !---------------------------------------------------------------------------------------------------------- !   y-pencil, qy = qy - dt * alpha * r * d(phi_ccc)/dy !---------------------------------------------------------------------------------------------------------- phi_ccc_ypencil = ZERO dphidy_cpc_ypencil = ZERO dphidy_cpc = ZERO call transpose_x_to_y ( phi_ccc , phi_ccc_ypencil , dm % dccc ) call Get_y_1der_C2P_3D ( phi_ccc_ypencil , dphidy_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_pr , dm % fbcy_pr ) !call axis_estimating_radial_xpx(dphidy_cpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(1)) call transpose_y_to_x ( dphidy_cpc_ypencil , dphidy_cpc , dm % dcpc ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( dphidy_cpc , dm % dcpc , dm % rp , 1 , IPENCIL ( 1 )) uy = uy - dm % dt * dm % tAlpha ( isub ) * dm % sigma2p * dphidy_cpc !---------------------------------------------------------------------------------------------------------- !   z-pencil, qz = qz - dt * alpha * 1/r * d(phi_ccc)/dz (if qz = uz) !---------------------------------------------------------------------------------------------------------- pphi_ccc_zpencil = ZERO dphidz_ccp_zpencil = ZERO dphidz_ccp_ypencil = ZERO dphidz_ccp = ZERO call transpose_y_to_z ( phi_ccc_ypencil , pphi_ccc_zpencil , dm % dccc ) call Get_z_1der_C2P_3D ( pphi_ccc_zpencil , dphidz_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_pr , dm % fbcz_pr ) call transpose_z_to_y ( dphidz_ccp_zpencil , dphidz_ccp_ypencil , dm % dccp ) call transpose_y_to_x ( dphidz_ccp_ypencil , dphidz_ccp , dm % dccp ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( dphidz_ccp , dm % dccp , dm % rci , 1 , IPENCIL ( 1 )) uz = uz - dm % dt * dm % tAlpha ( isub ) * dm % sigma2p * dphidz_ccp if ( dm % is_thermo ) then fl % gx = ux fl % gy = uy fl % gz = uz else fl % qx = ux fl % qy = uy fl % qz = uz end if return end subroutine Correct_massflux !========================================================================================================== subroutine solve_poisson ( fl , dm , isub ) use udf_type_mod use parameters_constant_mod use poisson_interface_mod use continuity_eq_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl integer , intent ( in ) :: isub real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: div real ( WP ) :: coeff #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_inline_msg ( \"Calculating the RHS of Poisson Equation ...\" ) #endif !========================================================================================================== ! RHS of Poisson Eq. ! RHS = r&#94;2 * d(\\rho)/dt + r&#94;2 * du/dx + r * dv/dy + dw/dz !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! $d\\rho / dt$ at cell centre !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then !if(isub==0) then !call Calculate_drhodt(fl%dDens, fl%dDensm2, fl%drhodt, dm) !else call Calculate_drhodt ( fl , dm ) !end if else fl % drhodt = ZERO end if !---------------------------------------------------------------------------------------------------------- ! $d(\\rho u_i)) / dx_i $ at cell centre !---------------------------------------------------------------------------------------------------------- div = ZERO call Get_divergence_flow ( fl , div , dm ) fl % pcor = fl % drhodt + div #ifdef DEBUG_STEPS write ( * , * ) 'RHS(phi)_no_drhodt' , div ( 1 , 1 : 4 , 1 ) #endif !---------------------------------------------------------------------------------------------------------- ! For cylindrical coordinate: ! Poisson eq is r&#94;2 * d2/dx2 + r * d(r * d/dy)/dy + d2/dz2  = r&#94;2 * div !---------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( fl % pcor , dm % dccc , dm % rc , 2 , IPENCIL ( 1 )) ! important coeff = ONE / ( dm % tAlpha ( isub ) * dm % sigma2p * dm % dt ) fl % pcor = fl % pcor * coeff #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % pcor , dm % dccc , fl % iteration , isub , 'PhiRHS@RHS phi' ) ! debug_ww !call wrt_3d_all_debug(fl%pcor, dm%dccc,   fl%iteration, 'PhiRHS@RHS phi') ! debug_ww write ( * , * ) 'RHS(phi)_w_drhodt' , fl % pcor ( 1 , 1 : 4 , 1 ) #endif !---------------------------------------------------------------------------------------------------------- !   solve Poisson !---------------------------------------------------------------------------------------------------------- call solve_fft_poisson ( fl % pcor , dm ) #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % pcor , dm % dccc , fl % iteration , isub , 'phi@sol phi' ) ! debug_ww !call wrt_3d_all_debug(fl%pcor, dm%dccc,   fl%iteration, 'phi@sol phi') ! debug_ww write ( * , * ) 'solved_phi' , fl % pcor ( 1 , 1 : 4 , 1 ) #endif return end subroutine ! !========================================================================================================== !   subroutine solve_poisson_x2z(fl, dm, isub) !     use udf_type_mod !     use parameters_constant_mod !     use decomp_2d_poisson !     use decomp_extended_mod !     use continuity_eq_mod !     implicit none !     type(t_domain), intent( in    ) :: dm !     type(t_flow),   intent( inout ) :: fl !     integer,        intent( in    ) :: isub !     real(WP), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ) :: rhs !     real(WP), dimension( dm%dccc%ysz(1), dm%dccc%ysz(2), dm%dccc%ysz(3) ) :: rhs_ypencil !     real(WP), dimension( dm%dccc%zsz(1), dm%dccc%zsz(2), dm%dccc%zsz(3) ) :: rhs_zpencil !     real(WP), dimension( dm%dccc%zst(1) : dm%dccc%zen(1), & !                          dm%dccc%zst(2) : dm%dccc%zen(2), & !                          dm%dccc%zst(3) : dm%dccc%zen(3) ) :: rhs_zpencil_ggg !     !integer :: i, j, k, jj, ii ! !========================================================================================================== ! ! RHS of Poisson Eq. ! !========================================================================================================== !     fl%pcor_zpencil_ggg = ZERO ! !---------------------------------------------------------------------------------------------------------- ! ! $d\\rho / dt$ at cell centre ! !---------------------------------------------------------------------------------------------------------- !     if (dm%is_thermo) then !       rhs = ZERO !       rhs_ypencil = ZERO !       rhs_zpencil = ZERO !       rhs_zpencil_ggg = ZERO !       call Calculate_drhodt(dm, tm%dDens, tm%dDensm1, tm%dDensm2, rhs) !       call transpose_x_to_y(rhs,         rhs_ypencil) !       call transpose_y_to_z(rhs_ypencil, rhs_zpencil) !       call zpencil_index_llg2ggg(rhs_zpencil, rhs_zpencil_ggg, dm%dccc) !       fl%pcor_zpencil_ggg = fl%pcor_zpencil_ggg + rhs_zpencil_ggg !     end if ! !---------------------------------------------------------------------------------------------------------- ! ! $d(\\rho u_i)) / dx_i $ at cell centre ! !---------------------------------------------------------------------------------------------------------- !     rhs_zpencil_ggg  = ZERO !     if (dm%is_thermo) then !       call Get_divergence_x2z(fl%gx, fl%gy, fl%gz, rhs_zpencil_ggg, dm) !     else !       call Get_divergence_x2z(fl%qx, fl%qy, fl%qz, rhs_zpencil_ggg, dm) !     end if !     fl%pcor_zpencil_ggg = fl%pcor_zpencil_ggg + rhs_zpencil_ggg !     fl%pcor_zpencil_ggg = fl%pcor_zpencil_ggg / (dm%tAlpha(isub) * dm%sigma2p * dm%dt) ! !========================================================================================================== ! !   solve Poisson ! !========================================================================================================== !     call poisson(fl%pcor_zpencil_ggg) ! !========================================================================================================== ! !   convert back RHS from zpencil ggg to xpencil gll ! !========================================================================================================== !     call zpencil_index_ggg2llg(fl%pcor_zpencil_ggg, rhs_zpencil, dm%dccc) !     call transpose_z_to_y (rhs_zpencil, rhs_ypencil, dm%dccc) !     call transpose_y_to_x (rhs_ypencil, fl%pcor,     dm%dccc) !     return !   end subroutine !========================================================================================================== !> \\brief To update the provisional u or rho u. !> !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                         ! !______________________________________________________________________________! !> \\param[inout]  fl            flow field !> \\param[inout]  dm            domain !> \\param[in]     isub         RK sub-iteration !========================================================================================================== subroutine Solve_momentum_eq ( fl , dm , isub ) use udf_type_mod use typeconvert_mod use continuity_eq_mod use boundary_conditions_mod use parameters_constant_mod use mpi_mod use solver_tools_mod use convert_primary_conservative_mod use io_restart_mod use find_max_min_ave_mod #ifdef DEBUG_STEPS use io_tools_mod use typeconvert_mod use wtformat_mod #endif implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( inout ) :: dm integer , intent ( in ) :: isub logical :: flg_bc_conv integer :: i real ( WP ) :: pres_bulk if ( dm % is_thermo ) call convert_primary_conservative ( fl , dm , IG2Q ) !---------------------------------------------------------------------------------------------------------- ! to set up halo b.c. for cylindrical pipe !---------------------------------------------------------------------------------------------------------- if ( dm % icoordinate == ICYLINDRICAL ) call update_fbcy_cc_flow_halo ( fl , dm ) !---------------------------------------------------------------------------------------------------------- ! to set up convective outlet b.c. assume x direction !---------------------------------------------------------------------------------------------------------- if ( dm % is_conv_outlet ) call update_fbcx_convective_outlet_flow ( fl , dm , isub ) !---------------------------------------------------------------------------------------------------------- ! to calculate the rhs of the momenturn equation in stepping method !---------------------------------------------------------------------------------------------------------- call Compute_momentum_rhs ( fl , dm , isub ) !---------------------------------------------------------------------------------------------------------- ! to update intermediate (\\hat{q}) or (\\hat{g}) !---------------------------------------------------------------------------------------------------------- if ( . not . dm % is_thermo ) then fl % qx = fl % qx + fl % mx_rhs fl % qy = fl % qy + fl % my_rhs fl % qz = fl % qz + fl % mz_rhs call enforce_velo_from_fbc ( dm , fl % qx , fl % qy , fl % qz , dm % fbcx_qx , dm % fbcy_qy , dm % fbcz_qz ) else if ( dm % is_thermo ) then fl % gx = fl % gx + fl % mx_rhs fl % gy = fl % gy + fl % my_rhs fl % gz = fl % gz + fl % mz_rhs call enforce_velo_from_fbc ( dm , fl % gx , fl % gy , fl % gz , dm % fbcx_gx , dm % fbcy_gy , dm % fbcz_gz ) else call Print_error_msg ( \"Error in velocity updating\" ) end if if ( dm % icoordinate == ICYLINDRICAL ) call update_fbcy_cc_flow_halo ( fl , dm ) #ifdef DEBUG_STEPS if ( . not . dm % is_thermo ) then call wrt_3d_pt_debug ( fl % qx , dm % dpcc , fl % iteration , isub , 'qx_bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % qy , dm % dcpc , fl % iteration , isub , 'qy_bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % qz , dm % dccp , fl % iteration , isub , 'qz_bf divg' ) ! debug_ww else call wrt_3d_pt_debug ( fl % gx , dm % dpcc , fl % iteration , isub , 'gx_bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % gy , dm % dcpc , fl % iteration , isub , 'gy_bf divg' ) ! debug_ww call wrt_3d_pt_debug ( fl % gz , dm % dccp , fl % iteration , isub , 'gz_bf divg' ) ! debug_ww end if !write(*,*) 'qx', fl%qx(:, 1, 1), fl%qx(:, 8, 8) !write(*,*) 'qy', fl%qy(:, 1, 1), fl%qy(:, 8, 8) !write(*,*) 'qz', fl%qz(:, 1, 1), fl%qz(:, 8, 8) #endif !in order for a high order spacial accuracy ! to use Alternating direction implicit method ! ref: Cui2013: Convergence analysis of high-order compact ! alternating direction implicit nnn/schemes for the two-dimensional ! time fractional equation ! #ifdef DEBUG_STEPS !   call write_snapshot_any3darray(fl%qx, 'qxs_RK'//trim(int2str(isub)), 'debug', dm%dpcc, dm, fl%iteration) !   call write_snapshot_any3darray(fl%qy, 'qys_RK'//trim(int2str(isub)), 'debug', dm%dcpc, dm, fl%iteration) !   call write_snapshot_any3darray(fl%qz, 'qzs_RK'//trim(int2str(isub)), 'debug', dm%dccp, dm, fl%iteration) ! #endif !---------------------------------------------------------------------------------------------------------- ! to solve Poisson equation !---------------------------------------------------------------------------------------------------------- !if(nrank == 0) call Print_debug_inline_msg(\"  Solving Poisson Equation ...\") !call solve_poisson_x2z(fl, dm, isub) ! call solve_poisson ( fl , dm , isub ) ! test show above two methods gave the same results. !---------------------------------------------------------------------------------------------------------- ! to update pressure !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_inline_msg ( \"Correcting the pressure term ...\" ) #endif fl % pres = fl % pres + fl % pcor ! correct pressure drift !call Get_volumetric_average_3d_for_var_xcx(dm, dm%dccc, fl%pres, pres_bulk, SPACE_AVERAGE, \"pressure\") !fl%pres = fl%pres - pres_bulk #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % pres , dm % dccc , fl % iteration , isub , 'pr_updated' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- ! to update velocity/massflux correction !---------------------------------------------------------------------------------------------------------- !if(nrank == 0) call Print_debug_inline_msg(\"  Updating velocity/mass flux ...\") call Correct_massflux ( fl , fl % pcor , dm , isub ) if ( . not . dm % is_thermo ) then call enforce_velo_from_fbc ( dm , fl % qx , fl % qy , fl % qz , dm % fbcx_qx , dm % fbcy_qy , dm % fbcz_qz ) else call enforce_velo_from_fbc ( dm , fl % gx , fl % gy , fl % gz , dm % fbcx_gx , dm % fbcy_gy , dm % fbcz_gz ) end if if ( dm % icoordinate == ICYLINDRICAL ) call update_fbcy_cc_flow_halo ( fl , dm ) #ifdef DEBUG_STEPS if ( dm % is_thermo ) then call wrt_3d_pt_debug ( fl % gx , dm % dpcc , fl % iteration , isub , 'gx_updated' ) ! debug_ww call wrt_3d_pt_debug ( fl % gy , dm % dcpc , fl % iteration , isub , 'gy_updated' ) ! debug_ww call wrt_3d_pt_debug ( fl % gz , dm % dccp , fl % iteration , isub , 'gz_updated' ) ! debug_ww end if #endif call Check_element_mass_conservation ( fl , dm , isub ) !---------------------------------------------------------------------------------------------------------- ! to update velocity from gx gy gz !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then call convert_primary_conservative ( fl , dm , IG2Q ) !if(isub == dm%nsubitr) then !fl%dDensm2 = fl%dDensm1 !fl%dDensm1 = fl%dDens !end if end if ! if(dm%is_thermo .and.isub == dm%nsubitr) then !   do i = 1, 100 !     call solve_poisson(fl, dm, 0) !     fl%pres = fl%pres + fl%pcor !     call Correct_massflux(fl, fl%pcor, dm, isub) !     call enforce_velo_from_fbc(dm, fl%gx, fl%gy, fl%gz, dm%fbcx_gx, dm%fbcy_gy, dm%fbcz_gz) !     if(dm%icoordinate == ICYLINDRICAL) call update_fbcy_cc_flow_halo(fl, dm) !     call convert_primary_conservative(fl, dm, IG2Q) !     call Check_element_mass_conservation(fl, dm, isub) !   end do ! end if #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % qx , dm % dpcc , fl % iteration , isub , 'qx_updated' ) ! debug_ww call wrt_3d_pt_debug ( fl % qy , dm % dcpc , fl % iteration , isub , 'qy_updated' ) ! debug_ww call wrt_3d_pt_debug ( fl % qz , dm % dccp , fl % iteration , isub , 'qz_updated' ) ! debug_ww if ( nrank == 0 ) then call Print_debug_inline_msg ( \"Conservative parameters have been updated.\" ) ! write(*,*) 'updated qx', fl%qx(1:4, 1, 1) ! write(*,*) 'updated qx', fl%qx(1, 1:4, 1) end if #endif return end subroutine Solve_momentum_eq end module eq_momentum_mod","tags":"","url":"sourcefile/eq_momentum2.f90.html"},{"title":"geometry.f90 – CHAPSim2","text":"Source Code !---------------------------------------------------------------------------------------------------------- !                      CHAPSim version 2.0.0 !                      -------------------------- ! This file is part of CHAPSim, a general-purpose CFD tool. ! ! This program is free software; you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation; either version 3 of the License, or (at your option) any later ! version. ! ! This program is distributed in the hope that it will be useful, but WITHOUT ! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS ! FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more ! details. ! ! You should have received a copy of the GNU General Public License along with ! this program; if not, write to the Free Software Foundation, Inc., 51 Franklin ! Street, Fifth Floor, Boston, MA 02110-1301, USA. !---------------------------------------------------------------------------------------------------------- !========================================================================================================== !> \\file geometry.f90 !> !> \\brief Building up the geometry and mesh information. !> !========================================================================================================== module geometry_mod use vars_df_mod , only : domain use precision_mod use print_msg_mod implicit none !private private :: Buildup_grid_mapping_1D_3fmd private :: Buildup_grid_mapping_1D_tanh private :: Buildup_grid_mapping_1D_powerlaw public :: Buildup_geometry_mesh_info contains subroutine Buildup_grid_mapping_1D_powerlaw ( str , n , dm , y , mp , opt_yp ) ! Powerlaw is not a suitable mesh stretching method, but it's easily degraded to uniform ! this is only for debug of stretching grids. use math_mod use udf_type_mod use typeconvert_mod use parameters_constant_mod implicit none character ( len = * ), intent ( in ) :: str integer , intent ( in ) :: n type ( t_domain ), intent ( in ) :: dm real ( WP ), optional , intent ( in ) :: opt_yp (:) real ( WP ), intent ( out ) :: y ( n ) real ( WP ), intent ( out ) :: mp ( n , 3 ) integer :: j real ( WP ) :: eta_shift real ( WP ) :: eta_delta real ( WP ) :: alpha , beta , gamma , delta real ( WP ) :: mm , ymin , ymax , ff real ( WP ), dimension ( n ) :: eta if ( dm % mstret /= MSTRET_POWL ) then call Print_error_msg ( 'Grid stretching method is not MSTRET_POWL.' ) end if if ( nrank == 0 ) call Print_debug_inline_msg ( \"Buildup_grid_mapping_1D_powerlaw for \" // trim ( str )) !---------------------------------------------------------------------------------------------------------- ! note: (1)if both yc and yp are calculated using the stretching function, !          yc_i /= (yp_i + yp_i+1) !       (2)if yc_i /= (yp_i + yp_i+1), the mapping function for yc is unknown explicitly. !---------------------------------------------------------------------------------------------------------- eta_shift = ZERO eta_delta = ONE if ( trim ( str ) == 'nd' ) then eta_shift = ZERO eta_delta = ONE / real ( n - 1 , WP ) else if ( trim ( str ) == 'cl' ) then eta_shift = ONE / ( real ( n , WP ) ) * HALF eta_delta = ONE / real ( n , WP ) else call Print_error_msg ( 'Grid stretching location not defined.' ) end if !---------------------------------------------------------------------------------------------------------- ! to build up the computational domain \\eta \\in [0, 1] uniform mesh !---------------------------------------------------------------------------------------------------------- eta ( 1 ) = ZERO + eta_shift do j = 2 , n eta ( j ) = eta ( 1 ) + real ( j - 1 , WP ) * eta_delta end do !write(*,*) 'eta', eta !---------------------------------------------------------------------------------------------------------- ! to build up the physical domain y stretching grids based on Eq(53) of Leizet2009JCP ! and to build up the derivates based on Eq(53) and (47) in Leizet2009JCP !---------------------------------------------------------------------------------------------------------- ymin = ZERO ymax = ZERO if ( dm % istret == ISTRET_NO ) then do j = 1 , n y ( j ) = eta ( j ) y ( j ) = y ( j ) * ( dm % lyt - dm % lyb ) + dm % lyb mp ( j , 1 ) = ONE mp ( j , 2 ) = ONE mp ( j , 3 ) = ONE end do return else if ( dm % istret == ISTRET_CENTRE ) then call Print_error_msg ( 'Grid stretching flag is not valid.' ) else if ( dm % istret == ISTRET_2SIDES ) then ymin = ZERO ymax = ONE else if ( dm % istret == ISTRET_BOTTOM ) then ymin = ZERO ymax = ONE else if ( dm % istret == ISTRET_TOP ) then ymin = ZERO ymax = ONE else call Print_error_msg ( 'Grid stretching flag is not valid.' ) end if beta = dm % rstret do j = 1 , n !---------------------------------------------------------------------------------------------------------- ! y \\in [-1, 1] or [0, 1] !---------------------------------------------------------------------------------------------------------- y ( j ) = eta ( j ) ** int ( beta ) mp ( j , 1 ) = beta * eta ( j ) ** ( int ( beta ) - 1 ) if ( mp ( j , 1 ) < MINP . and . mp ( j , 1 ) > MAXN ) then mp ( j , 1 ) = ONE if ( nrank == 0 ) call Print_warning_msg ( 'Th mapping function for ' // trim ( str ) // ' at j = ' // trim ( int2str ( j )) // ' is adjusted.' ) else mp ( j , 1 ) = ONE / mp ( j , 1 ) end if !---------------------------------------------------------------------------------------------------------- ! y \\in [lyb, lyt] !---------------------------------------------------------------------------------------------------------- ff = ( dm % lyt - dm % lyb ) / ( ymax - ymin ) y ( j ) = ( y ( j ) - ymin ) * ff + dm % lyb mp ( j , 1 ) = mp ( j , 1 ) / ff !---------------------------------------------------------------------------------------------------------- ! (1/h')&#94;2 !---------------------------------------------------------------------------------------------------------- mp ( j , 2 ) = mp ( j , 1 ) * mp ( j , 1 ) !mp(j, 3) is not used. end do return end subroutine subroutine Buildup_grid_mapping_1D_tanh ( str , n , dm , y , mp , opt_yp ) use math_mod use udf_type_mod use parameters_constant_mod use typeconvert_mod implicit none character ( len = * ), intent ( in ) :: str integer , intent ( in ) :: n type ( t_domain ), intent ( in ) :: dm real ( WP ), optional , intent ( in ) :: opt_yp (:) real ( WP ), intent ( out ) :: y ( n ) real ( WP ), intent ( out ) :: mp ( n , 3 ) integer :: j real ( WP ) :: eta_shift real ( WP ) :: eta_delta real ( WP ) :: alpha , beta , gamma , delta real ( WP ) :: mm , ymin , ymax , ff real ( WP ), dimension ( n ) :: eta if ( dm % mstret /= MSTRET_TANH ) then call Print_error_msg ( 'Grid stretching method is not MSTRET_TANH.' ) end if if ( nrank == 0 ) call Print_debug_inline_msg ( \"Buildup_grid_mapping_1D_tanh for \" // trim ( str )) !---------------------------------------------------------------------------------------------------------- ! note: (1)if both yc and yp are calculated using the stretching function, !          yc_i /= (yp_i + yp_i+1) !       (2)if yc_i /= (yp_i + yp_i+1), the mapping function for yc is unknown explicitly. !---------------------------------------------------------------------------------------------------------- eta_shift = ZERO eta_delta = ONE if ( trim ( str ) == 'nd' ) then eta_shift = ZERO eta_delta = ONE / real ( n - 1 , WP ) else if ( trim ( str ) == 'cl' ) then eta_shift = ONE / ( real ( n , WP ) ) * HALF eta_delta = ONE / real ( n , WP ) else call Print_error_msg ( 'Grid stretching location not defined.' ) end if !---------------------------------------------------------------------------------------------------------- ! to build up the computational domain \\eta \\in [0, 1] uniform mesh !---------------------------------------------------------------------------------------------------------- eta ( 1 ) = ZERO + eta_shift do j = 2 , n eta ( j ) = eta ( 1 ) + real ( j - 1 , WP ) * eta_delta end do !---------------------------------------------------------------------------------------------------------- ! to build up the physical domain y stretching grids based on Eq(53) of Leizet2009JCP ! and to build up the derivates based on Eq(53) and (47) in Leizet2009JCP !---------------------------------------------------------------------------------------------------------- gamma = ONE delta = ZERO ymin = ZERO ymax = ZERO if ( dm % istret == ISTRET_NO ) then do j = 1 , n y ( j ) = eta ( j ) y ( j ) = y ( j ) * ( dm % lyt - dm % lyb ) + dm % lyb mp ( j , 1 ) = ONE mp ( j , 2 ) = ONE mp ( j , 3 ) = ONE end do return else if ( dm % istret == ISTRET_CENTRE ) then call Print_error_msg ( 'Grid stretching flag is not valid.' ) else if ( dm % istret == ISTRET_2SIDES ) then gamma = HALF delta = HALF ymin = - ONE ymax = ONE else if ( dm % istret == ISTRET_BOTTOM ) then gamma = - ONE delta = ONE ymin = ZERO ymax = ONE else if ( dm % istret == ISTRET_TOP ) then gamma = ONE delta = ZERO ymin = ZERO ymax = ONE else call Print_error_msg ( 'Grid stretching flag is not valid.' ) end if beta = dm % rstret * TWENTY mm = tanh_wp ( beta * gamma ) do j = 1 , n !---------------------------------------------------------------------------------------------------------- ! y \\in [-1, 1] or [0, 1] !---------------------------------------------------------------------------------------------------------- if ( present ( opt_yp ) . and . trim ( str ) == 'cl' ) then y ( j ) = ( opt_yp ( j ) + opt_yp ( j + 1 )) * HALF else y ( j ) = tanh_wp ( beta * ( eta ( j ) - delta )) / mm end if mp ( j , 1 ) = ONE - y ( j ) * y ( j ) * mm * mm if ( mp ( j , 1 ) < MINP . and . mp ( j , 1 ) > MAXN ) then mp ( j , 1 ) = ONE if ( nrank == 0 ) call Print_warning_msg ( 'Th mapping function for ' // trim ( str ) // ' at j = ' // trim ( int2str ( j )) // ' is adjusted.' ) else mp ( j , 1 ) = mm / beta / mp ( j , 1 ) end if !---------------------------------------------------------------------------------------------------------- ! y \\in [lyb, lyt] !---------------------------------------------------------------------------------------------------------- ff = ( dm % lyt - dm % lyb ) / ( ymax - ymin ) y ( j ) = ( y ( j ) - ymin ) * ff + dm % lyb mp ( j , 1 ) = mp ( j , 1 ) / ff !---------------------------------------------------------------------------------------------------------- ! (1/h')&#94;2 !---------------------------------------------------------------------------------------------------------- mp ( j , 2 ) = mp ( j , 1 ) * mp ( j , 1 ) !mp(j, 3) is not used. end do return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief Building up the mesh mapping relation between physical domain and mesh !>  to a computational domain and mesh. !> !> This subroutine is used locally for 1D only. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     str          string to indicate mapping of cell centre or nodes !> \\param[in]     n            number of mapping points !> \\param[out]    y            the physical coordinate array !> \\param[out]    mp           the mapping relations for 1st and 2nd deriviatives !_______________________________________________________________________________ subroutine Buildup_grid_mapping_1D_3fmd ( str , n , dm , y , mp , opt_yp ) use math_mod use udf_type_mod use parameters_constant_mod implicit none character ( len = * ), intent ( in ) :: str integer , intent ( in ) :: n type ( t_domain ), intent ( in ) :: dm real ( WP ), optional , intent ( in ) :: opt_yp (:) real ( WP ), intent ( out ) :: y ( n ) real ( WP ), intent ( out ) :: mp ( n , 3 ) integer :: j real ( WP ) :: eta_shift real ( WP ) :: eta_delta real ( WP ) :: cc , dd , ee , st1 , st2 , mm real ( WP ), dimension ( n ) :: eta real ( WP ) :: alpha , beta , gamma , delta if ( dm % mstret /= MSTRET_3FMD ) then call Print_error_msg ( 'Grid stretching method is not MSTRET_3FMD.' ) end if if ( nrank == 0 ) call Print_debug_inline_msg ( \"Buildup_grid_mapping_1D_3fmd for \" // trim ( str )) !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- eta_shift = ZERO eta_delta = ONE if ( trim ( str ) == 'nd' ) then eta_shift = ZERO eta_delta = ONE / real ( n - 1 , WP ) else if ( trim ( str ) == 'cl' ) then eta_shift = ONE / ( real ( n , WP ) ) * HALF eta_delta = ONE / real ( n , WP ) else call Print_error_msg ( 'Grid stretching location not defined.' ) end if !---------------------------------------------------------------------------------------------------------- ! to build up the computational domain \\eta \\in [0, 1] uniform mesh !---------------------------------------------------------------------------------------------------------- eta ( 1 ) = ZERO + eta_shift do j = 2 , n eta ( j ) = eta ( 1 ) + real ( j - 1 , WP ) * eta_delta end do !---------------------------------------------------------------------------------------------------------- ! to build up the physical domain y stretching grids based on Eq(53) of Leizet2009JCP ! and to build up the derivates based on Eq(53) and (47) in Leizet2009JCP !---------------------------------------------------------------------------------------------------------- gamma = ONE delta = ZERO if ( dm % istret == ISTRET_NO ) then do j = 1 , n y ( j ) = eta ( j ) y ( j ) = y ( j ) * ( dm % lyt - dm % lyb ) + dm % lyb mp ( j , 1 ) = ONE mp ( j , 2 ) = ONE mp ( j , 3 ) = ONE end do return else if ( dm % istret == ISTRET_CENTRE ) then gamma = ONE delta = ZERO else if ( dm % istret == ISTRET_2SIDES ) then gamma = ONE delta = HALF else if ( dm % istret == ISTRET_BOTTOM ) then gamma = HALF delta = HALF else if ( dm % istret == ISTRET_TOP ) then gamma = HALF delta = ZERO else call Print_error_msg ( 'Grid stretching flag is not valid.' ) end if beta = dm % rstret alpha = ( - ONE + sqrt_wp ( ONE + FOUR * PI * PI * beta * beta ) ) / beta * HALF cc = sqrt_wp ( alpha * beta + ONE ) / sqrt_wp ( beta ) dd = cc / sqrt_wp ( alpha ) ee = cc * sqrt_wp ( alpha ) st1 = ( ONE - TWO * delta ) / gamma * HALF st2 = ( THREE - TWO * delta ) / gamma * HALF do j = 1 , n mm = PI * ( gamma * eta ( j ) + delta ) !---------------------------------------------------------------------------------------------------------- ! y \\in [0, 1] !---------------------------------------------------------------------------------------------------------- if ( present ( opt_yp ) . and . trim ( str ) == 'cl' ) then y ( j ) = ( opt_yp ( j ) + opt_yp ( j + 1 )) * HALF else y ( j ) = atan_wp ( dd * tan_wp ( mm ) ) - & atan_wp ( dd * tan_wp ( PI * delta ) ) + & PI * ( heaviside_step ( eta ( j ) - st1 ) + heaviside_step ( eta ( j ) - st2 ) ) y ( j ) = ONE / ( gamma * ee ) * y ( j ) if ( trim ( str ) == 'nd' . and . j == 1 ) y ( j ) = ZERO if ( trim ( str ) == 'nd' . and . j == n ) y ( j ) = ONE end if !---------------------------------------------------------------------------------------------------------- ! y \\in [lyb, lyt] !---------------------------------------------------------------------------------------------------------- y ( j ) = y ( j ) * ( dm % lyt - dm % lyb ) + dm % lyb !---------------------------------------------------------------------------------------------------------- ! 1/h' = d\\eta/dy !---------------------------------------------------------------------------------------------------------- mp ( j , 1 ) = ( alpha / PI + sin_wp ( mm ) * sin_wp ( mm ) / PI / beta ) / ( dm % lyt - dm % lyb ) !---------------------------------------------------------------------------------------------------------- ! (1/h')&#94;2 !---------------------------------------------------------------------------------------------------------- mp ( j , 2 ) = mp ( j , 1 ) * mp ( j , 1 ) !---------------------------------------------------------------------------------------------------------- ! -h\"/(h'&#94;3) = 1/h' * [ d(1/h') / d\\eta] !---------------------------------------------------------------------------------------------------------- mp ( j , 3 ) = gamma / ( dm % lyt - dm % lyb ) / beta * sin_wp ( TWO * mm ) * mp ( j , 1 ) end do return end subroutine Buildup_grid_mapping_1D_3fmd !========================================================================================================== subroutine Buildup_geometry_mesh_info ( dm ) use mpi_mod use math_mod use parameters_constant_mod use udf_type_mod use typeconvert_mod use mpi_mod use wtformat_mod use io_files_mod use find_max_min_ave_mod implicit none type ( t_domain ), intent ( inout ) :: dm integer :: j integer :: wrt_unit real ( WP ) :: dyp , dyn , ddy real ( WP ) :: dy ( dm % nc ( 2 )) if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialising domain geometric ...\" ) !---------------------------------------------------------------------------------------------------------- ! set up node number in geometry domain !---------------------------------------------------------------------------------------------------------- do j = 1 , NDIM dm % np_geo ( j ) = dm % nc ( j ) + 1 end do !---------------------------------------------------------------------------------------------------------- ! set up node number in computational domain !---------------------------------------------------------------------------------------------------------- do j = 1 , NDIM if ( dm % is_periodic ( j ) ) then dm % np ( j ) = dm % nc ( j ) else dm % np ( j ) = dm % np_geo ( j ) end if end do !---------------------------------------------------------------------------------------------------------- ! set dx, dz for uniform grids !---------------------------------------------------------------------------------------------------------- dm % h ( 1 ) = dm % lxx / real ( dm % nc ( 1 ), WP ) dm % h ( 3 ) = dm % lzz / real ( dm % nc ( 3 ), WP ) dm % h ( 2 ) = ( dm % lyt - dm % lyb ) / real ( dm % nc ( 2 ), WP ) ! default, uniform !---------------------------------------------------------------------------------------------------------- ! allocate  variables for mapping physical domain to computational domain !---------------------------------------------------------------------------------------------------------- allocate ( dm % yp ( dm % np_geo ( 2 ) ) ) ! yp(1:np_geo) allocate ( dm % yc ( dm % nc ( 2 ) ) ) ! yc(1:nc) dm % yp (:) = ZERO dm % yc (:) = ZERO allocate ( dm % yMappingpt ( dm % np_geo ( 2 ), 3 ) ) allocate ( dm % yMappingcc ( dm % nc ( 2 ), 3 ) ) dm % yMappingpt (:, :) = ONE dm % yMappingcc (:, :) = ONE if ( dm % is_stretching ( 2 )) then dm % h ( 2 ) = ONE / real ( dm % nc ( 2 ), WP ) ! updated for computational domain, check if ( dm % mstret == MSTRET_3FMD ) then ! stretching in only given function to provide a limited modes for a fast 3D FFT call Buildup_grid_mapping_1D_3fmd ( 'nd' , dm % np_geo ( 2 ), dm , dm % yp (:), dm % yMappingpt (:, :)) call Buildup_grid_mapping_1D_3fmd ( 'cl' , dm % nc ( 2 ), dm , dm % yc (:), dm % yMappingcc (:, :)) else if ( dm % mstret == MSTRET_TANH ) then call Buildup_grid_mapping_1D_tanh ( 'nd' , dm % np_geo ( 2 ), dm , dm % yp (:), dm % yMappingpt (:, :)) call Buildup_grid_mapping_1D_tanh ( 'cl' , dm % nc ( 2 ), dm , dm % yc (:), dm % yMappingcc (:, :)) else if ( dm % mstret == MSTRET_POWL ) then call Buildup_grid_mapping_1D_powerlaw ( 'nd' , dm % np_geo ( 2 ), dm , dm % yp (:), dm % yMappingpt (:, :)) call Buildup_grid_mapping_1D_powerlaw ( 'cl' , dm % nc ( 2 ), dm , dm % yc (:), dm % yMappingcc (:, :)) else call Print_error_msg ( 'Stretching grid is not supported for 2DECOMP_3DFFT' ) end if else dm % h ( 2 ) = ( dm % lyt - dm % lyb ) / real ( dm % nc ( 2 ), WP ) do j = 1 , dm % np_geo ( 2 ) dm % yp ( j ) = real ( j - 1 , WP ) * dm % h ( 2 ) + dm % lyb end do do j = 1 , dm % nc ( 2 ) dm % yc ( j ) = real ( j - 1 , WP ) * dm % h ( 2 ) + dm % h ( 2 ) * HALF + dm % lyb end do end if !---------------------------------------------------------------------------------------------------------- ! set 1/dx, 1/(dx)&#94;2 !---------------------------------------------------------------------------------------------------------- do j = 1 , NDIM dm % h2r ( j ) = ONE / ( dm % h ( j ) * dm % h ( j )) dm % h1r ( j ) = ONE / dm % h ( j ) end do !---------------------------------------------------------------------------------------------------------- ! allocate  cylindrical radius !---------------------------------------------------------------------------------------------------------- allocate ( dm % rpi ( dm % np_geo ( 2 ) ) ) allocate ( dm % rci ( dm % nc ( 2 ) ) ) allocate ( dm % rp ( dm % np_geo ( 2 ) ) ) allocate ( dm % rc ( dm % nc ( 2 ) ) ) if ( dm % icoordinate == ICARTESIAN ) then dm % rp (:) = ONE dm % rc (:) = ONE dm % rpi (:) = ONE dm % rci (:) = ONE else if ( dm % icoordinate == ICYLINDRICAL ) then dm % rp ( 1 : dm % np_geo ( 2 )) = dm % yp ( 1 : dm % np_geo ( 2 )) dm % rc ( 1 : dm % nc ( 2 )) = dm % yc ( 1 : dm % nc ( 2 )) if ( dabs ( dm % yp ( 1 ) ) < MINP ) then dm % rpi ( 1 ) = MAXP else dm % rpi ( 1 ) = ONE / dm % yp ( 1 ) end if dm % rpi ( 2 : dm % np_geo ( 2 )) = ONE / dm % yp ( 2 : dm % np_geo ( 2 )) dm % rci (:) = ONE / dm % yc (:) !---------------------------------------------------------------------------------------------------------- ! set up z-interior extention cells for pipe flow, zpencil only !---------------------------------------------------------------------------------------------------------- allocate ( dm % knc_sym ( dm % nc ( 3 ))) do j = 1 , dm % nc ( 3 ) dm % knc_sym ( j ) = j + dm % nc ( 3 ) / 2 if ( dm % knc_sym ( j ) > dm % nc ( 3 )) dm % knc_sym ( j ) = dm % knc_sym ( j ) - dm % nc ( 3 ) end do end if !---------------------------------------------------------------------------------------------------------- ! print out data !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then !write (*, wrtfmt1i) '------For the domain-x------ ', dm%idom write ( * , wrtfmt3l ) 'is periodic in xyz :' , dm % is_periodic ( 1 : NDIM ) write ( * , wrtfmt3i ) 'geometry number of nodes     in xyz :' , dm % np_geo ( 1 : NDIM ) write ( * , wrtfmt3i ) 'calculation number of cells  in xyz :' , dm % nc ( 1 : NDIM ) write ( * , wrtfmt3i ) 'calculation number of points in xyz :' , dm % np ( 1 : NDIM ) write ( * , wrtfmt3r ) 'grid spacing in x, z: ' , dm % h ( 1 ), dm % h ( 3 ) write ( * , wrtfmt1e ) 'grid spacing in y(geometric     uniform) :' , ( dm % lyt - dm % lyb ) / real ( dm % nc ( 2 ), WP ) write ( * , wrtfmt1e ) 'grid spacing in y(computational uniform) :' , dm % h ( 2 ) end if !---------------------------------------------------------------------------------------------------------- ! print out data for debugging !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then !---------------------------------------------------------------------------------------------------------- ! validate the mesh mapping function using the chain rule: dy = d(h(s)) = h'(s) ds !---------------------------------------------------------------------------------------------------------- open ( newunit = wrt_unit , file = trim ( dir_chkp ) // '/check_mesh_mapping.dat' , action = \"write\" , status = \"replace\" ) write ( wrt_unit , * ) 'index, dyn(numerical dy), dyp (physical dy), diff' dyn = dm % h ( 2 ) dy = ZERO do j = 2 , dm % nc ( 2 ) if ( dm % is_stretching ( 2 )) & dyn = dm % h ( 2 ) / dm % yMappingcc ( j , 1 ) dyp = dm % yp ( j + 1 ) - dm % yp ( j ) dy ( j ) = dyp ddy = dabs ( dyn - dyp ) write ( wrt_unit , * ) j , dyn , dyp , ddy !write(wrt_unit, *) j, dm%h(2) / dm%yMappingcc(j, 1), dm%yp(j+1) - dm%yp(j), dm%h(2) / dm%yMappingpt(j, 1), dm%yc(j) - dm%yc(j-1) end do close ( wrt_unit ) !call Find_max_min_1d(dy, 'dy') open ( newunit = wrt_unit , file = trim ( dir_chkp ) // '/check_mesh_yp.dat' , action = \"write\" , status = \"replace\" ) write ( wrt_unit , * ) 'index, yp, rp, rpi' do j = 1 , dm % np_geo ( 2 ) write ( wrt_unit , * ) j , dm % yp ( j ), dm % rp ( j ), dm % rpi ( j ) end do close ( wrt_unit ) open ( newunit = wrt_unit , file = trim ( dir_chkp ) // '/check_mesh_yc.dat' , action = \"write\" , status = \"replace\" ) write ( wrt_unit , * ) 'index, yc, growth, rc, rci' ddy = ZERO do j = 1 , dm % nc ( 2 ) if ( j <= ( dm % nc ( 2 ) - 1 )) then dyn = dm % yp ( j + 2 ) - dm % yp ( j + 1 ) dyp = dm % yp ( j + 1 ) - dm % yp ( j ) ddy = abs_wp ( dyn - dyp ) / min ( dyn , dyp ) end if write ( wrt_unit , * ) j , dm % yc ( j ), ddy , dm % rc ( j ), dm % rci ( j ) end do close ( wrt_unit ) if ( dm % icoordinate == ICYLINDRICAL ) then open ( newunit = wrt_unit , file = trim ( dir_chkp ) // '/check_mesh_ksym.dat' , action = \"write\" , status = \"replace\" ) write ( wrt_unit , * ) 'knc, knc_sym' do j = 1 , dm % nc ( 3 ) write ( wrt_unit , * ) j , dm % knc_sym ( j ) end do close ( wrt_unit ) end if end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine Buildup_geometry_mesh_info end module geometry_mod","tags":"","url":"sourcefile/geometry.f90.html"},{"title":"poisson_fishpack.f90 – CHAPSim2","text":"Source Code module fishpack_fft use precision_mod private integer , save :: LPx , LPy , LPz real ( WP ), save :: SCALx , SCALz real ( WP ), allocatable , save :: XRT (:), WX (:) real ( WP ), allocatable , save :: ZRT (:), WZ (:) real ( WP ), allocatable , save :: a (:), b (:), c (:), bb (:) private :: TRID0 private :: fishpack_root_1D private :: fishpack_fft_1D public :: fishpack_fft_init public :: fishpack_fft_simple contains !========================================================================================================== !========================================================================================================== SUBROUTINE TRID0 ( NG , T ) !A, BB, C, T) IMPLICIT NONE INTEGER , INTENT ( IN ) :: NG !REAL(WP), DIMENSION(NG), INTENT(IN)    :: A !REAL(WP), DIMENSION(NG), INTENT(IN)    :: BB !REAL(WP), DIMENSION(NG), INTENT(IN)    :: C REAL ( WP ), DIMENSION ( NG ), INTENT ( INOUT ) :: T INTEGER :: NR , MM1 , I , IP REAL ( WP ) :: Z REAL ( WP ), DIMENSION ( NG ) :: D NR = NG MM1 = NR - 1 Z = 1.0_WP / BB ( 1 ) D ( 1 ) = C ( 1 ) * Z T ( 1 ) = T ( 1 ) * Z DO I = 2 , MM1 Z = 1.0_WP / ( BB ( I ) - A ( I ) * D ( I - 1 )) D ( I ) = C ( I ) * Z T ( I ) = ( T ( I ) - A ( I ) * T ( I - 1 )) * Z END DO Z = BB ( NR ) - A ( NR ) * D ( MM1 ) IF ( DABS ( Z ) > 1.0E-10_WP ) THEN T ( NR ) = ( T ( NR ) - A ( NR ) * T ( MM1 )) / Z ELSE T ( NR ) = 0.0_WP END IF DO IP = 1 , MM1 I = NR - IP T ( I ) = T ( I ) - D ( I ) * T ( I + 1 ) END DO RETURN END SUBROUTINE !========================================================================================================== !========================================================================================================== SUBROUTINE fishpack_root_1D ( L , LP , C1 , SCALX , WX , XRT ) !---------------------------------------------------------------------------------------------------------- ! Generate FFT transform roots for 1-D direction ! Arguments: !   L   (INTEGER(4), IN): Grid dimensions in X direction, global !   LP  (INTEGER(4), IN): Parameters determining transform type !   C1   (REAL(WP), IN): Scaling factors for X transform !   SCALX(REAL(WP), IN): scaling factor !   WX   (REAL(WP), DIMENSION(:), OUT): Work arrays for FFT !   XRT  (REAL(WP), DIMENSION(:), OUT): Transform roots for X !---------------------------------------------------------------------------------------------------------- IMPLICIT NONE ! Arguments INTEGER ( 4 ), INTENT ( IN ) :: L , LP REAL ( WP ), INTENT ( IN ) :: C1 REAL ( WP ), INTENT ( OUT ) :: SCALX REAL ( WP ), DIMENSION (:), INTENT ( INOUT ) :: WX REAL ( WP ), DIMENSION (:), INTENT ( INOUT ) :: XRT ! Local variables REAL ( WP ) :: PI , DX , DI INTEGER ( 4 ) :: LR , LRDEL , I ! Compute PI PI = 2.0_WP * DASIN ( 1.0_WP ) WX = 0.0_WP XRT = 0.0_WP !----------------------------------------------------------- ! X direction transform roots !----------------------------------------------------------- LR = L LRDEL = (( LP - 1 ) * ( LP - 3 ) * ( LP - 5 )) / 3 SCALX = DBLE ( LR + LRDEL ) DX = PI / ( 2.0_WP * SCALX ) SELECT CASE ( LP ) CASE ( 1 ) ! RFFTI     INITIALIZE  RFFTF AND RFFTB ! RFFTF     FORWARD TRANSFORM OF A REAL PERIODIC SEQUENCE ! RFFTB     BACKWARD TRANSFORM OF A REAL COEFFICIENT ARRAY XRT ( 1 ) = 0.0_WP XRT ( LR ) = - 4.0_WP * C1 DO I = 3 , LR , 2 XRT ( I - 1 ) = - 4.0_WP * C1 * ( DSIN ( DBLE (( I - 1 )) * DX )) ** 2 ! WW: This is for 2nd order central difference only XRT ( I ) = XRT ( I - 1 ) END DO CALL RFFTI ( LR , WX ) CASE ( 2 ) ! SINTI     INITIALIZE SINT ! SINT      SINE TRANSFORM OF A REAL ODD SEQUENCE DI = 0.00_WP DO I = 1 , LR XRT ( I ) = - 4.0_WP * C1 * ( DSIN (( DBLE ( I ) - DI ) * DX )) ** 2 END DO SCALX = 2.0_WP * SCALX CALL SINTI ( LR , WX ) CASE ( 3 ) ! SINQI     INITIALIZE SINQF AND SINQB ! SINQF     FORWARD SINE TRANSFORM WITH ODD WAVE NUMBERS ! SINQB     UNNORMALIZED INVERSE OF SINQF DI = 0.50_WP SCALX = 2.0_WP * SCALX DO I = 1 , LR XRT ( I ) = - 4.0_WP * C1 * ( DSIN (( DBLE ( I ) - DI ) * DX )) ** 2 ENDDO SCALX = 2.0_WP * SCALX CALL SINQI ( LR , WX ) CASE ( 4 ) ! COSTI     INITIALIZE COST ! COST      COSINE TRANSFORM OF A REAL EVEN SEQUENCE DI = 1.00_WP DO I = 1 , LR XRT ( I ) = - 4.0_WP * C1 * ( DSIN (( DBLE ( I ) - DI ) * DX )) ** 2 END DO SCALX = 2.0_WP * SCALX CALL COSTI ( LR , WX ) CASE ( 5 ) ! COSQI     INITIALIZE COSQF AND COSQB ! COSQF     FORWARD COSINE TRANSFORM WITH ODD WAVE NUMBERS ! COSQB     UNNORMALIZED INVERSE OF COSQF DI = 0.50_WP SCALX = 2.0_WP * SCALX DO I = 1 , LR XRT ( I ) = - 4.0_WP * C1 * ( DSIN (( DBLE ( I ) - DI ) * DX )) ** 2 END DO SCALX = 2.0_WP * SCALX CALL COSQI ( LR , WX ) END SELECT RETURN END SUBROUTINE !========================================================================================================== !========================================================================================================== subroutine fishpack_fft_1D ( ifwrd , lp , t , w ) implicit none integer ( 4 ), intent ( in ) :: ifwrd , lp real ( WP ), intent ( inout ) :: t (:) real ( WP ), intent ( in ) :: w (:) integer ( 4 ) :: nx nx = size ( t ) if ( ifwrd == 1 ) then !----------------------------------------------------------- ! forward 1-D FFT, physical space to wave number space !----------------------------------------------------------- select case ( lp ) case ( 1 ) call RFFTF ( nx , t , w ) case ( 2 ) call SINT ( nx , t , w ) case ( 3 ) call SINQF ( nx , t , w ) case ( 4 ) call COST ( nx , t , w ) case ( 5 ) call COSQF ( nx , t , w ) end select else if ( ifwrd == 2 ) then !----------------------------------------------------------- ! backward 1-D FFT, wave number space to physical space !----------------------------------------------------------- select case ( lp ) case ( 1 ) call RFFTB ( nx , t , w ) case ( 2 ) call SINT ( nx , t , w ) case ( 3 ) call SINQB ( nx , t , w ) case ( 4 ) call COST ( nx , t , w ) case ( 5 ) call COSQB ( nx , t , w ) end select else error stop 'Error: ifwrd is not 1 or 2' end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine fishpack_fft_init ( dm ) use udf_type_mod use parameters_constant_mod use io_files_mod use print_msg_mod implicit none type ( t_domain ), intent ( in ) :: dm !integer :: wsz integer :: ibcx ( 2 ), ibcz ( 2 ) integer :: nx , ny , nz , np integer :: j , i , k , ii , kk !real(WP) :: dyfi(dm%nc(2)), dyci(dm%np_geo(2)) if ( nrank == 0 ) call Print_debug_inline_msg ( \"Initialising fishpack fft lib ...\" ) !----------------------------------------------------------- ! assign key info from domain !----------------------------------------------------------- nx = dm % nc ( 1 ) ny = dm % nc ( 2 ) nz = dm % nc ( 3 ) np = dm % np_geo ( 2 ) ibcx ( 1 : 2 ) = dm % ibcx_qx ( 1 : 2 ) ibcz ( 1 : 2 ) = dm % ibcz_qx ( 1 : 2 ) !----------------------------------------------------------- ! check input grid size !----------------------------------------------------------- if ( nx <= 3 . or . ny <= 3 . or . nz <= 3 ) then error stop 'Error: Grid size is too small for Fishpack FFT' end if !----------------------------------------------------------- ! assign FFT transform type, LP->x, MP->z, NP->y !----------------------------------------------------------- if ( ibcx ( 1 ) == IBC_PERIODIC . and . ibcx ( 2 ) == IBC_PERIODIC ) LPx = 0 if ( ibcx ( 1 ) == IBC_DIRICHLET . and . ibcx ( 2 ) == IBC_DIRICHLET ) LPx = 1 if ( ibcx ( 1 ) == IBC_DIRICHLET . and . ibcx ( 2 ) == IBC_NEUMANN ) LPx = 2 if ( ibcx ( 1 ) == IBC_NEUMANN . and . ibcx ( 2 ) == IBC_NEUMANN ) LPx = 3 if ( ibcx ( 1 ) == IBC_NEUMANN . and . ibcx ( 2 ) == IBC_DIRICHLET ) LPx = 4 if ( ibcz ( 1 ) == IBC_PERIODIC . and . ibcz ( 2 ) == IBC_PERIODIC ) LPz = 0 if ( ibcz ( 1 ) == IBC_DIRICHLET . and . ibcz ( 2 ) == IBC_DIRICHLET ) LPz = 1 if ( ibcz ( 1 ) == IBC_DIRICHLET . and . ibcz ( 2 ) == IBC_NEUMANN ) LPz = 2 if ( ibcz ( 1 ) == IBC_NEUMANN . and . ibcz ( 2 ) == IBC_NEUMANN ) LPz = 3 if ( ibcz ( 1 ) == IBC_NEUMANN . and . ibcz ( 2 ) == IBC_DIRICHLET ) LPz = 4 LPy = 1 LPx = LPx + 1 LPy = LPy + 1 LPz = LPz + 1 !wsz = 30 + nx + ny * 2 + nz + MAX(nx, ny, nz) + 7 * (INT((nx+1)/2) + INT((nz+1)/2)) + 128 !----------------------------------------------------------- ! Build up fft root for x !----------------------------------------------------------- allocate ( XRT ( nx ), WX ( 2 * nx + 64 )) call fishpack_root_1D ( nx , LPx , dm % h2r ( 1 ), SCALx , Wx , xRT ) !----------------------------------------------------------- ! Build up fft root for z !----------------------------------------------------------- allocate ( ZRT ( nz ), WZ ( 2 * nz + 64 )) call fishpack_root_1D ( nz , LPz , dm % h2r ( 3 ), SCALz , Wz , zRT ) ! if(nrank==0) WRITE(*,*)'fft-scl ', SCALX, SCALz ! if(nrank==0) WRITE(*,*)'fft-xrt  ', XRT ! if(nrank==0) WRITE(*,*)'fft-zrt  ', zRT !----------------------------------------------------------- ! cylinderical poisson equation solved is: ! r&#94;2 * d&#94;2f/dx&#94;2 + r * d(r df/dr)/dr + d&#94;2f/dz&#94;2 = rhs * r&#94;2 !----------------------------------------------------------- ! allocate work arrays for TMDA, and coefficients ! note: this is for 2nd order central difference only ! r * d(r*df/dy)/dy at j = a j_{j-1} + b j_{j} + c j_{j+1} <=> ! +f_{j+1} / ( (y_{j+1} - y_j) * (y'_{j+1}-y'_{j}) ) ! c = 1 / ( (y_{j+1} - y_{j}) * (y'_{j+1}-y'_{j}) ) ! +f_{j-1} / ( (y_j - y_{j-1}) * (y'_{j+1}-y'_{j}) ) ! a = 1 / ( (y_{j} - y_{j-1}) * (y'_{j+1}-y'_{j}) ) ! -f_{j}   * (a+b) !----------------------------------------------------------- allocate ( a ( ny ), b ( ny ), c ( ny ), bb ( ny )) ! do j = 1, dm%nc(2) !   dyfi(j) = 1.0_WP / (dm%yp(j+1) - dm%yp(j)) ! node to node spacing ! end do ! do j = 2, dm%nc(2) !   dyci(j) = 1.0_WP / (dm%yc(j) - dm%yc(j-1)) ! cell centre to centre spacing ! end do ! dyci(1 ) = 1.0_WP / (( dm%yc(1) - dm%yp(1)  ) * TWO)! ! dyci(np) = 1.0_WP / (( dm%yp(np)- dm%yc(np-1) ) * TWO)! ! do j = 1, dm%nc(2) !   a(j) = (dyci(j  )/dm%rpi(j  )) * (dyfi(j)/dm%rci(j)) !   c(j) = (dyci(j+1)/dm%rpi(j+1)) * (dyfi(j)/dm%rci(j)) ! end do ! if(.not. dm%is_periodic(2)) then !   b(1) = b(1) + a(1) !   a(1) = 0.0_WP !   b(dm%nc(2)) = b(dm%nc(2)) + c(dm%nc(2)) !   c(dm%nc(2)) = 0.0_WP ! end if ! write(*,*) 'a', a ! write(*,*) 'b', b ! write(*,*) 'c', c do j = 1 , dm % nc ( 2 ) a ( j ) = dm % h2r ( 2 ) * dm % yMappingcc ( j , 1 ) * dm % yMappingpt ( j , 1 ) * dm % rp ( j ) * dm % rc ( j ) c ( j ) = dm % h2r ( 2 ) * dm % yMappingcc ( j , 1 ) * dm % yMappingpt ( j + 1 , 1 ) * dm % rp ( j + 1 ) * dm % rc ( j ) end do b = - ( a + c ) if (. not . dm % is_periodic ( 2 )) then ! here apply the second order ghost cell configuration b ( 1 ) = b ( 1 ) + a ( 1 ) a ( 1 ) = 0.0_WP b ( dm % nc ( 2 )) = b ( dm % nc ( 2 )) + c ( dm % nc ( 2 )) c ( dm % nc ( 2 )) = 0.0_WP end if ! write(*,*) 'a', a ! write(*,*) 'b', b ! write(*,*) 'c', c !----------------------------------------------------------- ! data check !----------------------------------------------------------- ! if(nrank == 0) then !   open(221, file = trim(dir_chkp)//'/check_mesh_dyfi.dat') !   write(221, *) 'index, dyfi' !   do j = 1, dm%nc(2) !     write (221, *) j, dyfi(j) !   end do !   open(223, file = trim(dir_chkp)//'/check_mesh_dyci.dat') !   write(223, *) 'index, dyci' !   do j = 1, dm%np_geo(2) !     write (223, *) j, dyci(j) !   end do !   open(224, file = trim(dir_chkp)//'/check_mesh_abc.dat') !   write(224, *) 'index, a, b, c' !   do j = 1, dm%nc(2) !     write (224, *) j, a(j), b(j), c(j) !   end do ! end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine fishpack_fft_simple ( rhs_xpencil , dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( inout ) :: rhs_xpencil ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) integer :: ifwrd integer :: i , j , k , ii , kk real ( WP ) :: tx ( dm % dccc % xsz ( 1 )), ty ( dm % dccc % ysz ( 2 )), tz ( dm % dccc % zsz ( 3 )) real ( WP ) :: rhs_ypencil ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) real ( WP ) :: rhs_zpencil ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) !write(*,*) 'fft-in ', rhs_xpencil !----------------------------------------------------------- ! forward FFT in x direction ! x - pencil !----------------------------------------------------------- ifwrd = 1 do j = 1 , dm % dccc % xsz ( 2 ) do k = 1 , dm % dccc % xsz ( 3 ) do i = 1 , dm % dccc % xsz ( 1 ) tx ( i ) = rhs_xpencil ( i , j , k ) end do call fishpack_fft_1D ( ifwrd , LPx , tx , WX ) do i = 1 , dm % dccc % xsz ( 1 ) rhs_xpencil ( i , j , k ) = tx ( i ) !if(dabs(tx(i)) > 1.E+8) write(*,*) 'test1', tx(i) end do end do end do !----------------------------------------------------------- ! transfer data to z-pencil for z-FFT !----------------------------------------------------------- call transpose_x_to_y ( rhs_xpencil , rhs_ypencil , dm % dccc ) call transpose_y_to_z ( rhs_ypencil , rhs_zpencil , dm % dccc ) !----------------------------------------------------------- ! forward FFT in z direction !----------------------------------------------------------- ifwrd = 1 do i = 1 , dm % dccc % zsz ( 1 ) do j = 1 , dm % dccc % zsz ( 2 ) do k = 1 , dm % dccc % zsz ( 3 ) tz ( k ) = rhs_zpencil ( i , j , k ) end do call fishpack_fft_1D ( ifwrd , LPz , tz , WZ ) do k = 1 , dm % dccc % zsz ( 3 ) rhs_zpencil ( i , j , k ) = tz ( k ) !if(dabs(tz(k)) > 1.E+8) write(*,*) 'test2', tz(k) end do end do end do !write(*,'(A, I3, 1ES13.5)') ('test2', k, rhs_zpencil(16,32,k), k=1, dm%dccc%zsz(3)) !----------------------------------------------------------- ! transfer data to Y-pencil for Y-TDMA !----------------------------------------------------------- call transpose_z_to_y ( rhs_zpencil , rhs_ypencil , dm % dccc ) !----------------------------------------------------------- ! TMDA in the Y direction (stretching grids direction) !----------------------------------------------------------- !!write(*,*) 'fft-xzfft ', rhs_ypencil do i = 1 , dm % dccc % ysz ( 1 ) ii = dm % dccc % yst ( 1 ) + i - 1 do k = 1 , dm % dccc % ysz ( 3 ) kk = dm % dccc % yst ( 3 ) + k - 1 do j = 1 , dm % dccc % ysz ( 2 ) bb ( j ) = b ( j ) + xrt ( ii ) / ( dm % rci ( j ) * dm % rci ( j )) + zrt ( kk ) ty ( j ) = rhs_ypencil ( i , j , k ) !if(dabs(ty(j)) > 1.E+8) write(*,*) 'test31', ty(j), i, j, k end do call TRID0 ( dm % dccc % ysz ( 2 ), ty ) !a, bb, c, ty) do j = 1 , dm % dccc % ysz ( 2 ) rhs_ypencil ( i , j , k ) = ty ( j ) !if(dabs(ty(j)) > 1.E+8) write(*,*) 'test32', ty(j), i, j, k end do end do end do !write(*,*) 'fft-ytdma ', rhs_ypencil !write(*,'(A, I3, 1ES13.5)') ('test3', j, rhs_ypencil(16,j,8), j=1, dm%dccc%ysz(2)) !----------------------------------------------------------- ! transfer data to Z-pencil for backward z-FFT !----------------------------------------------------------- call transpose_y_to_z ( rhs_ypencil , rhs_zpencil , dm % dccc ) !----------------------------------------------------------- ! backward FFT in z direction !----------------------------------------------------------- ifwrd = 2 do i = 1 , dm % dccc % zsz ( 1 ) do j = 1 , dm % dccc % zsz ( 2 ) do k = 1 , dm % dccc % zsz ( 3 ) tz ( k ) = rhs_zpencil ( i , j , k ) end do call fishpack_fft_1D ( ifwrd , LPz , tz , WZ ) do k = 1 , dm % dccc % zsz ( 3 ) rhs_zpencil ( i , j , k ) = tz ( k ) !if(dabs(tz(k)) > 1.E+8) write(*,*) 'test4', tz(k) end do end do end do !write(*,'(A, I3, 1ES13.5)') ('test4', k, rhs_zpencil(16,32,k), k=1, dm%dccc%zsz(3)) !----------------------------------------------------------- ! transfer data to X-pencil for backward x-FFT !----------------------------------------------------------- call transpose_z_to_y ( rhs_zpencil , rhs_ypencil , dm % dccc ) call transpose_y_to_x ( rhs_ypencil , rhs_xpencil , dm % dccc ) !----------------------------------------------------------- ! backward FFT in x direction ! x - pencil !----------------------------------------------------------- ifwrd = 2 do j = 1 , dm % dccc % xsz ( 2 ) do k = 1 , dm % dccc % xsz ( 3 ) do i = 1 , dm % dccc % xsz ( 1 ) tx ( i ) = rhs_xpencil ( i , j , k ) end do call fishpack_fft_1D ( ifwrd , LPx , tx , WX ) do i = 1 , dm % dccc % xsz ( 1 ) rhs_xpencil ( i , j , k ) = tx ( i ) !if(dabs(tx(i)) > 1.E+8) write(*,*) 'test5', tx(i) end do end do end do !write(*,'(A, I3, 1ES13.5)') ('test5', i, rhs_xpencil(i,32,8), i=1, dm%dccc%xsz(1)) !----------------------------------------------------------- ! scale the result !----------------------------------------------------------- rhs_xpencil = rhs_xpencil / SCALX / SCALZ !WRITE(*,*)'fft-out',rhs_xpencil return end subroutine end module","tags":"","url":"sourcefile/poisson_fishpack.f90.html"},{"title":"chapsim.f90 – CHAPSim2","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !>                      CHAPSim version 2.0.0 !>                      -------------------------- !> This file is part of CHAPSim, a general-purpose CFD tool. !> !> This program is free software; you can redistribute it and/or modify it under !> the terms of the GNU General Public License as published by the Free Software !> Foundation; either version 3 of the License, or (at your option) any later !> version. !> !> This program is distributed in the hope that it will be useful, but WITHOUT !> ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS !> FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more !> details. !> !> You should have received a copy of the GNU General Public License along with !> this program; if not, write to the Free Software Foundation, Inc., 51 Franklin !> Street, Fifth Floor, Boston, MA 02110-1301, USA. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !========================================================================================================== !> \\file chapsim.f90 !> \\brief the main program. !> \\author Wei Wang, wei.wang@stfc.ac.uk !> \\date !========================================================================================================== program chapsim implicit none call initialise_chapsim call Solve_eqs_iteration call Finalise_chapsim end program !========================================================================================================== !> \\brief Initialisation and preprocessing of geometry, mesh and tools !> This subroutine is called at beginning of the main program !========================================================================================================== subroutine initialise_chapsim use apx_prerun_mod use boundary_conditions_mod use code_performance_mod use continuity_eq_mod use domain_decomposition_mod use io_files_mod use flow_thermo_initialiasation use geometry_mod use input_general_mod use mpi_mod use operations use poisson_interface_mod use solver_tools_mod use thermo_info_mod use io_visualisation_mod use eq_momentum_mod use wrt_debug_field_mod use mhd_mod implicit none integer :: i !---------------------------------------------------------------------------------------------------------- ! initialisation of mpi, nrank, nproc !---------------------------------------------------------------------------------------------------------- call create_directory call call_cpu_time ( CPU_TIME_CODE_START , 0 , 0 ) call initialise_mpi !---------------------------------------------------------------------------------------------------------- ! reading input parameters !---------------------------------------------------------------------------------------------------------- call Read_input_parameters !---------------------------------------------------------------------------------------------------------- ! build up geometry information, mesh size, grid spacing/spacing, stretching factor etc... !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain call Buildup_geometry_mesh_info ( domain ( i )) end do if ( nrank == 0 . and . is_prerun ) then call Print_debug_start_msg ( \"Pre-run for input variables adjustment\" ) call estimate_spacial_resolution ( flow ( 1 ), domain ( 1 )) call estimate_temporal_resolution ( flow ( 1 ), domain ( 1 )) stop 'Pre-run is completed.' end if !---------------------------------------------------------------------------------------------------------- ! build up operation coefficients for all x-subdomains !---------------------------------------------------------------------------------------------------------- call Prepare_LHS_coeffs_for_operations !---------------------------------------------------------------------------------------------------------- ! test all the operations. !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_ALGO call Test_algorithms () call Print_warning_msg ( \" === The solver will stop as per the user's request in <Test_algorithms> === \" ) stop 'End of Test_algorithms' #endif !---------------------------------------------------------------------------------------------------------- ! build up domain decomposition !---------------------------------------------------------------------------------------------------------- call Buildup_mpi_domain_decomposition !---------------------------------------------------------------------------------------------------------- ! build up fft basic info !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain call initialise_fft ( domain ( i )) end do !---------------------------------------------------------------------------------------------------------- ! build up thermo_mapping_relations, independent of any domains !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain if ( domain ( i )% is_thermo ) then call Buildup_thermo_mapping_relations ( thermo ( i )) exit end if end do !---------------------------------------------------------------------------------------------------------- ! build up boundary condition !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialising boundary conditions ...\" ) if ( domain ( i )% is_thermo ) then call Convert_thermal_input_2undim ( thermo ( i ), domain ( i )) call allocate_fbc_thermo ( domain ( i )) call initialise_fbc_thermo_given ( thermo ( i ), domain ( i )) end if call allocate_fbc_flow ( domain ( i )) call initialise_fbc_flow_given ( domain ( i )) if ( nrank == 0 ) call Print_debug_end_msg () end do !---------------------------------------------------------------------------------------------------------- ! initialise flow and thermo fields !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain call Allocate_flow_variables ( flow ( i ), domain ( i )) if ( domain ( i )% is_thermo ) then call Allocate_thermo_variables ( thermo ( i ), domain ( i )) call initialise_thermo_fields ( thermo ( i ), flow ( i ), domain ( i )) end if call initialise_flow_fields ( flow ( i ), domain ( i )) if ( domain ( i )% is_mhd ) then call initialise_mhd ( flow ( i ), mhd ( i ), domain ( i )) call compute_Lorentz_force ( flow ( i ), mhd ( i ), domain ( i )) end if !call Solve_momentum_eq(flow(i), domain(i), 0) call Check_element_mass_conservation ( flow ( i ), domain ( i ), 0 , opt_str = 'init-div-free' ) call write_visu_flow ( flow ( i ), domain ( i )) if ( domain ( i )% is_mhd ) call write_visu_mhd ( mhd ( i ), flow ( i ), domain ( i )) if ( domain ( i )% is_thermo ) call write_visu_thermo ( thermo ( i ), flow ( i ), domain ( i )) #ifdef DEBUG_STEPS if ( domain ( i )% is_thermo ) then call wrt_3d_pt_debug ( flow ( i )% gx , domain ( i )% dpcc , flow ( i )% iteration , 0 , 'gx@bf solv' ) ! debug_ww call wrt_3d_pt_debug ( flow ( i )% gy , domain ( i )% dcpc , flow ( i )% iteration , 0 , 'gy@bf solv' ) ! debug_ww call wrt_3d_pt_debug ( flow ( i )% gz , domain ( i )% dccp , flow ( i )% iteration , 0 , 'gz@bf solv' ) ! debug_ww end if call wrt_3d_pt_debug ( flow ( i )% qx , domain ( i )% dpcc , flow ( i )% iteration , 0 , 'qx@bf solv' ) ! debug_ww call wrt_3d_pt_debug ( flow ( i )% qy , domain ( i )% dcpc , flow ( i )% iteration , 0 , 'qy@bf solv' ) ! debug_ww call wrt_3d_pt_debug ( flow ( i )% qz , domain ( i )% dccp , flow ( i )% iteration , 0 , 'qz@bf solv' ) ! debug_ww call wrt_3d_pt_debug ( flow ( i )% pres , domain ( i )% dccc , flow ( i )% iteration , 0 , 'pr@bf solv' ) ! debug_ww !STOP  \"STOP after initialisation\" flow ( i )% nIterFlowEnd = 10 #endif end do !---------------------------------------------------------------------------------------------------------- ! update interface values for multiple domain !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain - 1 call update_fbc_2dm_flow_halo ( domain ( i ), flow ( i ), domain ( i + 1 ), flow ( i + 1 )) if ( domain ( i )% is_thermo ) call update_fbc_2dm_thermo_halo ( domain ( i ), thermo ( i ), domain ( i + 1 ), thermo ( i + 1 )) end do #ifdef DEBUG_STEPS !call test_poisson(domain(1)) ! debug_ww !call Print_warning_msg(\" === The solver will stop as per the user's request. === \") !stop #endif return end subroutine initialise_chapsim !========================================================================================================== !========================================================================================================== !> \\brief solve the governing equations in iteration !> !> This subroutine is the main solver. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     none          NA !> \\param[out]    none          NA !_______________________________________________________________________________ subroutine Solve_eqs_iteration !use iso_fortran_env use solver_tools_mod !,   only : Check_cfl_diffusion, Check_cfl_convection use continuity_eq_mod !use poisson_mod use eq_energy_mod use eq_momentum_mod use flow_thermo_initialiasation use code_performance_mod use thermo_info_mod use vars_df_mod use input_general_mod use mpi_mod use wtformat_mod use io_visualisation_mod use io_monitor_mod use io_tools_mod use io_restart_mod use statistics_mod use typeconvert_mod use boundary_conditions_mod use find_max_min_ave_mod use mhd_mod implicit none logical , allocatable :: is_flow (:) logical , allocatable :: is_thermo (:) integer :: i integer :: iter , isub integer :: iteration integer :: niter !========================================================================================================== ! flow advancing/marching iteration/time control !========================================================================================================== iteration = HUGE ( 0 ) niter = 0 do i = 1 , nxdomain if ( flow ( i )% iteration < iteration ) iteration = flow ( i )% iteration if ( flow ( i )% nIterFlowEnd > niter ) niter = flow ( i )% nIterFlowEnd if ( domain ( i )% is_thermo ) then if ( thermo ( i )% iteration < iteration ) iteration = thermo ( i )% iteration if ( thermo ( i )% nIterThermoEnd > niter ) niter = thermo ( i )% nIterThermoEnd end if call Check_cfl_diffusion ( flow ( i ), domain ( i )) end do allocate ( is_flow ( nxdomain )) allocate ( is_thermo ( nxdomain )) is_flow = . false . is_thermo = . false . call call_cpu_time ( CPU_TIME_STEP_START , iteration , niter ) if ( nrank == 0 ) call Print_debug_start_msg ( \"Solving the governing equations ...\" ) do iter = iteration + 1 , niter if ( mod ( iter , cpu_nfre ) == 0 ) call call_cpu_time ( CPU_TIME_ITER_START , iteration , niter , iter ) !========================================================================================================== ! Solver preparation for each domain !========================================================================================================== do i = 1 , nxdomain !---------------------------------------------------------------------------------------------------------- !      setting up 1/re, 1/re/prt, gravity, etc !---------------------------------------------------------------------------------------------------------- call Update_Re ( iter , flow ( i )) !---------------------------------------------------------------------------------------------------------- !     setting up thermo solver !---------------------------------------------------------------------------------------------------------- if ( domain ( i )% is_thermo ) then call Update_PrGr ( flow ( i ), thermo ( i )) if ( ( iter >= thermo ( i )% nIterThermoStart ) . and . ( iter <= thermo ( i )% nIterThermoEnd )) then is_thermo ( i ) = . true . if ( nrank == 0 ) write ( * , wrtfmt1e ) \"thermal field physical time (s) : \" , thermo ( i )% time thermo ( i )% time = thermo ( i )% time + domain ( i )% dt thermo ( i )% iteration = thermo ( i )% iteration + 1 call Check_cfl_diffusion ( flow ( i ), domain ( i )) end if end if !---------------------------------------------------------------------------------------------------------- !      setting up flow solver !---------------------------------------------------------------------------------------------------------- if ( ( iter >= flow ( i )% nIterFlowStart ) . and . ( iter <= flow ( i )% nIterFlowEnd )) then is_flow ( i ) = . true . if ( nrank == 0 ) write ( * , wrtfmt1e ) \"flow field physical time (s) : \" , flow ( i )% time flow ( i )% time = flow ( i )% time + domain ( i )% dt flow ( i )% iteration = flow ( i )% iteration + 1 call Check_cfl_convection ( flow ( i )% qx , flow ( i )% qy , flow ( i )% qz , domain ( i )) end if !---------------------------------------------------------------------------------------------------------- !  append and write out outlet data every real-iteration (not RK sub) !---------------------------------------------------------------------------------------------------------- if ( is_flow ( i ) . and . domain ( i )% is_record_xoutlet . and . iter >= domain ( i )% stat_istart ) then call write_instantaneous_xoutlet ( flow ( i ), domain ( i )) end if !---------------------------------------------------------------------------------------------------------- ! to read instantaneous inlet from database, real, not sub-RK !---------------------------------------------------------------------------------------------------------- if ( domain ( i )% is_read_xinlet ) call read_instantaneous_xinlet ( flow ( i ), domain ( i )) end do !========================================================================================================== !  main solver, domain coupling in each sub-iteration (check) !========================================================================================================== do isub = 1 , domain ( 1 )% nsubitr !---------------------------------------------------------------------------------------------------------- ! update interface values for multiple domain !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain - 1 if ( is_flow ( i )) call update_fbc_2dm_flow_halo ( domain ( i ), flow ( i ), domain ( i + 1 ), flow ( i + 1 )) if ( is_thermo ( i )) call update_fbc_2dm_thermo_halo ( domain ( i ), thermo ( i ), domain ( i + 1 ), thermo ( i + 1 )) end do do i = 1 , nxdomain if ( is_thermo ( i )) call Solve_energy_eq ( flow ( i ), thermo ( i ), domain ( i ), isub ) if ( domain ( i )% is_mhd ) call compute_Lorentz_force ( flow ( i ), mhd ( i ), domain ( i )) if ( is_flow ( i )) call Solve_momentum_eq ( flow ( i ), domain ( i ), isub ) end do #ifdef DEBUG_STEPS !call Print_warning_msg(\" === The solver will stop as per the user's request. === \") !stop #endif end do do i = 1 , nxdomain - 1 call update_fbc_2dm_flow_halo ( domain ( i ), flow ( i ), domain ( i + 1 ), flow ( i + 1 )) if ( domain ( i )% is_thermo ) call update_fbc_2dm_thermo_halo ( domain ( i ), thermo ( i ), domain ( i + 1 ), thermo ( i + 1 )) end do !========================================================================================================== ! result post-processing for each domain !========================================================================================================== do i = 1 , nxdomain !---------------------------------------------------------------------------------------------------------- !  validation for each time step !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) call Print_debug_mid_msg ( \"For domain id = \" // trim ( int2str ( i ))) if ( is_flow ( i )) then if ( is_thermo ( i )) then call Find_max_min_3d ( thermo ( i )% tTemp , \"T :\" , wrtfmt2ae ) call Find_max_min_3d ( thermo ( i )% rhoh , \"rhoh :\" , wrtfmt2ae ) end if call Find_max_min_3d ( flow ( i )% qx , \"qx :\" , wrtfmt2ae ) call Find_max_min_3d ( flow ( i )% qy , \"qy :\" , wrtfmt2ae ) call Find_max_min_3d ( flow ( i )% qz , \"qz :\" , wrtfmt2ae ) call Find_max_min_3d ( flow ( i )% pres , \"pr :\" , wrtfmt2ae ) call Find_max_min_3d ( flow ( i )% pcor , \"ph :\" , wrtfmt2ae ) call Check_element_mass_conservation ( flow ( i ), domain ( i ), iter ) end if !---------------------------------------------------------------------------------------------------------- !  update statistics !---------------------------------------------------------------------------------------------------------- if ( iter > domain ( i )% stat_istart . and . is_flow ( i )) then call update_statistics_flow ( flow ( i ), domain ( i )) end if if ( domain ( i )% is_thermo . and . is_thermo ( i )) then if ( iter > domain ( i )% stat_istart ) then call update_statistics_thermo ( thermo ( i ), domain ( i )) end if end if !---------------------------------------------------------------------------------------------------------- !  monitoring !---------------------------------------------------------------------------------------------------------- !if(domain(i)%icase == ICASE_TGV2D) call Validate_TGV2D_error (flow(i), domain(i)) if ((. not . domain ( i )% is_thermo ) . and . is_flow ( i )) then call write_monitor_bulk ( flow ( i ), domain ( i )) call write_monitor_probe ( flow ( i ), domain ( i )) end if if ( domain ( i )% is_thermo . and . is_thermo ( i )) then call write_monitor_bulk ( flow ( i ), domain ( i ), thermo ( i )) call write_monitor_probe ( flow ( i ), domain ( i ), thermo ( i )) end if !---------------------------------------------------------------------------------------------------------- !  write out check point data for restart !---------------------------------------------------------------------------------------------------------- if ( mod ( iter , domain ( i )% ckpt_nfre ) == 0 ) then if ( is_flow ( i )) then call write_instantaneous_flow ( flow ( i ), domain ( i )) if ( iter > domain ( i )% stat_istart ) call write_statistics_flow ( flow ( i ), domain ( i )) end if if ( domain ( i )% is_thermo . and . is_thermo ( i )) then call write_instantaneous_thermo ( thermo ( i ), domain ( i )) if ( iter > domain ( i )% stat_istart ) call write_statistics_thermo ( thermo ( i ), domain ( i )) end if end if !---------------------------------------------------------------------------------------------------------- ! write data for visualisation !---------------------------------------------------------------------------------------------------------- if ( MOD ( iter , domain ( i )% visu_nfre ) == 0 ) then if ( is_flow ( i )) call write_visu_flow ( flow ( i ), domain ( i )) if ( domain ( i )% is_mhd ) call write_visu_mhd ( mhd ( i ), flow ( i ), domain ( i )) if ( domain ( i )% is_thermo . and . is_thermo ( i )) then call write_visu_thermo ( thermo ( i ), flow ( i ), domain ( i )) end if if ( iter > domain ( i )% stat_istart ) then if ( is_flow ( i )) call write_visu_stats_flow ( flow ( i ), domain ( i )) if ( domain ( i )% is_thermo . and . is_thermo ( i )) then call write_visu_stats_thermo ( thermo ( i ), domain ( i )) end if end if end if end do ! domain if ( mod ( iter , cpu_nfre ) == 0 ) call call_cpu_time ( CPU_TIME_ITER_END , iteration , niter , iter ) end do ! iteration call call_cpu_time ( CPU_TIME_STEP_END , iteration , niter ) return end subroutine Solve_eqs_iteration subroutine Finalise_chapsim use mpi_mod use code_performance_mod implicit none call call_cpu_time ( CPU_TIME_CODE_END , 0 , 0 ) call Finalise_mpi () return end subroutine","tags":"","url":"sourcefile/chapsim.f90.html"},{"title":"bc_convective_outlet.f90 – CHAPSim2","text":"Source Code module bc_convective_outlet_mod use parameters_constant_mod use decomp_2d use udf_type_mod implicit none private :: get_convective_outlet_ux private :: calculate_fbcx_convective_outlet !public  :: update_flow_from_dyn_fbcx private :: enforce_domain_mass_balance_dyn_fbc !private :: enforce_domain_energy_balance_dyn_fbc !public  :: update_dyn_fbcx_from_flow public :: update_fbcx_convective_outlet_flow public :: update_fbcx_convective_outlet_thermo contains !========================================================================================================== subroutine get_convective_outlet_ux ( fl , dm , uxdx ) use wtformat_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl real ( WP ), intent ( out ) :: uxdx logical :: flg_bc_conv real ( WP ) :: uxmax , uxmin , uxmax_work , uxmin_work , uintf integer :: nn , k , j if (. not . dm % is_conv_outlet ) return uxmax = MINN uxmin = MAXP nn = dm % dpcc % xsz ( 1 ) - 1 do k = 1 , dm % dpcc % xsz ( 3 ) do j = 1 , dm % dpcc % xsz ( 2 ) uintf = fl % qx ( nn , j , k ) !( fl%qx(nn, j, k) + dm%fbcx_qx(2, j, k) ) * HALF ! at i=nc if ( fl % qx ( nn , j , k ) > uxmax ) uxmax = uintf if ( fl % qx ( nn , j , k ) < uxmin ) uxmin = uintf end do end do !write(*,*) 'outlet bc', fl%qx(nn, :, 2) call MPI_ALLREDUCE ( uxmax , uxmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) call MPI_ALLREDUCE ( uxmin , uxmin_work , 1 , MPI_REAL_WP , MPI_MIN , MPI_COMM_WORLD , ierror ) uxdx = HALF * ( uxmax_work + uxmin_work ) uxdx = uxdx * dm % h1r ( 1 ) #ifdef DEBUG_STEPS if ( nrank == 0 ) write ( * , '(10X, A, 3ES13.5, A, 1I5.1)' ) 'convective outlet uxmax, min, ave = ' , & uxmax_work , uxmin_work , HALF * ( uxmax_work + uxmin_work ), ' at iter(real) =' , fl % iteration #endif return end subroutine !========================================================================================================== subroutine calculate_fbcx_convective_outlet ( fbcx_var , uxdx , fbc_rhs0 , var , dtmp , dm , isub ) type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( 4 , dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: fbcx_var real ( WP ), dimension ( dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: fbc_rhs0 real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: var real ( WP ), intent ( in ) :: uxdx integer , intent ( in ) :: isub integer :: j , k , nn logical :: is_x real ( WP ) :: rhs_explicit_current , rhs_explicit_last , rhs_total if (. not . dm % is_conv_outlet ) return ! all based on x pencil ! dphi/dt + ux * dphi/dx = 0 ! data storage: ! ux = cell centre ! if ( dtmp % xsz ( 1 ) == dm % dpcc % xsz ( 1 )) then ! qx,  -----|-----|| !          qx     bc2/bc4 is_x = . true . nn = dm % dpcc % xsz ( 1 ) - 1 else ! any vars else, like v, w, phi, T, etc ! qy,  --x--|--x--||--x--| !       qy    qy  bc2 bc4 is_x = . false . nn = dm % dccc % xsz ( 1 ) end if do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) ! add explicit terms : convection rhs rhs_explicit_current = fbcx_var ( 4 , j , k ) - var ( nn , j , k ) ! at cell centre for ux, and bc point for otherse rhs_explicit_current = - rhs_explicit_current * uxdx rhs_explicit_last = fbc_rhs0 ( j , k ) rhs_total = ( dm % tGamma ( isub ) * rhs_explicit_current + & dm % tZeta ( isub ) * rhs_explicit_last ) * dm % dt fbc_rhs0 ( j , k ) = rhs_explicit_current ! calculate updated b.c. values fbcx_var ( 4 , j , k ) = fbcx_var ( 4 , j , k ) + rhs_total end do end do if ( is_x ) then ! ux, fbc = var(last point) do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) fbcx_var ( 2 , j , k ) = fbcx_var ( 4 , j , k ) var ( dm % dpcc % xsz ( 1 ), j , k ) = fbcx_var ( 2 , j , k ) end do end do else do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) fbcx_var ( 2 , j , k ) = ( fbcx_var ( 4 , j , k ) + var ( nn , j , k )) * HALF end do end do end if end subroutine !========================================================================================================== ! subroutine update_dyn_fbcx_from_flow(dm, ux, uy, uz, fbcx1, fbcx2, fbcx3) !   use print_msg_mod !   implicit none !   type(t_domain), intent(in) :: dm !   real(WP), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)), intent (in) :: ux !   real(WP), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)), intent (in) :: uy !   real(WP), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)), intent (in) :: uz !   real(WP), dimension(4,              dm%dpcc%xsz(2), dm%dpcc%xsz(3)), intent (inout) :: fbcx1 !   real(WP), dimension(4,              dm%dcpc%xsz(2), dm%dcpc%xsz(3)), intent (inout) :: fbcx2 !   real(WP), dimension(4,              dm%dccp%xsz(2), dm%dccp%xsz(3)), intent (inout) :: fbcx3 !   if( .not. dm%is_conv_outlet) return !   ! x - pencil !   if(dm%ibcx_nominal(2, 1) == IBC_CONVECTIVE) then !     !fbcx1(2, :, :) = ux(dm%dpcc%xsz(1), :, :) !     fbcx1(4, :, :) = fbcx1(2, :, :) !   end if !   if(dm%ibcx_nominal(2, 2) == IBC_CONVECTIVE) then !     fbcx2(4, :, :) = TWO * fbcx2(2, :, :) - uy(dm%dcpc%xsz(1), :, :) !   end if !   if(dm%ibcx_nominal(2, 3) == IBC_CONVECTIVE) then !     fbcx3(4, :, :) = TWO * fbcx3(2, :, :) - uz(dm%dccp%xsz(1), :, :) !   end if !   return ! end subroutine !========================================================================================================== ! subroutine update_flow_from_dyn_fbcx(dm, ux, uy, uz, fbcx1, fbcx2, fbcx3) !   use udf_type_mod !   use parameters_constant_mod !   use print_msg_mod !   implicit none !   type(t_domain), intent(in) :: dm !   real(WP), dimension(dm%dpcc%xsz(1), dm%dpcc%xsz(2), dm%dpcc%xsz(3)), intent (inout) :: ux !   real(WP), dimension(dm%dcpc%xsz(1), dm%dcpc%xsz(2), dm%dcpc%xsz(3)), intent (inout) :: uy !   real(WP), dimension(dm%dccp%xsz(1), dm%dccp%xsz(2), dm%dccp%xsz(3)), intent (inout) :: uz !   real(WP), dimension(4,              dm%dpcc%xsz(2), dm%dpcc%xsz(3)), intent (in)    :: fbcx1 !   real(WP), dimension(4,              dm%dcpc%xsz(2), dm%dcpc%xsz(3)), intent (in)    :: fbcx2 !   real(WP), dimension(4,              dm%dccp%xsz(2), dm%dccp%xsz(3)), intent (in)    :: fbcx3 !   if( .not. dm%is_conv_outlet) return !   ! x - pencil !   if(dm%ibcx_nominal(2, 1) == IBC_CONVECTIVE) then !     ux(dm%dpcc%xsz(1), :, :) = fbcx1(2, :, :) !   end if !   if(dm%ibcx_nominal(2, 2) == IBC_CONVECTIVE) then !     uy(dm%dcpc%xsz(1), :, :) = TWO * fbcx2(2, :, :) - fbcx2(4, :, :) !   end if !   if(dm%ibcx_nominal(2, 3) == IBC_CONVECTIVE) then !     uz(dm%dccp%xsz(1), :, :) =  TWO * fbcx3(2, :, :) - fbcx3(4, :, :) !   end if !   return ! end subroutine !========================================================================================================== subroutine enforce_domain_mass_balance_dyn_fbc ( fl , dm ) use wtformat_mod use bc_dirichlet_mod use find_max_min_ave_mod use cylindrical_rn_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( inout ) :: dm type ( DECOMP_INFO ) :: dtmp real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: fbcx real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) :: fbcy real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz real ( WP ) :: scale real ( WP ) :: fbcm_x ( 2 ), fbcm_y ( 2 ), fbcm_z ( 2 ) real ( WP ) :: bulkm logical :: iconv ( 3 ) real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc_xpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil ! only 1 direction could be convective outlet if (. not . dm % is_conv_outlet ) return if ( dm % is_thermo ) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccc , fl % drhodt , bulkm , SPACE_INTEGRAL , 'drhodt' ) else bulkm = ZERO end if iconv = . false . fbcm_x = ZERO fbcm_y = ZERO fbcm_z = ZERO !---------------------------------------------------------------------------------------------------------- ! x - inlet/outlet, ux = qx !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) then iconv ( 1 ) = . true . if ( dm % is_thermo ) then fbcx = dm % fbcx_gx else fbcx = dm % fbcx_qx end if call Get_area_average_2d_for_fbcx ( dm , dm % dpcc , fbcx , fbcm_x , SPACE_INTEGRAL , 'fbcx' ) else if ( dm % ibcy_nominal ( 2 , 2 ) == IBC_CONVECTIVE ) then !---------------------------------------------------------------------------------------------------------- ! y - inlet/outlet - uy = qr / r !---------------------------------------------------------------------------------------------------------- iconv ( 2 ) = . true . ! if(dm%icase == ICASE_PIPE) then !   if(dm%is_thermo) then !     acpc_xpencil = fl%gy !   else !     acpc_xpencil = fl%qy !   end if !   call transpose_x_to_y(acpc_xpencil, acpc_ypencil, dm%dcpc) !   call multiple_cylindrical_rn(acpc_ypencil, dm%dcpc, dm%rpi, 1, IPENCIL(2)) ! qr/r !   call axis_estimating_radial_xpx(acpc_ypencil, dm%dcpc, IPENCIL(2), dm, IDIM(2), is_reversed = .true.) !   call extract_dirichlet_fbcy(fbcy, acpc_ypencil, dm%dcpc, dm, is_reversed = .true.) ! else !   if(dm%is_thermo) then !     fbcy = dm%fbcy_gy !   else !     fbcy = dm%fbcy_qy !   end if !   if(dm%icoordinate == ICYLINDRICAL) then !     call multiple_cylindrical_rn_x4x(fbcy, dm%dcpc, dm%rpi, 1, IPENCIL(2)) !   end if ! end if if ( dm % icoordinate == ICYLINDRICAL ) then fbcy = dm % fbcy_qyr else fbcy = dm % fbcy_qy end if call Get_area_average_2d_for_fbcy ( dm , dm % dcpc , fbcy , fbcm_y , SPACE_INTEGRAL , 'fbcy' ) else if ( dm % ibcz_nominal ( 2 , 3 ) == IBC_CONVECTIVE ) then iconv ( 3 ) = . true . !---------------------------------------------------------------------------------------------------------- ! z - inlet/outlet - qz = u_theta !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then fbcz = dm % fbcz_gz else fbcz = dm % fbcz_qz end if ! if(dm%icoordinate == ICYLINDRICAL) then !   call multiple_cylindrical_rn_xx4(fbcz, dm%dccp, dm%rci, 1, IPENCIL(3)) ! end if call Get_area_average_2d_for_fbcz ( dm , dm % dccp , fbcz , fbcm_z , SPACE_INTEGRAL , 'fbcz' ) end if !---------------------------------------------------------------------------------------------------------- ! scaling factor for a mass conservation ! fbcm_x(1) - scaling * fbcm_x(2) + bulkm = 0 ! scale the dynamic bc !---------------------------------------------------------------------------------------------------------- if ( iconv ( 1 )) then scale = ( fbcm_x ( 1 ) + bulkm ) / fbcm_x ( 2 ) fbcx ( 2 , :, :) = fbcx ( 2 , :, :) * scale fbcx ( 4 , :, :) = fbcx ( 2 , :, :) else if ( iconv ( 2 )) then scale = ( fbcm_y ( 1 ) + bulkm ) / fbcm_y ( 2 ) fbcy (:, 2 , :) = fbcy (:, 2 , :) * scale fbcy (:, 4 , :) = fbcy (:, 2 , :) else if ( iconv ( 3 )) then scale = ( fbcm_z ( 1 ) + bulkm ) / fbcm_z ( 2 ) fbcz (:, :, 2 ) = fbcz (:, :, 2 ) * scale fbcz (:, :, 4 ) = fbcz (:, :, 2 ) else end if !---------------------------------------------------------------------------------------------------------- ! back to real fbc !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then if ( dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) dm % fbcx_gx ( 2 , :, :) = fbcx ( 2 , :, :) if ( dm % ibcy_nominal ( 2 , 2 ) == IBC_CONVECTIVE ) dm % fbcy_gy ( 2 , :, :) = fbcy ( 2 , :, :) if ( dm % ibcz_nominal ( 2 , 3 ) == IBC_CONVECTIVE ) dm % fbcz_gz ( 2 , :, :) = fbcz ( 2 , :, :) if ( dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) dm % fbcx_qx ( 2 , :, :) = dm % fbcx_gx ( 2 , :, :) / dm % fbcx_ftp ( 2 , :, :)% d if ( dm % ibcy_nominal ( 2 , 2 ) == IBC_CONVECTIVE ) dm % fbcy_qy ( 2 , :, :) = dm % fbcy_gy ( 2 , :, :) / dm % fbcy_ftp ( 2 , :, :)% d if ( dm % ibcz_nominal ( 2 , 3 ) == IBC_CONVECTIVE ) dm % fbcz_qz ( 2 , :, :) = dm % fbcz_gz ( 2 , :, :) / dm % fbcz_ftp ( 2 , :, :)% d !call update_flow_from_dyn_fbcx(dm, fl%gx, fl%gy, fl%gz, dm%fbcx_gx, dm%fbcx_gy, dm%fbcx_gz) else if ( dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) dm % fbcx_qx ( 2 , :, :) = fbcx ( 2 , :, :) if ( dm % ibcy_nominal ( 2 , 2 ) == IBC_CONVECTIVE ) dm % fbcy_qy ( 2 , :, :) = fbcy ( 2 , :, :) if ( dm % ibcz_nominal ( 2 , 3 ) == IBC_CONVECTIVE ) dm % fbcz_qz ( 2 , :, :) = fbcz ( 2 , :, :) end if !call update_flow_from_dyn_fbcx(dm, fl%qx, fl%qy, fl%qz, dm%fbcx_qx, dm%fbcx_qy, dm%fbcx_qz) #ifdef DEBUG_STEPS if ( nrank == 0 ) then write ( * , * ) \"m_in, m_out, m_bulk, m_net, scale\" if ( iconv ( 1 )) & write ( * , '(10X, A, 4ES13.5, 1F16.13)' ) 'x: ' , fbcm_x ( 1 ), fbcm_x ( 2 ), bulkm , fbcm_x ( 1 ) - fbcm_x ( 2 ) + bulkm , scale if ( iconv ( 2 )) & write ( * , '(10X, A, 4ES13.5, 1F16.13)' ) 'y: ' , fbcm_y ( 1 ), fbcm_y ( 2 ), bulkm , fbcm_y ( 1 ) - fbcm_y ( 2 ) + bulkm , scale if ( iconv ( 3 )) & write ( * , '(10X, A, 4ES13.5, 1F16.13)' ) 'z: ' , fbcm_z ( 1 ), fbcm_z ( 2 ), bulkm , fbcm_z ( 1 ) - fbcm_z ( 2 ) + bulkm , scale end if #endif return end subroutine enforce_domain_mass_balance_dyn_fbc !========================================================================================================== subroutine update_fbcx_convective_outlet_flow ( fl , dm , isub ) use bc_dirichlet_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_domain ), intent ( inout ) :: dm integer , intent ( in ) :: isub real ( WP ) :: uxdx integer :: i if (. not . dm % is_conv_outlet ) return #ifdef DEBUG_STEPS if ( nrank == 0 ) call Print_debug_inline_msg ( \"Calculate convective outlet for flow ...\" ) #endif ! work on fbcx, not fl directly call get_convective_outlet_ux ( fl , dm , uxdx ) if ( . not . dm % is_thermo ) then if ( dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) then call calculate_fbcx_convective_outlet ( dm % fbcx_qx (:, :, :), uxdx , fl % fbcx_qx_rhs0 (:, :), fl % qx , dm % dpcc , dm , isub ) end if if ( dm % ibcx_nominal ( 2 , 2 ) == IBC_CONVECTIVE ) then call calculate_fbcx_convective_outlet ( dm % fbcx_qy (:, :, :), uxdx , fl % fbcx_qy_rhs0 (:, :), fl % qy , dm % dcpc , dm , isub ) end if if ( dm % ibcx_nominal ( 2 , 3 ) == IBC_CONVECTIVE ) then call calculate_fbcx_convective_outlet ( dm % fbcx_qz (:, :, :), uxdx , fl % fbcx_qz_rhs0 (:, :), fl % qz , dm % dccp , dm , isub ) end if else ! todo-check , whether it is better to use qx = gx / density ? if ( dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) then call calculate_fbcx_convective_outlet ( dm % fbcx_qx (:, :, :), uxdx , fl % fbcx_qx_rhs0 (:, :), fl % qx , dm % dpcc , dm , isub ) call calculate_fbcx_convective_outlet ( dm % fbcx_gx (:, :, :), uxdx , fl % fbcx_gx_rhs0 (:, :), fl % gx , dm % dpcc , dm , isub ) end if if ( dm % ibcx_nominal ( 2 , 2 ) == IBC_CONVECTIVE ) then call calculate_fbcx_convective_outlet ( dm % fbcx_qy (:, :, :), uxdx , fl % fbcx_qy_rhs0 (:, :), fl % qy , dm % dcpc , dm , isub ) call calculate_fbcx_convective_outlet ( dm % fbcx_gy (:, :, :), uxdx , fl % fbcx_gy_rhs0 (:, :), fl % gy , dm % dcpc , dm , isub ) end if if ( dm % ibcx_nominal ( 2 , 3 ) == IBC_CONVECTIVE ) then call calculate_fbcx_convective_outlet ( dm % fbcx_qz (:, :, :), uxdx , fl % fbcx_qz_rhs0 (:, :), fl % qz , dm % dccp , dm , isub ) call calculate_fbcx_convective_outlet ( dm % fbcx_gz (:, :, :), uxdx , fl % fbcx_gz_rhs0 (:, :), fl % gz , dm % dccp , dm , isub ) end if end if call enforce_domain_mass_balance_dyn_fbc ( fl , dm ) if ( . not . dm % is_thermo ) then call enforce_velo_from_fbc ( dm , fl % qx , fl % qy , fl % qz , dm % fbcx_qx , dm % fbcy_qy , dm % fbcz_qz ) else ! todo-check , whether it is better to use qx = gx / density ? call enforce_velo_from_fbc ( dm , fl % qx , fl % qy , fl % qz , dm % fbcx_qx , dm % fbcy_qy , dm % fbcz_qz ) call enforce_velo_from_fbc ( dm , fl % gx , fl % gy , fl % gz , dm % fbcx_gx , dm % fbcy_gy , dm % fbcz_gz ) end if return end subroutine !========================================================================================================== subroutine update_fbcx_convective_outlet_thermo ( fl , tm , dm , isub ) use thermo_info_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm type ( t_domain ), intent ( inout ) :: dm integer , intent ( in ) :: isub real ( WP ) :: uxdx integer :: j , k real ( WP ), dimension ( 4 , dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) :: a4cc_xpencil if ( . not . dm % is_thermo ) return if ( . not . dm % is_conv_outlet ) return #ifdef DEBUG_STEPS if ( nrank == 0 ) call Print_debug_inline_msg ( \"Calculate convective outlet for thermo ...\" ) #endif call get_convective_outlet_ux ( fl , dm , uxdx ) if ( dm % ibcx_nominal ( 2 , 5 ) == IBC_CONVECTIVE ) then a4cc_xpencil = dm % fbcx_ftp (:, :, :)% rhoh call calculate_fbcx_convective_outlet ( a4cc_xpencil , uxdx , tm % fbcx_rhoh_rhs0 (:, :), tm % rhoh , dm % dccc , dm , isub ) dm % fbcx_ftp (:, :, :)% rhoh = a4cc_xpencil do j = 1 , size ( dm % fbcx_ftp , 2 ) do k = 1 , size ( dm % fbcx_ftp , 3 ) call ftp_refresh_thermal_properties_from_DH ( dm % fbcx_ftp ( 2 , j , k )) call ftp_refresh_thermal_properties_from_DH ( dm % fbcx_ftp ( 4 , j , k )) end do end do end if !call enforce_domain_energy_balance_dyn_fbc(fl, dm) ! todo-check necessary? return end subroutine end module","tags":"","url":"sourcefile/bc_convective_outlet.f90.html"},{"title":"io_restart.f90 – CHAPSim2","text":"Source Code module io_restart_mod use print_msg_mod use parameters_constant_mod use decomp_2d_io use udf_type_mod use io_files_mod use io_tools_mod implicit none character ( len = 10 ), parameter :: io_name = \"restart-io\" private :: write_instantaneous_array public :: write_instantaneous_flow public :: write_instantaneous_thermo private :: read_instantaneous_array public :: read_instantaneous_flow public :: read_instantaneous_thermo public :: restore_flow_variables_from_restart public :: restore_thermo_variables_from_restart private :: append_instantaneous_xoutlet private :: write_instantaneous_plane public :: write_instantaneous_xoutlet private :: assign_instantaneous_xinlet private :: read_instantaneous_plane public :: read_instantaneous_xinlet contains !========================================================================================================== !========================================================================================================== subroutine read_instantaneous_array ( var , keyword , idom , iter , dtmp ) implicit none integer , intent ( in ) :: idom character ( * ), intent ( in ) :: keyword integer , intent ( in ) :: iter type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), dimension (:, :, :), intent ( out ) :: var ( dtmp % xsz ( 1 ), & dtmp % xsz ( 2 ), & dtmp % xsz ( 3 )) character ( 120 ) :: data_flname call generate_file_name ( data_flname , idom , trim ( keyword ), 'bin' , iter ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"Reading \" // trim ( dir_data ) // \"/\" // trim ( data_flname )) call decomp_2d_read_one ( IPENCIL ( 1 ), var , trim ( data_flname ), & opt_dirname = trim ( dir_data ), & opt_decomp = dtmp , & opt_reduce_prec = . false .) return end subroutine !========================================================================================================== !========================================================================================================== subroutine write_instantaneous_array ( var , keyword , idom , iter , dtmp ) implicit none real ( WP ), contiguous , intent ( in ) :: var ( :, :, :) type ( DECOMP_INFO ), intent ( in ) :: dtmp character ( * ), intent ( in ) :: keyword integer , intent ( in ) :: idom integer , intent ( in ) :: iter character ( 120 ) :: data_flname_path call generate_pathfile_name ( data_flname_path , idom , trim ( keyword ), dir_data , 'bin' , iter ) call decomp_2d_write_one ( IPENCIL ( 1 ), var , trim ( data_flname_path ), opt_decomp = dtmp ) return end subroutine !========================================================================================================== !========================================================================================================== subroutine write_instantaneous_flow ( fl , dm ) implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl character ( 120 ) :: data_flname_path character ( 120 ) :: keyword if ( nrank == 0 ) call Print_debug_inline_msg ( \"writing out instantaneous 3d flow data ...\" ) call write_instantaneous_array ( fl % qx , 'qx' , dm % idom , fl % iteration , dm % dpcc ) call write_instantaneous_array ( fl % qy , 'qy' , dm % idom , fl % iteration , dm % dcpc ) call write_instantaneous_array ( fl % qz , 'qz' , dm % idom , fl % iteration , dm % dccp ) call write_instantaneous_array ( fl % pres , 'pr' , dm % idom , fl % iteration , dm % dccc ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine write_instantaneous_thermo ( tm , dm ) use thermo_info_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( in ) :: tm character ( 120 ) :: data_flname_path character ( 120 ) :: keyword if ( nrank == 0 ) call Print_debug_inline_msg ( \"writing out instantaneous 3d thermo data ...\" ) call write_instantaneous_array ( tm % rhoh , 'rhoh' , dm % idom , tm % iteration , dm % dccc ) call write_instantaneous_array ( tm % tTemp , 'temp' , dm % idom , tm % iteration , dm % dccc ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine read_instantaneous_flow ( fl , dm ) implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl character ( 120 ) :: data_flname character ( 120 ) :: keyword if ( nrank == 0 ) call Print_debug_inline_msg ( \"read instantaneous flow data ...\" ) call read_instantaneous_array ( fl % qx , 'qx' , dm % idom , fl % iterfrom , dm % dpcc ) call read_instantaneous_array ( fl % qy , 'qy' , dm % idom , fl % iterfrom , dm % dcpc ) call read_instantaneous_array ( fl % qz , 'qz' , dm % idom , fl % iterfrom , dm % dccp ) call read_instantaneous_array ( fl % pres , 'pr' , dm % idom , fl % iterfrom , dm % dccc ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine restore_flow_variables_from_restart ( fl , dm ) use mpi_mod use boundary_conditions_mod use solver_tools_mod use wtformat_mod use find_max_min_ave_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl real ( WP ) :: ubulk !call Get_volumetric_average_3d(.false., dm%ibcy_qx(:), dm%fbcy_qx(:, :, :), dm, dm%dpcc, fl%qx, ubulk, \"ux\") call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , fl % qx , ubulk , SPACE_AVERAGE , \"ux\" ) if ( nrank == 0 ) then call Print_debug_inline_msg ( \"The restarted mass flux is:\" ) write ( * , wrtfmt1e ) ' average[u(x,y,z)]_[x,y,z]: ' , ubulk end if !---------------------------------------------------------------------------------------------------------- ! to check maximum velocity !---------------------------------------------------------------------------------------------------------- call Find_max_min_3d ( fl % qx , \"qx: \" , wrtfmt2ae ) call Find_max_min_3d ( fl % qy , \"qy: \" , wrtfmt2ae ) call Find_max_min_3d ( fl % qz , \"qz: \" , wrtfmt2ae ) !---------------------------------------------------------------------------------------------------------- ! to set up other parameters for flow only, which will be updated in thermo flow. !---------------------------------------------------------------------------------------------------------- fl % pcor (:, :, :) = ZERO fl % pcor_zpencil_ggg (:, :, :) = ZERO if ( dm % is_thermo ) then fl % dDens (:, :, :) = ONE fl % mVisc (:, :, :) = ONE fl % dDensm1 (:, :, :) = ONE fl % dDensm2 (:, :, :) = ONE end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine read_instantaneous_thermo ( tm , dm ) use thermo_info_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_thermo ), intent ( inout ) :: tm character ( 120 ) :: data_flname character ( 120 ) :: keyword if (. not . dm % is_thermo ) return if ( nrank == 0 ) call Print_debug_inline_msg ( \"read instantaneous thermo data ...\" ) tm % iteration = tm % iterfrom keyword = 'rhoh' call generate_file_name ( data_flname , dm % idom , keyword , 'bin' , tm % iteration ) call decomp_2d_read_one ( IPENCIL ( 1 ), tm % rhoh , trim ( data_flname ), & opt_dirname = trim ( dir_data ), & opt_decomp = dm % dccc , & opt_reduce_prec = . false .) keyword = 'temp' call generate_file_name ( data_flname , dm % idom , keyword , 'bin' , tm % iteration ) call decomp_2d_read_one ( IPENCIL ( 1 ), tm % tTemp , trim ( data_flname ), & opt_dirname = trim ( dir_data ), & opt_decomp = dm % dccc , & opt_reduce_prec = . false .) tm % time = real ( tm % iterfrom , WP ) * dm % dt if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== subroutine restore_thermo_variables_from_restart ( fl , tm , dm ) use udf_type_mod use thermo_info_mod use eq_energy_mod use solver_tools_mod use convert_primary_conservative_mod type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm if (. not . dm % is_thermo ) return call Update_thermal_properties ( fl , tm , dm ) call convert_primary_conservative ( fl , dm , IQ2G ) fl % dDensm1 (:, :, :) = fl % dDens (:, :, :) fl % dDensm2 (:, :, :) = fl % dDens (:, :, :) return end subroutine !========================================================================================================== subroutine append_instantaneous_xoutlet ( fl , dm ) implicit none type ( t_flow ), intent ( in ) :: fl type ( t_domain ), intent ( inout ) :: dm integer :: niter , j , k type ( DECOMP_INFO ) :: dtmp ! based on x pencil if (. not . dm % is_record_xoutlet ) return ! if dm%ndbfre = 10 ! store : file_10, store  1,  2, ..., 10 !         file_20, store 11, 12, ..., 20 niter = mod ( fl % iteration , dm % ndbfre ) ! if ( niter == 0 ) niter = dm % ndbfre dtmp = dm % dpcc do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_qx_outl1 ( niter , j , k ) = fl % qx ( dtmp % xsz ( 1 ), j , k ) dm % fbcx_qx_outl2 ( niter , j , k ) = fl % qx ( dtmp % xsz ( 1 ) - 1 , j , k ) end do end do !write(*, *) 'j, fl%qx(1, j, 1), dm%fbcx_qx_outl1(niter, j, 1)' ! do j = 1, dm%dpcc%xsz(2) !   write(*, *) j, fl%qx(dtmp%xsz(1), j, 1), dm%fbcx_qx_outl1(niter, j, 1) ! end do dtmp = dm % dcpc do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_qy_outl1 ( niter , j , k ) = fl % qy ( dtmp % xsz ( 1 ), j , k ) dm % fbcx_qy_outl2 ( niter , j , k ) = fl % qy ( dtmp % xsz ( 1 ) - 1 , j , k ) end do end do dtmp = dm % dccp do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_qz_outl1 ( niter , j , k ) = fl % qz ( dtmp % xsz ( 1 ), j , k ) dm % fbcx_qz_outl2 ( niter , j , k ) = fl % qz ( dtmp % xsz ( 1 ) - 1 , j , k ) end do end do dtmp = dm % dccc do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_pr_outl1 ( niter , j , k ) = fl % pres ( dtmp % xsz ( 1 ), j , k ) dm % fbcx_pr_outl2 ( niter , j , k ) = fl % pres ( dtmp % xsz ( 1 ) - 1 , j , k ) end do end do return end subroutine !========================================================================================================== subroutine write_instantaneous_plane ( var , keyword , idom , iter , niter , dtmp ) implicit none real ( WP ), contiguous , intent ( in ) :: var ( :, :, :) type ( DECOMP_INFO ), intent ( in ) :: dtmp character ( * ), intent ( in ) :: keyword integer , intent ( in ) :: idom integer , intent ( in ) :: iter , niter character ( 120 ) :: data_flname_path call generate_pathfile_name ( data_flname_path , idom , trim ( keyword ), dir_data , 'bin' , iter ) if ( nrank == 0 ) write ( * , * ) 'Write outlet plane data to [' // trim ( data_flname_path ) // \"]\" !call decomp_2d_open_io (io_in2outlet, trim(data_flname_path), decomp_2d_write_mode) !call decomp_2d_start_io(io_in2outlet, trim(data_flname_path))! !call decomp_2d_write_outflow(trim(data_flname_path), trim(keyword), niter, var, io_in2outlet, dtmp) !call decomp_2d_write_plane(IPENCIL(1), var, 1, dtmp%xsz(1), trim(data_flname_path), dtmp) call decomp_2d_write_plane ( IPENCIL ( 1 ), var , data_flname_path , & opt_nplanes = niter , & opt_decomp = dtmp ) !call decomp_2d_end_io(io_in2outlet, trim(data_flname_path)) !call decomp_2d_close_io(io_in2outlet, trim(data_flname_path)) return end subroutine !========================================================================================================== subroutine write_instantaneous_xoutlet ( fl , dm ) implicit none type ( t_flow ), intent ( in ) :: fl type ( t_domain ), intent ( inout ) :: dm character ( 120 ) :: data_flname_path integer :: idom , niter , iter , j if (. not . dm % is_record_xoutlet ) return call append_instantaneous_xoutlet ( fl , dm ) if ( mod ( fl % iteration , dm % ndbfre ) /= 0 ) return niter = fl % iteration call write_instantaneous_plane ( dm % fbcx_qx_outl1 , 'outlet1_qx' , dm % idom , niter , dm % ndbfre , dm % dxcc ) call write_instantaneous_plane ( dm % fbcx_qx_outl2 , 'outlet2_qx' , dm % idom , niter , dm % ndbfre , dm % dxcc ) call write_instantaneous_plane ( dm % fbcx_qy_outl1 , 'outlet1_qy' , dm % idom , niter , dm % ndbfre , dm % dxpc ) call write_instantaneous_plane ( dm % fbcx_qy_outl2 , 'outlet2_qy' , dm % idom , niter , dm % ndbfre , dm % dxpc ) call write_instantaneous_plane ( dm % fbcx_qz_outl1 , 'outlet1_qz' , dm % idom , niter , dm % ndbfre , dm % dxcp ) call write_instantaneous_plane ( dm % fbcx_qz_outl2 , 'outlet2_qz' , dm % idom , niter , dm % ndbfre , dm % dxcp ) call write_instantaneous_plane ( dm % fbcx_pr_outl1 , 'outlet1_pr' , dm % idom , niter , dm % ndbfre , dm % dxcc ) call write_instantaneous_plane ( dm % fbcx_pr_outl2 , 'outlet2_pr' , dm % idom , niter , dm % ndbfre , dm % dxcc ) ! #ifdef DEBUG_STEPS !     write(*,*) 'outlet bc' !     do j = 1, dm%dpcc%xsz(2) !       write(*,*) dm%dpcc%xst(2) + j - 1, & !       dm%fbcx_qx_outl1(niter, j, 1), dm%fbcx_qx_outl2(niter, j, 1) !     end do !     call read_instantaneous_plane(dm%fbcx_qx_out1, 'outlet1_qx', dm%idom, niter, dm%ndbfre, dm%dxcc) !     call read_instantaneous_plane(dm%fbcx_qx_out2, 'outlet2_qx', dm%idom, niter, dm%ndbfre, dm%dxcc) !     call read_instantaneous_plane(dm%fbcx_qy_out1, 'outlet1_qy', dm%idom, niter, dm%ndbfre, dm%dxpc) !     call read_instantaneous_plane(dm%fbcx_qy_out2, 'outlet2_qy', dm%idom, niter, dm%ndbfre, dm%dxpc) !     call read_instantaneous_plane(dm%fbcx_qz_out1, 'outlet1_qz', dm%idom, niter, dm%ndbfre, dm%dxcp) !     call read_instantaneous_plane(dm%fbcx_qz_out2, 'outlet2_qz', dm%idom, niter, dm%ndbfre, dm%dxcp) !     call read_instantaneous_plane(dm%fbcx_pr_out1, 'outlet1_pr', dm%idom, niter, dm%ndbfre, dm%dxcc) !     call read_instantaneous_plane(dm%fbcx_pr_out2, 'outlet2_pr', dm%idom, niter, dm%ndbfre, dm%dxcc) !     write(*,*) 'inlet bc' !     do j = 1, dm%dpcc%xsz(2) !       write(*,*) dm%dpcc%xst(2) + j - 1, & !       dm%fbcx_qx_out1(niter, j, 1), dm%fbcx_qx_out2(niter, j, 1) !     end do ! #endif return end subroutine !========================================================================================================== subroutine assign_instantaneous_xinlet ( fl , dm ) implicit none type ( t_flow ), intent ( in ) :: fl type ( t_domain ), intent ( inout ) :: dm integer :: iter , j , k type ( DECOMP_INFO ) :: dtmp ! based on x pencil if (. not . dm % is_read_xinlet ) return if ( fl % iteration > dm % ndbend ) then iter = mod ( fl % iteration , dm % ndbend ) ! database recycle else if ( fl % iteration == 0 ) then iter = 1 else iter = fl % iteration end if iter = mod ( iter , dm % ndbfre ) if ( iter == 0 ) iter = dm % ndbfre if ( dm % ibcx_nominal ( 1 , 1 ) == IBC_DATABASE ) then dtmp = dm % dpcc do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_qx ( 1 , j , k ) = dm % fbcx_qx_inl1 ( iter , j , k ) dm % fbcx_qx ( 3 , j , k ) = dm % fbcx_qx_inl2 ( iter , j , k ) ! check, below !fl%qx(1, j, k) = dm%fbcx_qx(1, j, k) end do end do !if(nrank == 0) write(*,*) 'fbcx_qx = ', iter, dm%fbcx_qx(1, :, :) end if ! test !write(*,*) 'j, fl%qx(1, j, 1), dm%fbcx_qx(1, j, 1)' !do j = 1, dm%dpcc%xsz(2) !write(*,*) j, fl%qx(1, j, 1), dm%fbcx_qx(1, j, 1) !end do if ( dm % ibcx_nominal ( 1 , 2 ) == IBC_DATABASE ) then dtmp = dm % dcpc do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_qy ( 1 , j , k ) = dm % fbcx_qy_inl1 ( iter , j , k ) dm % fbcx_qy ( 3 , j , k ) = dm % fbcx_qy_inl2 ( iter , j , k ) end do end do !if(nrank == 0) write(*,*) 'fbcx_qy = ', iter, dm%fbcx_qy(1, :, :) end if if ( dm % ibcx_nominal ( 1 , 3 ) == IBC_DATABASE ) then dtmp = dm % dccp do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_qz ( 1 , j , k ) = dm % fbcx_qz_inl1 ( iter , j , k ) dm % fbcx_qz ( 3 , j , k ) = dm % fbcx_qz_inl2 ( iter , j , k ) end do end do !if(nrank == 0) write(*,*) 'fbcx_qz = ', iter, dm%fbcx_qz(1, :, :) end if if ( dm % ibcx_nominal ( 1 , 4 ) == IBC_DATABASE ) then dtmp = dm % dccc do j = 1 , dtmp % xsz ( 2 ) do k = 1 , dtmp % xsz ( 3 ) dm % fbcx_pr ( 1 , j , k ) = dm % fbcx_pr_inl1 ( iter , j , k ) dm % fbcx_pr ( 3 , j , k ) = dm % fbcx_pr_inl2 ( iter , j , k ) end do end do !if(nrank == 0) write(*,*) 'fbcx_pr = ', iter, dm%fbcx_pr(1, :, :) end if return end subroutine !========================================================================================================== subroutine read_instantaneous_plane ( var , keyword , idom , iter , nfre , dtmp ) use decomp_2d_io implicit none real ( WP ), contiguous , intent ( out ) :: var ( :, :, :) type ( DECOMP_INFO ), intent ( in ) :: dtmp character ( * ), intent ( in ) :: keyword integer , intent ( in ) :: idom integer , intent ( in ) :: iter integer , intent ( in ) :: nfre character ( 120 ) :: data_flname_path , flname call generate_pathfile_name ( data_flname_path , idom , trim ( keyword ), dir_data , 'bin' , iter , flname ) !call decomp_2d_open_io (io_in2outlet, trim(data_flname_path), decomp_2d_read_mode) if ( nrank == 0 ) call Print_debug_inline_msg ( \"Read data on a plane from file: \" // trim ( data_flname_path )) !call decomp_2d_read_inflow(trim(data_flname_path), trim(keyword), nfre, var, io_in2outlet, dtmp) call decomp_2d_read_plane ( IPENCIL ( 1 ), var , data_flname_path , nfre , & opt_decomp = dtmp ) !decomp_2d_read_plane(ipencil, var, varname, nplanes, & !  opt_dirname, & !  opt_mpi_file_open_info, & !  opt_mpi_file_set_view_info, & !  opt_reduce_prec, & !  opt_decomp, & !  opt_nb_req, & !  opt_io) !write(*,*) var !call decomp_2d_close_io(io_in2outlet, trim(data_flname_path)) return end subroutine !========================================================================================================== subroutine read_instantaneous_xinlet ( fl , dm ) use typeconvert_mod implicit none type ( t_flow ), intent ( in ) :: fl type ( t_domain ), intent ( inout ) :: dm character ( 120 ) :: data_flname_path integer :: idom , iter , niter , j if (. not . dm % is_read_xinlet ) return if ( fl % iteration > dm % ndbend ) then iter = mod ( fl % iteration , dm % ndbend ) ! database recycle else iter = fl % iteration end if niter = ( iter + dm % ndbfre - 1 ) / dm % ndbfre ! integer operation niter = niter * dm % ndbfre if ( fl % iteration == 0 ) niter = dm % ndbfre if ( mod ( iter - 1 , dm % ndbfre ) == 0 . or . & fl % iteration == 0 ) then if ( nrank == 0 ) call Print_debug_mid_msg ( \"Read inlet database at iteration \" & // trim ( int2str ( iter )) // '/' // trim ( int2str ( niter ))) call read_instantaneous_plane ( dm % fbcx_qx_inl1 , 'outlet1_qx' , dm % idom , niter , dm % ndbfre , dm % dxcc ) call read_instantaneous_plane ( dm % fbcx_qx_inl2 , 'outlet2_qx' , dm % idom , niter , dm % ndbfre , dm % dxcc ) call read_instantaneous_plane ( dm % fbcx_qy_inl1 , 'outlet1_qy' , dm % idom , niter , dm % ndbfre , dm % dxpc ) call read_instantaneous_plane ( dm % fbcx_qy_inl2 , 'outlet2_qy' , dm % idom , niter , dm % ndbfre , dm % dxpc ) call read_instantaneous_plane ( dm % fbcx_qz_inl1 , 'outlet1_qz' , dm % idom , niter , dm % ndbfre , dm % dxcp ) call read_instantaneous_plane ( dm % fbcx_qz_inl2 , 'outlet2_qz' , dm % idom , niter , dm % ndbfre , dm % dxcp ) call read_instantaneous_plane ( dm % fbcx_pr_inl1 , 'outlet1_pr' , dm % idom , niter , dm % ndbfre , dm % dxcc ) call read_instantaneous_plane ( dm % fbcx_pr_inl2 , 'outlet2_pr' , dm % idom , niter , dm % ndbfre , dm % dxcc ) ! #ifdef DEBUG_STEPS !       write(*,*) 'inlet bc', niter !       do j = 1, dm%dpcc%xsz(2) !         write(*,*) dm%dpcc%xst(2) + j - 1, & !         dm%fbcx_qx_inl1(niter, j, 1),  & !         dm%fbcx_qx_inl2(niter, j, 1) !       end do ! #endif end if call assign_instantaneous_xinlet ( fl , dm ) ! every iteration return end subroutine !========================================================================================================== end module","tags":"","url":"sourcefile/io_restart.f90.html"},{"title":"io_monitor.f90 – CHAPSim2","text":"Source Code module io_monitor_mod use precision_mod use print_msg_mod implicit none private !real(WP), save :: bulk_MKE0 public :: write_monitor_ini public :: write_monitor_bulk public :: write_monitor_probe character ( len = 120 ), parameter :: fl_bulk = \"monitor_bulk_history\" character ( len = 120 ), parameter :: fl_mass = \"monitor_change_history\" contains subroutine write_monitor_ini ( dm ) use typeconvert_mod use wtformat_mod use udf_type_mod use io_files_mod use io_tools_mod use parameters_constant_mod implicit none type ( t_domain ), intent ( inout ) :: dm integer :: myunit integer :: i , j logical :: exist character ( len = 120 ) :: flname , keyword integer :: idgb ( 3 ) integer :: nplc logical :: is_y , is_z integer , allocatable :: probeid (:, :) if ( nrank == 0 ) call Print_debug_start_msg ( \"Writing monitor initial files ...\" ) !---------------------------------------------------------------------------------------------------------- ! create history file for total variables !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then call generate_pathfile_name ( flname , dm % idom , trim ( fl_bulk ), dir_moni , 'log' ) inquire ( file = trim ( flname ), exist = exist ) if ( exist ) then !open(newunit = myunit, file = trim(flname), status=\"old\", position=\"append\", action=\"write\") else open ( newunit = myunit , file = trim ( flname ), status = \"new\" , action = \"write\" ) write ( myunit , * ) \"# domain-id : \" , dm % idom , \"pt-id : \" , i if ( dm % is_thermo ) then write ( myunit , * ) \"# time, MKE, qx_b, gx_b, T_b, h_b\" else write ( myunit , * ) \"# time, MKE, qx_b\" end if close ( myunit ) end if call generate_pathfile_name ( flname , dm % idom , trim ( fl_mass ), dir_moni , 'log' ) inquire ( file = trim ( flname ), exist = exist ) if ( exist ) then !open(newunit = myunit, file = trim(flname), status=\"old\", position=\"append\", action=\"write\") else open ( newunit = myunit , file = trim ( flname ), status = \"new\" , action = \"write\" ) write ( myunit , * ) \"# domain-id : \" , dm % idom , \"pt-id : \" , i write ( myunit , * ) \"# time, mass_conservation at inlet, bulk, outlet, total mass change rate, kinetic energy change rate\" ! to add more instantanous or statistics close ( myunit ) end if end if !---------------------------------------------------------------------------------------------------------- if ( dm % proben <= 0 ) return if ( nrank == 0 ) then call Print_debug_inline_msg ( \"  Probed points for monitoring ...\" ) end if !---------------------------------------------------------------------------------------------------------- allocate ( dm % probe_is_in ( dm % proben ) ) dm % probe_is_in (:) = . false . allocate ( probeid ( 3 , dm % proben ) ) nplc = 0 do i = 1 , dm % proben !---------------------------------------------------------------------------------------------------------- ! probe points find the nearest cell centre, global index info, then convert to local index in x-pencil !---------------------------------------------------------------------------------------------------------- idgb ( 1 : 3 ) = 0 idgb ( 1 ) = ceiling ( dm % probexyz ( 1 , i ) / dm % h ( 1 ) ) idgb ( 3 ) = ceiling ( dm % probexyz ( 3 , i ) / dm % h ( 3 ) ) do j = 1 , dm % np ( 2 ) - 1 if ( dm % probexyz ( 2 , i ) >= dm % yp ( j ) . and . & dm % probexyz ( 2 , i ) < dm % yp ( j + 1 )) then idgb ( 2 ) = j end if end do if ( dm % probexyz ( 2 , i ) >= dm % yp ( dm % np ( 2 )) . and . dm % probexyz ( 2 , i ) < dm % lyt ) then idgb ( 2 ) = dm % nc ( 2 ) end if !---------------------------------------------------------------------------------------------------------- ! convert global id to local, based on x-pencil !---------------------------------------------------------------------------------------------------------- is_y = . false . is_z = . false . if ( idgb ( 2 ) >= dm % dccc % xst ( 2 ) . and . idgb ( 2 ) <= dm % dccc % xen ( 2 ) ) is_y = . true . if ( idgb ( 3 ) >= dm % dccc % xst ( 3 ) . and . idgb ( 3 ) <= dm % dccc % xen ( 3 ) ) is_z = . true . if ( is_y . and . is_z ) then dm % probe_is_in ( i ) = . true . nplc = nplc + 1 probeid ( 1 , nplc ) = idgb ( 1 ) probeid ( 2 , nplc ) = idgb ( 2 ) - dm % dccc % xst ( 2 ) + 1 probeid ( 3 , nplc ) = idgb ( 3 ) - dm % dccc % xst ( 3 ) + 1 !write(*,*) 'test', i, nrank, nplc, probeid(1:3, nplc) end if end do if ( nplc > 0 ) allocate ( dm % probexid ( 3 , nplc )) do i = 1 , nplc dm % probexid ( 1 : 3 , i ) = probeid ( 1 : 3 , i ) end do deallocate ( probeid ) !---------------------------------------------------------------------------------------------------------- ! create probe history file for flow !---------------------------------------------------------------------------------------------------------- nplc = 0 do i = 1 , dm % proben if ( dm % probe_is_in ( i )) then nplc = nplc + 1 write ( * , '(A, I1, A, I1, A, 3F5.2, A, 3I6)' ) & '  pt global id =' , i , ', at nrank =' , nrank , ', location xyz=' , dm % probexyz ( 1 : 3 , i ), & ', local id = ' , dm % probexid ( 1 : 3 , nplc ) end if end do call mpi_barrier ( MPI_COMM_WORLD , ierror ) !---------------------------------------------------------------------------------------------------------- ! create probe history file for flow !---------------------------------------------------------------------------------------------------------- do i = 1 , dm % proben if (. not . dm % probe_is_in ( i )) cycle keyword = \"monitor_pt\" // trim ( int2str ( i )) // \"_flow\" call generate_pathfile_name ( flname , dm % idom , keyword , dir_moni , 'dat' ) inquire ( file = trim ( flname ), exist = exist ) if ( exist ) then !open(newunit = myunit, file = trim(flname), status=\"old\", position=\"append\", action=\"write\") else open ( newunit = myunit , file = trim ( flname ), status = \"new\" , action = \"write\" ) write ( myunit , * ) \"# domain-id : \" , dm % idom , \"pt-id : \" , i write ( myunit , * ) \"# probe pts location \" , dm % probexyz ( 1 : 3 , i ) if ( dm % is_thermo ) then write ( myunit , * ) \"# t, u, v, w, p, phi, T\" ! to add more instantanous or statistics else write ( myunit , * ) \"# t, u, v, w, p, phi\" ! to add more instantanous or statistics end if close ( myunit ) end if end do call mpi_barrier ( MPI_COMM_WORLD , ierror ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== subroutine write_monitor_bulk ( fl , dm , tm ) use typeconvert_mod use parameters_constant_mod use wtformat_mod use udf_type_mod use io_files_mod use io_tools_mod use solver_tools_mod use operations use find_max_min_ave_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), optional , intent ( in ) :: tm character ( len = 120 ) :: flname character ( len = 120 ) :: keyword character ( 200 ) :: iotxt integer :: ioerr , myunit real ( WP ) :: bulk_MKE , bulk_qx , bulk_gx , bulk_T , bulk_m , bulk_h real ( WP ) :: bulk_fbcx ( 2 ), bulk_fbcy ( 2 ), bulk_fbcz ( 2 ) real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: apcc_xpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: accp real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc1 real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc2 real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc3 real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: fenergy real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil , qy_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil , qz_zpencil real ( WP ) :: dMKEdt !---------------------------------------------------------------------------------------------------------- !   calculate the volumetric average of kinetic energy !---------------------------------------------------------------------------------------------------------- ! ux call Get_x_midp_P2C_3D ( fl % qx , accc1 , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx ) ! uy = qy/r call transpose_x_to_y ( fl % qy , acpc_ypencil , dm % dcpc ) call Get_y_midp_P2C_3D ( acpc_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_qy ) if ( dm % icoordinate == ICYLINDRICAL )& call multiple_cylindrical_rn ( accc_ypencil , dm % dccc , dm % rci , 1 , IPENCIL ( 2 )) call transpose_y_to_x ( accc_ypencil , accc2 , dm % dccc ) ! qz = uz call transpose_x_to_y ( fl % qz , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) call Get_z_midp_P2C_3D ( accp_zpencil , accc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_qz ) call transpose_z_to_y ( accc_zpencil , accc_ypencil , dm % dccc ) call transpose_y_to_x ( accc_ypencil , accc3 , dm % dccc ) !volumetric averaged kinetic energy - interiror: 1/2*rho * (uu+vv+ww) fenergy = HALF * ( accc1 * accc1 + accc2 * accc2 + accc3 * accc3 ) if ( dm % is_thermo ) then fenergy = fenergy * fl % dDens end if call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccc , fenergy , bulk_MKE , SPACE_AVERAGE , 'MKE' ) dMKEdt = ( bulk_MKE - fl % tt_kinetic_energy ) / dm % dt fl % tt_kinetic_energy = bulk_MKE !---------------------------------------------------------------------------------------------------------- !   calculate mass flux and mass change !---------------------------------------------------------------------------------------------------------- !density change introduced mass change if ( dm % is_thermo ) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccc , fl % drhodt , bulk_m , SPACE_INTEGRAL , 'drhodt' ) else bulk_m = ZERO end if !area averaged mass flux - x - boundary: rho*uy if ( dm % is_thermo ) then apcc_xpencil = fl % gx else apcc_xpencil = fl % qx end if call Get_area_average_2d_for_fbcx ( dm , dm % dpcc , apcc_xpencil , bulk_fbcx , SPACE_INTEGRAL , 'varx' ) !area averaged mass flux - y - boundary: rho*uy if ( dm % is_thermo ) then call transpose_x_to_y ( fl % gy , acpc_ypencil , dm % dcpc ) else call transpose_x_to_y ( fl % qy , acpc_ypencil , dm % dcpc ) end if if ( dm % icoordinate == ICYLINDRICAL ) then call multiple_cylindrical_rn ( acpc_ypencil , dm % dcpc , dm % rpi , 1 , IPENCIL ( 2 )) call axis_estimating_radial_xpx ( acpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 2 ), is_reversed = . true .) end if call Get_area_average_2d_for_fbcy ( dm , dm % dcpc , acpc_ypencil , bulk_fbcy , SPACE_INTEGRAL , 'vary' ) !area averaged mass flux - z - boundary: rho*uz if ( dm % is_thermo ) then call transpose_x_to_y ( fl % gz , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) else call transpose_x_to_y ( fl % qz , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) end if ! if(dm%icoordinate == ICYLINDRICAL) then !   call multiple_cylindrical_rn(accp_zpencil, dm%dccp, dm%rci, 1, IPENCIL(3)) ! end if call Get_area_average_2d_for_fbcz ( dm , dm % dccp , accp_zpencil , bulk_fbcz , SPACE_INTEGRAL , 'varz' ) ! mass change rate, kg/s fl % tt_mass_change = bulk_m + & bulk_fbcx ( 1 ) - bulk_fbcx ( 2 ) + & bulk_fbcy ( 1 ) - bulk_fbcy ( 2 ) + & bulk_fbcz ( 1 ) - bulk_fbcz ( 2 ) !---------------------------------------------------------------------------------------------------------- !   Bulk quantities !---------------------------------------------------------------------------------------------------------- ! bulk streamwise velocity call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , fl % qx , bulk_qx , SPACE_AVERAGE , 'qx' ) ! bulk thermal parameters if ( dm % is_thermo . and . present ( tm )) then call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , fl % gx , bulk_gx , SPACE_AVERAGE , 'gx' ) call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccc , tm % tTemp , bulk_T , SPACE_AVERAGE , 'T' ) call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dccc , tm % hEnth , bulk_h , SPACE_AVERAGE , 'h' ) end if !---------------------------------------------------------------------------------------------------------- ! open file !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then ! write out history of key conservative variables call generate_pathfile_name ( flname , dm % idom , trim ( fl_mass ), dir_moni , 'log' ) open ( newunit = myunit , file = trim ( flname ), status = \"old\" , action = \"write\" , position = \"append\" , & iostat = ioerr , iomsg = iotxt ) if ( ioerr /= 0 ) then call Print_error_msg ( 'Problem openning conservation file' ) end if write ( myunit , '(6ES13.5)' ) fl % time , fl % mcon ( 1 : 3 ), fl % tt_mass_change , dMKEdt close ( myunit ) ! write out history of bulk variables call generate_pathfile_name ( flname , dm % idom , trim ( fl_bulk ), dir_moni , 'log' ) open ( newunit = myunit , file = trim ( flname ), status = \"old\" , action = \"write\" , position = \"append\" , & iostat = ioerr , iomsg = iotxt ) if ( ioerr /= 0 ) then call Print_error_msg ( 'Problem openning bulk file' ) end if if ( dm % is_thermo . and . present ( tm )) then write ( myunit , '(6ES13.5)' ) fl % time , fl % tt_kinetic_energy , bulk_qx , bulk_gx , bulk_T , bulk_h else write ( myunit , '(3ES13.5)' ) fl % time , fl % tt_kinetic_energy , bulk_qx end if close ( myunit ) end if return end subroutine !========================================================================================================== subroutine write_monitor_probe ( fl , dm , tm ) use typeconvert_mod use parameters_constant_mod use wtformat_mod use udf_type_mod use io_files_mod use io_tools_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl type ( t_thermo ), optional , intent ( in ) :: tm character ( len = 120 ) :: flname character ( len = 120 ) :: keyword character ( 200 ) :: iotxt integer :: ioerr , myunit integer :: ix , iy , iz integer :: i , nplc if ( dm % proben <= 0 ) return !---------------------------------------------------------------------------------------------------------- ! based on x-pencil !---------------------------------------------------------------------------------------------------------- nplc = 0 do i = 1 , dm % proben if ( dm % probe_is_in ( i ) ) nplc = nplc + 1 if ( nplc > 0 ) then !---------------------------------------------------------------------------------------------------------- ! open file !---------------------------------------------------------------------------------------------------------- keyword = \"monitor_pt\" // trim ( int2str ( i )) // \"_flow\" call generate_pathfile_name ( flname , dm % idom , keyword , dir_moni , 'dat' ) open ( newunit = myunit , file = trim ( flname ), status = \"old\" , action = \"write\" , position = \"append\" , & iostat = ioerr , iomsg = iotxt ) if ( ioerr /= 0 ) then !write (*, *) 'Problem openning probing file' !write (*, *) 'Message: ', trim (iotxt) call Print_error_msg ( 'Problem openning probing file' ) end if !---------------------------------------------------------------------------------------------------------- ! write out local data !---------------------------------------------------------------------------------------------------------- ix = dm % probexid ( 1 , nplc ) iy = dm % probexid ( 2 , nplc ) iz = dm % probexid ( 3 , nplc ) !write(*,*) 'probe pts:', nrank, nplc, ix, iy, iz if ( dm % is_thermo . and . present ( tm )) then write ( myunit , '(7ES13.5)' ) fl % time , fl % qx ( ix , iy , iz ), fl % qy ( ix , iy , iz ), fl % qz ( ix , iy , iz ), & fl % pres ( ix , iy , iz ), fl % pcor ( ix , iy , iz ), tm % tTemp ( ix , iy , iz ) else write ( myunit , '(6ES13.5)' ) fl % time , fl % qx ( ix , iy , iz ), fl % qy ( ix , iy , iz ), fl % qz ( ix , iy , iz ), & fl % pres ( ix , iy , iz ), fl % pcor ( ix , iy , iz ) end if close ( myunit ) end if end do return end subroutine !========================================================================================================== end module","tags":"","url":"sourcefile/io_monitor.f90.html"},{"title":"bc_dirichlet.f90 – CHAPSim2","text":"Source Code module bc_dirichlet_mod use udf_type_mod use parameters_constant_mod use print_msg_mod implicit none character ( 18 ) :: filename ( 5 ) private :: map_bc_1d_uprofile public :: initialise_fbcx_given_profile private :: initialise_fbcx_given_const private :: initialise_fbcy_given_const private :: initialise_fbcz_given_const public :: initialise_fbc_flow_given ! applied once only, for bc of constant velocity public :: initialise_fbc_thermo_given ! applied once only, for bc of constant temperature public :: enforce_velo_from_fbc public :: extract_dirichlet_fbcx public :: extract_dirichlet_fbcy public :: extract_dirichlet_fbcz contains !========================================================================================================== !========================================================================================================== subroutine extract_dirichlet_fbcx ( fbc , var , dtmp ) use udf_type_mod use parameters_constant_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( out ) :: fbc ( 4 , dtmp % xsz ( 2 ), dtmp % xsz ( 3 )) real ( WP ), intent ( in ) :: var ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )) if ( dtmp % xsz ( 1 ) /= dtmp % xen ( 1 )) call Print_error_msg ( \"Error. This is not x-pencil.\" ) fbc ( 1 , :, :) = var ( 1 , :, :) fbc ( 2 , :, :) = var ( dtmp % xsz ( 1 ), :, :) fbc ( 3 : 4 , :, :) = fbc ( 1 : 2 , :, :) ! not used. return end subroutine !========================================================================================================== subroutine extract_dirichlet_fbcy ( fbc , var , dtmp , dm , is_reversed ) use udf_type_mod use parameters_constant_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( out ) :: fbc ( dtmp % ysz ( 1 ), 4 , dtmp % ysz ( 3 )) real ( WP ), intent ( in ) :: var ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )) logical , optional , intent ( in ) :: is_reversed real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 ) ) :: var_zpencil , var_zpencil1 real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 ) ) :: var_ypencil1 integer :: k real ( WP ) :: sign !------------------------------------------------------------------------------------------------------ ! Check if the input data is in y-pencil format !------------------------------------------------------------------------------------------------------ if ( dtmp % ysz ( 2 ) /= dtmp % yen ( 2 )) call Print_error_msg ( \"Error. This is not y-pencil.\" ) !------------------------------------------------------------------------------------------------------ ! Extract Dirichlet boundary conditions in the y-direction !------------------------------------------------------------------------------------------------------ fbc (:, 1 , :) = var (:, 1 , :) ! Lower boundary fbc (:, 2 , :) = var (:, dtmp % ysz ( 2 ), :) ! Upper boundary fbc (:, 4 , :) = TWO * var (:, dtmp % ysz ( 2 ), :) - var (:, dtmp % ysz ( 2 ) - 1 , :) ! Upper boundary !------------------------------------------------------------------------------------------------------ ! Handle special treatment of the lower boundary for pipe geometry (ICASE_PIPE) ! this part is the same as axis_mirroring !------------------------------------------------------------------------------------------------------ if ( dm % icase == ICASE_PIPE ) then sign = ONE if ( present ( is_reversed )) then if ( is_reversed ) sign = - ONE end if call transpose_y_to_z ( var , var_zpencil , dtmp ) do k = 1 , dtmp % zsz ( 3 ) var_zpencil1 (:, :, k ) = sign * var_zpencil (:, :, dm % knc_sym ( k )) end do call transpose_z_to_y ( var_zpencil1 , var_ypencil1 , dtmp ) fbc (:, 3 , :) = var_ypencil1 (:, 2 , :) else fbc (:, 3 , :) = TWO * var (:, 1 , :) - var (:, 2 , :) end if return end subroutine !========================================================================================================== subroutine extract_dirichlet_fbcz ( fbc , var , dtmp ) use udf_type_mod use parameters_constant_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )) real ( WP ), intent ( out ) :: fbc ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), 4 ) if ( dtmp % zsz ( 3 ) /= dtmp % zen ( 3 )) call Print_error_msg ( \"Error. This is not z-pencil.\" ) fbc (:, :, 1 ) = var (:, :, 1 ) fbc (:, :, 2 ) = var (:, :, dtmp % zsz ( 3 )) fbc (:, :, 3 : 4 ) = fbc (:, :, 1 : 2 ) return end subroutine !========================================================================================================== !========================================================================================================== subroutine map_bc_1d_uprofile ( filename , n , y , u ) use io_files_mod implicit none character ( * ), intent ( in ) :: filename integer , intent ( in ) :: n real ( WP ), intent ( in ) :: y ( n ) real ( WP ), intent ( out ) :: u ( n ) integer , parameter :: IOMSG_LEN = 200 character ( len = IOMSG_LEN ) :: iotxt integer :: ioerr , inputUnit character ( len = 80 ) :: str real ( WP ) :: rtmp integer :: i , nn integer :: pf_unit , j real ( WP ), allocatable :: uprofile (:) real ( WP ), allocatable :: yy (:) !---------------------------------------------------------------------------------------------------------- ! to read given u-velocity profile, dimensionless, x/H, U/Umean !---------------------------------------------------------------------------------------------------------- open ( newunit = inputUnit , & file = trim ( filename ), & status = 'old' , & action = 'read' , & iostat = ioerr , & iomsg = iotxt ) if ( ioerr /= 0 ) then str = 'Problem opening: ' // trim ( filename ) call Print_error_msg ( trim ( str )) end if nn = 0 read ( inputUnit , * , iostat = ioerr ) str do read ( inputUnit , * , iostat = ioerr ) rtmp , rtmp if ( ioerr /= 0 ) exit nn = nn + 1 end do rewind ( inputUnit ) !---------------------------------------------------------------------------------------------------------- ! to read given u-velocity profile, dimensionless, x/H, U/Umean !---------------------------------------------------------------------------------------------------------- allocate ( uprofile ( nn ) ) allocate ( yy ( nn ) ) read ( inputUnit , * , iostat = ioerr ) str do i = 1 , nn read ( inputUnit , * , iostat = ioerr ) yy ( i ), uprofile ( i ) end do close ( inputUnit ) call profile_interpolation ( nn , yy , uprofile , n , y , u ) if ( nrank == 0 ) then open ( newunit = pf_unit , & file = trim ( dir_chkp ) // '/check_given_ux_profile.dat' , & status = 'replace' , & action = 'write' ) write ( pf_unit , '(A)' ) \"#j, y, u - original\" do j = 1 , nn write ( pf_unit , '(1I3.1, 5ES15.7)' ) j , yy ( j ), uprofile ( j ) end do write ( pf_unit , '(A)' ) \"#j, y, u - interpolation\" do j = 1 , n write ( pf_unit , '(1I3.1, 5ES15.7)' ) j , y ( j ), u ( j ) end do close ( pf_unit ) end if deallocate ( uprofile ) deallocate ( yy ) return end subroutine !========================================================================================================== !========================================================================================================== subroutine initialise_fbcx_given_profile ( fbcx , var1y , jst , str ) use io_files_mod implicit none real ( WP ), intent ( inout ) :: fbcx (:, :, :) real ( WP ), intent ( in ) :: var1y (:) integer , intent ( in ) :: jst character ( 2 ), intent ( in ) :: str integer :: k , j , jj integer :: pf_unit do k = 1 , size ( fbcx , 3 ) do j = 1 , size ( fbcx , 2 ) jj = jst + j - 1 fbcx ( 1 , j , k ) = var1y ( jj ) fbcx ( 3 , j , k ) = fbcx ( 1 , j , k ) end do end do open ( newunit = pf_unit , & file = trim ( dir_chkp ) // '/check_given_' // trim ( str ) // '_profile.dat' , & position = 'append' , & action = 'write' ) write ( pf_unit , '(A)' ) \"#fbcx\" do j = 1 , size ( fbcx , 2 ) write ( pf_unit , '(1I3.1, 1ES15.7)' ) j , fbcx ( 1 , j , 1 ) end do close ( pf_unit ) return end subroutine !========================================================================================================== subroutine initialise_fbcx_given_const ( fbcx , fbcx_const ) real ( WP ), intent ( inout ) :: fbcx (:, :, :) real ( WP ), intent ( in ) :: fbcx_const ( 2 ) integer :: k , j , n do k = 1 , size ( fbcx , 3 ) do j = 1 , size ( fbcx , 2 ) do n = 1 , 2 fbcx ( n , j , k ) = fbcx_const ( n ) fbcx ( n + 2 , j , k ) = fbcx ( n , j , k ) end do end do end do return end subroutine !========================================================================================================== subroutine initialise_fbcy_given_const ( fbcy , fbcy_const , ri ) real ( WP ), intent ( inout ) :: fbcy (:, :, :) real ( WP ), intent ( in ) :: fbcy_const ( 2 ) real ( WP ), intent ( in ), optional :: ri (:) integer :: k , i , n real ( WP ) :: ri_new ( 2 ) if ( present ( ri )) then ri_new ( 1 ) = ri ( 1 ) ri_new ( 2 ) = ri ( size ( ri )) else ri_new = ONE end if do k = 1 , size ( fbcy , 3 ) do i = 1 , size ( fbcy , 1 ) do n = 1 , 2 if ( ri_new ( n ) < ( MAXP * HALF )) then fbcy ( i , n , k ) = fbcy_const ( n ) * ri_new ( n ) end if fbcy ( i , n + 2 , k ) = fbcy ( i , n , k ) end do end do end do return end subroutine !========================================================================================================== subroutine initialise_fbcz_given_const ( fbcz , fbcz_const , ri , jst ) real ( WP ), intent ( inout ) :: fbcz (:, :, :) real ( WP ), intent ( in ) :: fbcz_const ( 2 ) integer , intent ( in ), optional :: jst real ( WP ), intent ( in ), optional :: ri (:) integer :: i , j , n , jj jj = 0 do j = 1 , 1 , size ( fbcz , 2 ) if ( present ( jst )) jj = jst + j - 1 do i = 1 , size ( fbcz , 1 ) do n = 1 , 2 if ( present ( ri )) then fbcz ( i , j , n ) = fbcz_const ( n ) / ri ( jj ) else fbcz ( i , j , n ) = fbcz_const ( n ) end if fbcz ( i , j , n + 2 ) = fbcz ( i , j , n ) end do end do end do return end subroutine !========================================================================================================== !========================================================================================================== subroutine initialise_fbc_flow_given ( dm ) ! apply once only type ( t_domain ), intent ( inout ) :: dm real ( WP ) :: var1y ( 1 : dm % np ( 2 )) integer :: ny , n !========================================================================================================== ! to build up bc with constant values ! -3-1-||||-2-4 ! for constant bc, 3=1= geometric bc, side 1; !                  2=4= geometric bc, side 2 !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! x-bc in x-pencil, qx, qy, qz, pr !---------------------------------------------------------------------------------------------------------- call initialise_fbcx_given_const ( dm % fbcx_qx , dm % fbcx_const (:, 1 )) call initialise_fbcx_given_const ( dm % fbcx_qy , dm % fbcx_const (:, 2 )) call initialise_fbcx_given_const ( dm % fbcx_qz , dm % fbcx_const (:, 3 )) call initialise_fbcx_given_const ( dm % fbcx_pr , dm % fbcx_const (:, 4 )) !---------------------------------------------------------------------------------------------------------- ! y-bc in y-pencil, qx, qy, qz, pr !---------------------------------------------------------------------------------------------------------- call initialise_fbcy_given_const ( dm % fbcy_qx , dm % fbcy_const (:, 1 )) call initialise_fbcy_given_const ( dm % fbcy_qy , dm % fbcy_const (:, 2 )) call initialise_fbcy_given_const ( dm % fbcy_qz , dm % fbcy_const (:, 3 )) ! geo_bc, rpi, not rci call initialise_fbcy_given_const ( dm % fbcy_pr , dm % fbcy_const (:, 4 )) if ( dm % icoordinate == ICYLINDRICAL ) then !---------------------------------------------------------------------------------------------------------- ! y-bc in y-pencil, qyr = qy/r = uy !---------------------------------------------------------------------------------------------------------- call initialise_fbcy_given_const ( dm % fbcy_qyr , dm % fbcy_const (:, 2 ), dm % rpi ) call initialise_fbcy_given_const ( dm % fbcy_qzr , dm % fbcy_const (:, 3 ), dm % rci ) end if !---------------------------------------------------------------------------------------------------------- ! z-bc in z-pencil, qx, qy, qz, pr !---------------------------------------------------------------------------------------------------------- call initialise_fbcz_given_const ( dm % fbcz_qx , dm % fbcz_const (:, 1 )) call initialise_fbcz_given_const ( dm % fbcz_qy , dm % fbcz_const (:, 2 )) call initialise_fbcz_given_const ( dm % fbcz_qz , dm % fbcz_const (:, 3 )) call initialise_fbcz_given_const ( dm % fbcz_pr , dm % fbcz_const (:, 4 )) if ( dm % icoordinate == ICYLINDRICAL ) then !---------------------------------------------------------------------------------------------------------- ! z-bc in z-pencil, qyr = qy/r = uy !---------------------------------------------------------------------------------------------------------- call initialise_fbcz_given_const ( dm % fbcz_qyr , dm % fbcz_const (:, 2 ), dm % rpi , dm % dcpc % zst ( 2 )) call initialise_fbcz_given_const ( dm % fbcz_qzr , dm % fbcz_const (:, 3 ), dm % rci , dm % dccp % zst ( 2 )) end if !========================================================================================================== ! to build up bc for var(x_const, y, z) !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! x-bc1, qx(x_c, y, z) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( 1 , 1 ) == IBC_PROFILE1D ) then var1y = ZERO ny = dm % nc ( 2 ) filename ( 1 ) = trim ( 'PF1D_U1Y.DAT' ) !(undim) ! call map_bc_1d_uprofile( filename(1), ny, dm%yc, var1y(1:ny) ) ! call initialise_fbcx_given_profile(dm%fbcx_qx, var1y, dm%dpcc%xst(2), 'qx') end if !---------------------------------------------------------------------------------------------------------- ! x-bc1, qy(x_c, y, z) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( 1 , 2 ) == IBC_PROFILE1D ) then var1y = ZERO ny = dm % np ( 2 ) filename ( 2 ) = trim ( 'PF1D_V1Y.DAT' ) !(undim) call map_bc_1d_uprofile ( filename ( 2 ), ny , dm % yp , var1y ( 1 : ny ) ) if ( dm % icoordinate == ICARTESIAN ) var1y ( 1 : ny ) = var1y ( 1 : ny ) * dm % rp ( 1 : ny ) call initialise_fbcx_given_profile ( dm % fbcx_qy , var1y , dm % dcpc % xst ( 2 ), 'qy' ) end if !---------------------------------------------------------------------------------------------------------- ! x-bc1, qz(x_c, y, z) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( 1 , 3 ) == IBC_PROFILE1D ) then var1y = ZERO ny = dm % nc ( 2 ) filename ( 3 ) = trim ( 'PF1D_W1Y.DAT' ) !(undim) call map_bc_1d_uprofile ( filename ( 3 ), ny , dm % yc , var1y ( 1 : ny ) ) if ( dm % icoordinate == ICARTESIAN ) var1y ( 1 : ny ) = var1y ( 1 : ny ) * dm % rc ( 1 : ny ) call initialise_fbcx_given_profile ( dm % fbcx_qz , var1y , dm % dccp % xst ( 2 ), 'qz' ) end if !---------------------------------------------------------------------------------------------------------- ! x-bc1, pr(x_c, y, z) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( 1 , 4 ) == IBC_PROFILE1D ) then var1y = ZERO ny = dm % nc ( 2 ) filename ( 4 ) = trim ( 'PF1D_P1Y.DAT' ) !(undim) call map_bc_1d_uprofile ( filename ( 4 ), ny , dm % yc , var1y ( 1 : ny ) ) call initialise_fbcx_given_profile ( dm % fbcx_pr , var1y , dm % dccc % xst ( 2 ), 'pr' ) end if if ( dm % is_thermo ) then do n = 1 , 2 !---------------------------------------------------------------------------------------------------------- ! x-bc in x-pencil, gx, gy, gz !---------------------------------------------------------------------------------------------------------- dm % fbcx_gx ( n , :, :) = dm % fbcx_qx ( n , :, :) * dm % fbcx_ftp ( n , 1 , 1 )% d dm % fbcx_gy ( n , :, :) = dm % fbcx_qy ( n , :, :) * dm % fbcx_ftp ( n , 1 , 1 )% d dm % fbcx_gz ( n , :, :) = dm % fbcx_qz ( n , :, :) * dm % fbcx_ftp ( n , 1 , 1 )% d !---------------------------------------------------------------------------------------------------------- ! y-bc in y-pencil, gx, gy, gz, qyr = qy/r = uy !---------------------------------------------------------------------------------------------------------- dm % fbcy_gx (:, n , :) = dm % fbcy_qx (:, n , :) * dm % fbcy_ftp ( 1 , n , 1 )% d dm % fbcy_gy (:, n , :) = dm % fbcy_qy (:, n , :) * dm % fbcy_ftp ( 1 , n , 1 )% d dm % fbcy_gz (:, n , :) = dm % fbcy_qz (:, n , :) * dm % fbcy_ftp ( 1 , n , 1 )% d !if(dm%icoordinate == ICYLINDRICAL) then !dm%fbcy_gyr(:, n, :) = dm%fbcy_qyr(:, n, :) * dm%fbcy_ftp(1, n, 1)%d !dm%fbcy_gzr(:, n, :) = dm%fbcy_qzr(:, n, :) * dm%fbcy_ftp(1, n, 1)%d !end if !---------------------------------------------------------------------------------------------------------- ! z-bc in z-pencil, gx, gy, gz, gyr = gy/r !---------------------------------------------------------------------------------------------------------- dm % fbcz_gx (:, :, n ) = dm % fbcz_qx (:, :, n ) * dm % fbcz_ftp ( 1 , 1 , n )% d dm % fbcz_gy (:, :, n ) = dm % fbcz_qy (:, :, n ) * dm % fbcz_ftp ( 1 , 1 , n )% d dm % fbcz_gz (:, :, n ) = dm % fbcz_qz (:, :, n ) * dm % fbcz_ftp ( 1 , 1 , n )% d !if(dm%icoordinate == ICYLINDRICAL) then !dm%fbcz_gyr(:, :, n) = dm%fbcz_qyr(:, :, n) * dm%fbcz_ftp(1, 1, n)%d !dm%fbcz_gzr(:, :, n) = dm%fbcz_qzr(:, :, n) * dm%fbcz_ftp(1, 1, n)%d !end if end do end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine initialise_fbc_thermo_given ( tm , dm ) ! call this after scaling the fbc_ftp values use thermo_info_mod type ( t_domain ), intent ( inout ) :: dm type ( t_thermo ), intent ( in ) :: tm real ( WP ) :: var1y ( 1 : dm % np ( 2 )) integer :: ny , n , i , j , k !---------------------------------------------------------------------------------------------------------- ! to build up bc with constant values ! -3-1-||||-2-4 ! for constant bc, 3=1= geometric bc, side 1; !                  2=4= geometric bc, side 2 !---------------------------------------------------------------------------------------------------------- ! x-bc1, pr(x_c, y, z) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( 1 , 5 ) == IBC_PROFILE1D ) then ! var1y = ZERO ny = dm % nc ( 2 ) filename ( 4 ) = trim ( 'pf1d_T1y_undim.dat' ) !(undim) call map_bc_1d_uprofile ( filename ( 4 ), ny , dm % yc , var1y ( 1 : ny ) ) call initialise_fbcx_given_profile ( dm % fbcx_ftp (:,:,:)% t , var1y , dm % dccc % xst ( 2 ), 'Ty' ) call ftp_refresh_thermal_properties_from_T_undim_3d ( dm % fbcx_ftp ) else if ( nrank == 0 . and . dm % ibcx_nominal ( 1 , 1 ) == IBC_DATABASE ) & call Print_warning_msg ( \"The thermal field's inlet temperature is the same as Tini given.\" ) end if do n = 1 , 2 !---------------------------------------------------------------------------------------------------------- ! x-bc in x-pencil, ftp, qx, qy, qz, pr !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_nominal ( n , 5 ) == IBC_DIRICHLET ) then dm % fbcx_ftp ( n , :, :)% t = dm % fbcx_const ( n , 5 ) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm % fbcx_ftp ) else if ( dm % ibcx_nominal ( n , 5 ) == IBC_NEUMANN ) then dm % fbcx_qw ( n , :, :) = dm % fbcx_const ( n , 5 ) dm % fbcx_ftp = tm % ftp_ini else dm % fbcx_ftp = tm % ftp_ini end if !---------------------------------------------------------------------------------------------------------- ! y-bc in y-pencil, ftp, qx, qy, qz, pr !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_nominal ( n , 5 ) == IBC_DIRICHLET ) then dm % fbcy_ftp (:, n , :)% t = dm % fbcy_const ( n , 5 ) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm % fbcy_ftp ) !write(*,*) 'test, bc-T', dm%fbcy_const(n, 5), dm%fbcy_ftp(4, n, 4)%t else if ( dm % ibcy_nominal ( n , 5 ) == IBC_NEUMANN ) then dm % fbcy_qw (:, n , :) = dm % fbcy_const ( n , 5 ) dm % fbcy_ftp = tm % ftp_ini else dm % fbcy_ftp = tm % ftp_ini end if !---------------------------------------------------------------------------------------------------------- ! z-bc in z-pencil, qx, qy, qz, pr !---------------------------------------------------------------------------------------------------------- if ( dm % ibcz_nominal ( n , 5 ) == IBC_DIRICHLET ) then dm % fbcz_ftp (:, :, n )% t = dm % fbcz_const ( n , 5 ) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm % fbcz_ftp ) else if ( dm % ibcz_nominal ( n , 5 ) == IBC_NEUMANN ) then dm % fbcz_qw (:, :, n ) = dm % fbcz_const ( n , 5 ) dm % fbcz_ftp = tm % ftp_ini else dm % fbcz_ftp = tm % ftp_ini end if end do return end subroutine !========================================================================================================== subroutine enforce_velo_from_fbc ( dm , ux , uy , uz , fbcx0 , fbcy0 , fbcz0 ) use udf_type_mod use parameters_constant_mod use print_msg_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )), intent ( inout ) :: ux real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )), intent ( inout ) :: uy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )), intent ( inout ) :: uz real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )), optional , intent ( in ) :: fbcx0 real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )), optional , intent ( in ) :: fbcy0 real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ), optional , intent ( in ) :: fbcz0 real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: fbcx real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) :: fbcy real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz if (. not . present ( fbcx0 )) then fbcx = ZERO fbcy = ZERO fbcz = ZERO else fbcx = fbcx0 fbcy = fbcy0 fbcz = fbcz0 end if ! -mx_rhs- if ( dm % ibcx_qx ( 1 ) == IBC_DIRICHLET ) ux ( 1 , :, :) = fbcx ( 1 , :, :) if ( dm % ibcx_qx ( 2 ) == IBC_DIRICHLET ) ux ( dm % dpcc % xsz ( 1 ), :, :) = fbcx ( 2 , :, :) !-my_rhs- if ( dm % ibcy_qy ( 1 ) == IBC_DIRICHLET . or . & dm % ibcy_qy ( 2 ) == IBC_DIRICHLET ) then call transpose_x_to_y ( uy , acpc_ypencil , dm % dcpc ) if ( dm % ibcy_qy ( 1 ) == IBC_DIRICHLET ) acpc_ypencil (:, 1 , :) = fbcy (:, 1 , :) if ( dm % ibcy_qy ( 2 ) == IBC_DIRICHLET ) acpc_ypencil (:, dm % dcpc % ysz ( 2 ), :) = fbcy (:, 2 , :) call transpose_y_to_x ( acpc_ypencil , uy , dm % dcpc ) end if if ( dm % icase == ICASE_PIPE ) then call transpose_x_to_y ( uy , acpc_ypencil , dm % dcpc ) acpc_ypencil (:, 1 , :) = ZERO call transpose_y_to_x ( acpc_ypencil , uy , dm % dcpc ) end if !-mz_rhs- if ( dm % ibcz_qz ( 1 ) == IBC_DIRICHLET . or . & dm % ibcz_qz ( 2 ) == IBC_DIRICHLET ) then call transpose_x_to_y ( uz , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) if ( dm % ibcz_qz ( 1 ) == IBC_DIRICHLET ) accp_zpencil (:, :, 1 ) = fbcz (:, :, 1 ) if ( dm % ibcz_qz ( 2 ) == IBC_DIRICHLET ) accp_zpencil (:, :, dm % dccp % zsz ( 3 )) = fbcz (:, :, 2 ) call transpose_z_to_y ( accp_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , uz , dm % dccp ) end if return end subroutine end module","tags":"","url":"sourcefile/bc_dirichlet.f90.html"},{"title":"para_conversion.f90 – CHAPSim2","text":"Source Code module convert_primary_conservative_mod public :: convert_primary_conservative contains subroutine convert_primary_conservative ( fl , dm , itag ) use udf_type_mod use operations use decomp_2d use parameters_constant_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl integer , intent ( in ) :: itag real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: d_ccc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) :: d_ccc_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: d_pcc_xpencil real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 )) :: d_pcc_ypencil real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 )) :: d_pcc_zpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) :: d_cpc_xpencil real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 )) :: d_cpc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: d_cpc_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: qy_cpc_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: gy_cpc_ypencil real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) :: d_ccp_xpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: d_ccp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: d_ccp_zpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: qz_ccp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: qz_ccp_zpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: gz_ccp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: gz_ccp_zpencil real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: fbcx_4cc real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_c4c real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_cc4 if (. not . dm % is_thermo ) return !---------------------------------------------------------------------------------------------------------- ! x-pencil : u1 -> g1 = u1_pcc * d_pcc !---------------------------------------------------------------------------------------------------------- fbcx_4cc (:, :, :) = dm % fbcx_ftp (:, :, :)% d call Get_x_midp_C2P_3D ( fl % dDens , d_pcc_xpencil , dm , dm % iAccuracy , dm % ibcx_ftp , fbcx_4cc ) if ( itag == IQ2G ) fl % gx = fl % qx * d_pcc_xpencil if ( itag == IG2Q ) fl % qx = fl % gx / d_pcc_xpencil !---------------------------------------------------------------------------------------------------------- ! y-pencil : u2 -> g2 = u2_cpc * d_cpc !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( fl % dDens , d_ccc_ypencil , dm % dccc ) fbcy_c4c (:, :, :) = dm % fbcy_ftp (:, :, :)% d call Get_y_midp_C2P_3D ( d_ccc_ypencil , d_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp , fbcy_c4c ) call axis_estimating_radial_xpx ( d_cpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 1 )) if ( itag == IQ2G ) then call transpose_x_to_y ( fl % qy , qy_cpc_ypencil , dm % dcpc ) gy_cpc_ypencil = qy_cpc_ypencil * d_cpc_ypencil call transpose_y_to_x ( gy_cpc_ypencil , fl % gy , dm % dcpc ) else if ( itag == IG2Q ) then call transpose_x_to_y ( fl % gy , gy_cpc_ypencil , dm % dcpc ) qy_cpc_ypencil = gy_cpc_ypencil / d_cpc_ypencil call transpose_y_to_x ( qy_cpc_ypencil , fl % qy , dm % dcpc ) else end if !---------------------------------------------------------------------------------------------------------- ! Z-pencil : u3 -> g3 = u3_ccp * d_ccp !---------------------------------------------------------------------------------------------------------- call transpose_y_to_z ( d_ccc_ypencil , d_ccc_zpencil , dm % dccc ) fbcz_cc4 (:, :, :) = dm % fbcz_ftp (:, :, :)% d call Get_z_midp_C2P_3D ( d_ccc_zpencil , d_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp , fbcz_cc4 ) if ( itag == IQ2G ) then call transpose_x_to_y ( fl % qz , qz_ccp_ypencil , dm % dccp ) call transpose_y_to_z ( qz_ccp_ypencil , qz_ccp_zpencil , dm % dccp ) gz_ccp_zpencil = qz_ccp_zpencil * d_ccp_zpencil call transpose_z_to_y ( gz_ccp_zpencil , gz_ccp_ypencil , dm % dccp ) call transpose_y_to_x ( gz_ccp_ypencil , fl % gz , dm % dccp ) else if ( itag == IG2Q ) then call transpose_x_to_y ( fl % gz , gz_ccp_ypencil , dm % dccp ) call transpose_y_to_z ( gz_ccp_ypencil , gz_ccp_zpencil , dm % dccp ) qz_ccp_zpencil = gz_ccp_zpencil / d_ccp_zpencil call transpose_z_to_y ( qz_ccp_zpencil , qz_ccp_ypencil , dm % dccp ) call transpose_y_to_x ( qz_ccp_ypencil , fl % qz , dm % dccp ) else end if !---------------------------------------------------------------------------------------------------------- ! BC: - x pencil !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_qx ( 1 ) == IBC_DIRICHLET . or . dm % ibcx_qx ( 2 ) == IBC_DIRICHLET ) then if ( itag == IQ2G ) dm % fbcx_gx (:, :, :) = dm % fbcx_qx (:, :, :) * dm % fbcx_ftp (:, :, :)% d if ( itag == IG2Q ) dm % fbcx_qx (:, :, :) = dm % fbcx_gx (:, :, :) / dm % fbcx_ftp (:, :, :)% d end if if ( dm % ibcx_qy ( 1 ) == IBC_DIRICHLET . or . dm % ibcx_qy ( 2 ) == IBC_DIRICHLET ) then call transpose_y_to_x ( d_cpc_ypencil , d_cpc_xpencil , dm % dcpc ) if ( itag == IQ2G ) then dm % fbcx_gy ( 1 , :, :) = dm % fbcx_qy ( 1 , :, :) * d_cpc_xpencil ( 1 , :, :) dm % fbcx_gy ( 2 , :, :) = dm % fbcx_qy ( 2 , :, :) * d_cpc_xpencil ( dm % dcpc % xsz ( 1 ), :, :) dm % fbcx_gy ( 3 , :, :) = dm % fbcx_gy ( 1 , :, :) dm % fbcx_gy ( 4 , :, :) = dm % fbcx_gy ( 2 , :, :) else  if ( itag == IG2Q ) then dm % fbcx_qy ( 1 , :, :) = dm % fbcx_gy ( 1 , :, :) / d_cpc_xpencil ( 1 , :, :) dm % fbcx_qy ( 2 , :, :) = dm % fbcx_gy ( 2 , :, :) / d_cpc_xpencil ( dm % dcpc % xsz ( 1 ), :, :) dm % fbcx_qy ( 3 , :, :) = dm % fbcx_qy ( 1 , :, :) dm % fbcx_qy ( 4 , :, :) = dm % fbcx_qy ( 2 , :, :) else end if end if if ( dm % ibcx_qz ( 1 ) == IBC_DIRICHLET . or . dm % ibcx_qz ( 2 ) == IBC_DIRICHLET ) then call transpose_z_to_y ( d_ccp_zpencil , d_ccp_ypencil , dm % dccp ) call transpose_y_to_x ( d_ccp_ypencil , d_ccp_xpencil , dm % dccp ) if ( itag == IQ2G ) then dm % fbcx_gz ( 1 , :, :) = dm % fbcx_qz ( 1 , :, :) * d_ccp_xpencil ( 1 , :, :) dm % fbcx_gz ( 2 , :, :) = dm % fbcx_qz ( 2 , :, :) * d_ccp_xpencil ( dm % dccp % xsz ( 1 ), :, :) dm % fbcx_gz ( 3 , :, :) = dm % fbcx_gz ( 1 , :, :) dm % fbcx_gz ( 4 , :, :) = dm % fbcx_gz ( 2 , :, :) else  if ( itag == IG2Q ) then dm % fbcx_qz ( 1 , :, :) = dm % fbcx_gz ( 1 , :, :) / d_ccp_xpencil ( 1 , :, :) dm % fbcx_qz ( 2 , :, :) = dm % fbcx_gz ( 2 , :, :) / d_ccp_xpencil ( dm % dccp % xsz ( 1 ), :, :) dm % fbcx_qz ( 3 , :, :) = dm % fbcx_qz ( 1 , :, :) dm % fbcx_qz ( 4 , :, :) = dm % fbcx_qz ( 2 , :, :) else end if end if !---------------------------------------------------------------------------------------------------------- ! BC: - y pencil !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qx ( 1 ) == IBC_DIRICHLET . or . dm % ibcy_qx ( 2 ) == IBC_DIRICHLET ) then call transpose_x_to_y ( d_pcc_xpencil , d_pcc_ypencil , dm % dpcc ) if ( itag == IQ2G ) then dm % fbcy_gx (:, 1 , :) = dm % fbcy_qx (:, 1 , :) * d_pcc_ypencil (:, 1 , :) dm % fbcy_gx (:, 2 , :) = dm % fbcy_qx (:, 2 , :) * d_pcc_ypencil (:, dm % dpcc % ysz ( 2 ), :) dm % fbcy_gx (:, 3 , :) = dm % fbcy_gx (:, 1 , :) dm % fbcy_gx (:, 4 , :) = dm % fbcy_gx (:, 2 , :) else if ( itag == IG2Q ) then dm % fbcy_qx (:, 1 , :) = dm % fbcy_gx (:, 1 , :) / d_pcc_ypencil (:, 1 , :) dm % fbcy_qx (:, 2 , :) = dm % fbcy_gx (:, 2 , :) / d_pcc_ypencil (:, dm % dpcc % ysz ( 2 ), :) dm % fbcy_qx (:, 3 , :) = dm % fbcy_qx (:, 1 , :) dm % fbcy_qx (:, 4 , :) = dm % fbcy_qx (:, 2 , :) else end if end if if ( dm % ibcy_qy ( 1 ) == IBC_DIRICHLET . or . dm % ibcy_qy ( 1 ) == IBC_DIRICHLET ) then if ( itag == IQ2G ) then dm % fbcy_gy (:, 1 , :) = dm % fbcy_qy (:, 1 , :) * d_cpc_ypencil (:, 1 , :) dm % fbcy_gy (:, 2 , :) = dm % fbcy_qy (:, 2 , :) * d_cpc_ypencil (:, dm % dcpc % ysz ( 2 ), :) dm % fbcy_gy (:, 3 , :) = dm % fbcy_gy (:, 1 , :) dm % fbcy_gy (:, 4 , :) = dm % fbcy_gy (:, 2 , :) else if ( itag == IG2Q ) then dm % fbcy_qy (:, 1 , :) = dm % fbcy_gy (:, 1 , :) / d_cpc_ypencil (:, 1 , :) dm % fbcy_qy (:, 2 , :) = dm % fbcy_gy (:, 2 , :) / d_cpc_ypencil (:, dm % dcpc % ysz ( 2 ), :) dm % fbcy_qy (:, 3 , :) = dm % fbcy_qy (:, 1 , :) dm % fbcy_qy (:, 4 , :) = dm % fbcy_qy (:, 2 , :) else end if end if if ( dm % ibcy_qz ( 1 ) == IBC_DIRICHLET . or . dm % ibcy_qz ( 1 ) == IBC_DIRICHLET ) then call transpose_z_to_y ( d_ccp_zpencil , d_ccp_ypencil , dm % dccp ) if ( itag == IQ2G ) then dm % fbcy_gz (:, 1 , :) = dm % fbcy_qz (:, 1 , :) * d_ccp_ypencil (:, 1 , :) dm % fbcy_gz (:, 2 , :) = dm % fbcy_qz (:, 2 , :) * d_ccp_ypencil (:, dm % dccp % ysz ( 2 ), :) dm % fbcy_gz (:, 3 , :) = dm % fbcy_gz (:, 1 , :) dm % fbcy_gz (:, 4 , :) = dm % fbcy_gz (:, 2 , :) else if ( itag == IG2Q ) then dm % fbcy_qz (:, 1 , :) = dm % fbcy_gz (:, 1 , :) / d_ccp_ypencil (:, 1 , :) dm % fbcy_qz (:, 2 , :) = dm % fbcy_gz (:, 2 , :) / d_ccp_ypencil (:, dm % dccp % ysz ( 2 ), :) dm % fbcy_qz (:, 3 , :) = dm % fbcy_qz (:, 1 , :) dm % fbcy_qz (:, 4 , :) = dm % fbcy_qz (:, 2 , :) else end if end if !---------------------------------------------------------------------------------------------------------- ! BC: - z pencil !---------------------------------------------------------------------------------------------------------- if ( dm % ibcz_qx ( 1 ) == IBC_DIRICHLET . or . dm % ibcz_qx ( 1 ) == IBC_DIRICHLET ) then call transpose_x_to_y ( d_pcc_xpencil , d_pcc_ypencil ) call transpose_y_to_z ( d_pcc_ypencil , d_pcc_zpencil , dm % dpcc ) if ( itag == IQ2G ) then dm % fbcz_gx (:, :, 1 ) = dm % fbcz_qx (:, :, 1 ) * d_pcc_zpencil (:, :, 1 ) dm % fbcz_gx (:, :, 2 ) = dm % fbcz_qx (:, :, 2 ) * d_pcc_zpencil (:, :, dm % dpcc % zsz ( 3 )) dm % fbcz_gx (:, :, 3 ) = dm % fbcz_gx (:, :, 1 ) dm % fbcz_gx (:, :, 4 ) = dm % fbcz_gx (:, :, 2 ) else if ( itag == IG2Q ) then dm % fbcz_qx (:, :, 1 ) = dm % fbcz_gx (:, :, 1 ) / d_pcc_zpencil (:, :, 1 ) dm % fbcz_qx (:, :, 2 ) = dm % fbcz_gx (:, :, 2 ) / d_pcc_zpencil (:, :, dm % dpcc % zsz ( 3 )) dm % fbcz_qx (:, :, 3 ) = dm % fbcz_qx (:, :, 1 ) dm % fbcz_qx (:, :, 4 ) = dm % fbcz_qx (:, :, 2 ) else end if end if if ( dm % ibcz_qy ( 1 ) == IBC_DIRICHLET . or . dm % ibcz_qy ( 1 ) == IBC_DIRICHLET ) then call transpose_y_to_x ( d_cpc_ypencil , d_cpc_zpencil , dm % dcpc ) if ( itag == IQ2G ) then dm % fbcz_gy (:, :, 1 ) = dm % fbcz_qy (:, :, 1 ) * d_cpc_zpencil (:, :, 1 ) dm % fbcz_gy (:, :, 2 ) = dm % fbcz_qy (:, :, 2 ) * d_cpc_zpencil (:, :, dm % dcpc % zsz ( 3 )) dm % fbcz_gy (:, :, 3 ) = dm % fbcz_gy (:, :, 1 ) dm % fbcz_gy (:, :, 4 ) = dm % fbcz_gy (:, :, 2 ) else if ( itag == IG2Q ) then dm % fbcz_qy (:, :, 1 ) = dm % fbcz_gy (:, :, 1 ) / d_cpc_zpencil (:, :, 1 ) dm % fbcz_qy (:, :, 2 ) = dm % fbcz_gy (:, :, 2 ) / d_cpc_zpencil (:, :, dm % dcpc % zsz ( 3 )) dm % fbcz_qy (:, :, 3 ) = dm % fbcz_qy (:, :, 1 ) dm % fbcz_qy (:, :, 4 ) = dm % fbcz_qy (:, :, 2 ) else end if end if if ( dm % ibcz_qz ( 1 ) == IBC_DIRICHLET . or . dm % ibcz_qz ( 2 ) == IBC_DIRICHLET ) then if ( itag == IQ2G ) then dm % fbcz_gz (:, :, 1 ) = dm % fbcz_qz (:, :, 1 ) * d_ccp_zpencil (:, :, 1 ) dm % fbcz_gz (:, :, 2 ) = dm % fbcz_qz (:, :, 2 ) * d_ccp_zpencil (:, :, dm % dccp % zsz ( 3 )) dm % fbcz_gz (:, :, 3 ) = dm % fbcz_gz (:, :, 1 ) dm % fbcz_gz (:, :, 4 ) = dm % fbcz_gz (:, :, 2 ) else if ( itag == IG2Q ) then dm % fbcz_qz (:, :, 1 ) = dm % fbcz_gz (:, :, 1 ) / d_ccp_zpencil (:, :, 1 ) dm % fbcz_qz (:, :, 2 ) = dm % fbcz_gz (:, :, 2 ) / d_ccp_zpencil (:, :, dm % dccp % zsz ( 3 )) dm % fbcz_qz (:, :, 3 ) = dm % fbcz_qz (:, :, 1 ) dm % fbcz_qz (:, :, 4 ) = dm % fbcz_qz (:, :, 2 ) else end if end if return end subroutine end module","tags":"","url":"sourcefile/para_conversion.f90.html"},{"title":"eq_mhd.f90 – CHAPSim2","text":"Source Code module mhd_mod ! Note: This MHD solver is potential solver only. !       Assumed: the induced magnetic field is negligible. use parameters_constant_mod implicit none private :: cross_production_mhd public :: initialise_mhd public :: compute_Lorentz_force contains !========================================================================================================== subroutine initialise_mhd ( fl , mh , dm ) use udf_type_mod use math_mod use mpi_mod use print_msg_mod use io_visualisation_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl type ( t_mhd ), intent ( inout ) :: mh if ( nrank == 0 ) call Print_debug_start_msg ( 'Initialising MHD ...' ) !---------------------------------------------------------------------------------------------------------- !   allocate variables !---------------------------------------------------------------------------------------------------------- call alloc_x ( mh % ep , dm % dccc ); mh % ep = ZERO call alloc_x ( mh % jx , dm % dpcc ); mh % jx = ZERO call alloc_x ( mh % jy , dm % dcpc ); mh % jy = ZERO call alloc_x ( mh % jz , dm % dccp ); mh % jz = ZERO call alloc_x ( mh % bx , dm % dpcc ); mh % bx = ZERO call alloc_x ( mh % by , dm % dcpc ); mh % by = ZERO call alloc_x ( mh % bz , dm % dccp ); mh % bz = ZERO call alloc_x ( fl % lrfx , dm % dpcc ); fl % lrfx = ZERO call alloc_x ( fl % lrfy , dm % dcpc ); fl % lrfy = ZERO call alloc_x ( fl % lrfz , dm % dccp ); fl % lrfz = ZERO allocate ( mh % fbcx_jx ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_jx ( dm % dpcc % ysz ( 1 ), 4 , dm % dpcc % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_jx ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( mh % fbcx_jy ( 4 , dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_jy ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_jy ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( mh % fbcx_jz ( 4 , dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_jz ( dm % dccp % ysz ( 1 ), 4 , dm % dccp % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_jz ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( mh % fbcx_bx ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_bx ( dm % dpcc % ysz ( 1 ), 4 , dm % dpcc % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_bx ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( mh % fbcx_by ( 4 , dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_by ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_by ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( mh % fbcx_bz ( 4 , dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_bz ( dm % dccp % ysz ( 1 ), 4 , dm % dccp % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_bz ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( mh % fbcx_ep ( 4 , dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) ) ! default x pencil allocate ( mh % fbcy_ep ( dm % dccc % ysz ( 1 ), 4 , dm % dccc % ysz ( 3 )) ) ! default y pencil allocate ( mh % fbcz_ep ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), 4 ) ) ! default z pencil if ( mh % is_NStuart ) mh % NHartmn = sqrt_wp ( ONE / fl % rre * mh % NStuart ) if ( mh % is_NHartmn ) mh % NStuart = mh % NHartmn * mh % NHartmn * fl % rre !---------------------------------------------------------------------------------------------------------- !   Since B=(a, b, c) is a uniform field (constant in space), thus all derivatives of B are zero. !   This means: the the current density introduced by this magnetic field must be zero everywhere, !   including at the boundaries. !---------------------------------------------------------------------------------------------------------- mh % bx = mh % B_static ( 1 ) mh % by = mh % B_static ( 2 ) mh % bz = mh % B_static ( 3 ) mh % jx = ZERO mh % jy = ZERO mh % jz = ZERO mh % ep = ZERO !---------------------------------------------------------------------------------------------------------- ! Boundary for static magnetic field !---------------------------------------------------------------------------------------------------------- mh % ibcx_bx (:) = dm % ibcx_qx (:) mh % ibcx_by (:) = dm % ibcx_qy (:) mh % ibcx_bz (:) = dm % ibcx_qz (:) mh % ibcy_bx (:) = dm % ibcy_qx (:) mh % ibcy_by (:) = dm % ibcy_qy (:) mh % ibcy_bz (:) = dm % ibcy_qz (:) mh % ibcz_bx (:) = dm % ibcz_qx (:) mh % ibcz_by (:) = dm % ibcz_qy (:) mh % ibcz_bz (:) = dm % ibcz_qz (:) mh % fbcx_bx (:, :, :) = mh % B_static ( 1 ) mh % fbcy_bx (:, :, :) = mh % B_static ( 1 ) mh % fbcz_bx (:, :, :) = mh % B_static ( 1 ) mh % fbcx_by (:, :, :) = mh % B_static ( 2 ) mh % fbcy_by (:, :, :) = mh % B_static ( 2 ) mh % fbcz_by (:, :, :) = mh % B_static ( 2 ) mh % fbcx_bz (:, :, :) = mh % B_static ( 3 ) mh % fbcy_bz (:, :, :) = mh % B_static ( 3 ) mh % fbcz_bz (:, :, :) = mh % B_static ( 3 ) !---------------------------------------------------------------------------------------------------------- ! Boundary for current density !---------------------------------------------------------------------------------------------------------- mh % ibcx_jx (:) = dm % ibcx_qx (:) mh % ibcx_jy (:) = dm % ibcx_qy (:) mh % ibcx_jz (:) = dm % ibcx_qz (:) mh % ibcy_jx (:) = dm % ibcy_qx (:) mh % ibcy_jy (:) = dm % ibcy_qy (:) mh % ibcy_jz (:) = dm % ibcy_qz (:) mh % ibcz_jx (:) = dm % ibcz_qx (:) mh % ibcz_jy (:) = dm % ibcz_qy (:) mh % ibcz_jz (:) = dm % ibcz_qz (:) mh % fbcx_jx (:, :, :) = ZERO mh % fbcy_jx (:, :, :) = ZERO mh % fbcz_jx (:, :, :) = ZERO mh % fbcx_jy (:, :, :) = ZERO mh % fbcy_jy (:, :, :) = ZERO mh % fbcz_jy (:, :, :) = ZERO mh % fbcx_jz (:, :, :) = ZERO mh % fbcy_jz (:, :, :) = ZERO mh % fbcz_jz (:, :, :) = ZERO !---------------------------------------------------------------------------------------------------------- ! Boundary for electrical potential !---------------------------------------------------------------------------------------------------------- mh % ibcx_ep (:) = dm % ibcx_pr (:) mh % ibcy_ep (:) = dm % ibcy_pr (:) mh % ibcz_ep (:) = dm % ibcz_pr (:) mh % fbcx_ep (:, :, :) = ZERO mh % fbcy_ep (:, :, :) = ZERO mh % fbcz_ep (:, :, :) = ZERO !call write_visu_mhd(mh, fl, dm, 'initial_mhd') if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== subroutine cross_production_mhd ( fl , mh , ab_cross_x , ab_cross_y , ab_cross_z , str , dm ) ! to add cylindrical use udf_type_mod use operations use print_msg_mod use decomp_2d implicit none type ( t_flow ), intent ( in ) :: fl type ( t_mhd ), intent ( in ) :: mh type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )), intent ( out ) :: ab_cross_x real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )), intent ( out ) :: ab_cross_y real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )), intent ( out ) :: ab_cross_z character ( 8 ), intent ( in ) :: str real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: ax , bx real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) :: ay , by real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) :: az , bz integer :: ibcx_ax ( 2 ), ibcy_ax ( 2 ), ibcz_ax ( 2 ) integer :: ibcx_ay ( 2 ), ibcy_ay ( 2 ), ibcz_ay ( 2 ) integer :: ibcx_az ( 2 ), ibcy_az ( 2 ), ibcz_az ( 2 ) integer :: ibcx_bx ( 2 ), ibcy_bx ( 2 ), ibcz_bx ( 2 ) integer :: ibcx_by ( 2 ), ibcy_by ( 2 ), ibcz_by ( 2 ) integer :: ibcx_bz ( 2 ), ibcy_bz ( 2 ), ibcz_bz ( 2 ) integer :: n , iacc real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: fbcx_ax , fbcx_bx real ( WP ), dimension ( 4 , dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: fbcx_ay , fbcx_by real ( WP ), dimension ( 4 , dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: fbcx_az , fbcx_bz real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), 4 , dm % dpcc % ysz ( 3 ) ) :: fbcy_ax , fbcy_bx real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_ay , fbcy_by real ( WP ), dimension ( dm % dccp % ysz ( 1 ), 4 , dm % dccp % ysz ( 3 ) ) :: fbcy_az , fbcy_bz real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), 4 ) :: fbcz_ax , fbcz_bx real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), 4 ) :: fbcz_ay , fbcz_by real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_az , fbcz_bz real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc_xpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil , & ax_cpc_ypencil , & bx_cpc_ypencil , & az_cpc_ypencil , & bz_cpc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil , & ax_ccp_zpencil , & bx_ccp_zpencil , & ay_ccp_zpencil , & by_ccp_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: apcc_xpencil , & ay_pcc_xpencil , & by_pcc_xpencil , & az_pcc_xpencil , & bz_pcc_xpencil real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ) ) :: accp_xpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc_xpencil real ( WP ), dimension ( dm % dpcp % xsz ( 1 ), dm % dpcp % xsz ( 2 ), dm % dpcp % xsz ( 3 ) ) :: apcp_xpencil real ( WP ), dimension ( dm % dppc % xsz ( 1 ), dm % dppc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: appc_xpencil real ( WP ), dimension ( dm % dppc % ysz ( 1 ), dm % dppc % ysz ( 2 ), dm % dppc % ysz ( 3 ) ) :: appc_ypencil real ( WP ), dimension ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 ) ) :: apcc_ypencil real ( WP ), dimension ( dm % dpcp % ysz ( 1 ), dm % dpcp % ysz ( 2 ), dm % dpcp % ysz ( 3 ) ) :: apcp_ypencil real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), dm % dcpp % ysz ( 2 ), dm % dcpp % ysz ( 3 ) ) :: acpp_ypencil real ( WP ), dimension ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), dm % dcpc % zsz ( 3 ) ) :: acpc_zpencil real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), dm % dcpp % zsz ( 3 ) ) :: acpp_zpencil real ( WP ), dimension ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), dm % dpcc % zsz ( 3 ) ) :: apcc_zpencil real ( WP ), dimension ( dm % dpcp % zsz ( 1 ), dm % dpcp % zsz ( 2 ), dm % dpcp % zsz ( 3 ) ) :: apcp_zpencil iacc = dm % iAccuracy if ( trim ( str ) == 'ub_cross' ) then ax = fl % qx ay = fl % qy az = fl % qz ibcx_ax = dm % ibcx_qx ibcy_ax = dm % ibcy_qx ibcz_ax = dm % ibcz_qx ibcx_ay = dm % ibcx_qy ibcy_ay = dm % ibcy_qy ibcz_ay = dm % ibcz_qy ibcx_az = dm % ibcx_qz ibcy_az = dm % ibcy_qz ibcz_az = dm % ibcz_qz fbcx_ax = dm % fbcx_qx fbcy_ax = dm % fbcy_qx fbcz_ax = dm % fbcz_qx fbcx_ay = dm % fbcx_qy fbcy_ay = dm % fbcy_qy fbcz_ay = dm % fbcz_qy fbcx_az = dm % fbcx_qz fbcy_az = dm % fbcy_qz fbcz_az = dm % fbcz_qz else if ( trim ( str ) == 'jb_cross' ) then ax = mh % jx ay = mh % jy az = mh % jz ibcx_ax = mh % ibcx_jx ibcy_ax = mh % ibcy_jx ibcz_ax = mh % ibcz_jx ibcx_ay = mh % ibcx_jy ibcy_ay = mh % ibcy_jy ibcz_ay = mh % ibcz_jy ibcx_az = mh % ibcx_jz ibcy_az = mh % ibcy_jz ibcz_az = mh % ibcz_jz fbcx_ax = mh % fbcx_jx fbcy_ax = mh % fbcy_jx fbcz_ax = mh % fbcz_jx fbcx_ay = mh % fbcx_jy fbcy_ay = mh % fbcy_jy fbcz_ay = mh % fbcz_jy fbcx_az = mh % fbcx_jz fbcy_az = mh % fbcy_jz fbcz_az = mh % fbcz_jz else call Print_error_msg ( 'The required cross production is not supported.' ) end if bx = mh % bx by = mh % by bz = mh % bz ibcx_bx = mh % ibcx_bx ibcy_bx = mh % ibcy_bx ibcz_bx = mh % ibcz_bx ibcx_by = mh % ibcx_by ibcy_by = mh % ibcy_by ibcz_by = mh % ibcz_by ibcx_bz = mh % ibcx_bz ibcy_bz = mh % ibcy_bz ibcz_bz = mh % ibcz_bz fbcx_bx = mh % fbcx_bx fbcy_bx = mh % fbcy_bx fbcz_bx = mh % fbcz_bx fbcx_by = mh % fbcx_by fbcy_by = mh % fbcy_by fbcz_by = mh % fbcz_by fbcx_bz = mh % fbcx_bz fbcy_bz = mh % fbcy_bz fbcz_bz = mh % fbcz_bz !---------------------------------------------------------------------------------------------------------- ! preparation for u_cross_b for staggered vector !---------------------------------------------------------------------------------------------------------- ! ax_pcc_xpencil to ax_cpc_ypencil apcc_xpencil = ax call transpose_x_to_y ( apcc_xpencil , apcc_ypencil , dm % dpcc ) call Get_y_midp_C2P_3D ( apcc_ypencil , appc_ypencil , dm , iacc , ibcy_ax (:), fbcy_ax (:, :, :)) call transpose_y_to_x ( appc_ypencil , appc_xpencil , dm % dppc ) call Get_x_midp_P2C_3D ( appc_xpencil , acpc_xpencil , dm , iacc , ibcx_ax (:)) call transpose_x_to_y ( acpc_xpencil , acpc_ypencil , dm % dcpc ) ax_cpc_ypencil = acpc_ypencil ! ax_pcc_xpencil to ax_ccp_zpencil call transpose_y_to_z ( apcc_ypencil , apcc_zpencil , dm % dpcc ) call Get_z_midp_C2P_3D ( apcc_zpencil , apcp_zpencil , dm , iacc , ibcz_ax (:), fbcz_ax (:, :, :)) call transpose_z_to_y ( apcp_zpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_x ( apcp_ypencil , apcp_xpencil , dm % dpcp ) call Get_x_midp_P2C_3D ( apcp_xpencil , accp_xpencil , dm , iacc , ibcx_ax (:)) call transpose_x_to_y ( accp_xpencil , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) ax_ccp_zpencil = accp_zpencil ! bx_pcc_xpencil to bx_cpc_ypencil apcc_xpencil = bx call transpose_x_to_y ( apcc_xpencil , apcc_ypencil , dm % dpcc ) call Get_y_midp_C2P_3D ( apcc_ypencil , appc_ypencil , dm , iacc , ibcy_bx (:), fbcy_bx (:, :, :)) call transpose_y_to_x ( appc_ypencil , appc_xpencil , dm % dppc ) call Get_x_midp_P2C_3D ( appc_xpencil , acpc_xpencil , dm , iacc , ibcx_bx (:)) call transpose_x_to_y ( acpc_xpencil , acpc_ypencil , dm % dcpc ) bx_cpc_ypencil = acpc_ypencil ! bx_pcc_xpencil to bx_ccp_zpencil call transpose_y_to_z ( apcc_ypencil , apcc_zpencil , dm % dpcc ) call Get_z_midp_C2P_3D ( apcc_zpencil , apcp_zpencil , dm , iacc , ibcz_bx (:), fbcz_bx (:, :, :)) call transpose_z_to_y ( apcp_zpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_x ( apcp_ypencil , apcp_xpencil , dm % dpcp ) call Get_x_midp_P2C_3D ( apcp_xpencil , accp_xpencil , dm , iacc , ibcx_bx (:)) call transpose_x_to_y ( accp_xpencil , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) bx_ccp_zpencil = accp_zpencil !---------------------------------------------------------------------------------------------------------- ! ay_cpc_xpencil to ay_pcc_xpencil acpc_xpencil = ay call Get_x_midp_C2P_3D ( acpc_xpencil , appc_xpencil , dm , iacc , ibcx_ay (:), fbcx_ay (:, :, :)) call transpose_x_to_y ( appc_xpencil , appc_ypencil , dm % dppc ) call Get_y_midp_P2C_3D ( appc_ypencil , apcc_ypencil , dm , iacc , ibcy_ay (:)) call transpose_y_to_x ( apcc_ypencil , apcc_xpencil , dm % dpcc ) ay_pcc_xpencil = apcc_xpencil ! ay_cpc_xpencil to ay_ccp_zpencil call transpose_x_to_y ( acpc_xpencil , acpc_ypencil , dm % dcpc ) call transpose_y_to_z ( acpc_ypencil , acpc_zpencil , dm % dcpc ) call Get_z_midp_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , iacc , ibcz_ay (:), fbcz_ay (:, :, :)) call transpose_z_to_y ( acpp_zpencil , acpp_ypencil , dm % dcpp ) call Get_y_midp_P2C_3D ( acpp_ypencil , accp_ypencil , dm , iacc , ibcy_ay (:)) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) ay_ccp_zpencil = accp_zpencil ! by_cpc_xpencil to by_pcc_xpencil acpc_xpencil = by call Get_x_midp_C2P_3D ( acpc_xpencil , appc_xpencil , dm , iacc , ibcx_by (:), fbcx_by (:, :, :)) call transpose_x_to_y ( appc_xpencil , appc_ypencil , dm % dppc ) call Get_y_midp_P2C_3D ( appc_ypencil , apcc_ypencil , dm , iacc , ibcy_by (:)) call transpose_y_to_x ( apcc_ypencil , apcc_xpencil , dm % dpcc ) by_pcc_xpencil = apcc_xpencil ! by_cpc_xpencil to by_ccp_zpencil call transpose_x_to_y ( acpc_xpencil , acpc_ypencil , dm % dcpc ) call transpose_y_to_z ( acpc_ypencil , acpc_zpencil , dm % dcpc ) call Get_z_midp_C2P_3D ( acpc_zpencil , acpp_zpencil , dm , iacc , ibcz_by (:), fbcz_by (:, :, :)) call transpose_z_to_y ( acpp_zpencil , acpp_ypencil , dm % dcpp ) call Get_y_midp_P2C_3D ( acpp_ypencil , accp_ypencil , dm , iacc , ibcy_by (:)) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) by_ccp_zpencil = accp_zpencil !---------------------------------------------------------------------------------------------------------- ! az_ccp_xpencil to az_cpc_ypencil accp_xpencil = az call transpose_x_to_y ( accp_xpencil , accp_ypencil , dm % dccp ) call Get_y_midp_C2P_3D ( accp_ypencil , acpp_ypencil , dm , iacc , ibcy_az (:), fbcy_az (:, :, :)) call transpose_y_to_z ( acpp_ypencil , acpp_zpencil , dm % dcpp ) call Get_z_midp_P2C_3D ( acpp_zpencil , acpc_zpencil , dm , iacc , ibcz_az (:)) call transpose_z_to_y ( acpc_zpencil , acpc_ypencil , dm % dcpc ) az_cpc_ypencil = acpc_ypencil ! az_ccp_xpencil to az_pcc_xpencil call Get_x_midp_C2P_3D ( accp_xpencil , apcp_xpencil , dm , iacc , ibcx_az (:), fbcx_az (:, :, :)) call transpose_x_to_y ( apcp_xpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_z ( apcp_ypencil , apcp_zpencil , dm % dpcp ) call Get_z_midp_P2C_3D ( apcp_zpencil , apcc_zpencil , dm , iacc , ibcz_az (:)) call transpose_z_to_y ( apcc_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , apcc_xpencil , dm % dpcc ) az_pcc_xpencil = apcc_xpencil ! bz_ccp_xpencil to bz_cpc_ypencil accp_xpencil = bz call transpose_x_to_y ( accp_xpencil , accp_ypencil , dm % dccp ) call Get_y_midp_C2P_3D ( accp_ypencil , acpp_ypencil , dm , iacc , ibcy_bz (:), fbcy_bz (:, :, :)) call transpose_y_to_z ( acpp_ypencil , acpp_zpencil , dm % dcpp ) call Get_z_midp_P2C_3D ( acpp_zpencil , acpc_zpencil , dm , iacc , ibcz_bz (:)) call transpose_z_to_y ( acpc_zpencil , acpc_ypencil , dm % dcpc ) bz_cpc_ypencil = acpc_ypencil ! bz_ccp_xpencil to bz_pcc_xpencil call Get_x_midp_C2P_3D ( accp_xpencil , apcp_xpencil , dm , iacc , ibcx_bz (:), fbcx_bz (:, :, :)) call transpose_x_to_y ( apcp_xpencil , apcp_ypencil , dm % dpcp ) call transpose_y_to_z ( apcp_ypencil , apcp_zpencil , dm % dpcp ) call Get_z_midp_P2C_3D ( apcp_zpencil , apcc_zpencil , dm , iacc , ibcz_bz (:)) call transpose_z_to_y ( apcc_zpencil , apcc_ypencil , dm % dpcc ) call transpose_y_to_x ( apcc_ypencil , apcc_xpencil , dm % dpcc ) bz_pcc_xpencil = apcc_xpencil !---------------------------------------------------------------------------------------------------------- ! Compute the cross product of two vectors (ux, uy, uz) and (bx, by, bz) ! The resulting vector (cx, cy, cz) is given by: ! cx = uy * bz - uz * by; locates at (i', j, k); require y(cpc)->y(pcc); z(ccp)->z(pcc) ! cy = uz * bx - ux * bz; locates at (i, j', k); require x(pcc)->x(cpc); z(ccp)->z(cpc) ! cz = ux * by - uy * bx; locates at (i, j, k'); require x(pcc)->x(ccp); y(cpc)->y(ccp) ! This follows the right-hand rule and produces a vector perpendicular to both input vectors. !---------------------------------------------------------------------------------------------------------- apcc_xpencil = ay_pcc_xpencil * bz_pcc_xpencil - az_pcc_xpencil * by_pcc_xpencil acpc_ypencil = az_cpc_ypencil * bx_cpc_ypencil - ax_cpc_ypencil * bz_cpc_ypencil accp_zpencil = ax_ccp_zpencil * by_ccp_zpencil - ay_ccp_zpencil * bx_ccp_zpencil ab_cross_x = apcc_xpencil call transpose_y_to_x ( acpc_ypencil , ab_cross_y , dm % dcpc ) call transpose_z_to_y ( accp_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , ab_cross_z , dm % dccp ) return end subroutine !========================================================================================================== subroutine compute_Lorentz_force ( fl , mh , dm ) use udf_type_mod use operations use decomp_2d use continuity_eq_mod use poisson_interface_mod use io_visualisation_mod implicit none !---------------------------------------------------------------------------------------------------------- ! calculate the Lozrentz-force based on a static magnetic field B, B is time-independent !---------------------------------------------------------------------------------------------------------- type ( t_flow ), intent ( inout ) :: fl type ( t_mhd ), intent ( inout ) :: mh type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: ub_cross_x real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) :: ub_cross_y real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) :: ub_cross_z real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: apcc_xpencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) :: acpc_xpencil real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) :: accp_xpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: accc_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: acpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: accp_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) :: accc_zpencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: accp_zpencil !---------------------------------------------------------------------------------------------------------- ! calculate vector u cross-product vector b in x-pencil !---------------------------------------------------------------------------------------------------------- ub_cross_x = ZERO ub_cross_y = ZERO ub_cross_z = ZERO call cross_production_mhd ( fl , mh , ub_cross_x , ub_cross_y , ub_cross_z , 'ub_cross' , dm ) #ifdef DEBUG_STEPS call write_visu_any3darray ( ub_cross_x , 'ub_cross_x' , 'debug' , dm % dpcc , dm , fl % iteration ) call write_visu_any3darray ( ub_cross_y , 'ub_cross_y' , 'debug' , dm % dcpc , dm , fl % iteration ) call write_visu_any3darray ( ub_cross_z , 'ub_cross_z' , 'debug' , dm % dccp , dm , fl % iteration ) #endif !---------------------------------------------------------------------------------------------------------- ! calculate div(ub_cross) in x-pencil !---------------------------------------------------------------------------------------------------------- call Get_divergence_vector ( ub_cross_x , ub_cross_y , ub_cross_z , mh % ep , dm ) #ifdef DEBUG_STEPS call write_visu_any3darray ( mh % ep , 'ep1' , 'debug' , dm % dccc , dm , fl % iteration ) #endif !---------------------------------------------------------------------------------------------------------- ! solving the Poisson equation for the electric potential !---------------------------------------------------------------------------------------------------------- call solve_fft_poisson ( mh % ep , dm ) #ifdef DEBUG_STEPS call write_visu_any3darray ( mh % ep , 'ep2' , 'debug' , dm % dccc , dm , fl % iteration ) #endif !---------------------------------------------------------------------------------------------------------- ! calculate the current density jx, jy, jz (a vector) !---------------------------------------------------------------------------------------------------------- call Get_x_1der_C2P_3D ( mh % ep , apcc_xpencil , dm , dm % iAccuracy , mh % ibcx_ep , mh % fbcx_ep ) mh % jx = - apcc_xpencil + ub_cross_x call transpose_x_to_y ( mh % ep , accc_ypencil , dm % dccc ) call Get_y_1der_C2P_3D ( accc_ypencil , acpc_ypencil , dm , dm % iAccuracy , mh % ibcy_ep , mh % fbcy_ep ) call transpose_y_to_x ( acpc_ypencil , acpc_xpencil , dm % dcpc ) mh % jy = - acpc_xpencil + ub_cross_y call transpose_y_to_z ( accc_ypencil , accc_zpencil , dm % dccc ) call Get_z_1der_C2P_3D ( accc_zpencil , accp_zpencil , dm , dm % iAccuracy , mh % ibcz_ep , mh % fbcz_ep ) call transpose_z_to_y ( accp_zpencil , accp_ypencil , dm % dccp ) call transpose_y_to_x ( accp_ypencil , accp_xpencil , dm % dccp ) mh % jz = - accp_xpencil + ub_cross_z #ifdef DEBUG_STEPS call write_visu_any3darray ( mh % jx , 'jx' , 'debug' , dm % dpcc , dm , fl % iteration ) call write_visu_any3darray ( mh % jy , 'jy' , 'debug' , dm % dcpc , dm , fl % iteration ) call write_visu_any3darray ( mh % jz , 'jz' , 'debug' , dm % dccp , dm , fl % iteration ) #endif !---------------------------------------------------------------------------------------------------------- ! calculate the Lorentz force lrfx, lrfy, lrfz (a vector) !---------------------------------------------------------------------------------------------------------- call cross_production_mhd ( fl , mh , fl % lrfx , fl % lrfy , fl % lrfz , 'jb_cross' , dm ) !---------------------------------------------------------------------------------------------------------- ! un-dimensionlise the value !---------------------------------------------------------------------------------------------------------- fl % lrfx = fl % lrfx * mh % Nstuart fl % lrfy = fl % lrfy * mh % Nstuart fl % lrfz = fl % lrfz * mh % Nstuart #ifdef DEBUG_STEPS call write_visu_any3darray ( fl % lrfx , 'lrfx' , 'debug' , dm % dpcc , dm , fl % iteration ) call write_visu_any3darray ( fl % lrfy , 'lrfy' , 'debug' , dm % dcpc , dm , fl % iteration ) call write_visu_any3darray ( fl % lrfz , 'lrfz' , 'debug' , dm % dccp , dm , fl % iteration ) #endif return end subroutine end module","tags":"","url":"sourcefile/eq_mhd.f90.html"},{"title":"poisson_1stderivcomp.f90 – CHAPSim2","text":"Source Code !Copyright (c) 2012-2022, Xcompact3d !This file is part of Xcompact3d (xcompact3d.com) !SPDX-License-Identifier: BSD 3-Clause module fft2decomp_interface_mod use decomp_2d use mpi_mod use parameters_constant_mod , disabled => WP !, only: zero, half, one, onepfive, two, twopfive, & !        three, pi, threepfive, four, twopi, cx_one_one use math_mod , only : cos_prec , abs_prec , sin_prec , sqrt_wp !use geometry_mod, only: alpha, beta use print_msg_mod implicit none integer :: istret integer , parameter :: IFORWARD = 1 integer , parameter :: IBACKWARD = - 1 !---------------------------------------------------------------------------------------------------------- real ( mytype ) :: xlx ! domain length real ( mytype ) :: yly ! physical domain real ( mytype ) :: zlz !---------------------------------------------------------------------------------------------------------- logical :: nclx ! logic, whether it is periodic bc logical :: ncly logical :: nclz !---------------------------------------------------------------------------------------------------------- ! below information is from incompact3d. ! Boundary conditions : ncl = 2 --> Dirichlet ! Boundary conditions : ncl = 1 --> Free-slip ! Boundary conditions : ncl = 0 --> Periodic ! l: power of 2,3,4,5 and 6 ! if ncl = 1 or 2, --> n  = 2l+ 1 !                  --> nm = n - 1 !                  --> m  = n + 1 ! If ncl = 0,      --> n  = 2*l !                  --> nm = n !                  --> m  = n + 2 integer :: nclx1 ! boundary condition, velocity integer :: ncly1 integer :: nclz1 !---------------------------------------------------------------------------------------------------------- integer , save :: nx ! computational node number integer , save :: ny integer , save :: nz !---------------------------------------------------------------------------------------------------------- integer , save :: nxm ! number of spacing integer , save :: nym integer , save :: nzm !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: dx real ( mytype ), save :: dy ! physical grid spacing real ( mytype ), save :: dz real ( mytype ), save :: alpha , beta !---------------------------------------------------------------------------------------------------------- !real(mytype) :: alpha !real(mytype) :: beta !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: alcaix6 real ( mytype ), save :: acix6 real ( mytype ), save :: bcix6 !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: alcaiy6 real ( mytype ), save :: aciy6 real ( mytype ), save :: bciy6 !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: alcaiz6 real ( mytype ), save :: aciz6 real ( mytype ), save :: bciz6 !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: ailcaix6 real ( mytype ), save :: aicix6 real ( mytype ), save :: bicix6 real ( mytype ), save :: cicix6 real ( mytype ), save :: dicix6 !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: ailcaiy6 real ( mytype ), save :: aiciy6 real ( mytype ), save :: biciy6 real ( mytype ), save :: ciciy6 real ( mytype ), save :: diciy6 !---------------------------------------------------------------------------------------------------------- real ( mytype ), save :: ailcaiz6 real ( mytype ), save :: aiciz6 real ( mytype ), save :: biciz6 real ( mytype ), save :: ciciz6 real ( mytype ), save :: diciz6 !---------------------------------------------------------------------------------------------------------- !module waves complex ( mytype ), allocatable , dimension (:), save :: zkz , zk2 , ezs complex ( mytype ), allocatable , dimension (:), save :: yky , yk2 , eys complex ( mytype ), allocatable , dimension (:), save :: xkx , xk2 , exs public :: build_up_fft2decomp_interface contains !========================================================================================================== subroutine build_up_fft2decomp_interface ( dm ) use udf_type_mod use parameters_constant_mod use operations implicit none type ( t_domain ), intent ( in ) :: dm !real(WP) :: alcai, aci, bci if ( nrank == 0 ) call Print_debug_start_msg ( \"Building up the interface for the poisson solver ...\" ) !---------------------------------------------------------------------------------------------------------- istret = dm % istret beta = dm % rstret alpha = ( - ONE + sqrt_wp ( ONE + FOUR * PI * PI * beta * beta ) ) / beta * HALF !---------------------------------------------------------------------------------------------------------- xlx = dm % lxx yly = dm % lyt - dm % lyb ! check computational or physical length? zlz = dm % lzz !---------------------------------------------------------------------------------------------------------- nclx = dm % is_periodic ( 1 ) ncly = dm % is_periodic ( 2 ) nclz = dm % is_periodic ( 3 ) !---------------------------------------------------------------------------------------------------------- !   nclx1, ncly1, nclz1 are not used for poisson solver but only for debugging. !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_qx ( 1 ) == IBC_PERIODIC ) then nclx1 = 0 else if ( dm % ibcx_qx ( 1 ) == IBC_DIRICHLET ) then nclx1 = 2 else nclx1 = 1 end if if ( dm % ibcy_qx ( 1 ) == IBC_PERIODIC ) then ncly1 = 0 else if ( dm % ibcy_qx ( 1 ) == IBC_DIRICHLET ) then ncly1 = 2 else ncly1 = 1 end if if ( dm % ibcz_qx ( 1 ) == IBC_PERIODIC ) then nclz1 = 0 else if ( dm % ibcz_qx ( 1 ) == IBC_DIRICHLET ) then nclz1 = 2 else nclz1 = 1 end if !---------------------------------------------------------------------------------------------------------- if ( nclx ) then nx = dm % np_geo ( 1 ) - 1 nxm = dm % np_geo ( 1 ) - 1 else nx = dm % np_geo ( 1 ) - 1 nxm = dm % np_geo ( 1 ) - 1 end if if ( ncly ) then ny = dm % np_geo ( 2 ) - 1 nym = dm % np_geo ( 2 ) - 1 else ny = dm % np_geo ( 2 ) - 1 nym = dm % np_geo ( 2 ) - 1 end if if ( nclz ) then nz = dm % np_geo ( 3 ) - 1 nzm = dm % np_geo ( 3 ) - 1 else nz = dm % np_geo ( 3 ) - 1 nzm = dm % np_geo ( 3 ) - 1 end if !---------------------------------------------------------------------------------------------------------- !write(*,*) 'nx, ny, nz, nxm, nym, nzm:(var)', nx, ny, nz, nxm, nym, nzm dx = dm % h ( 1 ) dy = dm % h ( 2 ) !(dm%lyt - dm%lyb) / real(dm%nc(2), WP) !dm%h(2) ! check, computational or physical grid spacing (yes))? dz = dm % h ( 3 ) !---------------------------------------------------------------------------------------------------------- !alpha, beta from geo !---------------------------------------------------------------------------------------------------------- ! if(dm%iAccuracy == IACCU_CD2) then !   alcai = ZERO !   aci = ONE !   bci = ZERO ! else !   alcai = NINE / SIXTYTWO !   aci = SIXTYTHREE / SIXTYTWO !   bci = SEVENTEEN / SIXTYTWO / THREE ! end if alcaix6 = d1fC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) acix6 = d1rC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) / dx bcix6 = d1rC2P ( 3 , 2 , IBC_PERIODIC , dm % iAccuracy ) / dx alcaiy6 = d1fC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) aciy6 = d1rC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) / dy bciy6 = d1rC2P ( 3 , 2 , IBC_PERIODIC , dm % iAccuracy ) / dy alcaiz6 = d1fC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) aciz6 = d1rC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) / dz bciz6 = d1rC2P ( 3 , 2 , IBC_PERIODIC , dm % iAccuracy ) / dz ! ! only IBC_PERIODIC is necessary, as all non-period data are converted to periodic data. ! if(dm%ibcx(1, 1) == IBC_PERIODIC ) then !     alcaix6 = d1fC2P(3, 1, IBC_PERIODIC) !     acix6   = d1rC2P(3, 1, IBC_PERIODIC) / dx !     bcix6   = d1rC2P(3, 2, IBC_PERIODIC) / dx ! else if (dm%ibcx(1, 1) == IBC_DIRICHLET ) then !     alcaix6 = d1fC2P(3, 1, IBC_DIRICHLET) !     acix6   = d1rC2P(3, 1, IBC_DIRICHLET) / dx !     bcix6   = d1rC2P(3, 2, IBC_DIRICHLET) / dx ! else ! ! to add and check ! end if ! if(dm%ibcy(1, 2) == IBC_PERIODIC ) then !     alcaiy6 = d1fC2P(3, 1, IBC_PERIODIC) !     aciy6   = d1rC2P(3, 1, IBC_PERIODIC) / dy !     bciy6   = d1rC2P(3, 2, IBC_PERIODIC) / dy ! else if (dm%ibcy(1, 2) == IBC_DIRICHLET ) then !     alcaiy6 = d1fC2P(3, 1, IBC_DIRICHLET) !     aciy6   = d1rC2P(3, 1, IBC_DIRICHLET) / dy !     bciy6   = d1rC2P(3, 2, IBC_DIRICHLET) / dy ! else ! ! to add and check ! end if ! if(dm%ibcz(1, 3) == IBC_PERIODIC ) then !     alcaiz6 = d1fC2P(3, 1, IBC_PERIODIC) !     aciz6   = d1rC2P(3, 1, IBC_PERIODIC) / dz !     bciz6   = d1rC2P(3, 2, IBC_PERIODIC) / dz ! else if (dm%ibcz(1, 3) == IBC_DIRICHLET ) then !     alcaiz6 = d1fC2P(3, 1, IBC_PERIODIC) !     aciz6   = d1rC2P(3, 1, IBC_PERIODIC) / dz !     bciz6   = d1rC2P(3, 2, IBC_PERIODIC) / dz ! else ! ! to add and check ! end if #ifdef DEBUG_STEPS write ( * , * ) '1stder, alpha, a, b/3 = ' , alcaix6 , acix6 * dx , bcix6 * dx #endif !---------------------------------------------------------------------------------------------------------- !   only classic interpolation, no optimized schemes added here. check paper S. Lele 1992 !   check pros of optimized schemes, to do (see below info from xcompact3d) !*``ipinter=1``: conventional sixth-order interpolation coefficients as described in `Lele 1992 <https://www.sciencedirect.com/science/article/pii/002199919290324R>`_\\ !*``ipinter=2``: optimal sixth-order interpolation coefficients designed to be as close as possible to spectral interpolators. !*``ipinter=3``: aggressive sixth-order interpolation coefficients designed to add some numerical dissipation at small scales but they could result in spurious oscillations close to a wall. ! if(dm%iAccuracy == IACCU_CD2) then !   ailcaix6 = ZERO !   aicix6 = HALF !   bicix6 = ZERO !   cicix6 = ZERO !   dicix6 = ZERO ! else !   ailcaix6 = THREE * ZPONE !   aicix6 = ONEPFIVE * HALF !   bicix6 = ONE * ZPONE * HALF !   cicix6 = ZERO !   dicix6 = ZERO ! end if ailcaix6 = m1fC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) aicix6 = m1rC2P ( 3 , 1 , IBC_PERIODIC , dm % iAccuracy ) bicix6 = m1rC2P ( 3 , 2 , IBC_PERIODIC , dm % iAccuracy ) cicix6 = zero dicix6 = zero ailcaiy6 = ailcaix6 aiciy6 = aicix6 biciy6 = bicix6 ciciy6 = cicix6 diciy6 = dicix6 ailcaiz6 = ailcaix6 aiciz6 = aicix6 biciz6 = bicix6 ciciz6 = cicix6 diciz6 = dicix6 ! if(dm%ibcx(1, 1) == IBC_PERIODIC ) then !     ailcaix6 = m1fC2P(3, 1, IBC_PERIODIC) !     aicix6   = m1rC2P(3, 1, IBC_PERIODIC) !     bicix6   = m1rC2P(3, 2, IBC_PERIODIC) !     cicix6   = zero !     dicix6   = zero ! else if (dm%ibcx(1, 1) == IBC_DIRICHLET ) then !     ailcaix6 = m1fC2P(3, 1, IBC_DIRICHLET) !     aicix6   = m1rC2P(3, 1, IBC_DIRICHLET) !     bicix6   = m1rC2P(3, 2, IBC_DIRICHLET) !     cicix6   = zero !     dicix6   = zero ! else ! ! to add and check ! end if ! if(dm%ibcy(1, 2) == IBC_PERIODIC ) then !     ailcaiy6 = m1fC2P(3, 1, IBC_PERIODIC) !     aiciy6   = m1rC2P(3, 1, IBC_PERIODIC) !     biciy6   = m1rC2P(3, 2, IBC_PERIODIC) !     ciciy6   = zero !     diciy6   = zero ! else if (dm%ibcy(1, 2) == IBC_DIRICHLET ) then !     ailcaiy6 = m1fC2P(3, 1, IBC_DIRICHLET) !     aiciy6   = m1rC2P(3, 1, IBC_DIRICHLET) !     biciy6   = m1rC2P(3, 2, IBC_DIRICHLET) !     ciciy6   = zero !     diciy6   = zero ! else ! ! to add and check ! end if ! if(dm%ibcz(1, 3) == IBC_PERIODIC ) then !     ailcaiz6 = m1fC2P(3, 1, IBC_PERIODIC) !     aiciz6   = m1rC2P(3, 1, IBC_PERIODIC) !     biciz6   = m1rC2P(3, 2, IBC_PERIODIC) !     ciciz6   = zero !     diciz6   = zero ! else if (dm%ibcz(1, 3) == IBC_DIRICHLET ) then !     ailcaiz6 = m1fC2P(3, 1, IBC_DIRICHLET) !     aiciz6   = m1rC2P(3, 1, IBC_DIRICHLET) !     biciz6   = m1rC2P(3, 2, IBC_DIRICHLET) !     ciciz6   = zero !     diciz6   = zero ! else ! ! to add and check ! end if #ifdef DEBUG_STEPS write ( * , * ) 'interp, alpha, a/2, b/4 = ' , ailcaix6 , aicix6 , bicix6 #endif !---------------------------------------------------------------------------------------------------------- !module waves allocate ( zkz ( nz / 2 + 1 )) zkz = zero allocate ( zk2 ( nz / 2 + 1 )) zk2 = zero allocate ( ezs ( nz / 2 + 1 )) ezs = zero allocate ( yky ( ny )) yky = zero allocate ( yk2 ( ny )) yk2 = zero allocate ( eys ( ny )) eys = zero allocate ( xkx ( nx )) xkx = zero allocate ( xk2 ( nx )) xk2 = zero allocate ( exs ( nx )) exs = zero if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine build_up_fft2decomp_interface end module !========================================================================================================== ! below functions and subroutines are from incompact3d. ! please do not change them except \"use xxx\" !========================================================================================================== !################################################################## ! function rl(complexnumber) from incompact3d !################################################################## function rl ( complexnumber ) !use param use decomp_2d_mpi , only : mytype implicit none real ( mytype ) :: rl complex ( mytype ) :: complexnumber rl = real ( complexnumber , kind = mytype ) end function rl !################################################################## ! function iy(complexnumber) from incompact3d !################################################################## function iy ( complexnumber ) !use param use decomp_2d_constants , only : mytype implicit none real ( mytype ) :: iy complex ( mytype ) :: complexnumber iy = aimag ( complexnumber ) end function iy !################################################################## ! function cx(realpart,imaginarypart) from incompact3d !################################################################## function cx ( realpart , imaginarypart ) !use param use decomp_2d_constants , only : mytype implicit none complex ( mytype ) :: cx real ( mytype ) :: realpart , imaginarypart cx = cmplx ( realpart , imaginarypart , kind = mytype ) end function cx !========================================================================================================== !################################################################## !################################################################## subroutine inversion5_v1 ( aaa_in , eee , spI ) use decomp_2d !use decomp_2d_poisson !use variables !use param !use var !use mpi !use dbg_schemes, only: abs_prec use fft2decomp_interface_mod implicit none ! decomposition object for spectral space TYPE ( DECOMP_INFO ) :: spI #ifdef DOUBLE_PREC real ( mytype ), parameter :: epsilon = 1.e-16_mytype #else real ( mytype ), parameter :: epsilon = 1.e-8_mytype #endif complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), ny / 2 , spI % yst ( 3 ): spI % yen ( 3 ), 5 ) :: aaa , aaa_in complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), spI % yst ( 2 ): spI % yen ( 2 ), spI % yst ( 3 ): spI % yen ( 3 )) :: eee integer :: i , j , k , m , mi , jc integer , dimension ( 2 ) :: ja , jb complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), spI % yst ( 3 ): spI % yen ( 3 )) :: sr complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), spI % yst ( 3 ): spI % yen ( 3 )) :: a1 , b1 real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy aaa = aaa_in do i = 1 , 2 ja ( i ) = 4 - i jb ( i ) = 5 - i enddo do m = 1 , ny / 2 - 2 do i = 1 , 2 mi = m + i do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) if ( rl ( aaa ( j , m , k , 3 )) /= zero ) tmp1 = rl ( aaa ( j , mi , k , 3 - i )) / rl ( aaa ( j , m , k , 3 )) if ( iy ( aaa ( j , m , k , 3 )) /= zero ) tmp2 = iy ( aaa ( j , mi , k , 3 - i )) / iy ( aaa ( j , m , k , 3 )) sr ( j , k ) = cx ( tmp1 , tmp2 ) eee ( j , mi , k ) = cx ( rl ( eee ( j , mi , k )) - tmp1 * rl ( eee ( j , m , k )),& iy ( eee ( j , mi , k )) - tmp2 * iy ( eee ( j , m , k ))) enddo enddo do jc = ja ( i ), jb ( i ) do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) aaa ( j , mi , k , jc ) = cx ( rl ( aaa ( j , mi , k , jc )) - rl ( sr ( j , k )) * rl ( aaa ( j , m , k , jc + i )),& iy ( aaa ( j , mi , k , jc )) - iy ( sr ( j , k )) * iy ( aaa ( j , m , k , jc + i ))) enddo enddo enddo enddo enddo do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) if ( abs_prec ( rl ( aaa ( j , ny / 2 - 1 , k , 3 ))) > epsilon ) then tmp1 = rl ( aaa ( j , ny / 2 , k , 2 )) / rl ( aaa ( j , ny / 2 - 1 , k , 3 )) else tmp1 = zero endif if ( abs_prec ( iy ( aaa ( j , ny / 2 - 1 , k , 3 ))) > epsilon ) then tmp2 = iy ( aaa ( j , ny / 2 , k , 2 )) / iy ( aaa ( j , ny / 2 - 1 , k , 3 )) else tmp2 = zero endif sr ( j , k ) = cx ( tmp1 , tmp2 ) b1 ( j , k ) = cx ( rl ( aaa ( j , ny / 2 , k , 3 )) - tmp1 * rl ( aaa ( j , ny / 2 - 1 , k , 4 )),& iy ( aaa ( j , ny / 2 , k , 3 )) - tmp2 * iy ( aaa ( j , ny / 2 - 1 , k , 4 ))) if ( abs_prec ( rl ( b1 ( j , k ))) > epsilon ) then tmp1 = rl ( sr ( j , k )) / rl ( b1 ( j , k )) tmp3 = rl ( eee ( j , ny / 2 , k )) / rl ( b1 ( j , k )) - tmp1 * rl ( eee ( j , ny / 2 - 1 , k )) else tmp1 = zero tmp3 = zero endif if ( abs_prec ( iy ( b1 ( j , k ))) > epsilon ) then tmp2 = iy ( sr ( j , k )) / iy ( b1 ( j , k )) tmp4 = iy ( eee ( j , ny / 2 , k )) / iy ( b1 ( j , k )) - tmp2 * iy ( eee ( j , ny / 2 - 1 , k )) else tmp2 = zero tmp4 = zero endif a1 ( j , k ) = cx ( tmp1 , tmp2 ) eee ( j , ny / 2 , k ) = cx ( tmp3 , tmp4 ) if ( abs_prec ( rl ( aaa ( j , ny / 2 - 1 , k , 3 ))) > epsilon ) then tmp1 = one / rl ( aaa ( j , ny / 2 - 1 , k , 3 )) else tmp1 = zero endif if ( abs_prec ( iy ( aaa ( j , ny / 2 - 1 , k , 3 ))) > epsilon ) then tmp2 = one / iy ( aaa ( j , ny / 2 - 1 , k , 3 )) else tmp2 = zero endif b1 ( j , k ) = cx ( tmp1 , tmp2 ) a1 ( j , k ) = cx ( rl ( aaa ( j , ny / 2 - 1 , k , 4 )) * rl ( b1 ( j , k )),& iy ( aaa ( j , ny / 2 - 1 , k , 4 )) * iy ( b1 ( j , k ))) eee ( j , ny / 2 - 1 , k ) = cx ( rl ( eee ( j , ny / 2 - 1 , k )) * rl ( b1 ( j , k )) - rl ( a1 ( j , k )) * rl ( eee ( j , ny / 2 , k )),& iy ( eee ( j , ny / 2 - 1 , k )) * iy ( b1 ( j , k )) - iy ( a1 ( j , k )) * iy ( eee ( j , ny / 2 , k ))) enddo enddo do i = ny / 2 - 2 , 1 , - 1 do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) if ( abs_prec ( rl ( aaa ( j , i , k , 3 ))) > epsilon ) then tmp1 = one / rl ( aaa ( j , i , k , 3 )) else tmp1 = zero endif if ( abs_prec ( iy ( aaa ( j , i , k , 3 ))) > epsilon ) then tmp2 = one / iy ( aaa ( j , i , k , 3 )) else tmp2 = zero endif sr ( j , k ) = cx ( tmp1 , tmp2 ) a1 ( j , k ) = cx ( rl ( aaa ( j , i , k , 4 )) * rl ( sr ( j , k )),& iy ( aaa ( j , i , k , 4 )) * iy ( sr ( j , k ))) b1 ( j , k ) = cx ( rl ( aaa ( j , i , k , 5 )) * rl ( sr ( j , k )),& iy ( aaa ( j , i , k , 5 )) * iy ( sr ( j , k ))) eee ( j , i , k ) = cx ( rl ( eee ( j , i , k )) * rl ( sr ( j , k )) - rl ( a1 ( j , k )) * rl ( eee ( j , i + 1 , k )) - rl ( b1 ( j , k )) * rl ( eee ( j , i + 2 , k )),& iy ( eee ( j , i , k )) * iy ( sr ( j , k )) - iy ( a1 ( j , k )) * iy ( eee ( j , i + 1 , k )) - iy ( b1 ( j , k )) * iy ( eee ( j , i + 2 , k ))) enddo enddo enddo return end subroutine inversion5_v1 !################################################################## !################################################################## subroutine inversion5_v2 ( aaa , eee , spI ) use decomp_2d !use decomp_2d_poisson !use variables !use param !use var !use MPI !use dbg_schemes, only: abs_prec use fft2decomp_interface_mod implicit none ! decomposition object for spectral space TYPE ( DECOMP_INFO ) :: spI #ifdef DOUBLE_PREC real ( mytype ), parameter :: epsilon = 1.e-16_mytype #else real ( mytype ), parameter :: epsilon = 1.e-8_mytype #endif complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), nym , spI % yst ( 3 ): spI % yen ( 3 ), 5 ) :: aaa complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), nym , spI % yst ( 3 ): spI % yen ( 3 )) :: eee integer :: i , j , k , m , mi , jc integer , dimension ( 2 ) :: ja , jb complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), spI % yst ( 3 ): spI % yen ( 3 )) :: sr complex ( mytype ), dimension ( spI % yst ( 1 ): spI % yen ( 1 ), spI % yst ( 3 ): spI % yen ( 3 )) :: a1 , b1 real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy do i = 1 , 2 ja ( i ) = 4 - i jb ( i ) = 5 - i enddo do m = 1 , nym - 2 do i = 1 , 2 mi = m + i do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) if ( rl ( aaa ( j , m , k , 3 )) /= zero ) tmp1 = rl ( aaa ( j , mi , k , 3 - i )) / rl ( aaa ( j , m , k , 3 )) if ( iy ( aaa ( j , m , k , 3 )) /= zero ) tmp2 = iy ( aaa ( j , mi , k , 3 - i )) / iy ( aaa ( j , m , k , 3 )) sr ( j , k ) = cx ( tmp1 , tmp2 ) eee ( j , mi , k ) = cx ( rl ( eee ( j , mi , k )) - tmp1 * rl ( eee ( j , m , k )),& iy ( eee ( j , mi , k )) - tmp2 * iy ( eee ( j , m , k ))) enddo enddo do jc = ja ( i ), jb ( i ) do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) aaa ( j , mi , k , jc ) = cx ( rl ( aaa ( j , mi , k , jc )) - rl ( sr ( j , k )) * rl ( aaa ( j , m , k , jc + i )),& iy ( aaa ( j , mi , k , jc )) - iy ( sr ( j , k )) * iy ( aaa ( j , m , k , jc + i ))) enddo enddo enddo enddo enddo do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) if ( abs_prec ( rl ( aaa ( j , nym - 1 , k , 3 ))) > epsilon ) then tmp1 = rl ( aaa ( j , nym , k , 2 )) / rl ( aaa ( j , nym - 1 , k , 3 )) else tmp1 = zero endif if ( abs_prec ( iy ( aaa ( j , nym - 1 , k , 3 ))) > epsilon ) then tmp2 = iy ( aaa ( j , nym , k , 2 )) / iy ( aaa ( j , nym - 1 , k , 3 )) else tmp2 = zero endif sr ( j , k ) = cx ( tmp1 , tmp2 ) b1 ( j , k ) = cx ( rl ( aaa ( j , nym , k , 3 )) - tmp1 * rl ( aaa ( j , nym - 1 , k , 4 )),& iy ( aaa ( j , nym , k , 3 )) - tmp2 * iy ( aaa ( j , nym - 1 , k , 4 ))) if ( abs_prec ( rl ( b1 ( j , k ))) > epsilon ) then tmp1 = rl ( sr ( j , k )) / rl ( b1 ( j , k )) tmp3 = rl ( eee ( j , nym , k )) / rl ( b1 ( j , k )) - tmp1 * rl ( eee ( j , nym - 1 , k )) else tmp1 = zero tmp3 = zero endif if ( abs_prec ( iy ( b1 ( j , k ))) > epsilon ) then tmp2 = iy ( sr ( j , k )) / iy ( b1 ( j , k )) tmp4 = iy ( eee ( j , nym , k )) / iy ( b1 ( j , k )) - tmp2 * iy ( eee ( j , nym - 1 , k )) else tmp2 = zero tmp4 = zero endif a1 ( j , k ) = cx ( tmp1 , tmp2 ) eee ( j , nym , k ) = cx ( tmp3 , tmp4 ) if ( abs_prec ( rl ( aaa ( j , nym - 1 , k , 3 ))) > epsilon ) then tmp1 = one / rl ( aaa ( j , nym - 1 , k , 3 )) else tmp1 = zero endif if ( abs_prec ( iy ( aaa ( j , nym - 1 , k , 3 ))) > epsilon ) then tmp2 = one / iy ( aaa ( j , nym - 1 , k , 3 )) else tmp2 = zero endif b1 ( j , k ) = cx ( tmp1 , tmp2 ) a1 ( j , k ) = cx ( rl ( aaa ( j , nym - 1 , k , 4 )) * rl ( b1 ( j , k )),& iy ( aaa ( j , nym - 1 , k , 4 )) * iy ( b1 ( j , k ))) eee ( j , nym - 1 , k ) = cx ( rl ( eee ( j , nym - 1 , k )) * rl ( b1 ( j , k )) - rl ( a1 ( j , k )) * rl ( eee ( j , nym , k )),& iy ( eee ( j , nym - 1 , k )) * iy ( b1 ( j , k )) - iy ( a1 ( j , k )) * iy ( eee ( j , nym , k ))) enddo enddo do i = nym - 2 , 1 , - 1 do k = spI % yst ( 3 ), spI % yen ( 3 ) do j = spI % yst ( 1 ), spI % yen ( 1 ) if ( abs_prec ( rl ( aaa ( j , i , k , 3 ))) > epsilon ) then tmp1 = one / rl ( aaa ( j , i , k , 3 )) else tmp1 = zero endif if ( abs_prec ( iy ( aaa ( j , i , k , 3 ))) > epsilon ) then tmp2 = one / iy ( aaa ( j , i , k , 3 )) else tmp2 = zero endif sr ( j , k ) = cx ( tmp1 , tmp2 ) a1 ( j , k ) = cx ( rl ( aaa ( j , i , k , 4 )) * rl ( sr ( j , k )),& iy ( aaa ( j , i , k , 4 )) * iy ( sr ( j , k ))) b1 ( j , k ) = cx ( rl ( aaa ( j , i , k , 5 )) * rl ( sr ( j , k )),& iy ( aaa ( j , i , k , 5 )) * iy ( sr ( j , k ))) eee ( j , i , k ) = cx ( rl ( eee ( j , i , k )) * rl ( sr ( j , k )) - rl ( a1 ( j , k )) * rl ( eee ( j , i + 1 , k )) - rl ( b1 ( j , k )) * rl ( eee ( j , i + 2 , k )),& iy ( eee ( j , i , k )) * iy ( sr ( j , k )) - iy ( a1 ( j , k )) * iy ( eee ( j , i + 1 , k )) - iy ( b1 ( j , k )) * iy ( eee ( j , i + 2 , k ))) enddo enddo enddo return end subroutine inversion5_v2 !################################################################## module decomp_2d_poisson use decomp_2d use decomp_2d_fft use fft2decomp_interface_mod !use param !use variables implicit none private ! Make everything private unless declared public !  real(mytype), private, parameter :: PI = 3.14159265358979323846_mytype #ifdef DOUBLE_PREC real ( mytype ), parameter :: epsilon = 1.e-16_mytype #else real ( mytype ), parameter :: epsilon = 1.e-8_mytype #endif ! boundary conditions integer , save :: bcx , bcy , bcz ! decomposition object for physical space type ( DECOMP_INFO ), save :: ph ! decomposition object for spectral space type ( DECOMP_INFO ), save :: sp ! store sine/cosine factors real ( mytype ), save , allocatable , dimension (:) :: az , bz real ( mytype ), save , allocatable , dimension (:) :: ay , by real ( mytype ), save , allocatable , dimension (:) :: ax , bx ! wave numbers complex ( mytype ), save , allocatable , dimension (:,:,:) :: kxyz !wave numbers for stretching in a pentadiagonal matrice complex ( mytype ), save , allocatable , dimension (:,:,:,:) :: a , a2 , a3 ! work arrays, ! naming convention: cw (complex); rw (real); !                    1 = X-pencil; 2 = Y-pencil; 3 = Z-pencil real ( mytype ), allocatable , dimension (:,:,:) :: rw1 , rw1b , rw2 , rw2b , rw3 complex ( mytype ), allocatable , dimension (:,:,:) :: cw1 , cw1b , cw2 , cw22 , cw2b , cw2c ! underlying FFT library only needs to be initialised once logical , save :: fft_initialised = . false . abstract interface subroutine poisson_xxx ( rhs ) use decomp_2d_constants , only : mytype real ( mytype ), dimension (:,:,:), intent ( inout ) :: rhs end subroutine poisson_xxx end interface procedure ( poisson_xxx ), pointer :: poisson public :: decomp_2d_poisson_init , decomp_2d_poisson_finalize , poisson contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Initialise Poisson solver for given boundary conditions !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine decomp_2d_poisson_init () implicit none integer :: nx , ny , nz , i real ( mytype ) :: rl , iy external rl , iy if ( nclx ) then bcx = 0 else bcx = 1 endif if ( ncly ) then bcy = 0 else bcy = 1 endif if ( nclz ) then bcz = 0 else bcz = 1 endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Top level wrapper !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( bcx == 0 . and . bcy == 0 . and . bcz == 0 ) then poisson => poisson_000 #ifdef DEBUG_STEPS write ( * , * ) 'poisson_000 is used.' #endif else if ( bcx == 1 . and . bcy == 0 . and . bcz == 0 ) then poisson => poisson_100 #ifdef DEBUG_STEPS write ( * , * ) 'poisson_100 is used.' #endif else if ( bcx == 0 . and . bcy == 1 . and . bcz == 0 ) then poisson => poisson_010 #ifdef DEBUG_STEPS write ( * , * ) 'poisson_010 is used.' #endif else if ( bcx == 1 . and . bcy == 1 ) then ! 110 & 111 poisson => poisson_11x #ifdef DEBUG_STEPS write ( * , * ) 'poisson_11x is used.' #endif else error stop 'boundary condition not supported' end if nx = nx_global ny = ny_global nz = nz_global ! pressure-grid having 1 fewer point for non-periodic directions if ( bcx == 1 ) nx = nx - 1 if ( bcy == 1 ) ny = ny - 1 if ( bcz == 1 ) nz = nz - 1 #ifdef DEBUG_STEPS if ( nrank == 0 ) then write ( * , * ) 'nx_global, ny_global, nz_global ' , nx_global , ny_global , nz_global write ( * , * ) 'nx, ny, nz, nxm, nym, nzm in FFT' , nx , ny , nz , nxm , nym , nzm end if #endif #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init start' #endif allocate ( ax ( nx ), bx ( nx )) allocate ( ay ( ny ), by ( ny )) allocate ( az ( nz ), bz ( nz )) call abxyz ( ax , ay , az , bx , by , bz , nx , ny , nz , bcx , bcy , bcz ) #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init decomp_info_init' #endif call decomp_info_init ( nx , ny , nz , ph ) call decomp_info_init ( nx , ny , nz / 2 + 1 , sp ) #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init decomp_info_init ok' #endif ! allocate work space if ( bcx == 0 . and . bcy == 0 . and . bcz == 0 ) then allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( kxyz ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), ny , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) else if ( bcx == 1 . and . bcy == 0 . and . bcz == 0 ) then allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw1b ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( rw1 ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw1b ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw2 ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( kxyz ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), ny , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) else if ( bcx == 0 . and . bcy == 1 . and . bcz == 0 ) then allocate ( rw2 ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( rw2b ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw2 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw22 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2b ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2c ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( kxyz ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), ny , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) else if ( bcx == 1 . and . bcy == 1 ) then allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw1b ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw2 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw22 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2b ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2c ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( rw1 ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw1b ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw2 ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( rw2b ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) if ( bcz == 1 ) then allocate ( rw3 ( ph % zsz ( 1 ), ph % zsz ( 2 ), ph % zsz ( 3 ))) end if allocate ( kxyz ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), nym , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) end if #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init before waves' #endif call waves () if ( bcy == 1 . and . istret /= 0 ) call matrice_refinement () !write(*,*) 'POinit ii1 arl ', rl(a(1,1,1,1)),rl(a(1,1,1,2)),rl(a(1,1,1,3)),& !                              rl(a(1,1,1,4)),rl(a(1,1,1,5)) !write(*,*) 'POinit ii1 aiy ', iy(a(1,1,1,1)),iy(a(1,1,1,2)),iy(a(1,1,1,3)),& !                              iy(a(1,1,1,4)),iy(a(1,1,1,5)) !! !write(*,*) 'POinit ii5 arl ', rl(a(5,5,5,1)),rl(a(5,5,5,2)),rl(a(5,5,5,3)),& !                              rl(a(5,5,5,4)),rl(a(5,5,5,5)) !write(*,*) 'POinit ii5 aiy ', iy(a(5,5,5,1)),iy(a(5,5,5,2)),iy(a(5,5,5,3)),& !                              iy(a(5,5,5,4)),iy(a(5,5,5,5)) !!! !write(*,*) 'POinit ii1 a2rl ', rl(a2(1,1,1,1)),rl(a2(1,1,1,2)),rl(a2(1,1,1,3)),& !                               rl(a2(1,1,1,4)),rl(a2(1,1,1,5)) !write(*,*) 'POinit ii1 a2iy ', iy(a2(1,1,1,1)),iy(a2(1,1,1,2)),iy(a2(1,1,1,3)),& !                               iy(a2(1,1,1,4)),iy(a2(1,1,1,5)) !! !write(*,*) 'POinit ii5 a2rl ', rl(a2(5,5,5,1)),rl(a2(5,5,5,2)),rl(a2(5,5,5,3)),& !                               rl(a2(5,5,5,4)),rl(a2(5,5,5,5)) !write(*,*) 'POinit ii5 a2iy ', iy(a2(5,5,5,1)),iy(a2(5,5,5,2)),iy(a2(5,5,5,3)),& !                               iy(a2(5,5,5,4)),iy(a2(5,5,5,5)) !!! !write(*,*) 'POinit ii1 a3rl ', rl(a3(1,1,1,1)),rl(a3(1,1,1,2)),rl(a3(1,1,1,3)),& !                               rl(a3(1,1,1,4)),rl(a3(1,1,1,5)) !write(*,*) 'POinit ii1 a3iy ', iy(a3(1,1,1,1)),iy(a3(1,1,1,2)),iy(a3(1,1,1,3)),& !                               iy(a3(1,1,1,4)),iy(a3(1,1,1,5)) !! !write(*,*) 'POinit ii5 a3rl ', rl(a3(5,5,5,1)),rl(a3(5,5,5,2)),rl(a3(5,5,5,3)),& !                               rl(a3(5,5,5,4)),rl(a3(5,5,5,5)) !write(*,*) 'POinit ii5 a3iy ', iy(a3(5,5,5,1)),iy(a3(5,5,5,2)),iy(a3(5,5,5,3)),& !                               iy(a3(5,5,5,4)),iy(a3(5,5,5,5)) #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init end' #endif return end subroutine decomp_2d_poisson_init !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Release memory used by Poisson solver !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine decomp_2d_poisson_finalize implicit none deallocate ( ax , bx , ay , by , az , bz ) call decomp_info_finalize ( ph ) call decomp_info_finalize ( sp ) call decomp_2d_fft_finalize fft_initialised = . false . deallocate ( kxyz ) if ( bcx == 0 . and . bcy == 0 . and . bcz == 0 ) then deallocate ( cw1 ) deallocate ( a , a2 , a3 ) else if ( bcx == 1 . and . bcy == 0 . and . bcz == 0 ) then deallocate ( cw1 , cw1b , rw1 , rw1b , rw2 ) deallocate ( a , a2 , a3 ) else if ( bcx == 0 . and . bcy == 1 . and . bcz == 0 ) then deallocate ( cw1 , cw2 , cw2b , rw2 , rw2b ) deallocate ( a , a2 , a3 ) else if ( bcx == 1 . and . bcy == 1 ) then deallocate ( cw1 , cw1b , cw2 , cw2b , rw1 , rw1b , rw2 , rw2b ) deallocate ( a , a2 , a3 ) if ( bcz == 1 ) then deallocate ( rw3 ) end if end if return end subroutine decomp_2d_poisson_finalize !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Solving 3D Poisson equation with periodic B.C in all 3 dimensions !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine poisson_000 ( rhs ) !use derivX !use derivY !use derivZ ! right-hand-side of Poisson as input ! solution of Poisson as output real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs integer , dimension ( 3 ) :: fft_start , fft_end , fft_size complex ( mytype ) :: xyzk complex ( mytype ) :: ytt , xtt , ztt , yt1 , xt1 , yt2 , xt2 complex ( mytype ) :: xtt1 , ytt1 , ztt1 , zt1 , zt2 real ( mytype ) :: tmp1 , tmp2 , x , y , z , avg_param integer :: nx , ny , nz , i , j , k complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy nx = nx_global ny = ny_global nz = nz_global if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z ) fft_initialised = . true . end if #ifdef DEBUG_FFT avg_param = zero call avg3d ( rhs , avg_param ) if ( nrank == 0 ) write ( * , * ) '## rhs_ijk physical ' , avg_param #endif ! #ifdef DEBUG_FFT !     do k = ph%zst(3), ph%zen(3) !       do j = ph%zst(2), ph%zen(2) !         do i = ph%zst(1), ph%zen(1) !           write(*, *) 'd-orgn', k, j, i, rhs(i, j, k) !         end do !       end do !     end do ! #endif ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## hat_lmn(rhs_ijk) ' , avg_param #endif !   WWcoments: cw1 is at node points (x_np = 0, x_1, x_2), it needs to shif to cell centre for further calculation. !   hat_f_{i+1/2} * e&#94;(-I k_x x_{i+1/2} ) = [ hat_f_{i} * e&#94;(-I k_x x_{i} ) ] * e&#94;(-I k_x dx/2) !   = (rl + I iy)(cos(-k_x*dx/2) + i sin(-k_x * dx/2)) !   = (rl + I iy)(b - i a) !   = (rl * b + iy * a, iy * b - rl * a ) do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) ! post-processing in spectral space ! POST PROCESSING IN Z tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) ! POST PROCESSING IN Y tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * by ( j ) + tmp2 * ay ( j ), & tmp2 * by ( j ) - tmp1 * ay ( j )) if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) ! POST PROCESSING IN X tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bx ( i ) + tmp2 * ax ( i ), & tmp2 * bx ( i ) - tmp1 * ax ( i )) if ( i > ( nx / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) ! #ifdef DEBUG_FFT !              write(*, *) 'f-shif', k, j, i, cw1(i, j, k) ! #endif ! Solve Poisson tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) ! CANNOT DO A DIVISION BY ZERO if (( tmp1 < epsilon ). or .( tmp2 < epsilon )) then cw1 ( i , j , k ) = zero else cw1 ( i , j , k ) = cx ( rl ( cw1 ( i , j , k )) / ( - tmp1 ), & iy ( cw1 ( i , j , k )) / ( - tmp2 )) end if ! #ifdef DEBUG_FFT !              !Print result in spectal space after Poisson !               if (abs_prec(cw1(i,j,k)) > 1.0e-4_mytype) then !                 write(*,*) 'AFTER',i,j,k,cw1(i,j,k),xyzk !               end if ! #endif !   WWcoments: calculation is at mid points, it needs to shif back to node points. !   hat_f_i * e&#94;(-I k_x x_{i} ) = [hat_f_{i+1/2} * e&#94;(-I k_x x_{i+1/2} )] * e&#94;(+I k_x dx/2) !   = (rl + I iy)(cos(k_x*dx/2) + i sin(k_x * dx/2)) !   = (rl + I iy)(b + i a) !   = (rl * b - iy * a, iy * b + rl * a ) ! post-processing backward ! POST PROCESSING IN Z tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) !cw1(i,j,k) = cx(tmp1 * bz(k) - tmp2 * az(k), & !               -tmp2 * bz(k) - tmp1 * az(k)) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) ! POST PROCESSING IN Y tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) !cw1(i,j,k) = cx(tmp1 * by(j) + tmp2 * ay(j), & !                tmp2 * by(j) - tmp1 * ay(j)) cw1 ( i , j , k ) = cx ( tmp1 * by ( j ) - tmp2 * ay ( j ), & tmp2 * by ( j ) + tmp1 * ay ( j )) if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) ! POST PROCESSING IN X tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) !cw1(i,j,k) = cx(tmp1 * bx(i) + tmp2 * ax(i), & !               -tmp2 * bx(i) + tmp1 * ax(i)) cw1 ( i , j , k ) = cx ( tmp1 * bx ( i ) - tmp2 * ax ( i ), & tmp2 * bx ( i ) + tmp1 * ax ( i )) if ( i > ( nx / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) ! #ifdef DEBUG_FFT !              write(*, *) 'f-back', k, j, i, cw1(i, j, k) ! #endif end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## hat_lmn(rhs_ijk/wave) ' , avg_param #endif ! compute c2r transform call decomp_2d_fft_3d ( cw1 , rhs ) ! #ifdef DEBUG_FFT !     do k = ph%zst(3), ph%zen(3) !       do j = ph%zst(2), ph%zen(2) !         do i = ph%zst(1), ph%zen(1) !           write(*, *) 'd-back', k, j, i, rhs(i, j, k) !         end do !       end do !     end do ! #endif #ifdef DEBUG_FFT avg_param = zero call avg3d ( rhs , avg_param ) if ( nrank == 0 ) write ( * , * ) '## rhs_ijk physical new' , avg_param #endif !   call decomp_2d_fft_finalize return end subroutine poisson_000 subroutine poisson_100 ( rhs ) !use dbg_schemes, only: abs_prec use math_mod , only : abs_prec implicit none real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs complex ( mytype ) :: xyzk real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 real ( mytype ) :: xx1 , xx2 , xx3 , xx4 , xx5 , xx6 , xx7 , xx8 integer :: nx , ny , nz , i , j , k , itmp complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy 100 format ( 1 x , a8 , 3 I4 , 2 F12 . 6 ) nx = nx_global - 1 ny = ny_global nz = nz_global !write(*,*) 'Poisson_100' ! rhs is in Z-pencil but requires global operations in X call transpose_z_to_y ( rhs , rw2 , ph ) call transpose_y_to_x ( rw2 , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( i , j , k ) = rw1 ( 2 * ( i - 1 ) + 1 , j , k ) enddo do i = nx / 2 + 1 , nx rw1b ( i , j , k ) = rw1 ( 2 * nx - 2 * i + 2 , j , k ) enddo enddo end do call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z , nx , ny , nz ) fft_initialised = . true . end if ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'START' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! post-processing in spectral space ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after z' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Y do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * by ( j ) + tmp2 * ay ( j ), & tmp2 * by ( j ) - tmp1 * ay ( j )) if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after y' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1b ( 1 , j , k ) = cw1 ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) tmp3 = rl ( cw1 ( nx - i + 2 , j , k )) tmp4 = iy ( cw1 ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) xx2 = tmp1 * ax ( i ) xx3 = tmp2 * bx ( i ) xx4 = tmp2 * ax ( i ) xx5 = tmp3 * bx ( i ) xx6 = tmp3 * ax ( i ) xx7 = tmp4 * bx ( i ) xx8 = tmp4 * ax ( i ) cw1b ( i , j , k ) = half * cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'after x' , i , j , k , cw1b ( i , j , k ) end if end do end do end do #endif ! Solve Poisson do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) ! CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( zero , zero ) end if if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( zero , iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( rl ( cw1b ( i , j , k )) / ( - tmp1 ), zero ) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( rl ( cw1b ( i , j , k )) / ( - tmp1 ), iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if #ifdef DEBUG_FFT if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'AFTER' , i , j , k , cw1b ( i , j , k ) #endif end do end do end do ! post-processing backward ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1 ( 1 , j , k ) = cw1b ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1b ( i , j , k )) tmp2 = iy ( cw1b ( i , j , k )) tmp3 = rl ( cw1b ( nx - i + 2 , j , k )) tmp4 = iy ( cw1b ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) xx2 = tmp1 * ax ( i ) xx3 = tmp2 * bx ( i ) xx4 = tmp2 * ax ( i ) xx5 = tmp3 * bx ( i ) xx6 = tmp3 * ax ( i ) xx7 = tmp4 * bx ( i ) xx8 = tmp4 * ax ( i ) cw1 ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER X' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! POST PROCESSING IN Y do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * by ( j ) - tmp2 * ay ( j ), & tmp2 * by ( j ) + tmp1 * ay ( j )) if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'AFTER Y' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'END' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! compute c2r transform call decomp_2d_fft_3d ( cw1 , rhs ) ! rhs is in Z-pencil but requires global operations in X call transpose_z_to_y ( rhs , rw2 , ph ) call transpose_y_to_x ( rw2 , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( 2 * i - 1 , j , k ) = rw1 ( i , j , k ) enddo do i = 1 , nx / 2 rw1b ( 2 * i , j , k ) = rw1 ( nx - i + 1 , j , k ) enddo enddo end do call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) !  call decomp_2d_fft_finalize return end subroutine poisson_100 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Solving 3D Poisson equation: Neumann in Y; periodic in X & Z !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine poisson_010 ( rhs ) !use dbg_schemes, only: abs_prec use math_mod , only : abs_prec implicit none real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs complex ( mytype ) :: xyzk real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 real ( mytype ) :: xx1 , xx2 , xx3 , xx4 , xx5 , xx6 , xx7 , xx8 integer :: nx , ny , nz , i , j , k complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy !real(mytype) :: avg_param 100 format ( 1 x , a8 , 3 I4 , 2 F12 . 6 ) nx = nx_global ny = ny_global - 1 nz = nz_global #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# Poisoon_010 Init' #endif ! rhs is in Z-pencil but requires global operations in Y call transpose_z_to_y ( rhs , rw2 , ph ) do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , j , k ) = rw2 ( i , 2 * ( j - 1 ) + 1 , k ) enddo do j = ny / 2 + 1 , ny rw2b ( i , j , k ) = rw2 ( i , 2 * ny - 2 * j + 2 , k ) enddo enddo end do call transpose_y_to_z ( rw2b , rhs , ph ) if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z , nx , ny , nz ) fft_initialised = . true . end if ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'START' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! post-processing in spectral space ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after z' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bx ( i ) + tmp2 * ax ( i ), & tmp2 * bx ( i ) - tmp1 * ax ( i )) if ( i . gt .( nx / 2 + 1 )) cw1 ( i , j , k ) =- cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after x' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Y ! NEED TO BE IN Y PENCILS!!!!!!!!!!!!!!! call transpose_x_to_y ( cw1 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , 1 , k ) = cw2 ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2 ( i , j , k )) tmp2 = iy ( cw2 ( i , j , k )) tmp3 = rl ( cw2 ( i , ny - j + 2 , k )) tmp4 = iy ( cw2 ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) xx2 = tmp1 * ay ( j ) xx3 = tmp2 * by ( j ) xx4 = tmp2 * ay ( j ) xx5 = tmp3 * by ( j ) xx6 = tmp3 * ay ( j ) xx7 = tmp4 * by ( j ) xx8 = tmp4 * ay ( j ) cw2b ( i , j , k ) = half * cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( abs_prec ( cw2b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'after y' , i , j , k , cw2b ( i , j , k ) write ( * , * ) kxyz ( i , j , k ) end if end do end do end do #endif if ( istret == 0 ) then ! Solve Poisson ! doing wave number division in Y-pencil do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) !CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw2b ( i , j , k ) = cx ( zero , zero ) end if if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw2b ( i , j , k ) = cx ( zero , iy ( cw2b ( i , j , k )) / ( - tmp2 )) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw2b ( i , j , k ) = cx ( rl ( cw2b ( i , j , k )) / ( - tmp1 ), zero ) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw2b ( i , j , k ) = cx ( rl ( cw2b ( i , j , k )) / ( - tmp1 ), iy ( cw2b ( i , j , k )) / ( - tmp2 )) end if end do end do end do else call matrice_refinement () !write(*,*) 'PO_010 ii1 A rl ', rl(a(1,1,1,1)),rl(a(1,1,1,2)),rl(a(1,1,1,3)),& !                              rl(a(1,1,1,4)),rl(a(1,1,1,5)) !write(*,*) 'PO_010 ii1 A iy ', iy(a(1,1,1,1)),iy(a(1,1,1,2)),iy(a(1,1,1,3)),& !                              iy(a(1,1,1,4)),iy(a(1,1,1,5)) !! !write(*,*) 'PO_010 ii5 A rl ', rl(a(5,5,5,1)),rl(a(5,5,5,2)),rl(a(5,5,5,3)),& !                              rl(a(5,5,5,4)),rl(a(5,5,5,5)) !write(*,*) 'PO_010 ii5 A iy ', iy(a(5,5,5,1)),iy(a(5,5,5,2)),iy(a(5,5,5,3)),& !                              iy(a(5,5,5,4)),iy(a(5,5,5,5)) !! !write(*,*) 'PO_010 ii1 A2 rl ', rl(a2(1,1,1,1)),rl(a2(1,1,1,2)),rl(a2(1,1,1,3)),& !                               rl(a2(1,1,1,4)),rl(a2(1,1,1,5)) !write(*,*) 'PO_010 ii1 A2 iy ', iy(a2(1,1,1,1)),iy(a2(1,1,1,2)),iy(a2(1,1,1,3)),& !                               iy(a2(1,1,1,4)),iy(a2(1,1,1,5)) !! !write(*,*) 'PO_010 ii5 A2 rl ', rl(a2(5,5,5,1)),rl(a2(5,5,5,2)),rl(a2(5,5,5,3)),& !                               rl(a2(5,5,5,4)),rl(a2(5,5,5,5)) !write(*,*) 'PO_010 ii5 A2 iy ', iy(a2(5,5,5,1)),iy(a2(5,5,5,2)),iy(a2(5,5,5,3)),& !                               iy(a2(5,5,5,4)),iy(a2(5,5,5,5)) !!! !!! !write(*,*) 'PO_010 ii1 A3 rl ', rl(a3(1,1,1,1)),rl(a3(1,1,1,2)),rl(a3(1,1,1,3)),& !                          rl(a3(1,1,1,4)),rl(a3(1,1,1,5)) !write(*,*) 'PO_010 ii1 A3 iy ', iy(a3(1,1,1,1)),iy(a3(1,1,1,2)),iy(a3(1,1,1,3)),& !                          iy(a3(1,1,1,4)),iy(a3(1,1,1,5)) !! !write(*,*) 'PO_010 ii5 A3 rl ', rl(a3(5,5,5,1)),rl(a3(5,5,5,2)),rl(a3(5,5,5,3)),& !                             rl(a3(5,5,5,4)),rl(a3(5,5,5,5)) !write(*,*) 'PO_010 ii5 A3 iy ', iy(a3(5,5,5,1)),iy(a3(5,5,5,2)),iy(a3(5,5,5,3)),& !                             iy(a3(5,5,5,4)),iy(a3(5,5,5,5)) if ( istret /= 3 ) then cw2 = zero cw2c = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny / 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , 2 * j - 1 , k ) cw2c ( i , j , k ) = cw2b ( i , 2 * j , k ) enddo enddo enddo call inversion5_v1 ( a , cw2 , sp ) call inversion5_v1 ( a2 , cw2c , sp ) cw2b = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny - 1 , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i ,( j + 1 ) / 2 , k ) enddo enddo do j = 2 , ny , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2c ( i , j / 2 , k ) enddo enddo enddo else do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , j , k ) enddo enddo enddo call inversion5_v2 ( a3 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i , j , k ) enddo enddo enddo endif endif !we are in Y pencil, !check below necessary? , commented by WW !  do k = sp%yst(3), sp%yen(3) !     do i = sp%yst(1), sp%yen(1) !        if ((i == nx/2+1).and.(k == nz/2+1)) then !           cw2b(i,:,k) = zero !        endif !     enddo !  enddo #ifdef DEBUG_FFT do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( abs_prec ( cw2b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER' , i , j , k , cw2b ( i , j , k ) write ( * , * ) kxyz ( i , j , k ) end if end do end do end do #endif ! post-processing backward ! POST PROCESSING IN Y do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , 1 , k ) = cw2b ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2b ( i , j , k )) tmp2 = iy ( cw2b ( i , j , k )) tmp3 = rl ( cw2b ( i , ny - j + 2 , k )) tmp4 = iy ( cw2b ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) xx2 = tmp1 * ay ( j ) xx3 = tmp2 * by ( j ) xx4 = tmp2 * ay ( j ) xx5 = tmp3 * by ( j ) xx6 = tmp3 * ay ( j ) xx7 = tmp4 * by ( j ) xx8 = tmp4 * ay ( j ) cw2 ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do ! Back to X-pencil call transpose_y_to_x ( cw2 , cw1 , sp ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER Y' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bx ( i ) - tmp2 * ax ( i ), & tmp2 * bx ( i ) + tmp1 * ax ( i )) if ( i > ( nx / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'AFTER X' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'END' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! compute c2r transform, back to physical space call decomp_2d_fft_3d ( cw1 , rhs ) ! rhs is in Z-pencil but requires global operations in Y call transpose_z_to_y ( rhs , rw2 , ph ) do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , 2 * j - 1 , k ) = rw2 ( i , j , k ) enddo do j = 1 , ny / 2 rw2b ( i , 2 * j , k ) = rw2 ( i , ny - j + 1 , k ) enddo enddo end do call transpose_y_to_z ( rw2b , rhs , ph ) !  call decomp_2d_fft_finalize return end subroutine poisson_010 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Solving 3D Poisson equation: Neumann in X, Y; Neumann/periodic in Z !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine poisson_11x ( rhs ) !use dbg_schemes, only: abs_prec use math_mod , only : abs_prec implicit none real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs complex ( mytype ) :: xyzk real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 real ( mytype ) :: xx1 , xx2 , xx3 , xx4 , xx5 , xx6 , xx7 , xx8 integer :: nx , ny , nz , i , j , k complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy #ifdef DEBUG_FFT real ( mytype ) avg_param #endif 100 format ( 1 x , a8 , 3 I4 , 2 F12 . 6 ) nx = nx_global - 1 ny = ny_global - 1 !write(*,*) 'Poisson_11x' if ( bcz == 1 ) then nz = nz_global - 1 else if ( bcz == 0 ) then nz = nz_global end if if ( bcz == 1 ) then do j = 1 , ph % zsz ( 2 ) do i = 1 , ph % zsz ( 1 ) do k = 1 , nz / 2 rw3 ( i , j , k ) = rhs ( i , j , 2 * ( k - 1 ) + 1 ) end do do k = nz / 2 + 1 , nz rw3 ( i , j , k ) = rhs ( i , j , 2 * nz - 2 * k + 2 ) end do end do end do call transpose_z_to_y ( rw3 , rw2 , ph ) else if ( bcz == 0 ) then call transpose_z_to_y ( rhs , rw2 , ph ) end if do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , j , k ) = rw2 ( i , 2 * ( j - 1 ) + 1 , k ) end do do j = ny / 2 + 1 , ny rw2b ( i , j , k ) = rw2 ( i , 2 * ny - 2 * j + 2 , k ) end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( rw2b , avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Start rw2 ' , avg_param #endif ! the global operations in X call transpose_y_to_x ( rw2b , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( i , j , k ) = rw1 ( 2 * ( i - 1 ) + 1 , j , k ) end do do i = nx / 2 + 1 , nx rw1b ( i , j , k ) = rw1 ( 2 * nx - 2 * i + 2 , j , k ) end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( rw1b , avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Start rw1 ' , avg_param #endif ! back to Z-pencil call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z , nx , ny , nz ) fft_initialised = . true . end if ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'START' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! post-processing in spectral space ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after z' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Post in Z cw1 ' , avg_param #endif ! POST PROCESSING IN Y ! WE HAVE TO BE IN Y PENCILS call transpose_x_to_y ( cw1 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , 1 , k ) = cw2 ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2 ( i , j , k )) tmp2 = iy ( cw2 ( i , j , k )) tmp3 = rl ( cw2 ( i , ny - j + 2 , k )) tmp4 = iy ( cw2 ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) * half xx2 = tmp1 * ay ( j ) * half xx3 = tmp2 * by ( j ) * half xx4 = tmp2 * ay ( j ) * half xx5 = tmp3 * by ( j ) * half xx6 = tmp3 * ay ( j ) * half xx7 = tmp4 * by ( j ) * half xx8 = tmp4 * ay ( j ) * half cw2b ( i , j , k ) = cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw2 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Post in Y cw2 ' , avg_param #endif ! back to X-pencil call transpose_y_to_x ( cw2b , cw1 , sp ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'after y' , i , j , k , cw1 ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Back to X cw1 ' , avg_param #endif ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1b ( 1 , j , k ) = cw1 ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) tmp3 = rl ( cw1 ( nx - i + 2 , j , k )) tmp4 = iy ( cw1 ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) * half xx2 = tmp1 * ax ( i ) * half xx3 = tmp2 * bx ( i ) * half xx4 = tmp2 * ax ( i ) * half xx5 = tmp3 * bx ( i ) * half xx6 = tmp3 * ax ( i ) * half xx7 = tmp4 * bx ( i ) * half xx8 = tmp4 * ax ( i ) * half cw1b ( i , j , k ) = cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , * ) 'BEFORE' , i , j , k , cw1b ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Back to X cw1b ' , avg_param #endif if ( istret == 0 ) then ! Solve Poisson do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) !CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( zero , zero ) end if if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( zero , iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( rl ( cw1b ( i , j , k )) / ( - tmp1 ), zero ) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( real ( cw1b ( i , j , k )) / ( - tmp1 ), iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois istret 0 ' , avg_param #endif else call matrice_refinement () !write(*,*) 'PO_11X ii1 arl ', rl(a(1,1,1,1)),rl(a(1,1,1,2)),rl(a(1,1,1,3)),& !                              rl(a(1,1,1,4)),rl(a(1,1,1,5)) !write(*,*) 'PO_11X ii1 aiy ', iy(a(1,1,1,1)),iy(a(1,1,1,2)),iy(a(1,1,1,3)),& !                              iy(a(1,1,1,4)),iy(a(1,1,1,5)) !! !write(*,*) 'PO_11X ii5 arl ', rl(a(5,5,5,1)),rl(a(5,5,5,2)),rl(a(5,5,5,3)),& !                              rl(a(5,5,5,4)),rl(a(5,5,5,5)) !write(*,*) 'PO_11X ii5 aiy ', iy(a(5,5,5,1)),iy(a(5,5,5,2)),iy(a(5,5,5,3)),& !                              iy(a(5,5,5,4)),iy(a(5,5,5,5)) !! !write(*,*) 'PO_11X ii1 a2rl ', rl(a2(1,1,1,1)),rl(a2(1,1,1,2)),rl(a2(1,1,1,3)),& !                               rl(a2(1,1,1,4)),rl(a2(1,1,1,5)) !write(*,*) 'PO_11X ii1 a2iy ', iy(a2(1,1,1,1)),iy(a2(1,1,1,2)),iy(a2(1,1,1,3)),& !                               iy(a2(1,1,1,4)),iy(a2(1,1,1,5)) !! !write(*,*) 'PO_11X ii5 a2rl ', rl(a2(5,5,5,1)),rl(a2(5,5,5,2)),rl(a2(5,5,5,3)),& !                               rl(a2(5,5,5,4)),rl(a2(5,5,5,5)) !write(*,*) 'PO_11X ii5 a2iy ', iy(a2(5,5,5,1)),iy(a2(5,5,5,2)),iy(a2(5,5,5,3)),& !                               iy(a2(5,5,5,4)),iy(a2(5,5,5,5)) !!! !write(*,*) 'PO_11X ii1 rl ', rl(a3(1,1,1,1)),rl(a3(1,1,1,2)),rl(a3(1,1,1,3)),& !                             rl(a3(1,1,1,4)),rl(a3(1,1,1,5)) !write(*,*) 'PO_11X ii1 iy ', iy(a3(1,1,1,1)),iy(a3(1,1,1,2)),iy(a3(1,1,1,3)),& !                             iy(a3(1,1,1,4)),iy(a3(1,1,1,5)) !! !write(*,*) 'PO_11X ii1 rl ', rl(a3(5,5,5,1)),rl(a3(5,5,5,2)),rl(a3(5,5,5,3)),& !                             rl(a3(5,5,5,4)),rl(a3(5,5,5,5)) !write(*,*) 'PO_11X ii1 iy ', iy(a3(5,5,5,1)),iy(a3(5,5,5,2)),iy(a3(5,5,5,3)),& !                             iy(a3(5,5,5,4)),iy(a3(5,5,5,5)) ! the stretching is only working in Y pencils call transpose_x_to_y ( cw1b , cw2b , sp ) !we are now in Y pencil if ( istret /= 3 ) then cw2 = zero cw2c = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny / 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , 2 * j - 1 , k ) cw2c ( i , j , k ) = cw2b ( i , 2 * j , k ) enddo enddo enddo call inversion5_v1 ( a , cw2 , sp ) call inversion5_v1 ( a2 , cw2c , sp ) cw2b = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny - 1 , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i ,( j + 1 ) / 2 , k ) enddo enddo do j = 2 , ny , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2c ( i , j / 2 , k ) enddo enddo enddo #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw2b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois istret < 3 ' , avg_param #endif else cw2 = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , j , k ) enddo enddo enddo call inversion5_v2 ( a3 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i , j , k ) enddo enddo enddo endif #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw2b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois istret = 3 ' , avg_param #endif !we have to go back in X pencils call transpose_y_to_x ( cw2b , cw1b , sp ) endif #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-6 ) then write ( * , * ) 'AFTER' , i , j , k , cw1b ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois AFTER ' , avg_param #endif !stop ! post-processing backward do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1 ( 1 , j , k ) = cw1b ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1b ( i , j , k )) tmp2 = iy ( cw1b ( i , j , k )) tmp3 = rl ( cw1b ( nx - i + 2 , j , k )) tmp4 = iy ( cw1b ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) xx2 = tmp1 * ax ( i ) xx3 = tmp2 * bx ( i ) xx4 = tmp2 * ax ( i ) xx5 = tmp3 * bx ( i ) xx6 = tmp3 * ax ( i ) xx7 = tmp4 * bx ( i ) xx8 = tmp4 * ax ( i ) cw1 ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER X' , i , j , k , cw1 ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois POSTPR X ' , avg_param #endif ! POST PROCESSING IN Y ! NEED to be in Y-pencil call transpose_x_to_y ( cw1 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , 1 , k ) = cw2 ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2 ( i , j , k )) tmp2 = iy ( cw2 ( i , j , k )) tmp3 = rl ( cw2 ( i , ny - j + 2 , k )) tmp4 = iy ( cw2 ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) xx2 = tmp1 * ay ( j ) xx3 = tmp2 * by ( j ) xx4 = tmp2 * ay ( j ) xx5 = tmp3 * by ( j ) xx6 = tmp3 * ay ( j ) xx7 = tmp4 * by ( j ) xx8 = tmp4 * ay ( j ) cw2b ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do #ifdef DEBUG_FFT do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( abs_prec ( cw2b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER Y' , i , j , k , cw2b ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw2b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois POSTPR Y ' , avg_param #endif ! back to X-pencil call transpose_y_to_x ( cw2b , cw1 , sp ) ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'END' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois POSTPR Z ' , avg_param #endif ! compute c2r transform, back to physical space call decomp_2d_fft_3d ( cw1 , rhs ) #ifdef DEBUG_FFT avg_param = zero call avg3d ( rhs , avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois Back Phy RHS ' , avg_param #endif if ( bcz == 1 ) then do j = 1 , ph % zsz ( 2 ) do i = 1 , ph % zsz ( 1 ) do k = 1 , nz / 2 rw3 ( i , j , 2 * k - 1 ) = rhs ( i , j , k ) end do do k = 1 , nz / 2 rw3 ( i , j , 2 * k ) = rhs ( i , j , nz - k + 1 ) end do end do end do call transpose_z_to_y ( rw3 , rw2 , ph ) else if ( bcz == 0 ) then call transpose_z_to_y ( rhs , rw2 , ph ) end if do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , 2 * j - 1 , k ) = rw2 ( i , j , k ) end do do j = 1 , ny / 2 rw2b ( i , 2 * j , k ) = rw2 ( i , ny - j + 1 , k ) end do enddo end do call transpose_y_to_x ( rw2b , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( 2 * i - 1 , j , k ) = rw1 ( i , j , k ) enddo do i = 1 , nx / 2 rw1b ( 2 * i , j , k ) = rw1 ( nx - i + 1 , j , k ) enddo enddo end do call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) !  call decomp_2d_fft_finalize return end subroutine poisson_11x subroutine abxyz ( ax , ay , az , bx , by , bz , nx , ny , nz , bcx , bcy , bcz ) !use param !use dbg_schemes, only: sin_prec, cos_prec implicit none integer , intent ( IN ) :: nx , ny , nz integer , intent ( IN ) :: bcx , bcy , bcz real ( mytype ), dimension (:), intent ( OUT ) :: ax , bx real ( mytype ), dimension (:), intent ( OUT ) :: ay , by real ( mytype ), dimension (:), intent ( OUT ) :: az , bz integer :: i , j , k if ( bcx == 0 ) then do i = 1 , nx ax ( i ) = sin_prec ( real ( i - 1 , kind = mytype ) * PI / real ( nx , kind = mytype )) bx ( i ) = cos_prec ( real ( i - 1 , kind = mytype ) * PI / real ( nx , kind = mytype )) end do elseif ( bcx == 1 ) then do i = 1 , nx ax ( i ) = sin_prec ( real ( i - 1 , kind = mytype ) * PI * half / & real ( nx , kind = mytype )) bx ( i ) = cos_prec ( real ( i - 1 , kind = mytype ) * PI * half / & real ( nx , kind = mytype )) end do end if if ( bcy == 0 ) then do j = 1 , ny ay ( j ) = sin_prec ( real ( j - 1 , kind = mytype ) * PI / real ( ny , kind = mytype )) by ( j ) = cos_prec ( real ( j - 1 , kind = mytype ) * PI / real ( ny , kind = mytype )) end do elseif ( bcy == 1 ) then do j = 1 , ny ay ( j ) = sin_prec ( real ( j - 1 , kind = mytype ) * PI * half / & real ( ny , kind = mytype )) by ( j ) = cos_prec ( real ( j - 1 , kind = mytype ) * PI * half / & real ( ny , kind = mytype )) end do end if if ( bcz == 0 ) then do k = 1 , nz az ( k ) = sin_prec ( real ( k - 1 , kind = mytype ) * PI / real ( nz , kind = mytype )) bz ( k ) = cos_prec ( real ( k - 1 , kind = mytype ) * PI / real ( nz , kind = mytype )) end do elseif ( bcz == 1 ) then do k = 1 , nz az ( k ) = sin_prec ( real ( k - 1 , kind = mytype ) * PI * half / & real ( nz , kind = mytype )) bz ( k ) = cos_prec ( real ( k - 1 , kind = mytype ) * PI * half / & real ( nz , kind = mytype )) end do end if return end subroutine abxyz ! *********************************************************** ! subroutine waves () ! !*********************************************************** !use derivX !use derivY !use derivZ !use param use decomp_2d !use variables use decomp_2d_fft !use dbg_schemes, only: sin_prec, cos_prec use fft2decomp_interface_mod implicit none integer :: i , j , k real ( mytype ) :: w , wp , w1 , w1p complex ( mytype ) :: xyzk complex ( mytype ) :: ytt , xtt , ztt , yt1 , xt1 , yt2 , xt2 complex ( mytype ) :: xtt1 , ytt1 , ztt1 , zt1 , zt2 , tmp1 , tmp2 , tmp3 complex ( mytype ) :: tmp4 , tmp5 , tmp6 real ( mytype ) :: rlexs real ( mytype ) :: rleys real ( mytype ) :: rlezs , iyezs real ( mytype ) :: ytt_rl , xtt_rl , ztt_rl , yt1_rl , xt1_rl , zt1_rl real ( mytype ) :: xtt1_rl , ytt1_rl , ztt1_rl complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy logical :: ftr = . false . xkx = zero xk2 = zero yky = zero yk2 = zero zkz = zero zk2 = zero !WAVE NUMBER IN X if ( bcx == 0 ) then do i = 1 , nx / 2 + 1 w = twopi * real ( i - 1 , mytype ) / real ( nx , mytype ) wp = acix6 * two * dx * sin_prec ( w * half ) + bcix6 * two * dx * sin_prec ( three * half * w ) wp = wp / ( one + two * alcaix6 * cos_prec ( w )) ! xkx ( i ) = cx_one_one * ( real ( nx , mytype ) * wp / xlx ) exs ( i ) = cx_one_one * ( real ( nx , mytype ) * w / xlx ) xk2 ( i ) = cx_one_one * ( real ( nx , mytype ) * wp / xlx ) ** 2 ! enddo do i = nx / 2 + 2 , nx xkx ( i ) = xkx ( nx - i + 2 ) exs ( i ) = exs ( nx - i + 2 ) xk2 ( i ) = xk2 ( nx - i + 2 ) enddo else do i = 1 , nx w = twopi * half * real ( i - 1 , mytype ) / real ( nxm , mytype ) wp = acix6 * two * dx * sin_prec ( w * half ) + bcix6 * two * dx * sin_prec ( three * half * w ) wp = wp / ( one + two * alcaix6 * cos_prec ( w )) ! xkx ( i ) = cx_one_one * real ( nxm , mytype ) * wp / xlx exs ( i ) = cx_one_one * real ( nxm , mytype ) * w / xlx xk2 ( i ) = cx_one_one * ( real ( nxm , mytype ) * wp / xlx ) ** 2 ! enddo xkx ( 1 ) = zero exs ( 1 ) = zero xk2 ( 1 ) = zero endif ! !WAVE NUMBER IN Y if ( bcy == 0 ) then do j = 1 , ny / 2 + 1 w = twopi * real ( j - 1 , mytype ) / real ( ny , mytype ) wp = aciy6 * two * dy * sin_prec ( w * half ) + bciy6 * two * dy * sin_prec ( three * half * w ) wp = wp / ( one + two * alcaiy6 * cos_prec ( w )) ! if ( istret == 0 ) yky ( j ) = cx_one_one * ( real ( ny , mytype ) * wp / yly ) if ( istret /= 0 ) yky ( j ) = cx_one_one * ( real ( ny , mytype ) * wp ) eys ( j ) = cx_one_one * ( real ( ny , mytype ) * w / yly ) yk2 ( j ) = cx_one_one * ( real ( ny , mytype ) * wp / yly ) ** 2 ! enddo do j = ny / 2 + 2 , ny yky ( j ) = yky ( ny - j + 2 ) eys ( j ) = eys ( ny - j + 2 ) yk2 ( j ) = yk2 ( ny - j + 2 ) enddo else do j = 1 , ny w = twopi * half * real ( j - 1 , mytype ) / real ( nym , mytype ) wp = aciy6 * two * dy * sin_prec ( w * half ) + ( bciy6 * two * dy ) * sin_prec ( three * half * w ) wp = wp / ( one + two * alcaiy6 * cos_prec ( w )) ! if ( istret == 0 ) yky ( j ) = cx_one_one * ( real ( nym , mytype ) * wp / yly ) if ( istret /= 0 ) yky ( j ) = cx_one_one * ( real ( nym , mytype ) * wp ) eys ( j ) = cx_one_one * ( real ( nym , mytype ) * w / yly ) yk2 ( j ) = cx_one_one * ( real ( nym , mytype ) * wp / yly ) ** 2 ! enddo yky ( 1 ) = zero eys ( 1 ) = zero yk2 ( 1 ) = zero endif !WAVE NUMBER IN Z if ( bcz == 0 ) then do k = 1 , nz / 2 + 1 w = twopi * real ( k - 1 , mytype ) / real ( nz , mytype ) wp = aciz6 * two * dz * sin_prec ( w * half ) + ( bciz6 * two * dz ) * sin_prec ( three * half * w ) wp = wp / ( one + two * alcaiz6 * cos_prec ( w )) ! zkz ( k ) = cx_one_one * ( real ( nz , mytype ) * wp / zlz ) ezs ( k ) = cx_one_one * ( real ( nz , mytype ) * w / zlz ) zk2 ( k ) = cx_one_one * ( real ( nz , mytype ) * wp / zlz ) ** 2 ! enddo else do k = 1 , nz / 2 + 1 w = pi * real ( k - 1 , mytype ) / real ( nzm , mytype ) w1 = pi * real (( nzm - k + 1 ), mytype ) / real ( nzm , mytype ) wp = aciz6 * two * dz * sin_prec ( w * half ) + ( bciz6 * two * dz ) * sin_prec ( three * half * w ) wp = wp / ( one + two * alcaiz6 * cos_prec ( w )) w1p = aciz6 * two * dz * sin_prec ( w1 * half ) + ( bciz6 * two * dz ) * sin_prec ( three * half * w1 ) w1p = w1p / ( one + two * alcaiz6 * cos_prec ( w1 )) ! zkz ( k ) = cx ( real ( nzm , mytype ) * wp / zlz , - real ( nzm , mytype ) * w1p / zlz ) ezs ( k ) = cx ( real ( nzm , mytype ) * w / zlz , real ( nzm , mytype ) * w1 / zlz ) zk2 ( k ) = cx (( real ( nzm , mytype ) * wp / zlz ) ** 2 , ( real ( nzm , mytype ) * w1p / zlz ) ** 2 ) ! enddo endif if (( bcx == 0 ). and .( bcz == 0 ). and .( bcy /= 0 )) then do k = sp % yst ( 3 ), sp % yen ( 3 ) ! if ( ftr ) rlezs = rl ( ezs ( k )) * dz ! do j = sp % yst ( 2 ), sp % yen ( 2 ) ! if ( ftr ) rleys = rl ( eys ( j )) * dy ! do i = sp % yst ( 1 ), sp % yen ( 1 ) ! if ( ftr ) then rlexs = rl ( exs ( i )) * dx ! xtt_rl = two * & ( bicix6 * cos_prec ( rlexs * onepfive ) + cicix6 * cos_prec ( rlexs * twopfive ) + dicix6 * cos_prec ( rlexs * threepfive )) ! ytt_rl = two * & ( biciy6 * cos_prec ( rleys * onepfive ) + ciciy6 * cos_prec ( rleys * twopfive ) + diciy6 * cos_prec ( rleys * threepfive )) ! ztt_rl = two * & ( biciz6 * cos_prec ( rlezs * onepfive ) + ciciz6 * cos_prec ( rlezs * twopfive ) + diciz6 * cos_prec ( rlezs * threepfive )) ! xtt1_rl = two * aicix6 * cos_prec ( rlexs * half ) ytt1_rl = two * aiciy6 * cos_prec ( rleys * half ) ztt1_rl = two * aiciz6 * cos_prec ( rlezs * half ) ! xt1_rl = one + two * ailcaix6 * cos_prec ( rlexs ) yt1_rl = one + two * ailcaiy6 * cos_prec ( rleys ) zt1_rl = one + two * ailcaiz6 * cos_prec ( rlezs ) ! xt2 = xk2 ( i ) * (((( ytt1_rl + ytt_rl ) / yt1_rl ) * (( ztt1_rl + ztt_rl ) / zt1_rl )) ** 2 ) yt2 = yk2 ( j ) * (((( xtt1_rl + xtt_rl ) / xt1_rl ) * (( ztt1_rl + ztt_rl ) / zt1_rl )) ** 2 ) zt2 = zk2 ( k ) * (((( xtt1_rl + xtt_rl ) / xt1_rl ) * (( ytt1_rl + ytt_rl ) / yt1_rl )) ** 2 ) else xt2 = xk2 ( i ) yt2 = yk2 ( j ) zt2 = zk2 ( k ) end if xyzk = xt2 + yt2 + zt2 kxyz ( i , j , k ) = xyzk ! enddo enddo enddo else if ( bcz == 0 ) then do k = sp % xst ( 3 ), sp % xen ( 3 ) ! if ( ftr ) rlezs = rl ( ezs ( k )) * dz ! do j = sp % xst ( 2 ), sp % xen ( 2 ) ! if ( ftr ) rleys = rl ( eys ( j )) * dy ! do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( ftr ) then rlexs = rl ( exs ( i )) * dx ! xtt_rl = two * & ( bicix6 * cos_prec ( rlexs * onepfive ) + cicix6 * cos_prec ( rlexs * twopfive ) + dicix6 * cos_prec ( rlexs * threepfive )) ! ytt_rl = two * & ( biciy6 * cos_prec ( rleys * onepfive ) + ciciy6 * cos_prec ( rleys * twopfive ) + diciy6 * cos_prec ( rleys * threepfive )) ! ztt_rl = two * & ( biciz6 * cos_prec ( rlezs * onepfive ) + ciciz6 * cos_prec ( rlezs * twopfive ) + diciz6 * cos_prec ( rlezs * threepfive )) ! xtt1_rl = two * aicix6 * cos_prec ( rlexs * half ) ytt1_rl = two * aiciy6 * cos_prec ( rleys * half ) ztt1_rl = two * aiciz6 * cos_prec ( rlezs * half ) ! xt1_rl = one + two * ailcaix6 * cos_prec ( rlexs ) yt1_rl = one + two * ailcaiy6 * cos_prec ( rleys ) zt1_rl = one + two * ailcaiz6 * cos_prec ( rlezs ) ! xt2 = xk2 ( i ) * (((( ytt1_rl + ytt_rl ) / yt1_rl ) * (( ztt1_rl + ztt_rl ) / zt1_rl )) ** 2 ) yt2 = yk2 ( j ) * (((( xtt1_rl + xtt_rl ) / xt1_rl ) * (( ztt1_rl + ztt_rl ) / zt1_rl )) ** 2 ) zt2 = zk2 ( k ) * (((( xtt1_rl + xtt_rl ) / xt1_rl ) * (( ytt1_rl + ytt_rl ) / yt1_rl )) ** 2 ) else xt2 = xk2 ( i ) yt2 = yk2 ( j ) zt2 = zk2 ( k ) end if xyzk = xt2 + yt2 + zt2 kxyz ( i , j , k ) = xyzk ! enddo enddo enddo else do k = sp % xst ( 3 ), sp % xen ( 3 ) ! if ( ftr ) rlezs = rl ( ezs ( k )) * dz if ( ftr ) iyezs = iy ( ezs ( k )) * dz ! do j = sp % xst ( 2 ), sp % xen ( 2 ) if ( ftr ) rleys = rl ( eys ( j )) * dy ! do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( ftr ) then rlexs = rl ( exs ( i )) * dx ! xtt_rl = two * & ( bicix6 * cos_prec ( rlexs * onepfive ) + cicix6 * cos_prec ( rlexs * twopfive ) + dicix6 * cos_prec ( rlexs * threepfive )) ! ytt_rl = two * & ( biciy6 * cos_prec ( rleys * onepfive ) + ciciy6 * cos_prec ( rleys * twopfive ) + diciy6 * cos_prec ( rleys * threepfive )) ! ztt = two * cx ( & biciz6 * cos_prec ( rlezs * onepfive ) + ciciz6 * cos_prec ( rlezs * twopfive ) + diciz6 * cos_prec ( rlezs * threepfive ),& biciz6 * cos_prec ( iyezs * onepfive ) + ciciz6 * cos_prec ( iyezs * twopfive ) + diciz6 * cos_prec ( iyezs * threepfive )) ! xtt1_rl = two * aicix6 * cos_prec ( rlexs * half ) ytt1_rl = two * aiciy6 * cos_prec ( rleys * half ) ! ztt1 = two * cx ( aiciz6 * cos_prec ( rlezs * half ),& aiciz6 * cos_prec ( iyezs * half )) ! xt1_rl = one + two * ailcaix6 * cos_prec ( rlexs ) yt1_rl = one + two * ailcaiy6 * cos_prec ( rleys ) ! zt1 = cx (( one + two * ailcaiz6 * cos_prec ( rlezs )),& ( one + two * ailcaiz6 * cos_prec ( iyezs ))) ! tmp1 = cx ( rl ( ztt1 + ztt ) / rl ( zt1 ),& iy ( ztt1 + ztt ) / iy ( zt1 )) ! tmp2 = cx_one_one * ( ytt1_rl + ytt_rl ) / yt1_rl ! tmp3 = cx_one_one * ( xtt1_rl + xtt_rl ) / xt1_rl ! tmp4 = rl ( tmp2 ) ** 2 * cx ( rl ( tmp1 ) ** 2 , iy ( tmp1 ) ** 2 ) ! tmp5 = rl ( tmp3 ) ** 2 * cx ( rl ( tmp1 ) ** 2 , iy ( tmp1 ) ** 2 ) ! tmp6 = ( rl ( tmp3 ) * rl ( tmp2 )) ** 2 * cx_one_one ! tmp1 = cx ( rl ( tmp4 ) * rl ( xk2 ( i )), iy ( tmp4 ) * iy ( xk2 ( i ))) ! tmp2 = cx ( rl ( tmp5 ) * rl ( yk2 ( j )), iy ( tmp5 ) * iy ( yk2 ( j ))) ! tmp3 = rl ( tmp6 ) * zk2 ( k ) ! xyzk = tmp1 + tmp2 + tmp3 else xyzk = xk2 ( i ) + yk2 ( j ) + zk2 ( k ) end if kxyz ( i , j , k ) = xyzk ! enddo enddo enddo ! endif endif #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) !write(*,*) 'kxyz', k, j, i, -kxyz(i,j,k) end do end do end do #endif return end subroutine waves !************************************************************************** ! subroutine matrice_refinement () ! !************************************************************************** use decomp_2d !use variables !use param !use var !use MPI !use derivX !use derivY !use derivZ !use dbg_schemes, only: cos_prec implicit none integer :: i , j , k complex ( mytype ), dimension ( sp % yst ( 1 ): sp % yen ( 1 )) :: transx complex ( mytype ), dimension ( sp % yst ( 2 ): sp % yen ( 2 )) :: transy complex ( mytype ), dimension ( sp % yst ( 3 ): sp % yen ( 3 )) :: transz real ( mytype ), dimension ( sp % yst ( 1 ): sp % yen ( 1 )) :: transx_rl , transx_rl2 real ( mytype ), dimension ( sp % yst ( 2 ): sp % yen ( 2 )) :: transy_rl , transy_rl2 real ( mytype ), dimension ( sp % yst ( 3 ): sp % yen ( 3 )) :: transz_rl , transz_iy , transz_rl2 , transz_iy2 real ( mytype ) :: xa0 , xa1 complex ( mytype ) :: ytt , xtt , ztt , yt1 , xt1 , yt2 , xt2 complex ( mytype ) :: xtt1 , ytt1 , ztt1 , zt1 , zt2 , tmp1 , tmp2 , tmp3 complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy real ( mytype ) :: xtt_rl , xtt1_rl , xt1_rl real ( mytype ) :: rlexs real ( mytype ) :: ytt_rl , ytt1_rl , yt1_rl real ( mytype ) :: rleys real ( mytype ) :: ztt_rl , ztt1_rl , zt1_rl real ( mytype ) :: rlezs , iyezs ! real ( mytype ) :: xa0_2 , xa1_2 , xa01 , xa0p1_2 logical :: ftr = . false . ! do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( ftr ) then rlexs = rl ( exs ( i )) * dx xtt_rl = two * ( bicix6 * cos_prec ( rlexs * onepfive ) + cicix6 * cos_prec ( rlexs * twopfive ) + dicix6 * cos_prec ( rlexs * threepfive )) xtt1_rl = two * aicix6 * cos_prec ( rlexs * half ) xt1_rl = one + two * ailcaix6 * cos_prec ( rlexs ) ! transx_rl ( i ) = ( xtt1_rl + xtt_rl ) / xt1_rl else transx_rl ( i ) = one end if transx_rl2 ( i ) = transx_rl ( i ) ** 2 ! transx ( i ) = cx_one_one * transx_rl ( i ) ! enddo ! do j = sp % yst ( 2 ), sp % yen ( 2 ) if ( ftr ) then rleys = rl ( eys ( j )) * dy ytt_rl = two * ( biciy6 * cos_prec ( rleys * onepfive ) + ciciy6 * cos_prec ( rleys * twopfive ) + diciy6 * cos_prec ( rleys * threepfive )) ytt1_rl = two * aiciy6 * cos_prec ( rleys * half ) yt1_rl = one + two * ailcaiy6 * cos_prec ( rleys ) transy_rl ( j ) = ( ytt1_rl + ytt_rl ) / yt1_rl else transy_rl ( j ) = one !(ytt1_rl + ytt_rl) / yt1_rl end if transy_rl2 ( j ) = transy_rl ( j ) ** 2 ! transy ( j ) = cx_one_one * transy_rl ( j ) ! enddo ! if ( bcz == 0 ) then do k = sp % yst ( 3 ), sp % yen ( 3 ) if ( ftr ) then rlezs = rl ( ezs ( k )) * dz ztt_rl = two * ( biciz6 * cos_prec ( rlezs * onepfive ) + ciciz6 * cos_prec ( rlezs * twopfive ) + diciz6 * cos_prec ( rlezs * threepfive )) ztt1_rl = two * aiciz6 * cos_prec ( rlezs * half ) zt1_rl = one + two * ailcaiz6 * cos_prec ( rlezs ) ! transz_rl ( k ) = ( ztt1_rl + ztt_rl ) / zt1_rl else transz_rl ( k ) = one end if transz_rl2 ( k ) = transz_rl ( k ) ** 2 ! transz_iy ( k ) = transz_rl ( k ) transz_iy2 ( k ) = transz_rl2 ( k ) ! transz ( k ) = cx_one_one * transz_rl ( k ) ! enddo else do k = sp % yst ( 3 ), sp % yen ( 3 ) if ( ftr ) then rlezs = rl ( ezs ( k )) * dz iyezs = iy ( ezs ( k )) * dz ztt = two * cx ( biciz6 * cos_prec ( rlezs * onepfive ) + ciciz6 * cos_prec ( rlezs * twopfive ), & biciz6 * cos_prec ( iyezs * onepfive ) + ciciz6 * cos_prec ( iyezs * twopfive )) ztt1 = two * cx ( aiciz6 * cos_prec ( rlezs * half ),& aiciz6 * cos_prec ( iyezs * half )) zt1 = cx ( one + two * ailcaiz6 * cos_prec ( rlezs ),& one + two * ailcaiz6 * cos_prec ( iyezs )) ! transz_rl ( k ) = rl ( ztt1 + ztt ) / rl ( zt1 ) transz_iy ( k ) = iy ( ztt1 + ztt ) / iy ( zt1 ) else transz_rl ( k ) = one transz_iy ( k ) = one end if transz_rl2 ( k ) = transz_rl ( k ) ** 2 transz_iy2 ( k ) = transz_iy ( k ) ** 2 ! transz ( k ) = cx ( transz_rl ( k ), transz_iy ( k )) ! enddo endif ! if (( istret == 1 ). or .( istret == 2 )) then ! xa0 = alpha / pi + half / beta / pi if ( istret == 1 ) xa1 = + one / four / beta / pi if ( istret == 2 ) xa1 = - one / four / beta / pi ! below 2 lines added by WW xa0 = xa0 / yly xa1 = xa1 / yly xa0_2 = xa0 ** 2 xa1_2 = xa1 ** 2 xa01 = xa0 * xa1 xa0p1_2 = ( xa0 + xa1 ) ** 2 ! !      construction of the pentadiagonal matrice ! do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny / 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) ! cw22 ( i , j , k ) = transx_rl ( i ) * cx ( rl ( yky ( 2 * j - 1 )) * rl ( transz ( k )),& iy ( yky ( 2 * j - 1 )) * iy ( transz ( k ))) cw2 ( i , j , k ) = transx_rl ( i ) * cx ( rl ( yky ( 2 * j )) * rl ( transz ( k )),& iy ( yky ( 2 * j )) * iy ( transz ( k ))) ! enddo enddo enddo !main diagonal do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 2 , ny / 2 - 1 do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , j , k , 3 ) =- cx ( rl ( xk2 ( i )) * transy_rl2 ( 2 * j - 1 ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( 2 * j - 1 ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw22 ( i , j , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , j , k )) * ( rl ( cw22 ( i , j - 1 , k )) + rl ( cw22 ( i , j + 1 , k ))), & ! iy ( xk2 ( i )) * transy_rl2 ( 2 * j - 1 ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( 2 * j - 1 ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw22 ( i , j , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , j , k )) * ( iy ( cw22 ( i , j - 1 , k )) + iy ( cw22 ( i , j + 1 , k )))) ! a2 ( i , j , k , 3 ) =- cx ( rl ( xk2 ( i )) * transy_rl2 ( 2 * j ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( 2 * j ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw2 ( i , j , k )) ** 2 & + xa1_2 * rl ( cw2 ( i , j , k )) * ( rl ( cw2 ( i , j - 1 , k )) + rl ( cw2 ( i , j + 1 , k ))),& ! iy ( xk2 ( i )) * transy_rl2 ( 2 * j ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( 2 * j ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw2 ( i , j , k )) ** 2 & + xa1_2 * iy ( cw2 ( i , j , k )) * ( iy ( cw2 ( i , j - 1 , k )) + iy ( cw2 ( i , j + 1 , k )))) ! enddo enddo ! do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , 1 , k , 3 ) =- cx ( rl ( xk2 ( i )) * transy_rl2 ( 1 ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( 1 ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , 1 , k )) * rl ( cw22 ( i , 2 , k )),& ! iy ( xk2 ( i )) * transy_rl2 ( 1 ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( 1 ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , 1 , k )) * iy ( cw22 ( i , 2 , k ))) ! a ( i , ny / 2 , k , 3 ) =- cx ( rl ( xk2 ( i )) * transy_rl2 ( ny - 2 ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( ny - 2 ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw22 ( i , ny / 2 , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , ny / 2 , k )) * rl ( cw22 ( i , ny / 2 - 1 , k )), & ! iy ( xk2 ( i )) * transy_rl2 ( ny - 2 ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( ny - 2 ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw22 ( i , ny / 2 , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , ny / 2 , k )) * iy ( cw22 ( i , ny / 2 - 1 , k ))) ! a2 ( i , 1 , k , 3 ) =- cx ( rl ( xk2 ( i )) * transy_rl2 ( 2 ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( 2 ) * transx_rl2 ( i ) & + ( xa0_2 - xa1_2 ) * rl ( cw2 ( i , 1 , k )) ** 2 & + xa1_2 * rl ( cw2 ( i , 1 , k )) * rl ( cw2 ( i , 2 , k )),& ! iy ( xk2 ( i )) * transy_rl2 ( 2 ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( 2 ) * transx_rl2 ( i ) & + ( xa0_2 - xa1_2 ) * iy ( cw2 ( i , 1 , k )) ** 2 & + xa1_2 * iy ( cw2 ( i , 1 , k )) * iy ( cw2 ( i , 2 , k ))) ! a2 ( i , ny / 2 , k , 3 ) =- cx ( rl ( xk2 ( i )) * transy_rl2 ( ny - 1 ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( ny - 1 ) * transx_rl2 ( i ) & + xa0p1_2 * rl ( cw2 ( i , ny / 2 , k )) ** 2 & + xa1_2 * rl ( cw2 ( i , ny / 2 , k )) * rl ( cw2 ( i , ny / 2 - 1 , k )), & ! iy ( xk2 ( i )) * transy_rl2 ( ny - 1 ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( ny - 1 ) * transx_rl2 ( i ) & + xa0p1_2 * iy ( cw2 ( i , ny / 2 , k )) ** 2 & + xa1_2 * iy ( cw2 ( i , ny / 2 , k )) * iy ( cw2 ( i , ny / 2 - 1 , k ))) ! enddo enddo !sup diag +1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 2 , ny / 2 - 1 do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , j , k , 4 ) = xa01 * cx ( rl ( cw22 ( i , j + 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j + 1 , k ))), & iy ( cw22 ( i , j + 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j + 1 , k )))) ! a2 ( i , j , k , 4 ) = xa01 * cx ( rl ( cw2 ( i , j + 1 , k )) * ( rl ( cw2 ( i , j , k )) + rl ( cw2 ( i , j + 1 , k ))), & iy ( cw2 ( i , j + 1 , k )) * ( iy ( cw2 ( i , j , k )) + iy ( cw2 ( i , j + 1 , k )))) ! enddo enddo ! do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , 1 , k , 4 ) = two * xa01 * cx ( rl ( cw22 ( i , 1 , k )) * rl ( cw22 ( i , 2 , k )) + rl ( cw22 ( i , 2 , k )) * rl ( cw22 ( i , 2 , k )), & iy ( cw22 ( i , 1 , k )) * iy ( cw22 ( i , 2 , k )) + iy ( cw22 ( i , 2 , k )) * iy ( cw22 ( i , 2 , k ))) ! a2 ( i , 1 , k , 4 ) = cx (( xa0 - xa1 ) * xa1 * ( rl ( cw2 ( i , 1 , k )) * rl ( cw2 ( i , 2 , k ))) + xa0 * xa1 * ( rl ( cw2 ( i , 2 , k )) * rl ( cw2 ( i , 2 , k ))), & ( xa0 - xa1 ) * xa1 * ( iy ( cw2 ( i , 1 , k )) * iy ( cw2 ( i , 2 , k ))) + xa0 * xa1 * ( iy ( cw2 ( i , 2 , k )) * iy ( cw2 ( i , 2 , k )))) ! a2 ( i , ny / 2 - 1 , k , 4 ) = cx ( xa0 * xa1 * rl ( cw2 ( i , ny / 2 - 1 , k )) * rl ( cw2 ( i , ny / 2 , k )) + ( xa0 + xa1 ) * xa1 * ( rl ( cw2 ( i , ny / 2 , k )) ** 2 ), & xa0 * xa1 * iy ( cw2 ( i , ny / 2 - 1 , k )) * iy ( cw2 ( i , ny / 2 , k )) + ( xa0 + xa1 ) * xa1 * ( iy ( cw2 ( i , ny / 2 , k )) ** 2 )) ! a2 ( i , ny / 2 , k , 4 ) = zero ! enddo enddo ! !sup diag +2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 1 , ny / 2 - 2 ! a ( i , j , k , 5 ) = xa1_2 * cx ( - rl ( cw22 ( i , j + 1 , k )) * rl ( cw22 ( i , j + 2 , k )),& - iy ( cw22 ( i , j + 1 , k )) * iy ( cw22 ( i , j + 2 , k ))) a2 ( i , j , k , 5 ) = xa1_2 * cx ( - rl ( cw2 ( i , j + 1 , k )) * rl ( cw2 ( i , j + 2 , k )),& - iy ( cw2 ( i , j + 1 , k )) * iy ( cw2 ( i , j + 2 , k ))) ! enddo ! a ( i , 1 , k , 5 ) = two * cx ( rl ( a ( i , 1 , k , 5 )), iy ( a ( i , 1 , k , 5 ))) a ( i , ny / 2 - 1 , k , 5 ) = zero a ( i , ny / 2 , k , 5 ) = zero a2 ( i , ny / 2 - 1 , k , 5 ) = zero a2 ( i , ny / 2 , k , 5 ) = zero ! enddo enddo !inf diag -1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 2 , ny / 2 ! a ( i , j , k , 2 ) = xa01 * cx ( rl ( cw22 ( i , j - 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j - 1 , k ))), & iy ( cw22 ( i , j - 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j - 1 , k )))) ! a2 ( i , j , k , 2 ) = xa01 * cx ( rl ( cw2 ( i , j - 1 , k )) * ( rl ( cw2 ( i , j , k )) + rl ( cw2 ( i , j - 1 , k ))), & iy ( cw2 ( i , j - 1 , k )) * ( iy ( cw2 ( i , j , k )) + iy ( cw2 ( i , j - 1 , k )))) ! enddo a ( i , 1 , k , 2 ) = zero a2 ( i , 1 , k , 2 ) = zero ! a2 ( i , 2 , k , 2 ) = cx ( xa0 * xa1 * ( rl ( cw2 ( i , 2 , k )) * rl ( cw2 ( i , 1 , k )))& + ( xa0 + xa1 ) * xa1 * ( rl ( cw2 ( i , 1 , k )) * rl ( cw2 ( i , 1 , k ))),& ! xa0 * xa1 * ( iy ( cw2 ( i , 2 , k )) * iy ( cw2 ( i , 1 , k )))& + ( xa0 + xa1 ) * xa1 * ( iy ( cw2 ( i , 1 , k )) * iy ( cw2 ( i , 1 , k )))) ! a2 ( i , ny / 2 , k , 2 ) = cx (( xa0 + xa1 ) * xa1 * ( rl ( cw2 ( i , ny / 2 , k )) * rl ( cw2 ( i , ny / 2 - 1 , k )))& + xa0 * xa1 * ( rl ( cw2 ( i , ny / 2 - 1 , k )) * rl ( cw2 ( i , ny / 2 - 1 , k ))),& ! ( xa0 + xa1 ) * xa1 * ( iy ( cw2 ( i , ny / 2 , k )) * iy ( cw2 ( i , ny / 2 - 1 , k )))& + xa0 * xa1 * ( iy ( cw2 ( i , ny / 2 - 1 , k )) * iy ( cw2 ( i , ny / 2 - 1 , k )))) ! enddo enddo !inf diag -2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 3 , ny / 2 a ( i , j , k , 1 ) = xa1_2 * cx ( - rl ( cw22 ( i , j - 1 , k )) * rl ( cw22 ( i , j - 2 , k )),& - iy ( cw22 ( i , j - 1 , k )) * iy ( cw22 ( i , j - 2 , k ))) a2 ( i , j , k , 1 ) = xa1_2 * cx ( - rl ( cw2 ( i , j - 1 , k )) * rl ( cw2 ( i , j - 2 , k )),& - iy ( cw2 ( i , j - 1 , k )) * iy ( cw2 ( i , j - 2 , k ))) enddo a ( i , 1 , k , 1 ) = zero a ( i , 2 , k , 1 ) = zero a2 ( i , 1 , k , 1 ) = zero a2 ( i , 2 , k , 1 ) = zero enddo enddo !not to have a singular matrice do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if (( rl ( xk2 ( i )) == zero ). and .( rl ( zk2 ( k )) == zero )) then a ( i , 1 , k , 3 ) = cx_one_one a ( i , 1 , k , 4 ) = zero a ( i , 1 , k , 5 ) = zero endif enddo enddo ! else ! xa0 = alpha / pi + half / beta / pi xa1 = - one / four / beta / pi ! xa0_2 = xa0 ** 2 xa1_2 = xa1 ** 2 xa01 = xa0 * xa1 ! !construction of the pentadiagonal matrice ! do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , nym do i = sp % yst ( 1 ), sp % yen ( 1 ) ! cw22 ( i , j , k ) = transx_rl ( i ) * cx ( rl ( yky ( j )) * rl ( transz ( k )), & iy ( yky ( j )) * iy ( transz ( k ))) ! enddo enddo enddo !main diagonal do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 2 , nym - 1 do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a3 ( i , j , k , 3 ) = - cx ( rl ( xk2 ( i )) * transy_rl2 ( j ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( j ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw22 ( i , j , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , j , k )) * ( rl ( cw22 ( i , j - 1 , k )) + rl ( cw22 ( i , j + 1 , k ))),& ! iy ( xk2 ( i )) * transy_rl2 ( j ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( j ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw22 ( i , j , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , j , k )) * ( iy ( cw22 ( i , j - 1 , k )) + iy ( cw22 ( i , j + 1 , k )))) ! enddo enddo enddo do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a3 ( i , 1 , k , 3 ) = - cx ( rl ( xk2 ( i )) * transy_rl2 ( 1 ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( 1 ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , 1 , k )) * rl ( cw22 ( i , 2 , k )),& ! iy ( xk2 ( i )) * transy_rl2 ( 1 ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( 1 ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , 1 , k )) * iy ( cw22 ( i , 2 , k ))) ! a3 ( i , nym , k , 3 ) = - cx ( rl ( xk2 ( i )) * transy_rl2 ( nym ) * transz_rl2 ( k ) & + rl ( zk2 ( k )) * transy_rl2 ( nym ) * transx_rl2 ( i ) & + xa0_2 * rl ( cw22 ( i , nym , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , nym , k )) * rl ( cw22 ( i , nym - 1 , k )), & ! iy ( xk2 ( i )) * transy_rl2 ( nym ) * transz_iy2 ( k ) & + iy ( zk2 ( k )) * transy_rl2 ( nym ) * transx_rl2 ( i ) & + xa0_2 * iy ( cw22 ( i , nym , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , nym , k )) * iy ( cw22 ( i , nym - 1 , k ))) ! enddo enddo !sup diag +1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 2 , nym - 1 a3 ( i , j , k , 4 ) = xa01 * cx ( rl ( cw22 ( i , j + 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j + 1 , k ))), & iy ( cw22 ( i , j + 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j + 1 , k )))) enddo a3 ( i , 1 , k , 4 ) = xa01 * cx ( rl ( cw22 ( i , 2 , k )) * ( rl ( cw22 ( i , 1 , k )) + rl ( cw22 ( i , 2 , k ))), & iy ( cw22 ( i , 2 , k )) * ( iy ( cw22 ( i , 1 , k )) + iy ( cw22 ( i , 2 , k )))) enddo enddo !sup diag +2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 1 , nym - 2 a3 ( i , j , k , 5 ) = - xa1_2 * cx ( rl ( cw22 ( i , j + 1 , k )) * rl ( cw22 ( i , j + 2 , k )), & iy ( cw22 ( i , j + 1 , k )) * iy ( cw22 ( i , j + 2 , k ))) enddo a3 ( i , nym - 1 , k , 5 ) = zero a3 ( i , nym , k , 5 ) = zero enddo enddo !inf diag -1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 2 , nym a3 ( i , j , k , 2 ) = xa01 * cx ( rl ( cw22 ( i , j - 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j - 1 , k ))), & iy ( cw22 ( i , j - 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j - 1 , k )))) enddo a3 ( i , 1 , k , 2 ) = zero enddo enddo !inf diag -2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 3 , nym a3 ( i , j , k , 1 ) = - xa1_2 * cx ( rl ( cw22 ( i , j - 1 , k )) * rl ( cw22 ( i , j - 2 , k )),& iy ( cw22 ( i , j - 1 , k )) * iy ( cw22 ( i , j - 2 , k ))) enddo a3 ( i , 1 , k , 1 ) = zero a3 ( i , 2 , k , 1 ) = zero enddo enddo !not to have a singular matrice if ( nrank == 0 ) then a3 ( 1 , 1 , 1 , 3 ) = cx_one_one a3 ( 1 , 1 , 1 , 4 ) = zero a3 ( 1 , 1 , 1 , 5 ) = zero endif endif return end subroutine matrice_refinement !===================================== subroutine avg3d ( var , avg ) use decomp_2d_mpi use decomp_2d , only : xsize , xend !use param !use dbg_schemes, only: sqrt_prec !use variables, only: nx,ny,nz,nxm,nym,nzm !use mpi implicit none real ( mytype ), dimension ( xsize ( 1 ), xsize ( 2 ), xsize ( 3 )), intent ( in ) :: var real ( mytype ), intent ( out ) :: avg real ( mytype ) :: dep integer :: i , j , k , code integer :: nxc , nyc , nzc , xsize1 , xsize2 , xsize3 if ( nclx1 == 1. and . xend ( 1 ) == nx ) then xsize1 = xsize ( 1 ) - 1 else xsize1 = xsize ( 1 ) endif if ( ncly1 == 1. and . xend ( 2 ) == ny ) then xsize2 = xsize ( 2 ) - 1 else xsize2 = xsize ( 2 ) endif if ( nclz1 == 1. and . xend ( 3 ) == nz ) then xsize3 = xsize ( 3 ) - 1 else xsize3 = xsize ( 3 ) endif if ( nclx1 == 1 ) then nxc = nxm else nxc = nx endif if ( ncly1 == 1 ) then nyc = nym else nyc = ny endif if ( nclz1 == 1 ) then nzc = nzm else nzc = nz endif dep = zero do k = 1 , xsize3 do j = 1 , xsize2 do i = 1 , xsize1 !dep=dep+var(i,j,k)**2 dep = dep + var ( i , j , k ) enddo enddo enddo call MPI_ALLREDUCE ( dep , avg , 1 , real_type , MPI_SUM , MPI_COMM_WORLD , code ) !avg=sqrt_prec(avg)/(nxc*nyc*nzc) avg = avg / ( nxc * nyc * nzc ) return end subroutine avg3d end module decomp_2d_poisson","tags":"","url":"sourcefile/poisson_1stderivcomp.f90.html"},{"title":"basics_operations2.f90 – CHAPSim2","text":"Source Code !---------------------------------------------------------------------------------------------------------- !                      CHAPSim version 2.0.0 !                      -------------------------- ! This file is part of CHAPSim, a general-purpose CFD tool. ! ! This program is free software; you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation; either version 3 of the License, or (at your option) any later ! version. ! ! This program is disatributed in the hope that it will be useful, but WITHOUT ! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS ! FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more ! details. ! ! You should have received a copy of the GNU General Public License along with ! this program; if not, write to the Free Software Foundation, Inc., 51 Franklin ! Street, Fifth Floor, Boston, MA 02110-1301, USA. !---------------------------------------------------------------------------------------------------------- !========================================================================================================== !> \\file operations.f90 !> !> \\brief A general operation of derivative and interpolation in 1D. !> !========================================================================================================== module operations use precision_mod , only : WP use print_msg_mod use parameters_constant_mod implicit none private logical , save :: bc_ghost_cd = . true . logical , save :: bc_intp_upw = . false . logical , save :: flg_wrn_xmidp_c2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_xmidp_c2p_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_xmidp_c2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_xmidp_p2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_xmidp_p2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_ymidp_c2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_ymidp_c2p_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_ymidp_c2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_ymidp_p2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_ymidp_p2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_zmidp_c2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_zmidp_c2p_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_zmidp_c2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_zmidp_p2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_zmidp_p2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_c2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_c2c_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_c2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_p2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_p2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_c2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_c2p_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_c2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_p2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_x1der_p2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_c2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_c2c_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_c2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_p2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_p2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_c2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_c2p_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_c2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_p2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_y1der_p2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_c2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_c2c_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_c2c_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_p2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_p2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_c2p_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_c2p_dirichlet ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_c2p_neumann ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_p2c_interior ( 2 ) = ( / . false ., . false . / ) logical , save :: flg_wrn_z1der_p2c_neumann ( 2 ) = ( / . false ., . false . / ) !---------------------------------------------------------------------------------------------------------- ! basic coefficients for TDMA of 1st deriviative ! to store coefficients for TDMA !     d1fC2C vs d1rC2C : !       f : coefficients in the LHS, unknown side. !       r : coefficients in the RHS, known side. ! eg, d1fC2C(5, 3, 5) !     First column: 1:2 for L1,2, one side b.c. !                   4:5 for L4,5, the other side b.c. !                   3   for L-bulk, all other cells !     Second column: 1 for coefficients of LHS f&#94;(1)_{i-1} !                    2 for coefficients of LHS f&#94;(1)_{i} !                    3 for coefficients of LHS f&#94;(1)_{i+1} !     Third column:  for b.c. types !                    0 = IBC_INTERIOR !                    1 = IBC_PERIODIC !                    2 = IBC_SYMMETRIC !                    3 = IBC_ASYMMETRIC !                    4 = IBC_DIRICHLET !                    5 = IBC_NEUMANN !                    6 = IBC_INTRPL !     Fourth column:  Accuracy !                    1 = IACCU_CD2 !                    2 = IACCU_CD4 !                    3 = IACCU_CP4 !                    4 = IACCU_CP6 !---------------------------------------------------------------------------------------------------------- integer , parameter :: NL = 5 ! rows/line types integer , parameter :: NS = 3 ! how many coefficients integer , parameter :: NBCS = 0 ! bc index, start integer , parameter :: NBCE = 6 ! bc index, end integer , parameter :: NACC = 4 ! accuracy types !---------------------------------------------------------------------------------------------------------- ! for 1st derivative !---------------------------------------------------------------------------------------------------------- ! collocated C2C real ( WP ), save , public :: d1fC2C ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), save , public :: d1rC2C ( NL , 2 * NS , NBCS : NBCE , NACC ) ! collocated P2P real ( WP ), save , public :: d1fP2P ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), save , public :: d1rP2P ( NL , 2 * NS , NBCS : NBCE , NACC ) ! staggered C2P real ( WP ), save , public :: d1fC2P ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), save , public :: d1rC2P ( NL , 2 * NS , NBCS : NBCE , NACC ) ! staggered P2C real ( WP ), save , public :: d1fP2C ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), save , public :: d1rP2C ( NL , 2 * NS , NBCS : NBCE , NACC ) !---------------------------------------------------------------------------------------------------------- ! for iterpolation !---------------------------------------------------------------------------------------------------------- ! interpolation P2C real ( WP ), save , public :: m1fP2C ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), save , public :: m1rP2C ( NL , 2 * NS , NBCS : NBCE , NACC ) ! interpolation C2P real ( WP ), save , public :: m1fC2P ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), save , public :: m1rC2P ( NL , 2 * NS , NBCS : NBCE , NACC ) !---------------------------------------------------------------------------------------------------------- ! coefficients array for TDMA of 1st deriviative ! to store coefficients array for TDMA !---------------------------------------------------------------------------------------------------------- type t_xtdma_lhs !---------------------------------------------------------------------------------------------------------- !   x : pre-processed TDMA LHS Matrix for 1st deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad1x_P2P (:, :, :, :) real ( WP ), allocatable :: bd1x_P2P (:, :, :, :) real ( WP ), allocatable :: cd1x_P2P (:, :, :, :) real ( WP ), allocatable :: dd1x_P2P (:, :, :, :) real ( WP ), allocatable :: ad1x_C2C (:, :, :, :) real ( WP ), allocatable :: bd1x_C2C (:, :, :, :) real ( WP ), allocatable :: cd1x_C2C (:, :, :, :) real ( WP ), allocatable :: dd1x_C2C (:, :, :, :) real ( WP ), allocatable :: ad1x_P2C (:, :, :, :) real ( WP ), allocatable :: bd1x_P2C (:, :, :, :) real ( WP ), allocatable :: cd1x_P2C (:, :, :, :) real ( WP ), allocatable :: dd1x_P2C (:, :, :, :) real ( WP ), allocatable :: ad1x_C2P (:, :, :, :) real ( WP ), allocatable :: bd1x_C2P (:, :, :, :) real ( WP ), allocatable :: cd1x_C2P (:, :, :, :) real ( WP ), allocatable :: dd1x_C2P (:, :, :, :) !---------------------------------------------------------------------------------------------------------- !   x : pre-processed TDMA LHS Matrix for mid-point interpolation !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: am1x_P2C (:, :, :, :) real ( WP ), allocatable :: bm1x_P2C (:, :, :, :) real ( WP ), allocatable :: cm1x_P2C (:, :, :, :) real ( WP ), allocatable :: dm2x_P2C (:, :, :, :) real ( WP ), allocatable :: am1x_C2P (:, :, :, :) real ( WP ), allocatable :: bm1x_C2P (:, :, :, :) real ( WP ), allocatable :: cm1x_C2P (:, :, :, :) real ( WP ), allocatable :: dm2x_C2P (:, :, :, :) end type t_xtdma_lhs type ( t_xtdma_lhs ), allocatable :: xtdma_lhs (:) !---------------------------------------------------------------------------------------------------------- ! y : pre-processed TDMA LHS Matrix for 1st deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad1y_P2P (:, :, :, :) real ( WP ), allocatable :: bd1y_P2P (:, :, :, :) real ( WP ), allocatable :: cd1y_P2P (:, :, :, :) real ( WP ), allocatable :: dd1y_P2P (:, :, :, :) real ( WP ), allocatable :: ad1y_C2C (:, :, :, :) real ( WP ), allocatable :: bd1y_C2C (:, :, :, :) real ( WP ), allocatable :: cd1y_C2C (:, :, :, :) real ( WP ), allocatable :: dd1y_C2C (:, :, :, :) real ( WP ), allocatable :: ad1y_P2C (:, :, :, :) real ( WP ), allocatable :: bd1y_P2C (:, :, :, :) real ( WP ), allocatable :: cd1y_P2C (:, :, :, :) real ( WP ), allocatable :: dd1y_P2C (:, :, :, :) real ( WP ), allocatable :: ad1y_C2P (:, :, :, :) real ( WP ), allocatable :: bd1y_C2P (:, :, :, :) real ( WP ), allocatable :: cd1y_C2P (:, :, :, :) real ( WP ), allocatable :: dd1y_C2P (:, :, :, :) !---------------------------------------------------------------------------------------------------------- ! y : pre-processed TDMA LHS Matrix for mid-point interpolation !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: am1y_P2C (:, :, :, :) real ( WP ), allocatable :: bm1y_P2C (:, :, :, :) real ( WP ), allocatable :: cm1y_P2C (:, :, :, :) real ( WP ), allocatable :: dm1y_P2C (:, :, :, :) real ( WP ), allocatable :: am1y_C2P (:, :, :, :) real ( WP ), allocatable :: bm1y_C2P (:, :, :, :) real ( WP ), allocatable :: cm1y_C2P (:, :, :, :) real ( WP ), allocatable :: dm1y_C2P (:, :, :, :) !---------------------------------------------------------------------------------------------------------- ! z : pre-processed TDMA LHS Matrix for 1st deriviative !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: ad1z_P2P (:, :, :, :) real ( WP ), allocatable :: bd1z_P2P (:, :, :, :) real ( WP ), allocatable :: cd1z_P2P (:, :, :, :) real ( WP ), allocatable :: dd1z_P2P (:, :, :, :) real ( WP ), allocatable :: ad1z_C2C (:, :, :, :) real ( WP ), allocatable :: bd1z_C2C (:, :, :, :) real ( WP ), allocatable :: cd1z_C2C (:, :, :, :) real ( WP ), allocatable :: dd1z_C2C (:, :, :, :) real ( WP ), allocatable :: ad1z_P2C (:, :, :, :) real ( WP ), allocatable :: bd1z_P2C (:, :, :, :) real ( WP ), allocatable :: cd1z_P2C (:, :, :, :) real ( WP ), allocatable :: dd1z_P2C (:, :, :, :) real ( WP ), allocatable :: ad1z_C2P (:, :, :, :) real ( WP ), allocatable :: bd1z_C2P (:, :, :, :) real ( WP ), allocatable :: cd1z_C2P (:, :, :, :) real ( WP ), allocatable :: dd1z_C2P (:, :, :, :) !---------------------------------------------------------------------------------------------------------- ! z : pre-processed TDMA LHS Matrix for mid-point interpolation !---------------------------------------------------------------------------------------------------------- real ( WP ), allocatable :: am1z_P2C (:, :, :, :) real ( WP ), allocatable :: bm1z_P2C (:, :, :, :) real ( WP ), allocatable :: cm1z_P2C (:, :, :, :) real ( WP ), allocatable :: dm2z_P2C (:, :, :, :) real ( WP ), allocatable :: am1z_C2P (:, :, :, :) real ( WP ), allocatable :: bm1z_C2P (:, :, :, :) real ( WP ), allocatable :: cm1z_C2P (:, :, :, :) real ( WP ), allocatable :: dm2z_C2P (:, :, :, :) !---------------------------------------------------------------------------------------------------------- ! processures !---------------------------------------------------------------------------------------------------------- private :: Prepare_compact_coefficients private :: Buildup_TDMA_LHS_array public :: Prepare_LHS_coeffs_for_operations private :: buildup_ghost_cells_P private :: buildup_ghost_cells_C private :: Prepare_TDMA_interp_P2C_RHS_array private :: Get_x_midp_P2C_1D private :: Get_y_midp_P2C_1D private :: Get_z_midp_P2C_1D public :: Get_x_midp_P2C_3D public :: Get_y_midp_P2C_3D public :: Get_z_midp_P2C_3D private :: Prepare_TDMA_interp_C2P_RHS_array private :: Get_x_midp_C2P_1D private :: Get_y_midp_C2P_1D private :: Get_z_midp_C2P_1D public :: Get_x_midp_C2P_3D public :: Get_y_midp_C2P_3D public :: Get_z_midp_C2P_3D private :: Prepare_TDMA_1deri_C2C_RHS_array private :: Get_x_1der_C2C_1D private :: Get_y_1der_C2C_1D private :: Get_z_1der_C2C_1D public :: Get_x_1der_C2C_3D public :: Get_y_1der_C2C_3D public :: Get_z_1der_C2C_3D private :: Prepare_TDMA_1deri_P2P_RHS_array private :: Get_x_1der_P2P_1D private :: Get_y_1der_P2P_1D private :: Get_z_1der_P2P_1D public :: Get_x_1der_P2P_3D public :: Get_y_1der_P2P_3D public :: Get_z_1der_P2P_3D private :: Prepare_TDMA_1deri_C2P_RHS_array private :: Get_x_1der_C2P_1D private :: Get_y_1der_C2P_1D private :: Get_z_1der_C2P_1D public :: Get_x_1der_C2P_3D public :: Get_y_1der_C2P_3D public :: Get_z_1der_C2P_3D private :: Prepare_TDMA_1deri_P2C_RHS_array private :: Get_x_1der_P2C_1D private :: Get_y_1der_P2C_1D private :: Get_z_1der_P2C_1D public :: Get_x_1der_P2C_3D public :: Get_y_1der_P2C_3D public :: Get_z_1der_P2C_3D public :: Test_interpolation public :: Test_1st_derivative private :: reduce_bc_to_interp private :: check_size contains subroutine check_size ( var_name , dim , expected , actual , message ) integer , intent ( in ) :: dim , expected , actual character ( * ), intent ( in ) :: var_name , message if ( expected /= actual ) then write ( * , * ) 'nrank, ' , var_name , nrank , expected , actual call Print_error_msg ( \"Error: \" // message ) end if end subroutine check_size subroutine reduce_bc_to_interp ( ibc , flg , strbc , strcode ) use parameters_constant_mod use mpi_mod implicit none integer , intent ( inout ) :: ibc logical , intent ( inout ) :: flg character ( * ), intent ( in ) :: strbc character ( * ), intent ( in ) :: strcode if ((. not . flg ) . and . nrank == 0 ) & call Print_warning_msg ( 'Lack of fbc for ' // trim ( strbc ) // ', which is reduced to IBC_INTRPL in subroutine: ' // trim ( strcode )) flg = . true . ibc = IBC_INTRPL return end subroutine !========================================================================================================== !> \\brief Assigned the cooefficients for the compact schemes !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   privatee !> reference: !> [Gaitonde1998] Gaitonde, D.V. and Visbal, M., 1998. High-order schemes for Navier-Stokes quations: algorithm !> and implementation into FDL3DI. Air Vehicles Directorte, Air Force Research Laboratory, Air Force Materiel Command. !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role                                           ! !---------------------------------------------------------------------------------------------------------- !> \\param[in]     iaccu         the accuracy given by user !========================================================================================================== subroutine Prepare_compact_coefficients use parameters_constant_mod use input_general_mod use mpi_mod implicit none real ( WP ) :: alpha ( NACC ), a ( NACC ), b ( NACC ), c ( NACC ) real ( WP ) :: alpha1 ( NACC ), a1 ( NACC ), b1 ( NACC ), c1 ( NACC ), d1 ( NACC ), e1 ( NACC ), f1 ( NACC ) real ( WP ) :: alpha2 ( NACC ), a2 ( NACC ), b2 ( NACC ), c2 ( NACC ), d2 ( NACC ), e2 ( NACC ), f2 ( NACC ) integer :: n if ( nrank == 0 ) then call Print_debug_start_msg & ( \"Assigning coefficient matrix for the compact schemes ...\" ) !write(*, *) \"The given numerical accuracy =\", iaccu end if if ( bc_ghost_cd . and . bc_intp_upw ) call Print_error_msg ( \"Please choose a boundary treatment method correctly.\" ) !---------------------------------------------------------------------------------------------------------- !   initialisation !---------------------------------------------------------------------------------------------------------- d1fC2C (:, :, :, :) = MAXP d1rC2C (:, :, :, :) = MAXP d1fP2P (:, :, :, :) = MAXP d1rP2P (:, :, :, :) = MAXP d1fC2P (:, :, :, :) = MAXP d1rC2P (:, :, :, :) = MAXP d1fP2C (:, :, :, :) = MAXP d1rP2C (:, :, :, :) = MAXP m1fC2P (:, :, :, :) = MAXP m1rC2P (:, :, :, :) = MAXP m1fP2C (:, :, :, :) = MAXP m1rP2C (:, :, :, :) = MAXP !========================================================================================================== ! Set 1 : C2C, periodic & symmetric & asymmetric !         1st derivative on collocated grids, C2C/P2P bulk coefficients ! d1fC2C : \"d1\"=first deriviative, \"f\"=f'  side, \"C2C\"= center 2 centre ! d1rC2C : \"d1\"=first deriviative, \"r\"=rhs side, \"C2C\"= center 2 centre ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) ! C2C unknows: ! when i=1,    need: LHS: f'_0;      RHS: f_0, f_{-1} ! when i=2,    need:                 RHS: f_0 ! when i=nc-1, need:                 RHS: f_{nc+1} ! when i=nc,   need: LHS: f'_{nc+1}; RHS: f_{nc+1}, f_{nc+2} !========================================================================================================== ! below ref: Table 2.1 in [Gaitonde1998] alpha = 0.0_WP a = 0.0_WP b = 0.0_WP c = 0.0_WP do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha ( n ) = 0.0_WP a ( n ) = 1.0_WP b ( n ) = 0.0_WP case ( IACCU_CD4 ) alpha ( n ) = 0.0_WP a ( n ) = 4.0_WP / 3.0_WP b ( n ) = - 1.0_WP / 3.0_WP case ( IACCU_CP4 ) alpha ( n ) = 1.0_WP / 4.0_WP a ( n ) = 3.0_WP / 2.0_WP b ( n ) = 0.0_WP case ( IACCU_CP6 ) alpha ( n ) = 1.0_WP / 3.0_WP a ( n ) = 1 4.0_WP / 9.0_WP b ( n ) = 1.0_WP / 9.0_WP case default print * , \"Invalid accuracy\" end select end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2C, IBC_PERIODIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2C ( 1 : 5 , 1 , IBC_PERIODIC , n ) = alpha ( n ) d1fC2C ( 1 : 5 , 2 , IBC_PERIODIC , n ) = ONE d1fC2C ( 1 : 5 , 3 , IBC_PERIODIC , n ) = alpha ( n ) d1rC2C ( 1 : 5 , 1 , IBC_PERIODIC , n ) = a ( n ) * HALF ! a/2 d1rC2C ( 1 : 5 , 2 , IBC_PERIODIC , n ) = b ( n ) * QUARTER ! b/4 end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2C, IBC_SYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2C ( 1 , 1 , IBC_SYMMETRIC , n ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_SYMMETRIC , n ) = ONE - alpha ( n ) d1fC2C ( 1 , 3 , IBC_SYMMETRIC , n ) = alpha ( n ) d1fC2C ( 5 , 1 , IBC_SYMMETRIC , n ) = d1fC2C ( 1 , 3 , IBC_SYMMETRIC , n ) d1fC2C ( 5 , 2 , IBC_SYMMETRIC , n ) = d1fC2C ( 1 , 2 , IBC_SYMMETRIC , n ) d1fC2C ( 5 , 3 , IBC_SYMMETRIC , n ) = d1fC2C ( 1 , 1 , IBC_SYMMETRIC , n ) d1fC2C ( 2 : 4 , :, IBC_SYMMETRIC , n ) = d1fC2C ( 2 : 4 , :, IBC_PERIODIC , n ) d1rC2C (:, :, IBC_SYMMETRIC , n ) = d1rC2C (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2C, IBC_ASYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2C ( 1 , 1 , IBC_ASYMMETRIC , n ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_ASYMMETRIC , n ) = ONE + alpha ( n ) d1fC2C ( 1 , 3 , IBC_ASYMMETRIC , n ) = alpha ( n ) d1fC2C ( 5 , 1 , IBC_ASYMMETRIC , n ) = d1fC2C ( 1 , 3 , IBC_ASYMMETRIC , n ) d1fC2C ( 5 , 2 , IBC_ASYMMETRIC , n ) = d1fC2C ( 1 , 2 , IBC_ASYMMETRIC , n ) d1fC2C ( 5 , 3 , IBC_ASYMMETRIC , n ) = d1fC2C ( 1 , 1 , IBC_ASYMMETRIC , n ) d1fC2C ( 2 : 4 , :, IBC_ASYMMETRIC , n ) = d1fC2C ( 2 : 4 , :, IBC_PERIODIC , n ) d1rC2C (:, :, IBC_ASYMMETRIC , n ) = d1rC2C (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2C, IBC_INTERIOR, f unknowns only from rhs could be reconstructed from bc, thus explicit ! f' unknow is only first layer ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- d1fC2C (:, :, IBC_INTERIOR , :) = d1fC2C (:, :, IBC_PERIODIC , :) d1rC2C (:, :, IBC_INTERIOR , :) = d1rC2C (:, :, IBC_PERIODIC , :) do n = 1 , NACC if ( n == IACCU_CP4 . or . n == IACCU_CP6 ) then d1fC2C ( 1 , :, IBC_INTERIOR , n ) = d1fC2C ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rC2C ( 1 , :, IBC_INTERIOR , n ) = d1rC2C ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1fC2C ( 5 , :, IBC_INTERIOR , n ) = d1fC2C ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rC2C ( 5 , :, IBC_INTERIOR , n ) = d1rC2C ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD end if end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2C, IBC_INTRPL, no bc, no reconstuction. exterpolation only. for the first point !                    f'_1 + alpha * f'_{2}   = a1 * f_1 + b1 * f_2 + c1 * f-3 + ... ! alpha * f'_{1}   + f'_2 + alpha * f'_{3}   = a2 * f_1 + b2 * f_2 + c2 * f-3 + ... ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! below ref: Table 2.2 in [Gaitonde1998] alpha1 = 0.0_WP a1 = 0.0_WP b1 = 0.0_WP c1 = 0.0_WP d1 = 0.0_WP e1 = 0.0_WP f1 = 0.0_WP do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha1 ( n ) = 0.0_WP a1 ( n ) = - 3.0_WP / 2.0_WP b1 ( n ) = 2.0_WP c1 ( n ) = - 1.0_WP / 2.0_WP case ( IACCU_CD4 ) alpha1 ( n ) = 0.0_WP a1 ( n ) = - 2 5.0_WP / 1 2.0_WP b1 ( n ) = 4.0_WP c1 ( n ) = - 3.0_WP d1 ( n ) = 4.0_WP / 3.0_WP e1 ( n ) = - 1.0_WP / 4.0_WP case ( IACCU_CP4 ) alpha1 ( n ) = 3.0_WP a1 ( n ) = - 1 7.0_WP / 6.0_WP b1 ( n ) = 3.0_WP / 2.0_WP c1 ( n ) = 3.0_WP / 2.0_WP d1 ( n ) = - 1.0_WP / 6.0_WP case ( IACCU_CP6 ) alpha1 ( n ) = 5.0_WP a1 ( n ) = - 19 7.0_WP / 6 0.0_WP b1 ( n ) = - 5.0_WP / 1 2.0_WP c1 ( n ) = 5.0_WP d1 ( n ) = - 5.0_WP / 3.0_WP e1 ( n ) = 5.0_WP / 1 2.0_WP f1 ( n ) = - 1.0_WP / 2 0.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC d1fC2C ( 1 , 1 , IBC_INTRPL , n ) = ZERO ! not used d1fC2C ( 1 , 2 , IBC_INTRPL , n ) = ONE d1fC2C ( 1 , 3 , IBC_INTRPL , n ) = alpha1 ( n ) d1rC2C ( 1 , 1 , IBC_INTRPL , n ) = a1 ( n ) d1rC2C ( 1 , 2 , IBC_INTRPL , n ) = b1 ( n ) d1rC2C ( 1 , 3 , IBC_INTRPL , n ) = c1 ( n ) d1rC2C ( 1 , 4 , IBC_INTRPL , n ) = d1 ( n ) d1rC2C ( 1 , 5 , IBC_INTRPL , n ) = e1 ( n ) d1rC2C ( 1 , 6 , IBC_INTRPL , n ) = f1 ( n ) d1fC2C ( 5 , 1 , IBC_INTRPL , n ) = d1fC2C ( 1 , 3 , IBC_INTRPL , n ) d1fC2C ( 5 , 2 , IBC_INTRPL , n ) = d1fC2C ( 1 , 2 , IBC_INTRPL , n ) d1fC2C ( 5 , 3 , IBC_INTRPL , n ) = d1fC2C ( 1 , 1 , IBC_INTRPL , n ) d1rC2C ( 5 , :, IBC_INTRPL , n ) = - d1rC2C ( 1 , :, IBC_INTRPL , n ) end do do n = 1 , NACC d1fC2C ( 3 , :, IBC_INTRPL , n ) = d1fC2C ( 3 , :, IBC_PERIODIC , n ) d1rC2C ( 3 , :, IBC_INTRPL , n ) = d1rC2C ( 3 , :, IBC_PERIODIC , n ) end do ! below ref: Table 2.6 & 2.3 in [Gaitonde1998] alpha2 = 0.0_WP a2 = 0.0_WP b2 = 0.0_WP c2 = 0.0_WP d2 = 0.0_WP e2 = 0.0_WP f2 = 0.0_WP do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha2 ( n ) = 0.0_WP a2 ( n ) = - 1.0_WP / 2.0_WP b2 ( n ) = 0.0_WP c2 ( n ) = 1.0_WP / 2.0_WP case ( IACCU_CD4 ) alpha2 ( n ) = 0.0_WP a2 ( n ) = - 1.0_WP / 4.0_WP b2 ( n ) = - 5.0_WP / 6.0_WP c2 ( n ) = 3.0_WP / 2.0_WP d2 ( n ) = - 1.0_WP / 2.0_WP e2 ( n ) = 1.0_WP / 1 2.0_WP case ( IACCU_CP4 ) alpha2 ( n ) = 1.0_WP / 4.0_WP a2 ( n ) = - 3.0_WP / 4.0_WP b2 ( n ) = 0.0_WP c2 ( n ) = 3.0_WP / 4.0_WP case ( IACCU_CP6 ) alpha2 ( n ) = 2.0_WP / 1 1.0_WP a2 ( n ) = - 2 0.0_WP / 3 3.0_WP b2 ( n ) = - 3 5.0_WP / 13 2.0_WP c2 ( n ) = 3 4.0_WP / 3 3.0_WP d2 ( n ) = - 7.0_WP / 3 3.0_WP e2 ( n ) = 2.0_WP / 3 3.0_WP f2 ( n ) = - 1.0_WP / 13 2.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC d1fC2C ( 2 , 1 , IBC_INTRPL , n ) = alpha2 ( n ) d1fC2C ( 2 , 2 , IBC_INTRPL , n ) = ONE d1fC2C ( 2 , 3 , IBC_INTRPL , n ) = alpha2 ( n ) d1rC2C ( 2 , 1 , IBC_INTRPL , n ) = a2 ( n ) d1rC2C ( 2 , 2 , IBC_INTRPL , n ) = b2 ( n ) d1rC2C ( 2 , 3 , IBC_INTRPL , n ) = c2 ( n ) d1rC2C ( 2 , 4 , IBC_INTRPL , n ) = d2 ( n ) d1rC2C ( 2 , 5 , IBC_INTRPL , n ) = e2 ( n ) d1rC2C ( 2 , 6 , IBC_INTRPL , n ) = f2 ( n ) d1fC2C ( 4 , 1 , IBC_INTRPL , n ) = d1fC2C ( 2 , 3 , IBC_INTRPL , n ) d1fC2C ( 4 , 2 , IBC_INTRPL , n ) = d1fC2C ( 2 , 2 , IBC_INTRPL , n ) d1fC2C ( 4 , 3 , IBC_INTRPL , n ) = d1fC2C ( 2 , 1 , IBC_INTRPL , n ) d1rC2C ( 4 , :, IBC_INTRPL , n ) = - d1rC2C ( 2 , :, IBC_INTRPL , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2C: IBC_DIRICHLET, IBC_NEUMANN !---------------------------------------------------------------------------------------------------------- if ( bc_ghost_cd ) then d1fC2C (:, :, IBC_DIRICHLET , :) = d1fC2C (:, :, IBC_INTERIOR , :) d1rC2C (:, :, IBC_DIRICHLET , :) = d1rC2C (:, :, IBC_INTERIOR , :) d1fC2C (:, :, IBC_NEUMANN , :) = d1fC2C (:, :, IBC_INTERIOR , :) d1rC2C (:, :, IBC_NEUMANN , :) = d1rC2C (:, :, IBC_INTERIOR , :) end if if ( bc_intp_upw ) then d1fC2C (:, :, IBC_DIRICHLET , :) = d1fC2C (:, :, IBC_INTRPL , :) d1rC2C (:, :, IBC_DIRICHLET , :) = d1rC2C (:, :, IBC_INTRPL , :) d1fC2C (:, :, IBC_NEUMANN , :) = d1fC2C (:, :, IBC_INTRPL , :) d1rC2C (:, :, IBC_NEUMANN , :) = d1rC2C (:, :, IBC_INTRPL , :) end if !========================================================================================================== ! 1st-derivative, P2P : ! d1fP2P : \"d1\"=first deriviative, \"f\"=f'  side, \"P2P\"= point(node) 2 point ! d1rP2P : \"d1\"=first deriviative, \"r\"=rhs side, \"P2P\"= point(node) 2 point ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(2h) * ( f_{i'+1} - f_{i'-1} ) + & !                                                 b/(4h) * ( f_{i'+2} - f_{i'-2} ) ! P2P unknows: ! when i'=1,     need: LHS: f'_0';      RHS: f_0', f_{-1'} ! when i'=2,     need:                  RHS: f_0' ! when i'=np'-1, need:                  RHS: f_{np'+1} ! when i'=np',   need: LHS: f'_{np'+1}; RHS: f_{np'+1}, f_{np'+2} !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P, IBC_PERIODIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_PERIODIC , :) = d1fC2C (:, :, IBC_PERIODIC , :) d1rP2P (:, :, IBC_PERIODIC , :) = d1rC2C (:, :, IBC_PERIODIC , :) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P : IBC_SYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fP2P ( 1 , 1 , IBC_SYMMETRIC , n ) = ZERO ! not used d1fP2P ( 1 , 2 , IBC_SYMMETRIC , n ) = ONE d1fP2P ( 1 , 3 , IBC_SYMMETRIC , n ) = ZERO d1fP2P ( 5 , 1 , IBC_SYMMETRIC , n ) = d1fP2P ( 1 , 3 , IBC_SYMMETRIC , n ) d1fP2P ( 5 , 2 , IBC_SYMMETRIC , n ) = d1fP2P ( 1 , 2 , IBC_SYMMETRIC , n ) d1fP2P ( 5 , 3 , IBC_SYMMETRIC , n ) = d1fP2P ( 1 , 1 , IBC_SYMMETRIC , n ) d1fP2P ( 2 : 4 , :, IBC_SYMMETRIC , n ) = d1fP2P ( 2 : 4 , :, IBC_PERIODIC , n ) d1rP2P (:, :, IBC_SYMMETRIC , n ) = d1rP2P (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P : IBC_ASYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fP2P ( 1 , 1 , IBC_ASYMMETRIC , n ) = ZERO ! not used d1fP2P ( 1 , 2 , IBC_ASYMMETRIC , n ) = ONE d1fP2P ( 1 , 3 , IBC_ASYMMETRIC , n ) = TWO * alpha ( n ) d1fP2P ( 5 , 1 , IBC_ASYMMETRIC , n ) = d1fP2P ( 1 , 3 , IBC_ASYMMETRIC , n ) d1fP2P ( 5 , 2 , IBC_ASYMMETRIC , n ) = d1fP2P ( 1 , 2 , IBC_ASYMMETRIC , n ) d1fP2P ( 5 , 3 , IBC_ASYMMETRIC , n ) = d1fP2P ( 1 , 1 , IBC_ASYMMETRIC , n ) d1fP2P ( 2 : 4 , :, IBC_ASYMMETRIC , n ) = d1fP2P ( 2 : 4 , :, IBC_PERIODIC , n ) d1rP2P (:, :, IBC_ASYMMETRIC , n ) = d1rP2P (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P : IBC_INTERIOR, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_INTERIOR , :) = d1fP2P (:, :, IBC_PERIODIC , :) d1rP2P (:, :, IBC_INTERIOR , :) = d1rP2P (:, :, IBC_PERIODIC , :) do n = 1 , NACC if ( n == IACCU_CP4 . or . n == IACCU_CP6 ) then d1fP2P ( 1 , :, IBC_INTERIOR , n ) = d1fP2P ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rP2P ( 1 , :, IBC_INTERIOR , n ) = d1rP2P ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1fP2P ( 5 , :, IBC_INTERIOR , n ) = d1fP2P ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rP2P ( 5 , :, IBC_INTERIOR , n ) = d1rP2P ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD end if end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P : exterpolation ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(2h) * ( f_{i'+1} - f_{i'-1} ) + & !                                                 b/(4h) * ( f_{i'+2} - f_{i'-2} ) ! 1st-derivative, C2C, IBC_INTRPL, no bc, no reconstuction. exterpolation only. !                     f'_1' + alpha * f'_{2'}   = a1 * f_1' + b1 * f_2' + c1 * f_3' ! alpha * f'_{1'}   + f'_2' + alpha * f'_{3'}   = a/(2h) * ( f_{i'+1} - f_{i'-1} ) ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(2h) * ( f_{i'+1} - f_{i'-1} ) + & !                                                 b/(4h) * ( f_{i'+2} - f_{i'-2} ) !---------------------------------------------------------------------------------------------------------- d1fP2P (:, :, IBC_INTRPL , :) = d1fC2C (:, :, IBC_INTRPL , :) d1rP2P (:, :, IBC_INTRPL , :) = d1rC2C (:, :, IBC_INTRPL , :) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P : NEUMANN, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fP2P ( 1 , 1 , IBC_NEUMANN , n ) = ZERO ! not used d1fP2P ( 1 , 2 , IBC_NEUMANN , n ) = ONE d1fP2P ( 1 , 3 , IBC_NEUMANN , n ) = ZERO d1rP2P ( 1 , :, IBC_NEUMANN , n ) = ZERO d1fP2P ( 5 , 1 , IBC_NEUMANN , n ) = ZERO d1fP2P ( 5 , 2 , IBC_NEUMANN , n ) = ONE d1fP2P ( 5 , 3 , IBC_NEUMANN , n ) = ZERO d1rP2P ( 5 , :, IBC_NEUMANN , n ) = ZERO end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2P : IBC_DIRICHLET, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- if ( bc_intp_upw ) then d1fP2P (:, :, IBC_DIRICHLET , :) = d1fP2P (:, :, IBC_INTRPL , :) d1rP2P (:, :, IBC_DIRICHLET , :) = d1rP2P (:, :, IBC_INTRPL , :) d1fP2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1fP2P ( 2 : 4 , :, IBC_INTRPL , :) d1rP2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1rP2P ( 2 : 4 , :, IBC_INTRPL , :) end if if ( bc_ghost_cd ) then d1fP2P (:, :, IBC_DIRICHLET , :) = d1fP2P (:, :, IBC_INTERIOR , :) d1rP2P (:, :, IBC_DIRICHLET , :) = d1rP2P (:, :, IBC_INTERIOR , :) d1fP2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1fP2P ( 2 : 4 , :, IBC_INTERIOR , :) d1rP2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1rP2P ( 2 : 4 , :, IBC_INTERIOR , :) end if !========================================================================================================== ! 1st derivative on staggered grids C2P ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(h ) * ( f_{i}   - f_{i-1} ) + & !                                                 b/(3h) * ( f_{i+1} - f_{i-2} ) ! when i' = 1',    need: f'_0', f_0, f_{-1} ! when i' = 2',    need: f_0 ! when i' = np-1', need: f_{np} ! when i' = np',   need: f'_{np+1'}, f_{np}, f_{np+1} !========================================================================================================== ! below ref: Table 2.10 in [Gaitonde1998] alpha = 0.0_WP a = 0.0_WP b = 0.0_WP c = 0.0_WP do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha ( n ) = 0.0_WP a ( n ) = 1.0_WP b ( n ) = 0.0_WP case ( IACCU_CD4 ) alpha ( n ) = 0.0_WP a ( n ) = ( 9.0_WP - 6.0_WP * alpha ( n )) / 8.0_WP b ( n ) = ( - 1.0_WP + 2 2.0_WP * alpha ( n )) / 8.0_WP case ( IACCU_CP4 ) alpha ( n ) = 1.0_WP / 2 2.0_WP a ( n ) = ( 9.0_WP - 6.0_WP * alpha ( n )) / 8.0_WP b ( n ) = ( - 1.0_WP + 2 2.0_WP * alpha ( n )) / 8.0_WP case ( IACCU_CP6 ) alpha ( n ) = 9.0_WP / 6 2.0_WP a ( n ) = 6 3.0_WP / 6 2.0_WP b ( n ) = 1 7.0_WP / 6 2.0_WP case default print * , \"Invalid accuracy\" end select end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2P, IBC_PERIODIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2P ( 1 : 5 , 1 , IBC_PERIODIC , n ) = alpha ( n ) d1fC2P ( 1 : 5 , 2 , IBC_PERIODIC , n ) = ONE d1fC2P ( 1 : 5 , 3 , IBC_PERIODIC , n ) = alpha ( n ) d1rC2P ( 1 : 5 , 1 , IBC_PERIODIC , n ) = a ( n ) ! a d1rC2P ( 1 : 5 , 2 , IBC_PERIODIC , n ) = b ( n ) * ONE_THIRD ! b/3 d1rC2P ( 1 : 5 , 3 , IBC_PERIODIC , n ) = ZERO ! not used. end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2P, IBC_SYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2P ( 1 , 1 , IBC_SYMMETRIC , n ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_SYMMETRIC , n ) = ONE d1fC2P ( 1 , 3 , IBC_SYMMETRIC , n ) = ZERO d1fC2P ( 5 , 1 , IBC_SYMMETRIC , n ) = d1fC2P ( 1 , 3 , IBC_SYMMETRIC , n ) d1fC2P ( 5 , 2 , IBC_SYMMETRIC , n ) = d1fC2P ( 1 , 2 , IBC_SYMMETRIC , n ) d1fC2P ( 5 , 3 , IBC_SYMMETRIC , n ) = d1fC2P ( 1 , 1 , IBC_SYMMETRIC , n ) d1fC2P ( 2 : 4 , :, IBC_SYMMETRIC , n ) = d1fC2P ( 2 : 4 , :, IBC_PERIODIC , n ) d1rC2P (:, :, IBC_SYMMETRIC , n ) = d1rC2P (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2P : IBC_ASYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2P ( 1 , 1 , IBC_ASYMMETRIC , n ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_ASYMMETRIC , n ) = ONE d1fC2P ( 1 , 3 , IBC_ASYMMETRIC , n ) = TWO * alpha ( n ) d1fC2P ( 5 , 1 , IBC_ASYMMETRIC , n ) = d1fC2P ( 1 , 3 , IBC_ASYMMETRIC , n ) d1fC2P ( 5 , 2 , IBC_ASYMMETRIC , n ) = d1fC2P ( 1 , 2 , IBC_ASYMMETRIC , n ) d1fC2P ( 5 , 3 , IBC_ASYMMETRIC , n ) = d1fC2P ( 1 , 1 , IBC_ASYMMETRIC , n ) d1fC2P ( 2 : 4 , :, IBC_ASYMMETRIC , n ) = d1fC2P ( 2 : 4 , :, IBC_PERIODIC , n ) d1rC2P (:, :, IBC_ASYMMETRIC , n ) = d1rC2P (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2P, IBC_INTERIOR, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- d1fC2P (:, :, IBC_INTERIOR , :) = d1fC2P (:, :, IBC_PERIODIC , :) d1rC2P (:, :, IBC_INTERIOR , :) = d1rC2P (:, :, IBC_PERIODIC , :) do n = 1 , NACC if ( n == IACCU_CP4 . or . n == IACCU_CP6 ) then d1fC2P ( 1 , :, IBC_INTERIOR , n ) = d1fC2P ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rC2P ( 1 , :, IBC_INTERIOR , n ) = d1rC2P ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1fC2P ( 5 , :, IBC_INTERIOR , n ) = d1fC2P ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rC2P ( 5 , :, IBC_INTERIOR , n ) = d1rC2P ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD end if end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : C2P, IBC_INTRPL, no bc, no reconstuction. exterpolation only. ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(h ) * ( f_{i}   - f_{i-1} ) + & !                                                 b/(3h) * ( f_{i+1} - f_{i-2} ) ! when i' = 1',    need: f'_0', f_0, f_{-1} ! when i' = 2',    need: f_0 ! when i' = np-1', need: f_{np} ! when i' = np',   need: f'_{np+1'}, f_{np}, f_{np+1} ! [ 1     alpha1                            ][f'_1']=[a1 * f_{1}/h  + b1 * f_{2}/h + c1 * f_{3}/h  ] ! [alpha2 1      alpha2                     ][f'_2'] [a2 * (f_{2} - f_{1})/h  ] ! [       alpha  1      alpha               ][f'_i'] [a *  (f_{i} - f_{i-1})/h + b/3 * (f_{i+1} - f_{i-2})/h] ! [                     alpha2 1      alpha2][f'_4'] [a2 * (f_{n-1} - f_{n-2})/h] ! [                            alpha1 1     ][f'_5'] [-a1 * f_{n-1}/h  - b1 * f_{n-2}/h - c1 * f_{n-3}/h] ! tested: low accuracy at the line 2 and 4. !---------------------------------------------------------------------------------------------------------- !    ref: [Gaitonde1998] Table 2.12 alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO e1 = ZERO f1 = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha1 ( n ) = ZERO a1 ( n ) = - 2.0_WP - alpha1 ( n ) b1 ( n ) = 3.0_WP + alpha1 ( n ) c1 ( n ) = - 1.0_WP case ( IACCU_CD4 , IACCU_CP4 ) alpha1 ( n ) = ZERO ! 22.0_WP invalids TDMA a1 ( n ) = ( - 9 3.0_WP - 2 2.0_WP * alpha1 ( n )) / 2 4.0_WP b1 ( n ) = ( 22 9.0_WP + 1 7.0_WP * alpha1 ( n )) / 2 4.0_WP c1 ( n ) = ( - 7 5.0_WP + 3.0_WP * alpha1 ( n )) / 8.0_WP d1 ( n ) = ( 11 1.0_WP - 5.0_WP * alpha1 ( n )) / 2 4.0_WP e1 ( n ) = ( - 2 2.0_WP + 1.0_WP * alpha1 ( n )) / 2 4.0_WP case ( IACCU_CP6 ) alpha1 ( n ) = 168 9.0_WP / 7 1.0_WP ! this is 5th order Compact a1 ( n ) = ( - 304 3.0_WP - 56 3.0_WP * alpha1 ( n )) / 64 0.0_WP b1 ( n ) = ( 535 3.0_WP + 20 1.0_WP * alpha1 ( n )) / 38 4.0_WP c1 ( n ) = ( - 348 9.0_WP + 14 3.0_WP * alpha1 ( n )) / 19 2.0_WP d1 ( n ) = ( 85 9.0_WP - 3 7.0_WP * alpha1 ( n )) / 6 4.0_WP e1 ( n ) = ( - 204 1.0_WP + 8 7.0_WP * alpha1 ( n )) / 38 4.0_WP f1 ( n ) = ( 168 9.0_WP - 7 1.0_WP * alpha1 ( n )) / 192 0.0_WP ! alpha1(n) =     1627.0_WP /     62.0_WP !     a1(n) = -1104667.0_WP /  39680.0_WP !     b1(n) =   658913.0_WP /  23808.0_WP !     c1(n) =    16343.0_WP /  11904.0_WP !     d1(n) =    -6941.0_WP /   3968.0_WP !     e1(n) =    15007.0_WP /  23808.0_WP !     f1(n) =   -10799.0_WP / 119040.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC d1fC2P ( 1 , 1 , IBC_INTRPL , n ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_INTRPL , n ) = ONE d1fC2P ( 1 , 3 , IBC_INTRPL , n ) = alpha1 ( n ) d1rC2P ( 1 , 1 , IBC_INTRPL , n ) = a1 ( n ) d1rC2P ( 1 , 2 , IBC_INTRPL , n ) = b1 ( n ) d1rC2P ( 1 , 3 , IBC_INTRPL , n ) = c1 ( n ) d1rC2P ( 1 , 4 , IBC_INTRPL , n ) = d1 ( n ) d1rC2P ( 1 , 5 , IBC_INTRPL , n ) = e1 ( n ) d1rC2P ( 1 , 6 , IBC_INTRPL , n ) = f1 ( n ) d1fC2P ( 5 , 1 , IBC_INTRPL , n ) = d1fC2P ( 1 , 3 , IBC_INTRPL , n ) d1fC2P ( 5 , 2 , IBC_INTRPL , n ) = d1fC2P ( 1 , 2 , IBC_INTRPL , n ) d1fC2P ( 5 , 3 , IBC_INTRPL , n ) = d1fC2P ( 1 , 1 , IBC_INTRPL , n ) d1rC2P ( 5 , :, IBC_INTRPL , n ) = - d1rC2P ( 1 , :, IBC_INTRPL , n ) end do do n = 1 , NACC d1fC2P ( 3 , :, IBC_INTRPL , n ) = d1fC2P ( 3 , :, IBC_PERIODIC , n ) d1rC2P ( 3 , :, IBC_INTRPL , n ) = d1rC2P ( 3 , :, IBC_PERIODIC , n ) end do !    ref: [Gaitonde1998] Table 2.13 alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO d2 = ZERO e2 = ZERO f2 = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha2 ( n ) = 0.0_WP a2 ( n ) = - 1.0_WP b2 ( n ) = 1.0_WP case ( IACCU_CD4 ) alpha2 ( n ) = 0.0_WP a2 ( n ) = ( - 1 1.0_WP - 4 6.0_WP * alpha2 ( n )) / 1 2.0_WP b2 ( n ) = ( 1 7.0_WP + 20 2.0_WP * alpha2 ( n )) / 2 4.0_WP c2 ( n ) = ( 3.0_WP - 6 6.0_WP * alpha2 ( n )) / 8.0_WP d2 ( n ) = ( - 5.0_WP + 11 0.0_WP * alpha2 ( n )) / 2 4.0_WP e2 ( n ) = ( 1.0_WP - 2 2.0_WP * alpha2 ( n )) / 2 4.0_WP case ( IACCU_CP4 ) alpha2 ( n ) = 1.0_WP / 2 2.0_WP a2 ( n ) = ( - 1 1.0_WP - 4 6.0_WP * alpha2 ( n )) / 1 2.0_WP b2 ( n ) = ( 1 7.0_WP + 20 2.0_WP * alpha2 ( n )) / 2 4.0_WP c2 ( n ) = ( 3.0_WP - 6 6.0_WP * alpha2 ( n )) / 8.0_WP d2 ( n ) = ( - 5.0_WP + 11 0.0_WP * alpha2 ( n )) / 2 4.0_WP e2 ( n ) = ( 1.0_WP - 2 2.0_WP * alpha2 ( n )) / 2 4.0_WP case ( IACCU_CP6 ) alpha2 ( n ) = 3 1.0_WP / 81 8.0_WP a2 ( n ) = - 519 5.0_WP / 490 8.0_WP b2 ( n ) = 495 7.0_WP / 490 8.0_WP c2 ( n ) = 11 9.0_WP / 122 7.0_WP d2 ( n ) = - 8 5.0_WP / 122 7.0_WP e2 ( n ) = 11 9.0_WP / 490 8.0_WP f2 ( n ) = - 1 7.0_WP / 490 8.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC d1fC2P ( 2 , 1 , IBC_INTRPL , n ) = alpha2 ( n ) d1fC2P ( 2 , 2 , IBC_INTRPL , n ) = ONE d1fC2P ( 2 , 3 , IBC_INTRPL , n ) = alpha2 ( n ) d1rC2P ( 2 , 1 , IBC_INTRPL , n ) = a2 ( n ) d1rC2P ( 2 , 2 , IBC_INTRPL , n ) = b2 ( n ) d1rC2P ( 2 , 3 , IBC_INTRPL , n ) = c2 ( n ) d1rC2P ( 2 , 4 , IBC_INTRPL , n ) = d2 ( n ) d1rC2P ( 2 , 5 , IBC_INTRPL , n ) = e2 ( n ) d1rC2P ( 2 , 6 , IBC_INTRPL , n ) = f2 ( n ) d1fC2P ( 4 , 1 , IBC_INTRPL , n ) = d1fC2P ( 2 , 3 , IBC_INTRPL , n ) d1fC2P ( 4 , 2 , IBC_INTRPL , n ) = d1fC2P ( 2 , 2 , IBC_INTRPL , n ) d1fC2P ( 4 , 3 , IBC_INTRPL , n ) = d1fC2P ( 2 , 1 , IBC_INTRPL , n ) d1rC2P ( 4 , :, IBC_INTRPL , n ) = - d1rC2P ( 2 , :, IBC_INTRPL , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, C2P : IBC_NEUMANN, unknowns only from only rhs could be reconstructed from bc, thus explicit ! 1st-derivative, C2P : IBC_DIRICHLET, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fC2P ( 1 , 1 , IBC_NEUMANN , n ) = ZERO ! not used d1fC2P ( 1 , 2 , IBC_NEUMANN , n ) = ONE d1fC2P ( 1 , 3 , IBC_NEUMANN , n ) = ZERO d1rC2P ( 1 , :, IBC_NEUMANN , n ) = ZERO ! not used d1fC2P ( 5 , 1 , IBC_NEUMANN , n ) = ZERO d1fC2P ( 5 , 2 , IBC_NEUMANN , n ) = ONE d1fC2P ( 5 , 3 , IBC_NEUMANN , n ) = ZERO d1rC2P ( 5 , :, IBC_NEUMANN , n ) = ZERO end do if ( bc_intp_upw ) then d1fC2P (:, :, IBC_DIRICHLET , :) = d1fC2P (:, :, IBC_INTRPL , :) d1rC2P (:, :, IBC_DIRICHLET , :) = d1rC2P (:, :, IBC_INTRPL , :) d1fC2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1fC2P ( 2 : 4 , :, IBC_INTRPL , :) d1rC2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1rC2P ( 2 : 4 , :, IBC_INTRPL , :) end if if ( bc_ghost_cd ) then d1fC2P (:, :, IBC_DIRICHLET , :) = d1fC2P (:, :, IBC_INTERIOR , :) d1rC2P (:, :, IBC_DIRICHLET , :) = d1rC2P (:, :, IBC_INTERIOR , :) d1fC2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1fC2P ( 2 : 4 , :, IBC_INTERIOR , :) d1rC2P ( 2 : 4 , :, IBC_NEUMANN , :) = d1rC2P ( 2 : 4 , :, IBC_INTERIOR , :) end if !========================================================================================================== ! 1st derivative on staggered grids P2C ! alpha * f'_{i-1} +  f'_i +  alpha * f'_{i+1}  = a/(h ) * ( f_{i'+1} - f_{i'} ) + & !                                                 b/(3h) * ( f_{i'+2} - f_{i'-1} ) ! when i = 1,    need: f'_0, f_0' ! when i = 2,    need: nothing ! when i = nc-1, need: nothing ! when i = nc,   need: f'_{nc+1'}, f_{np'}, f_{np'+1} !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2C, IBC_PERIODIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- d1fP2C (:, :, IBC_PERIODIC , :) = d1fC2P (:, :, IBC_PERIODIC , :) d1rP2C (:, :, IBC_PERIODIC , :) = d1rC2P (:, :, IBC_PERIODIC , :) !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : P2C : IBC_SYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. ! alpha * f'_{i-1} +  f'_i +  alpha * f'_{i+1}  = a/(h ) * ( f_{i'+1} - f_{i'} ) + & !                                                 b/(3h) * ( f_{i'+2} - f_{i'-1} ) !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fP2C ( 1 , 1 , IBC_SYMMETRIC , n ) = ZERO ! not used d1fP2C ( 1 , 2 , IBC_SYMMETRIC , n ) = ONE - alpha ( n ) d1fP2C ( 1 , 3 , IBC_SYMMETRIC , n ) = alpha ( n ) d1fP2C ( 5 , 1 , IBC_SYMMETRIC , n ) = d1fP2C ( 1 , 3 , IBC_SYMMETRIC , n ) d1fP2C ( 5 , 2 , IBC_SYMMETRIC , n ) = d1fP2C ( 1 , 2 , IBC_SYMMETRIC , n ) d1fP2C ( 5 , 3 , IBC_SYMMETRIC , n ) = d1fP2C ( 1 , 1 , IBC_SYMMETRIC , n ) d1fP2C ( 2 : 4 , :, IBC_SYMMETRIC , n ) = d1fP2C ( 2 : 4 , :, IBC_PERIODIC , n ) d1rP2C (:, :, IBC_SYMMETRIC , n ) = d1rP2C (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : IBC_ASYMMETRIC, unknowns from both rhs and lhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC d1fP2C ( 1 , 1 , IBC_ASYMMETRIC , n ) = ZERO ! not used d1fP2C ( 1 , 2 , IBC_ASYMMETRIC , n ) = ONE + alpha ( n ) d1fP2C ( 1 , 3 , IBC_ASYMMETRIC , n ) = alpha ( n ) d1fP2C ( 5 , 1 , IBC_ASYMMETRIC , n ) = d1fP2C ( 1 , 3 , IBC_ASYMMETRIC , n ) d1fP2C ( 5 , 2 , IBC_ASYMMETRIC , n ) = d1fP2C ( 1 , 2 , IBC_ASYMMETRIC , n ) d1fP2C ( 5 , 3 , IBC_ASYMMETRIC , n ) = d1fP2C ( 1 , 1 , IBC_ASYMMETRIC , n ) d1fP2C ( 2 : 4 , :, IBC_ASYMMETRIC , n ) = d1fP2C ( 2 : 4 , :, IBC_PERIODIC , n ) d1rP2C (:, :, IBC_ASYMMETRIC , n ) = d1rP2C (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2C, IBC_INTERIOR, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- d1fP2C (:, :, IBC_INTERIOR , :) = d1fP2C (:, :, IBC_PERIODIC , :) d1rP2C (:, :, IBC_INTERIOR , :) = d1rP2C (:, :, IBC_PERIODIC , :) do n = 1 , NACC if ( n == IACCU_CP4 . or . n == IACCU_CP6 ) then d1fP2C ( 1 , :, IBC_INTERIOR , n ) = d1fP2C ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rP2C ( 1 , :, IBC_INTERIOR , n ) = d1rP2C ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1fP2C ( 5 , :, IBC_INTERIOR , n ) = d1fP2C ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD d1rP2C ( 5 , :, IBC_INTERIOR , n ) = d1rP2C ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD end if end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative : ! P2C : exterpolation, no bc, no reconstuction. exterpolation only. ! [ 1     alpha1                            ][f'_1]=[a1 * f_{1'}/h  + b1 * f_{2'}/h + c1 * f_{3'}/h  ] ! [alpha2 1      alpha2                     ][f'_2] [a2 * (f_{3'} - f_{2'})/h  ] ! [       alpha  1      alpha               ][f'_i] [a *  (f_{i'+1} - f_{i'})/h + b/3 * (f_{i'+2} - f_{i'-1})/h] ! [                     alpha2 1      alpha2][f'_4] [a2 * (f_{n'} - f_{n'-1})/h] ! [                            alpha1 1     ][f'_5] [-a1 * f_{n'+1}/h  - b1 * f_{n'}/h - c1 * f_{n'-1}/h] !---------------------------------------------------------------------------------------------------------- !    ref: [Gaitonde1998] Table 2.11 alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO e1 = ZERO f1 = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha1 ( n ) = ZERO a1 ( n ) = - ONE b1 ( n ) = ONE case ( IACCU_CD4 , IACCU_CP4 ) alpha1 ( n ) = ZERO a1 ( n ) = ( - 2 2.0_WP + alpha1 ( n )) / 2 4.0_WP b1 ( n ) = ( 1 7.0_WP - 2 7.0_WP * alpha1 ( n )) / 2 4.0_WP c1 ( n ) = ( 3.0_WP + 9.0_WP * alpha1 ( n )) / 8.0_WP d1 ( n ) = ( - 5.0_WP - alpha1 ( n )) / 2 4.0_WP e1 ( n ) = 1.0_WP / 2 4.0_WP case ( IACCU_CP6 ) alpha1 ( n ) = 7 1.0_WP / 9.0_WP ! this is 5th order Compact a1 ( n ) = ( - 168 9.0_WP + 7 1.0_WP * alpha1 ( n )) / 192 0.0_WP b1 ( n ) = ( 6 7.0_WP - 14 1.0_WP * alpha1 ( n )) / 12 8.0_WP c1 ( n ) = ( 14 3.0_WP + 20 7.0_WP * alpha1 ( n )) / 19 2.0_WP d1 ( n ) = ( - 11 1.0_WP + 1.0_WP * alpha1 ( n )) / 19 2.0_WP e1 ( n ) = ( 2 9.0_WP - 3.0_WP * alpha1 ( n )) / 12 8.0_WP f1 ( n ) = ( - 7 1.0_WP + 9.0_WP * alpha1 ( n )) / 192 0.0_WP ! alpha1(n) =     62.0_WP /     9.0_WP !     a1(n) = -10799.0_WP / 17280.0_WP !     b1(n) =  -2713.0_WP /   384.0_WP !     c1(n) =    523.0_WP /    64.0_WP !     d1(n) =   -937.0_WP /  1728.0_WP !     e1(n) =     25.0_WP /   384.0_WP !     f1(n) =     -3.0_WP /   640.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC d1fP2C ( 1 , 1 , IBC_INTRPL , n ) = ZERO ! not used d1fP2C ( 1 , 2 , IBC_INTRPL , n ) = ONE d1fP2C ( 1 , 3 , IBC_INTRPL , n ) = alpha1 ( n ) d1rP2C ( 1 , 1 , IBC_INTRPL , n ) = a1 ( n ) d1rP2C ( 1 , 2 , IBC_INTRPL , n ) = b1 ( n ) d1rP2C ( 1 , 3 , IBC_INTRPL , n ) = c1 ( n ) d1rP2C ( 1 , 4 , IBC_INTRPL , n ) = d1 ( n ) d1rP2C ( 1 , 5 , IBC_INTRPL , n ) = e1 ( n ) d1rP2C ( 1 , 6 , IBC_INTRPL , n ) = f1 ( n ) d1fP2C ( 5 , 1 , IBC_INTRPL , n ) = d1fP2C ( 1 , 3 , IBC_INTRPL , n ) d1fP2C ( 5 , 2 , IBC_INTRPL , n ) = d1fP2C ( 1 , 2 , IBC_INTRPL , n ) d1fP2C ( 5 , 3 , IBC_INTRPL , n ) = d1fP2C ( 1 , 1 , IBC_INTRPL , n ) d1rP2C ( 5 , :, IBC_INTRPL , n ) = - d1rP2C ( 1 , :, IBC_INTRPL , n ) d1fP2C ( 2 : 4 , :, IBC_INTRPL , n ) = d1fP2C ( 2 : 4 , :, IBC_PERIODIC , n ) d1rP2C ( 2 : 4 , :, IBC_INTRPL , n ) = d1rP2C ( 2 : 4 , :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! 1st-derivative, P2C, IBC_DIRICHLET, IBC_NEUMANN !---------------------------------------------------------------------------------------------------------- if ( bc_intp_upw ) then d1fP2C (:, :, IBC_DIRICHLET , :) = d1fP2C (:, :, IBC_INTRPL , :) d1rP2C (:, :, IBC_DIRICHLET , :) = d1rP2C (:, :, IBC_INTRPL , :) d1fP2C (:, :, IBC_NEUMANN , :) = d1fP2C (:, :, IBC_INTRPL , :) d1rP2C (:, :, IBC_NEUMANN , :) = d1rP2C (:, :, IBC_INTRPL , :) end if if ( bc_ghost_cd ) then d1fP2C (:, :, IBC_DIRICHLET , :) = d1fP2C (:, :, IBC_INTERIOR , :) d1rP2C (:, :, IBC_DIRICHLET , :) = d1rP2C (:, :, IBC_INTERIOR , :) d1fP2C (:, :, IBC_NEUMANN , :) = d1fP2C (:, :, IBC_INTERIOR , :) d1rP2C (:, :, IBC_NEUMANN , :) = d1rP2C (:, :, IBC_INTERIOR , :) end if !========================================================================================================== !interpolation. C2P ! alpha * f_{i'-1} + f_i' + alpha * f_{i'+1} = a/2 * ( f_{i}   + f_{i-1} ) + & !                                              b/2 * ( f_{i+1} + f_{i-2} ) ! when i' = 1,    need: f_{0'}, f_{0}, f_{-1} ! when i' = 2,    need:         f_{0} ! when i' = np-1, need:         f_{np'} ! when i' = np,   need: f_{np'+1}, f_{np'}, f_{np'+1} !========================================================================================================== !    ref: [Gaitonde1998] Table 2.7 alpha = ZERO a = ZERO b = ZERO c = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha ( n ) = 0.0_WP a ( n ) = 1.0_WP b ( n ) = 0.0_WP case ( IACCU_CD4 ) alpha ( n ) = 0.0_WP a ( n ) = 9.0_WP / 8.0_WP + 5.0_WP / 4.0_WP * alpha ( n ) b ( n ) = - 1.0_WP / 8.0_WP + 3.0_WP / 4.0_WP * alpha ( n ) case ( IACCU_CP4 ) alpha ( n ) = 1.0_WP / 6.0_WP a ( n ) = 9.0_WP / 8.0_WP + 5.0_WP / 4.0_WP * alpha ( n ) b ( n ) = - 1.0_WP / 8.0_WP + 3.0_WP / 4.0_WP * alpha ( n ) case ( IACCU_CP6 ) alpha ( n ) = 3.0_WP / 1 0.0_WP a ( n ) = 5.0_WP * ( 1 5.0_WP + 1 4.0_WP * alpha ( n )) / 6 4.0_WP b ( n ) = ( - 2 5.0_WP + 12 6.0_WP * alpha ( n )) / 12 8.0_WP c ( n ) = ( 3.0_WP - 1 0.0_WP * alpha ( n )) / 12 8.0_WP case default print * , \"Invalid accuracy\" end select end do !---------------------------------------------------------------------------------------------------------- !interpolation : C2P for IBC_PERIODIC, unknowns from both lhs and rhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC m1fC2P ( 1 : 5 , 1 , IBC_PERIODIC , n ) = alpha ( n ) m1fC2P ( 1 : 5 , 2 , IBC_PERIODIC , n ) = ONE m1fC2P ( 1 : 5 , 3 , IBC_PERIODIC , n ) = alpha ( n ) m1rC2P ( 1 : 5 , 1 , IBC_PERIODIC , n ) = a ( n ) * HALF m1rC2P ( 1 : 5 , 2 , IBC_PERIODIC , n ) = b ( n ) * HALF m1rC2P ( 1 : 5 , 3 , IBC_PERIODIC , n ) = ZERO ! not used end do !---------------------------------------------------------------------------------------------------------- !interpolation. C2P for IBC_SYMMETRIC, unknowns from both lhs and rhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC m1fC2P ( 1 , 1 , IBC_SYMMETRIC , n ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_SYMMETRIC , n ) = ONE m1fC2P ( 1 , 3 , IBC_SYMMETRIC , n ) = alpha ( n ) + alpha ( n ) m1fC2P ( 5 , 1 , IBC_SYMMETRIC , n ) = m1fC2P ( 1 , 3 , IBC_SYMMETRIC , n ) m1fC2P ( 5 , 2 , IBC_SYMMETRIC , n ) = m1fC2P ( 1 , 2 , IBC_SYMMETRIC , n ) m1fC2P ( 5 , 3 , IBC_SYMMETRIC , n ) = m1fC2P ( 1 , 1 , IBC_SYMMETRIC , n ) m1fC2P ( 2 : 4 , :, IBC_SYMMETRIC , n ) = m1fC2P ( 2 : 4 , :, IBC_PERIODIC , n ) m1rC2P (:, :, IBC_SYMMETRIC , n ) = m1rC2P (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- !interpolation. C2P for IBC_ASYMMETRIC, unknowns from both lhs and rhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC m1fC2P ( 1 , 1 , IBC_ASYMMETRIC , n ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_ASYMMETRIC , n ) = ONE m1fC2P ( 1 , 3 , IBC_ASYMMETRIC , n ) = ZERO m1fC2P ( 5 , 1 , IBC_ASYMMETRIC , n ) = m1fC2P ( 1 , 3 , IBC_ASYMMETRIC , n ) m1fC2P ( 5 , 2 , IBC_ASYMMETRIC , n ) = m1fC2P ( 1 , 2 , IBC_ASYMMETRIC , n ) m1fC2P ( 5 , 3 , IBC_ASYMMETRIC , n ) = m1fC2P ( 1 , 1 , IBC_ASYMMETRIC , n ) m1fC2P ( 2 : 4 , :, IBC_ASYMMETRIC , n ) = m1fC2P ( 2 : 4 , :, IBC_PERIODIC , n ) m1rC2P (:, :, IBC_ASYMMETRIC , n ) = m1rC2P (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! interpolation : C2P for IBC_INTERIOR, unknowns only from only rhs could be reconstructed from bc, thus explicit !---------------------------------------------------------------------------------------------------------- m1fC2P (:, :, IBC_INTERIOR , :) = m1fC2P (:, :, IBC_PERIODIC , :) m1rC2P (:, :, IBC_INTERIOR , :) = m1rC2P (:, :, IBC_PERIODIC , :) do n = 1 , NACC if ( n == IACCU_CP4 . or . n == IACCU_CP6 ) then m1fC2P ( 1 , :, IBC_INTERIOR , n ) = m1fC2P ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD m1rC2P ( 1 , :, IBC_INTERIOR , n ) = m1rC2P ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD m1fC2P ( 5 , :, IBC_INTERIOR , n ) = m1fC2P ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD m1rC2P ( 5 , :, IBC_INTERIOR , n ) = m1rC2P ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD end if end do !---------------------------------------------------------------------------------------------------------- ! interpolation. C2P, exterpolation !---------------------------------------------------------------------------------------------------------- alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO e1 = ZERO f1 = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha1 ( n ) = 0.0_WP a1 ( n ) = ( 3.0_WP + alpha1 ( n )) / 2.0_WP b1 ( n ) = ( - 1.0_WP + alpha1 ( n )) / 2.0_WP case ( IACCU_CD4 ) alpha1 ( n ) = 0.0_WP a1 ( n ) = ( 3 5.0_WP + 5.0_WP * alpha1 ( n )) / 1 6.0_WP b1 ( n ) = ( - 3 5.0_WP + 1 5.0_WP * alpha1 ( n )) / 1 6.0_WP c1 ( n ) = ( 2 1.0_WP - 5.0_WP * alpha1 ( n )) / 1 6.0_WP d1 ( n ) = ( - 5.0_WP + alpha1 ( n )) / 1 6.0_WP case ( IACCU_CP4 ) alpha1 ( n ) = 5.0_WP a1 ( n ) = ( 3 5.0_WP + 5.0_WP * alpha1 ( n )) / 1 6.0_WP b1 ( n ) = ( - 3 5.0_WP + 1 5.0_WP * alpha1 ( n )) / 1 6.0_WP c1 ( n ) = ( 2 1.0_WP - 5.0_WP * alpha1 ( n )) / 1 6.0_WP d1 ( n ) = ( - 5.0_WP + alpha1 ( n )) / 1 6.0_WP case ( IACCU_CP6 ) alpha1 ( n ) = 9.0_WP a1 ( n ) = ( 69 3.0_WP + 6 3.0_WP * alpha1 ( n )) / 25 6.0_WP b1 ( n ) = ( - 115 5.0_WP + 31 5.0_WP * alpha1 ( n )) / 25 6.0_WP c1 ( n ) = ( 69 3.0_WP - 10 5.0_WP * alpha1 ( n )) / 12 8.0_WP d1 ( n ) = ( - 49 5.0_WP + 6 3.0_WP * alpha1 ( n )) / 12 8.0_WP e1 ( n ) = ( 38 5.0_WP - 4 5.0_WP * alpha1 ( n )) / 25 6.0_WP f1 ( n ) = ( - 6 3.0_WP + 7.0_WP * alpha1 ( n )) / 25 6.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC m1fC2P ( 1 , 1 , IBC_INTRPL , n ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_INTRPL , n ) = ONE m1fC2P ( 1 , 3 , IBC_INTRPL , n ) = alpha1 ( n ) m1rC2P ( 1 , 1 , IBC_INTRPL , n ) = a1 ( n ) m1rC2P ( 1 , 2 , IBC_INTRPL , n ) = b1 ( n ) m1rC2P ( 1 , 3 , IBC_INTRPL , n ) = c1 ( n ) m1rC2P ( 1 , 4 , IBC_INTRPL , n ) = d1 ( n ) m1rC2P ( 1 , 5 , IBC_INTRPL , n ) = e1 ( n ) m1rC2P ( 1 , 6 , IBC_INTRPL , n ) = f1 ( n ) m1fC2P ( 5 , 1 , IBC_INTRPL , n ) = m1fC2P ( 1 , 3 , IBC_INTRPL , n ) m1fC2P ( 5 , 2 , IBC_INTRPL , n ) = m1fC2P ( 1 , 2 , IBC_INTRPL , n ) m1fC2P ( 5 , 3 , IBC_INTRPL , n ) = m1fC2P ( 1 , 1 , IBC_INTRPL , n ) m1rC2P ( 5 , :, IBC_INTRPL , n ) = m1rC2P ( 1 , :, IBC_INTRPL , n ) end do do n = 1 , NACC m1fC2P ( 3 , :, IBC_INTRPL , n ) = m1fC2P ( 3 , :, IBC_PERIODIC , n ) m1rC2P ( 3 , :, IBC_INTRPL , n ) = m1rC2P ( 3 , :, IBC_PERIODIC , n ) end do alpha2 = ZERO a2 = ZERO b2 = ZERO c2 = ZERO d2 = ZERO e2 = ZERO f2 = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha2 ( n ) = ZERO a2 ( n ) = ( 1.0_WP + 2.0_WP * alpha2 ( n )) / 2.0_WP b2 ( n ) = ( 1.0_WP + 2.0_WP * alpha2 ( n )) / 2.0_WP case ( IACCU_CD4 ) alpha2 ( n ) = ZERO a2 ( n ) = ( 5.0_WP + 3 4.0_WP * alpha2 ( n )) / 1 6.0_WP b2 ( n ) = ( 1 5.0_WP - 2 6.0_WP * alpha2 ( n )) / 1 6.0_WP c2 ( n ) = ( - 5.0_WP + 3 0.0_WP * alpha2 ( n )) / 1 6.0_WP d2 ( n ) = ( 1.0_WP - 6.0_WP * alpha2 ( n )) / 1 6.0_WP case ( IACCU_CP4 ) alpha2 ( n ) = 1.0_WP / 6.0_WP a2 ( n ) = ( 5.0_WP + 3 4.0_WP * alpha2 ( n )) / 1 6.0_WP b2 ( n ) = ( 1 5.0_WP - 2 6.0_WP * alpha2 ( n )) / 1 6.0_WP c2 ( n ) = ( - 5.0_WP + 3 0.0_WP * alpha2 ( n )) / 1 6.0_WP d2 ( n ) = ( 1.0_WP - 6.0_WP * alpha2 ( n )) / 1 6.0_WP case ( IACCU_CP6 ) alpha2 ( n ) = 9.0_WP a2 ( n ) = ( 6 3.0_WP + 68 6.0_WP * alpha2 ( n )) / 25 6.0_WP b2 ( n ) = ( 31 5.0_WP - 105 0.0_WP * alpha2 ( n )) / 25 6.0_WP c2 ( n ) = ( - 10 5.0_WP + 79 8.0_WP * alpha2 ( n )) / 12 8.0_WP d2 ( n ) = ( 6 3.0_WP - 53 0.0_WP * alpha2 ( n )) / 12 8.0_WP e2 ( n ) = ( - 4 5.0_WP + 40 6.0_WP * alpha2 ( n )) / 25 6.0_WP f2 ( n ) = ( 7.0_WP - 6 6.0_WP * alpha2 ( n )) / 25 6.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC m1fC2P ( 2 , 1 , IBC_INTRPL , n ) = alpha2 ( n ) m1fC2P ( 2 , 2 , IBC_INTRPL , n ) = ONE m1fC2P ( 2 , 3 , IBC_INTRPL , n ) = alpha2 ( n ) m1rC2P ( 2 , 1 , IBC_INTRPL , n ) = a2 ( n ) m1rC2P ( 2 , 2 , IBC_INTRPL , n ) = b2 ( n ) m1rC2P ( 2 , 3 , IBC_INTRPL , n ) = c2 ( n ) m1rC2P ( 2 , 4 , IBC_INTRPL , n ) = d2 ( n ) m1rC2P ( 2 , 5 , IBC_INTRPL , n ) = e2 ( n ) m1rC2P ( 2 , 6 , IBC_INTRPL , n ) = f2 ( n ) m1fC2P ( 4 , 1 , IBC_INTRPL , n ) = m1fC2P ( 2 , 3 , IBC_INTRPL , n ) m1fC2P ( 4 , 2 , IBC_INTRPL , n ) = m1fC2P ( 2 , 2 , IBC_INTRPL , n ) m1fC2P ( 4 , 3 , IBC_INTRPL , n ) = m1fC2P ( 2 , 1 , IBC_INTRPL , n ) m1rC2P ( 4 , :, IBC_INTRPL , n ) = m1rC2P ( 2 , :, IBC_INTRPL , n ) end do !---------------------------------------------------------------------------------------------------------- ! interpolation : C2P, IBC_DIRICHLET, IBC_NEUMANN !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC m1fC2P ( 1 , 1 , IBC_DIRICHLET , n ) = ZERO ! not used m1fC2P ( 1 , 2 , IBC_DIRICHLET , n ) = ONE m1fC2P ( 1 , 3 , IBC_DIRICHLET , n ) = ZERO m1rC2P ( 1 , :, IBC_DIRICHLET , n ) = ZERO ! not used m1fC2P ( 5 , 1 , IBC_DIRICHLET , n ) = ZERO m1fC2P ( 5 , 2 , IBC_DIRICHLET , n ) = ONE m1fC2P ( 5 , 3 , IBC_DIRICHLET , n ) = ZERO m1rC2P ( 5 , :, IBC_DIRICHLET , n ) = ZERO end do if ( bc_intp_upw ) then m1fC2P (:, :, IBC_NEUMANN , :) = m1fC2P (:, :, IBC_INTRPL , :) m1rC2P (:, :, IBC_NEUMANN , :) = m1rC2P (:, :, IBC_INTRPL , :) m1fC2P ( 2 : 4 , :, IBC_DIRICHLET , :) = m1fC2P ( 2 : 4 , :, IBC_INTRPL , :) m1rC2P ( 2 : 4 , :, IBC_DIRICHLET , :) = m1rC2P ( 2 : 4 , :, IBC_INTRPL , :) end if if ( bc_ghost_cd ) then m1fC2P (:, :, IBC_NEUMANN , :) = m1fC2P (:, :, IBC_INTERIOR , :) m1rC2P (:, :, IBC_NEUMANN , :) = m1rC2P (:, :, IBC_INTERIOR , :) m1fC2P ( 2 : 4 , :, IBC_DIRICHLET , :) = m1fC2P ( 2 : 4 , :, IBC_INTERIOR , :) m1rC2P ( 2 : 4 , :, IBC_DIRICHLET , :) = m1rC2P ( 2 : 4 , :, IBC_INTERIOR , :) end if !========================================================================================================== !interpolation. P2C ! P2C : i_max = nc ! alpha * f_{i-1} + f_i + alpha * f_{i+1} =    a/2 * ( f_{i'}   + f_{i'+1} ) + & !                                              b/2 * ( f_{i'+2} + f_{i'-1} ) ! when i = 1,    need: LHS: f_{0}, RHS: f_{0'} ! when i = 2,    need: nothing ! when i = nc-1, need: nothing ! when i = nc,   need: LHS: f_{np}, RHS: f_{np'+1} !========================================================================================================== !---------------------------------------------------------------------------------------------------------- !interpolation : P2C for IBC_PERIODIC, unknowns from both lhs and rhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- m1fP2C (:, :, IBC_PERIODIC , :) = m1fC2P (:, :, IBC_PERIODIC , :) m1rP2C (:, :, IBC_PERIODIC , :) = m1rC2P (:, :, IBC_PERIODIC , :) !---------------------------------------------------------------------------------------------------------- !interpolation. P2C. IBC_SYMMETRIC, unknowns from both lhs and rhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC m1fP2C ( 1 , 1 , IBC_SYMMETRIC , n ) = ZERO ! not used m1fP2C ( 1 , 2 , IBC_SYMMETRIC , n ) = ONE + alpha ( n ) m1fP2C ( 1 , 3 , IBC_SYMMETRIC , n ) = alpha ( n ) m1fP2C ( 5 , 1 , IBC_SYMMETRIC , n ) = m1fP2C ( 1 , 3 , IBC_SYMMETRIC , n ) m1fP2C ( 5 , 2 , IBC_SYMMETRIC , n ) = m1fP2C ( 1 , 2 , IBC_SYMMETRIC , n ) m1fP2C ( 5 , 3 , IBC_SYMMETRIC , n ) = m1fP2C ( 1 , 1 , IBC_SYMMETRIC , n ) m1fP2C ( 2 : 4 , :, IBC_SYMMETRIC , n ) = m1fP2C ( 2 : 4 , :, IBC_PERIODIC , n ) m1rP2C (:, :, IBC_SYMMETRIC , n ) = m1rP2C (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- !interpolation. P2C. IBC_ASYMMETRIC, unknowns from both lhs and rhs could be reconstructed from bc. !---------------------------------------------------------------------------------------------------------- do n = 1 , NACC m1fP2C ( 1 , 1 , IBC_ASYMMETRIC , n ) = ZERO ! not used m1fP2C ( 1 , 2 , IBC_ASYMMETRIC , n ) = ONE - alpha ( n ) m1fP2C ( 1 , 3 , IBC_ASYMMETRIC , n ) = alpha ( n ) m1fP2C ( 5 , 1 , IBC_ASYMMETRIC , n ) = m1fP2C ( 1 , 3 , IBC_ASYMMETRIC , n ) m1fP2C ( 5 , 2 , IBC_ASYMMETRIC , n ) = m1fP2C ( 1 , 2 , IBC_ASYMMETRIC , n ) m1fP2C ( 5 , 3 , IBC_ASYMMETRIC , n ) = m1fP2C ( 1 , 1 , IBC_ASYMMETRIC , n ) m1fP2C ( 2 : 4 , :, IBC_ASYMMETRIC , n ) = m1fP2C ( 2 : 4 , :, IBC_PERIODIC , n ) m1rP2C (:, :, IBC_ASYMMETRIC , n ) = m1rP2C (:, :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- ! interpolation : P2C, IBC_INTERIOR !---------------------------------------------------------------------------------------------------------- m1fP2C (:, :, IBC_INTERIOR , :) = m1fP2C (:, :, IBC_PERIODIC , :) m1rP2C (:, :, IBC_INTERIOR , :) = m1rP2C (:, :, IBC_PERIODIC , :) do n = 1 , NACC if ( n == IACCU_CP4 . or . n == IACCU_CP6 ) then m1fP2C ( 1 , :, IBC_INTERIOR , n ) = m1fP2C ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD m1rP2C ( 1 , :, IBC_INTERIOR , n ) = m1rP2C ( 1 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD m1fP2C ( 5 , :, IBC_INTERIOR , n ) = m1fP2C ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD m1rP2C ( 5 , :, IBC_INTERIOR , n ) = m1rP2C ( 5 , :, IBC_PERIODIC , IACCU_CD4 ) ! 5 cell stencil, 6th CP --> 4th CD end if end do !---------------------------------------------------------------------------------------------------------- ! interpolation. P2C: exterpolation ! [ 1    alpha1                          ][f_1']=[a1 * f_{1'} + b1 * f_{2'} + c1 * f_{3'}  ] ! [      alpha2 1     alpha2             ][f_2'] [a2/2 * (f_{2'}   + f_{3'})] ! [             alpha 1      alpha       ][f_i'] [a/2  * (f_{i'}   + f_{i'+1}) + b/2 * (f_{i'+2} + f_{i'-1})] ! [                   alpha2 1     alpha2][f_4'] [a2/2 * (f_{n'-1}   + f_{n'})] ! [                          alpha1 1    ][f_5'] [a1   * f_{n'+1} + b1 * f_{n'} + c1 * f_{n'-1}] !----------------------------------------------------------------------------- !    ref: [Gaitonde1998] Table 2.8 alpha1 = ZERO a1 = ZERO b1 = ZERO c1 = ZERO d1 = ZERO e1 = ZERO f1 = ZERO do n = 1 , NACC select case ( n ) case ( IACCU_CD2 ) alpha1 ( n ) = 0.0_WP a1 ( n ) = 0.5_WP b1 ( n ) = 0.5_WP c1 ( n ) = 0.0_WP case ( IACCU_CD4 ) alpha1 ( n ) = 0.0_WP a1 ( n ) = ( 5.0_WP - alpha1 ( n )) / 1 6.0_WP b1 ( n ) = ( 1 5.0_WP + 9.0_WP * alpha1 ( n )) / 1 6.0_WP c1 ( n ) = ( - 5.0_WP + 9.0_WP * alpha1 ( n )) / 1 6.0_WP d1 ( n ) = ( 1.0_WP - alpha1 ( n )) / 1 6.0_WP case ( IACCU_CP4 ) alpha1 ( n ) = 1.0_WP a1 ( n ) = ( 5.0_WP - alpha1 ( n )) / 1 6.0_WP b1 ( n ) = ( 1 5.0_WP + 9.0_WP * alpha1 ( n )) / 1 6.0_WP c1 ( n ) = ( - 5.0_WP + 9.0_WP * alpha1 ( n )) / 1 6.0_WP d1 ( n ) = ( 1.0_WP - alpha1 ( n )) / 1 6.0_WP case ( IACCU_CP6 ) alpha1 ( n ) = 7.0_WP / 3.0_WP a1 ( n ) = ( 6 3.0_WP - 7.0_WP * alpha1 ( n )) / 25 6.0_WP b1 ( n ) = ( 31 5.0_WP + 10 5.0_WP * alpha1 ( n )) / 25 6.0_WP c1 ( n ) = ( - 7.0_WP + 7.0_WP * alpha1 ( n )) * 1 5.0_WP / 12 8.0_WP d1 ( n ) = ( 6 3.0_WP - 3 5.0_WP * alpha1 ( n )) / 12 8.0_WP e1 ( n ) = ( - 1 5.0_WP + 7.0_WP * alpha1 ( n )) * 3.0_WP / 25 6.0_WP f1 ( n ) = ( 7.0_WP - 3.0_WP * alpha1 ( n )) / 25 6.0_WP case default print * , \"Invalid accuracy\" end select end do do n = 1 , NACC m1fP2C ( 1 , 1 , IBC_INTRPL , n ) = ZERO ! not used m1fP2C ( 1 , 2 , IBC_INTRPL , n ) = ONE m1fP2C ( 1 , 3 , IBC_INTRPL , n ) = alpha1 ( n ) m1rP2C ( 1 , 1 , IBC_INTRPL , n ) = a1 ( n ) m1rP2C ( 1 , 2 , IBC_INTRPL , n ) = b1 ( n ) m1rP2C ( 1 , 3 , IBC_INTRPL , n ) = c1 ( n ) m1rP2C ( 1 , 4 , IBC_INTRPL , n ) = d1 ( n ) m1rP2C ( 1 , 5 , IBC_INTRPL , n ) = e1 ( n ) m1rP2C ( 1 , 6 , IBC_INTRPL , n ) = f1 ( n ) m1fP2C ( 5 , 1 , IBC_INTRPL , n ) = m1fP2C ( 1 , 3 , IBC_INTRPL , n ) m1fP2C ( 5 , 2 , IBC_INTRPL , n ) = m1fP2C ( 1 , 2 , IBC_INTRPL , n ) m1fP2C ( 5 , 3 , IBC_INTRPL , n ) = m1fP2C ( 1 , 1 , IBC_INTRPL , n ) m1rP2C ( 5 , :, IBC_INTRPL , n ) = m1rP2C ( 1 , :, IBC_INTRPL , n ) m1fP2C ( 2 : 4 , :, IBC_INTRPL , n ) = m1fP2C ( 2 : 4 , :, IBC_PERIODIC , n ) m1rP2C ( 2 : 4 , :, IBC_INTRPL , n ) = m1rP2C ( 2 : 4 , :, IBC_PERIODIC , n ) end do !---------------------------------------------------------------------------------------------------------- !interpolation. P2C. IBC_DIRICHLET, IBC_NEUMANN !---------------------------------------------------------------------------------------------------------- if ( bc_intp_upw ) then m1fP2C (:, :, IBC_NEUMANN , :) = m1fP2C (:, :, IBC_INTRPL , :) m1rP2C (:, :, IBC_NEUMANN , :) = m1rP2C (:, :, IBC_INTRPL , :) m1fP2C (:, :, IBC_DIRICHLET , :) = m1fP2C (:, :, IBC_INTRPL , :) m1rP2C (:, :, IBC_DIRICHLET , :) = m1rP2C (:, :, IBC_INTRPL , :) end if if ( bc_ghost_cd ) then m1fP2C (:, :, IBC_NEUMANN , :) = m1fP2C (:, :, IBC_INTERIOR , :) m1rP2C (:, :, IBC_NEUMANN , :) = m1rP2C (:, :, IBC_INTERIOR , :) m1fP2C (:, :, IBC_DIRICHLET , :) = m1fP2C (:, :, IBC_INTERIOR , :) m1rP2C (:, :, IBC_DIRICHLET , :) = m1rP2C (:, :, IBC_INTERIOR , :) end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine Prepare_compact_coefficients !========================================================================================================== !> \\brief Assigning the sparse matrix in the LHS of the compact scheme, and !> calculating the geometry-only dependent variables for the TDMA scheme. !> !> This subroutine is called once locally. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role                                           ! !---------------------------------------------------------------------------------------------------------- !> \\param[in]     n             the number of unknown array !> \\param[in]     bc            the boundary condition at two ends of the unknown !> \\param[in]     coeff         the basic TDMA coefficients defined above. !> \\param[out]    a             the coefficients for TDMA !> \\param[out]    b             a_i * x_(i-1) + b_i * x_(i) + c_i * x_(i+1) !> \\param[out]    c             = RHS !> \\param[out]    d             An assisting coeffients for the TDMA scheme. !---------------------------------------------------------------------------------------------------------- subroutine Buildup_TDMA_LHS_array ( n , coeff , a , b , c , d ) use tridiagonal_matrix_algorithm use parameters_constant_mod implicit none integer , intent ( in ) :: n real ( WP ), intent ( in ) :: coeff ( NL , NS , NBCS : NBCE , NACC ) real ( WP ), intent ( out ) :: a ( n , NBCS : NBCE , NBCS : NBCE , NACC ), & b ( n , NBCS : NBCE , NBCS : NBCE , NACC ), & c ( n , NBCS : NBCE , NBCS : NBCE , NACC ), & d ( n , NBCS : NBCE , NBCS : NBCE , NACC ) integer :: i , j , m , k a (:, :, :, :) = ZERO b (:, :, :, :) = ZERO c (:, :, :, :) = ZERO d (:, :, :, :) = ZERO k = IBC_PERIODIC do m = 1 , NACC do j = NBCS , NBCE do i = NBCS , NBCE a ( 1 , i , j , m ) = coeff ( 1 , 1 , i , m ) a ( 2 , i , j , m ) = coeff ( 2 , 1 , i , m ) a ( 3 : n - 2 , i , j , m ) = coeff ( 3 , 1 , k , m ) a ( n - 1 , i , j , m ) = coeff ( 4 , 1 , j , m ) a ( n , i , j , m ) = coeff ( 5 , 1 , j , m ) b ( 1 , i , j , m ) = coeff ( 1 , 2 , i , m ) b ( 2 , i , j , m ) = coeff ( 2 , 2 , i , m ) b ( 3 : n - 2 , i , j , m ) = coeff ( 3 , 2 , k , m ) b ( n - 1 , i , j , m ) = coeff ( 4 , 2 , j , m ) b ( n , i , j , m ) = coeff ( 5 , 2 , j , m ) c ( 1 , i , j , m ) = coeff ( 1 , 3 , i , m ) c ( 2 , i , j , m ) = coeff ( 2 , 3 , i , m ) c ( 3 : n - 2 , i , j , m ) = coeff ( 3 , 3 , k , m ) c ( n - 1 , i , j , m ) = coeff ( 4 , 3 , j , m ) c ( n , i , j , m ) = coeff ( 5 , 3 , j , m ) if ( j == k . and . i == k ) then call Preprocess_TDMA_coeffs ( a ( 1 : n - 1 , i , j , m ), & b ( 1 : n - 1 , i , j , m ), & c ( 1 : n - 1 , i , j , m ), & d ( 1 : n - 1 , i , j , m ), & n - 1 ) else call Preprocess_TDMA_coeffs ( a (:, i , j , m ), & b (:, i , j , m ), & c (:, i , j , m ), & d (:, i , j , m ), & n ) end if end do end do end do return end subroutine Buildup_TDMA_LHS_array !========================================================================================================== !> \\brief Preparing coefficients for TDMA calculation. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain !>         all    once           all !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role                                           ! !---------------------------------------------------------------------------------------------------------- !========================================================================================================== subroutine Prepare_LHS_coeffs_for_operations use vars_df_mod , only : domain use mpi_mod use parameters_constant_mod implicit none integer :: i , nsz !========================================================================================================== !   building up the basic lhs coeffients for compact schemes !========================================================================================================== call Prepare_compact_coefficients !========================================================================================================== !   building up the full size lhs coeffients for compact schemes !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! y-direction, with nc unknows !---------------------------------------------------------------------------------------------------------- i = 2 nsz = domain ( 1 )% nc ( i ) allocate ( ad1y_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1y_C2C = ZERO allocate ( bd1y_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1y_C2C = ZERO allocate ( cd1y_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1y_C2C = ZERO allocate ( dd1y_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1y_C2C = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fC2C , & ad1y_C2C , bd1y_C2C , cd1y_C2C , dd1y_C2C ) allocate ( ad1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1y_P2C = ZERO allocate ( bd1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1y_P2C = ZERO allocate ( cd1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1y_P2C = ZERO allocate ( dd1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1y_P2C = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fP2C , & ad1y_P2C , bd1y_P2C , cd1y_P2C , dd1y_P2C ) allocate ( am1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); am1y_P2C = ZERO allocate ( bm1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bm1y_P2C = ZERO allocate ( cm1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cm1y_P2C = ZERO allocate ( dm1y_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dm1y_P2C = ZERO call Buildup_TDMA_LHS_array ( nsz , m1fP2C , & am1y_P2C , bm1y_P2C , cm1y_P2C , dm1y_P2C ) !---------------------------------------------------------------------------------------------------------- ! y-direction, with np unknows !---------------------------------------------------------------------------------------------------------- nsz = domain ( 1 )% np ( i ) allocate ( ad1y_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1y_P2P = ZERO allocate ( bd1y_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1y_P2P = ZERO allocate ( cd1y_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1y_P2P = ZERO allocate ( dd1y_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1y_P2P = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fP2P , & ad1y_P2P , bd1y_P2P , cd1y_P2P , dd1y_P2P ) allocate ( ad1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1y_C2P = ZERO allocate ( bd1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1y_C2P = ZERO allocate ( cd1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1y_C2P = ZERO allocate ( dd1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1y_C2P = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fC2P , & ad1y_C2P , bd1y_C2P , cd1y_C2P , dd1y_C2P ) allocate ( am1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); am1y_C2P = ZERO allocate ( bm1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bm1y_C2P = ZERO allocate ( cm1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cm1y_C2P = ZERO allocate ( dm1y_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dm1y_C2P = ZERO call Buildup_TDMA_LHS_array ( nsz , m1fC2P , & am1y_C2P , bm1y_C2P , cm1y_C2P , dm1y_C2P ) !---------------------------------------------------------------------------------------------------------- ! z-direction, with nc unknows !---------------------------------------------------------------------------------------------------------- i = 3 nsz = domain ( 1 )% nc ( i ) allocate ( ad1z_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1z_C2C = ZERO allocate ( bd1z_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1z_C2C = ZERO allocate ( cd1z_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1z_C2C = ZERO allocate ( dd1z_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1z_C2C = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fC2C , & ad1z_C2C , bd1z_C2C , cd1z_C2C , dd1z_C2C ) allocate ( ad1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1z_P2C = ZERO allocate ( bd1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1z_P2C = ZERO allocate ( cd1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1z_P2C = ZERO allocate ( dd1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1z_P2C = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fP2C , & ad1z_P2C , bd1z_P2C , cd1z_P2C , dd1z_P2C ) allocate ( am1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); am1z_P2C = ZERO allocate ( bm1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bm1z_P2C = ZERO allocate ( cm1z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cm1z_P2C = ZERO allocate ( dm2z_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dm2z_P2C = ZERO call Buildup_TDMA_LHS_array ( nsz , m1fP2C , & am1z_P2C , bm1z_P2C , cm1z_P2C , dm2z_P2C ) !---------------------------------------------------------------------------------------------------------- ! z-direction, with np unknows !---------------------------------------------------------------------------------------------------------- nsz = domain ( 1 )% np ( i ) !---------------------------------------------------------------------------------------------------------- ! 1st derivative in z direction with np unknows !---------------------------------------------------------------------------------------------------------- allocate ( ad1z_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1z_P2P = ZERO allocate ( bd1z_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1z_P2P = ZERO allocate ( cd1z_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1z_P2P = ZERO allocate ( dd1z_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1z_P2P = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fP2P , & ad1z_P2P , bd1z_P2P , cd1z_P2P , dd1z_P2P ) allocate ( ad1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); ad1z_C2P = ZERO allocate ( bd1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bd1z_C2P = ZERO allocate ( cd1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cd1z_C2P = ZERO allocate ( dd1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dd1z_C2P = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fC2P , & ad1z_C2P , bd1z_C2P , cd1z_C2P , dd1z_C2P ) allocate ( am1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); am1z_C2P = ZERO allocate ( bm1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); bm1z_C2P = ZERO allocate ( cm1z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); cm1z_C2P = ZERO allocate ( dm2z_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); dm2z_C2P = ZERO call Buildup_TDMA_LHS_array ( nsz , m1fC2P , & am1z_C2P , bm1z_C2P , cm1z_C2P , dm2z_C2P ) !---------------------------------------------------------------------------------------------------------- ! x-direction !---------------------------------------------------------------------------------------------------------- allocate ( xtdma_lhs ( nxdomain ) ) do i = 1 , nxdomain !---------------------------------------------------------------------------------------------------------- ! x-direction, with nc unknows !---------------------------------------------------------------------------------------------------------- nsz = domain ( i )% nc ( 1 ) allocate ( xtdma_lhs ( i )% ad1x_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% ad1x_C2C = ZERO allocate ( xtdma_lhs ( i )% bd1x_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% bd1x_C2C = ZERO allocate ( xtdma_lhs ( i )% cd1x_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% cd1x_C2C = ZERO allocate ( xtdma_lhs ( i )% dd1x_C2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% dd1x_C2C = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fC2C , & xtdma_lhs ( i )% ad1x_C2C , & xtdma_lhs ( i )% bd1x_C2C , & xtdma_lhs ( i )% cd1x_C2C , & xtdma_lhs ( i )% dd1x_C2C ) allocate ( xtdma_lhs ( i )% ad1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% ad1x_P2C = ZERO allocate ( xtdma_lhs ( i )% bd1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% bd1x_P2C = ZERO allocate ( xtdma_lhs ( i )% cd1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% cd1x_P2C = ZERO allocate ( xtdma_lhs ( i )% dd1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% dd1x_P2C = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fP2C , & xtdma_lhs ( i )% ad1x_P2C , & xtdma_lhs ( i )% bd1x_P2C , & xtdma_lhs ( i )% cd1x_P2C , & xtdma_lhs ( i )% dd1x_P2C ) allocate ( xtdma_lhs ( i )% am1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% am1x_P2C = ZERO allocate ( xtdma_lhs ( i )% bm1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% bm1x_P2C = ZERO allocate ( xtdma_lhs ( i )% cm1x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% cm1x_P2C = ZERO allocate ( xtdma_lhs ( i )% dm2x_P2C ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% dm2x_P2C = ZERO call Buildup_TDMA_LHS_array ( nsz , m1fP2C , & xtdma_lhs ( i )% am1x_P2C , & xtdma_lhs ( i )% bm1x_P2C , & xtdma_lhs ( i )% cm1x_P2C , & xtdma_lhs ( i )% dm2x_P2C ) !---------------------------------------------------------------------------------------------------------- ! x-direction, with np unknows !---------------------------------------------------------------------------------------------------------- nsz = domain ( i )% np ( 1 ) allocate ( xtdma_lhs ( i )% ad1x_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% ad1x_P2P = ZERO allocate ( xtdma_lhs ( i )% bd1x_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% bd1x_P2P = ZERO allocate ( xtdma_lhs ( i )% cd1x_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% cd1x_P2P = ZERO allocate ( xtdma_lhs ( i )% dd1x_P2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% dd1x_P2P = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fP2P , & xtdma_lhs ( i )% ad1x_P2P , & xtdma_lhs ( i )% bd1x_P2P , & xtdma_lhs ( i )% cd1x_P2P , & xtdma_lhs ( i )% dd1x_P2P ) allocate ( xtdma_lhs ( i )% ad1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% ad1x_C2P = ZERO allocate ( xtdma_lhs ( i )% bd1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% bd1x_C2P = ZERO allocate ( xtdma_lhs ( i )% cd1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% cd1x_C2P = ZERO allocate ( xtdma_lhs ( i )% dd1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% dd1x_C2P = ZERO call Buildup_TDMA_LHS_array ( nsz , d1fC2P , & xtdma_lhs ( i )% ad1x_C2P , & xtdma_lhs ( i )% bd1x_C2P , & xtdma_lhs ( i )% cd1x_C2P , & xtdma_lhs ( i )% dd1x_C2P ) allocate ( xtdma_lhs ( i )% am1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% am1x_C2P = ZERO allocate ( xtdma_lhs ( i )% bm1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% bm1x_C2P = ZERO allocate ( xtdma_lhs ( i )% cm1x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% cm1x_C2P = ZERO allocate ( xtdma_lhs ( i )% dm2x_C2P ( nsz , NBCS : NBCE , NBCS : NBCE , NACC ) ); xtdma_lhs ( i )% dm2x_C2P = ZERO call Buildup_TDMA_LHS_array ( nsz , m1fC2P , & xtdma_lhs ( i )% am1x_C2P , & xtdma_lhs ( i )% bm1x_C2P , & xtdma_lhs ( i )% cm1x_C2P , & xtdma_lhs ( i )% dm2x_C2P ) end do return end subroutine Prepare_LHS_coeffs_for_operations !========================================================================================================== !========================================================================================================== subroutine buildup_ghost_cells_C ( fi , ibc , fc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) real ( WP ), intent ( inout ) :: fc ( - 1 : 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) integer :: nc ! cell number nc = size ( fi ) !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>         -1     0      1     2            nc-1   nc    nc+1   nc+2 !---------------------------------------------------------------------------------------------------------- if ( ibc ( 1 ) == IBC_INTERIOR ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ buildup_ghost_cells_C' ) fc ( 0 ) = opt_fbc ( 1 ) fc ( - 1 ) = opt_fbc ( 3 ) else if ( ibc ( 1 ) == IBC_PERIODIC ) then fc ( 0 ) = fi ( nc ) fc ( - 1 ) = fi ( nc - 1 ) else if ( ibc ( 1 ) == IBC_SYMMETRIC ) then fc ( 0 ) = fi ( 1 ) fc ( - 1 ) = fi ( 2 ) else if ( ibc ( 1 ) == IBC_ASYMMETRIC ) then fc ( 0 ) = - fi ( 1 ) fc ( - 1 ) = - fi ( 2 ) else if ( ibc ( 1 ) == IBC_DIRICHLET ) then !if(.not. present(opt_fbc)) call Print_warning_msg('Lack of fbc info for IBC_DIRICHLET @ buildup_ghost_cells_C') fc ( 0 ) = TWO * opt_fbc ( 1 ) - fi ( 1 ) fc ( - 1 ) = TWO * opt_fbc ( 1 ) - fi ( 2 ) else if ( ibc ( 1 ) == IBC_NEUMANN ) then !if(.not. present(opt_fbc)) call Print_warning_msg('Lack of fbc info for IBC_NEUMANN @ buildup_ghost_cells_C') fc ( 0 ) = fi ( 1 ) - opt_fbc ( 1 ) * opt_dp ( 1 ) fc ( - 1 ) = fi ( 2 ) - opt_fbc ( 1 ) * opt_dp ( 3 ) else fc ( 0 ) = MAXP fc ( - 1 ) = MAXP end if !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>         -1     0      1     2            nc-1   nc    nc+1   nc+2 !---------------------------------------------------------------------------------------------------------- if ( ibc ( 2 ) == IBC_INTERIOR ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ buildup_ghost_cells_C2C' ) fc ( 1 ) = opt_fbc ( 2 ) fc ( 2 ) = opt_fbc ( 4 ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fc ( 1 ) = fi ( 1 ) fc ( 2 ) = fi ( 2 ) else if ( ibc ( 2 ) == IBC_SYMMETRIC ) then fc ( 1 ) = fi ( nc ) fc ( 2 ) = fi ( nc - 1 ) else if ( ibc ( 2 ) == IBC_ASYMMETRIC ) then fc ( 1 ) = - fi ( nc ) fc ( 2 ) = - fi ( nc - 1 ) else if ( ibc ( 2 ) == IBC_DIRICHLET ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_DIRICHLET @ buildup_ghost_cells_C2C' ) fc ( 1 ) = TWO * opt_fbc ( 2 ) - fi ( nc ) fc ( 2 ) = TWO * opt_fbc ( 2 ) - fi ( nc - 1 ) else if ( ibc ( 2 ) == IBC_NEUMANN ) then !if(.not. present(opt_fbc)) call Print_warning_msg('Lack of fbc info for IBC_NEUMANN @ buildup_ghost_cells_C2C') fc ( 1 ) = fi ( nc ) + opt_fbc ( 2 ) * opt_dp ( 2 ) fc ( 2 ) = fi ( nc - 1 ) + opt_fbc ( 2 ) * opt_dp ( 4 ) else fc ( 1 ) = MAXP fc ( 2 ) = MAXP end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine buildup_ghost_cells_P ( fi , ibc , fp , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) real ( WP ), intent ( inout ) :: fp ( - 1 : 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) integer :: np np = size ( fi ) !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>      -1     0      1     2     3      np-2   np-1  np    np+1  np+2 (non-periodic) !>      -1     0      1     2     3      np-1   np    np+1  np+2  np+3 (periodic) !> dp(1) = ( yp(2) - yp(1) ) * 2 !> dp(3) = ( yp(3) - yp(1) ) * 2 !> dp(2) = ( yp(np) - yp(np-1) ) * 2 !> dp(4) = ( yp(np) - yp(np-2) ) * 2 !---------------------------------------------------------------------------------------------------------- if ( ibc ( 1 ) == IBC_INTERIOR ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ buildup_ghost_cells_P' ) fp ( 0 ) = opt_fbc ( 1 ) fp ( - 1 ) = opt_fbc ( 3 ) else if ( ibc ( 1 ) == IBC_PERIODIC ) then fp ( 0 ) = fi ( np ) fp ( - 1 ) = fi ( np - 1 ) else if ( ibc ( 1 ) == IBC_SYMMETRIC ) then fp ( 0 ) = fi ( 2 ) fp ( - 1 ) = fi ( 3 ) else if ( ibc ( 1 ) == IBC_ASYMMETRIC ) then fp ( 0 ) = - fi ( 2 ) fp ( - 1 ) = - fi ( 3 ) else if ( ibc ( 1 ) == IBC_DIRICHLET ) then if ( present ( opt_fbc )) then fp ( 0 ) = TWO * opt_fbc ( 1 ) - fi ( 2 ) fp ( - 1 ) = TWO * opt_fbc ( 1 ) - fi ( 3 ) else fp ( 0 ) = TWO * fi ( 1 ) - fi ( 2 ) fp ( - 1 ) = TWO * fi ( 1 ) - fi ( 3 ) end if else if ( ibc ( 1 ) == IBC_NEUMANN ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN @ buildup_ghost_cells_P' ) fp ( 0 ) = fi ( 2 ) - opt_fbc ( 1 ) * opt_dp ( 1 ) fp ( - 1 ) = fi ( 3 ) - opt_fbc ( 1 ) * opt_dp ( 3 ) else fp ( 0 ) = MAXP fp ( - 1 ) = MAXP end if !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>      -1     0      1     2     3      np-2   np-1  np    np+1  np+2 (non-periodic) !>      -1     0      1     2     3      np-1   np    np+1  np+2  np+3 (periodic) !---------------------------------------------------------------------------------------------------------- if ( ibc ( 2 ) == IBC_INTERIOR ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_INTERIOR @ buildup_ghost_cells_P' ) fp ( 1 ) = opt_fbc ( 2 ) fp ( 2 ) = opt_fbc ( 4 ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fp ( 1 ) = fi ( 1 ) fp ( 2 ) = fi ( 2 ) else if ( ibc ( 2 ) == IBC_SYMMETRIC ) then fp ( 1 ) = fi ( np - 1 ) fp ( 2 ) = fi ( np - 2 ) else if ( ibc ( 2 ) == IBC_ASYMMETRIC ) then fp ( 1 ) = - fi ( np - 1 ) fp ( 2 ) = - fi ( np - 2 ) else if ( ibc ( 2 ) == IBC_NEUMANN ) then if (. not . present ( opt_fbc )) call Print_error_msg ( 'Lack of fbc info for IBC_NEUMANN @ buildup_ghost_cells_P' ) fp ( 1 ) = fi ( np - 1 ) + opt_fbc ( 2 ) * opt_dp ( 2 ) fp ( 2 ) = fi ( np - 2 ) + opt_fbc ( 2 ) * opt_dp ( 4 ) else if ( ibc ( 2 ) == IBC_DIRICHLET ) then if ( present ( opt_fbc )) then fp ( 1 ) = TWO * opt_fbc ( 2 ) - fi ( np - 1 ) fp ( 2 ) = TWO * opt_fbc ( 2 ) - fi ( np - 2 ) else fp ( 1 ) = TWO * fi ( np ) - fi ( np - 1 ) fp ( 2 ) = TWO * fi ( np ) - fi ( np - 2 ) end if else fp ( 1 ) = MAXP fp ( 2 ) = MAXP end if return end subroutine !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for interpolation. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> \\param[in]   np      the number of unknowns, here is np !> \\param[in]   ibc     the b.c. type at two ends of the unknown array !> \\param[in]   fbc     the b.c. values for the given ibc !> \\param[in]   coeff   the defined TDMA coefficients !> \\param[in]   d1      spacing !> \\param[in]   fi      the input variable to build up the RHS array !> \\param[out]  fo      the output RHS array !========================================================================================================== subroutine Prepare_TDMA_interp_P2C_RHS_array ( fi , fo , nc , coeff , ibc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers, nc real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 1 : NL , 1 : 2 * NS , NBCS : NBCE ) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) integer :: i !, m, l real ( WP ) :: fp ( - 1 : 2 ) logical :: is_bc1 , is_bc5 fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- do i = 2 , nc - 2 fo ( i ) = coeff ( 3 , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( 3 , 2 , IBC_PERIODIC ) * ( fi ( i - 1 ) + fi ( i + 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !                        1     2             nc-1   nc    nc+1  nc+2 !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>      -1     0      1     2     3      np-2   np-1  np    np+1  np+2 (non-periodic) !>      -1     0      1     2     3      np-1   np    np+1  np+2  np+3 (periodic) !---------------------------------------------------------------------------------------------------------- call buildup_ghost_cells_P ( fi (:), ibc (:), fp ( - 1 : 2 ), opt_fbc (:), opt_dp (:)) is_bc1 = ( ibc ( 1 ) == IBC_INTERIOR . or . & ibc ( 1 ) == IBC_PERIODIC . or . & ibc ( 1 ) == IBC_SYMMETRIC . or . & ibc ( 1 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc1 = ( is_bc1 . or . & ibc ( 1 ) == IBC_DIRICHLET . or . & ibc ( 1 ) == IBC_NEUMANN ) end if is_bc5 = ( ibc ( 2 ) == IBC_INTERIOR . or . & ibc ( 2 ) == IBC_SYMMETRIC . or . & ibc ( 2 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc5 = ( is_bc5 . or . & ibc ( 2 ) == IBC_DIRICHLET . or . & ibc ( 2 ) == IBC_NEUMANN ) end if !---------------------------------------------------------------------------------------------------------- i = 1 if ( is_bc1 ) then fo ( i ) = coeff ( 1 , 1 , ibc ( 1 ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( 1 , 2 , ibc ( 1 ) ) * ( fp ( 0 ) + fi ( i + 2 ) ) else fo ( i ) = coeff ( 1 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 1 , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 1 , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 1 , 4 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 1 , 5 , IBC_INTRPL ) * fi ( i + 4 ) + & coeff ( 1 , 6 , IBC_INTRPL ) * fi ( i + 5 ) end if !---------------------------------------------------------------------------------------------------------- i = nc if ( is_bc5 ) then fo ( i ) = coeff ( 5 , 1 , ibc ( 2 ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( 5 , 2 , ibc ( 2 ) ) * ( fi ( i - 1 ) + fp ( 1 ) ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 5 , 1 , IBC_PERIODIC ) * ( fi ( i ) + fp ( 1 ) ) + & coeff ( 5 , 2 , IBC_PERIODIC ) * ( fi ( i - 1 ) + fp ( 2 ) ) else fo ( nc ) = coeff ( 5 , 1 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 5 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 5 , 3 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 5 , 4 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 5 , 5 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 5 , 6 , IBC_INTRPL ) * fi ( i - 4 ) end if !---------------------------------------------------------------------------------------------------------- i = nc - 1 if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 4 , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( 4 , 2 , IBC_PERIODIC ) * ( fi ( i - 1 ) + fp ( 1 ) ) else fo ( i ) = coeff ( 4 , 1 , ibc ( 2 ) ) * ( fi ( i ) + fi ( i + 1 ) ) + & coeff ( 4 , 2 , ibc ( 2 ) ) * ( fi ( i - 1 ) + fi ( i + 2 ) ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- ! nothing. return end subroutine Prepare_TDMA_interp_P2C_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for interpolation. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> \\param[in]   np      the number of unknowns, here is np !> \\param[in]   ibc     the b.c. type at two ends of the unknown array !> \\param[in]   fbc     the b.c. values for the given ibc !> \\param[in]   coeff   the defined TDMA coefficients !> \\param[in]   d1      spacing !> \\param[in]   fi      the input variable to build up the RHS array !> \\param[out]  fo      the output RHS array !========================================================================================================== subroutine Prepare_TDMA_interp_C2P_RHS_array ( fi , fo , np , coeff , ibc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers, np real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 1 : NL , 1 : 2 * NS , NBCS : NBCE ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) ! used for Dirichlet B.C. (1||2) & interior (3, 1,|| 2, 4) integer :: i real ( WP ) :: fc ( - 1 : 2 ) logical :: is_bc1 , is_bc2 , is_bc4 , is_bc5 !========================================================================================================== !interpolation. C2P ! alpha * f_{i'-1} + f_i' + alpha * f_{i'+1} = a/2 * ( f_{i}   + f_{i-1} ) + & !                                              b/2 * ( f_{i+1} + f_{i-2} ) ! when i' = 1,    need: f_{0'}, f_{0}, f_{-1} ! when i' = 2,    need:         f_{0} ! when i' = np-1, need:         f_{np'} ! when i' = np,   need: f_{np'+1}, f_{np'}, f_{np'+1} !========================================================================================================== fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- do i = 3 , np - 2 fo ( i ) = coeff ( 3 , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( 3 , 2 , IBC_PERIODIC ) * ( fi ( i + 1 ) + fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>         -1     0      1     2            nc-1   nc    nc+1   nc+2 !---------------------------------------------------------------------------------------------------------- call buildup_ghost_cells_C ( fi (:), ibc (:), fc ( - 1 : 2 ), opt_fbc (:), opt_dp (:)) is_bc1 = ( ibc ( 1 ) == IBC_INTERIOR . or . & ibc ( 1 ) == IBC_PERIODIC . or . & ibc ( 1 ) == IBC_SYMMETRIC . or . & ibc ( 1 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc1 = ( is_bc1 . or . & ibc ( 1 ) == IBC_NEUMANN ) end if is_bc5 = ( ibc ( 2 ) == IBC_INTERIOR . or . & ibc ( 2 ) == IBC_SYMMETRIC . or . & ibc ( 2 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc5 = ( is_bc5 . or . & ibc ( 2 ) == IBC_NEUMANN ) end if is_bc2 = is_bc1 if ( bc_ghost_cd ) then is_bc2 = ( is_bc2 . or . & ibc ( 1 ) == IBC_DIRICHLET ) end if is_bc4 = is_bc5 if ( bc_ghost_cd ) then is_bc4 = ( is_bc4 . or . & ibc ( 2 ) == IBC_DIRICHLET ) end if !---------------------------------------------------------------------------------------------------------- i = 1 if ( is_bc1 ) then fo ( i ) = coeff ( 1 , 1 , ibc ( 1 )) * ( fi ( i ) + fc ( 0 ) ) + & coeff ( 1 , 2 , ibc ( 1 )) * ( fi ( i + 1 ) + fc ( - 1 ) ) else if ( ibc ( 1 ) == IBC_DIRICHLET ) then fo ( i ) = opt_fbc ( 1 ) else fo ( i ) = coeff ( 1 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 1 , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 1 , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 1 , 4 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 1 , 5 , IBC_INTRPL ) * fi ( i + 4 ) + & coeff ( 1 , 6 , IBC_INTRPL ) * fi ( i + 5 ) end if !---------------------------------------------------------------------------------------------------------- i = 2 if ( is_bc2 ) then fo ( i ) = coeff ( 2 , 1 , ibc ( 1 )) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( 2 , 2 , ibc ( 1 )) * ( fi ( i + 1 ) + fc ( 0 ) ) else fo ( i ) = coeff ( 2 , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 2 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 2 , 3 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 2 , 4 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 2 , 5 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 2 , 6 , IBC_INTRPL ) * fi ( i + 4 ) end if !---------------------------------------------------------------------------------------------------------- i = np if ( is_bc5 ) then fo ( i ) = coeff ( 5 , 1 , ibc ( 2 ) ) * ( fc ( 1 ) + fi ( i - 1 ) ) + & coeff ( 5 , 2 , ibc ( 2 ) ) * ( fc ( 2 ) + fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 5 , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( 5 , 2 , IBC_PERIODIC ) * ( fc ( 1 ) + fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_DIRICHLET ) then fo ( i ) = opt_fbc ( 2 ) else fo ( i ) = coeff ( 5 , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 5 , 2 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 5 , 3 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 5 , 4 , IBC_INTRPL ) * fi ( i - 4 ) + & coeff ( 5 , 5 , IBC_INTRPL ) * fi ( i - 5 ) + & coeff ( 5 , 6 , IBC_INTRPL ) * fi ( i - 6 ) end if !---------------------------------------------------------------------------------------------------------- i = np - 1 if ( is_bc4 ) then fo ( i ) = coeff ( 4 , 1 , ibc ( 2 ) ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( 4 , 2 , ibc ( 2 ) ) * ( fc ( 1 ) + fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 4 , 1 , IBC_PERIODIC ) * ( fi ( i ) + fi ( i - 1 ) ) + & coeff ( 4 , 2 , IBC_PERIODIC ) * ( fi ( i + 1 ) + fi ( i - 2 ) ) else fo ( i ) = coeff ( 4 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 4 , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 4 , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 4 , 4 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 4 , 5 , IBC_INTRPL ) * fi ( i - 4 ) + & coeff ( 4 , 6 , IBC_INTRPL ) * fi ( i - 5 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- ! nothing return end subroutine Prepare_TDMA_interp_C2P_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> for the 1st derivative. !---------------------------------------------------------------------------------------------------------- ! 1st derivative on collocated grids, C2C/P2P coefficients : Periodic or Symmetric B.C. ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- !> \\param[in]   nc      the number of unknowns, here is nc !> \\param[in]   ibc     the b.c. type at two ends of the unknown array !> \\param[in]   fbc     the b.c. values for the given ibc !> \\param[in]   coeff   the defined TDMA coefficients !> \\param[in]   dd      1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]   fi      the input variable to build up the RHS array !> \\param[out]  fo      the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_C2C_RHS_array ( fi , fo , nc , coeff , dd , ibc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 1 : NL , 1 : 2 * NS , NBCS : NBCE ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) ! used for Dirichlet B.C. or interior integer :: i , l real ( WP ) :: fc ( - 1 : 2 ) logical :: is_bc ( 2 ) fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- l = 3 do i = 3 , nc - 2 fo ( i ) = coeff ( l , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( l , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>         -1     0      1     2            nc-1   nc    nc+1   nc+2 !---------------------------------------------------------------------------------------------------------- call buildup_ghost_cells_C ( fi (:), ibc (:), fc ( - 1 : 2 ), opt_fbc (:), opt_dp (:)) do i = 1 , 2 is_bc ( i ) = ( ibc ( i ) == IBC_INTERIOR . or . & ibc ( i ) == IBC_PERIODIC . or . & ibc ( i ) == IBC_SYMMETRIC . or . & ibc ( i ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc ( i ) = ( is_bc ( i ) . or . & ibc ( i ) == IBC_DIRICHLET . or . & ibc ( i ) == IBC_NEUMANN ) end if end do !---------------------------------------------------------------------------------------------------------- i = 1 if ( is_bc ( 1 )) then fo ( i ) = coeff ( 1 , 1 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fc ( 0 ) ) + & coeff ( 1 , 2 , ibc ( 1 ) ) * ( fi ( i + 2 ) - fc ( - 1 ) ) else fo ( i ) = coeff ( 1 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 1 , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 1 , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 1 , 4 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 1 , 5 , IBC_INTRPL ) * fi ( i + 4 ) + & coeff ( 1 , 6 , IBC_INTRPL ) * fi ( i + 5 ) end if !---------------------------------------------------------------------------------------------------------- i = 2 if ( is_bc ( 1 )) then fo ( i ) = coeff ( 2 , 1 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( 2 , 2 , ibc ( 1 ) ) * ( fi ( i + 2 ) - fc ( 0 ) ) else fo ( i ) = coeff ( 2 , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 2 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 2 , 3 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 2 , 4 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 2 , 5 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 2 , 6 , IBC_INTRPL ) * fi ( i + 4 ) end if !---------------------------------------------------------------------------------------------------------- i = nc if ( is_bc ( 2 )) then fo ( i ) = coeff ( 5 , 1 , ibc ( 2 ) ) * ( fc ( 1 ) - fi ( i - 1 ) ) + & coeff ( 5 , 2 , ibc ( 2 ) ) * ( fc ( 2 ) - fi ( i - 2 ) ) else fo ( i ) = coeff ( 5 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 5 , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 5 , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 5 , 4 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 5 , 5 , IBC_INTRPL ) * fi ( i - 4 ) + & coeff ( 5 , 6 , IBC_INTRPL ) * fi ( i - 5 ) end if !---------------------------------------------------------------------------------------------------------- i = nc - 1 if ( is_bc ( 2 )) then fo ( i ) = coeff ( 4 , 1 , ibc ( 2 ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( 4 , 2 , ibc ( 2 ) ) * ( fc ( 1 ) - fi ( i - 2 ) ) else fo ( i ) = coeff ( 4 , 1 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 4 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 4 , 3 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 4 , 4 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 4 , 5 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 4 , 6 , IBC_INTRPL ) * fi ( i - 4 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd return end subroutine Prepare_TDMA_1deri_C2C_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !---------------------------------------------------------------------------------------------------------- ! 1st derivative on collocated grids, C2C/P2P coefficients : Periodic or Symmetric B.C. ! alpha * f'_{i-1} + f'_i + alpha * f'_{i+1} = a/(2h) * ( f_{i+1} - f_{i-1} ) + & !                                              b/(4h) * ( f_{i+2} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !> \\param[in]   np      the number of unknowns, here is np !> \\param[in]   ibc     the b.c. type at two ends of the unknown array !> \\param[in]   fbc     the b.c. values for the given ibc !> \\param[in]   coeff   the defined TDMA coefficients !> \\param[in]   dd      1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]   fi      the input variable to build up the RHS array !> \\param[out]  fo      the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_P2P_RHS_array ( fi , fo , np , coeff , dd , ibc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 1 : NL , 1 : 2 * NS , NBCS : NBCE ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) ! used for IBC_NEUMANN or interior integer :: i real ( WP ) :: fp ( - 1 : 2 ) logical :: is_bc1 ( 2 ), is_bc2 ( 2 ) fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- do i = 3 , np - 2 fo ( i ) = coeff ( 3 , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( 3 , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>      -1     0      1     2     3      np-2   np-1  np    np+1  np+2 (non-periodic) !>      -1     0      1     2     3      np-1   np    np+1  np+2  np+3 (periodic) !---------------------------------------------------------------------------------------------------------- call buildup_ghost_cells_P ( fi (:), ibc (:), fp ( - 1 : 2 ), opt_fbc (:), opt_dp (:)) do i = 1 , 2 is_bc1 ( i ) = ( ibc ( i ) == IBC_INTERIOR . or . & ibc ( i ) == IBC_PERIODIC . or . & ibc ( i ) == IBC_SYMMETRIC . or . & ibc ( i ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc1 ( i ) = ( is_bc1 ( i ) . or . & ibc ( i ) == IBC_DIRICHLET ) end if is_bc2 ( i ) = is_bc1 ( i ) if ( bc_ghost_cd ) then is_bc2 ( i ) = ( is_bc2 ( i ) . or . & ibc ( i ) == IBC_DIRICHLET . or . & ibc ( i ) == IBC_NEUMANN ) end if end do !---------------------------------------------------------------------------------------------------------- i = 1 if ( is_bc1 ( 1 )) then fo ( i ) = coeff ( 1 , 1 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fp ( 0 ) ) + & coeff ( 1 , 2 , ibc ( 1 ) ) * ( fi ( i + 2 ) - fp ( - 1 ) ) else if ( ibc ( 1 ) == IBC_NEUMANN ) then fo ( i ) = opt_fbc ( 1 ) / dd else fo ( i ) = coeff ( 1 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 1 , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 1 , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 1 , 4 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 1 , 5 , IBC_INTRPL ) * fi ( i + 4 ) + & coeff ( 1 , 6 , IBC_INTRPL ) * fi ( i + 5 ) end if !---------------------------------------------------------------------------------------------------------- i = 2 if ( is_bc2 ( 1 )) then fo ( i ) = coeff ( 2 , 1 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( 2 , 2 , ibc ( 1 ) ) * ( fi ( i + 2 ) - fp ( 0 ) ) else fo ( i ) = coeff ( 2 , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 2 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 2 , 3 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 2 , 4 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 2 , 5 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 2 , 6 , IBC_INTRPL ) * fi ( i + 4 ) end if !---------------------------------------------------------------------------------------------------------- i = np if ( is_bc1 ( 2 )) then fo ( i ) = coeff ( 5 , 1 , ibc ( 2 ) ) * ( fp ( 1 ) - fi ( i - 1 ) ) + & coeff ( 5 , 2 , ibc ( 2 ) ) * ( fp ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_NEUMANN ) then fo ( i ) = opt_fbc ( 2 ) / dd else fo ( i ) = coeff ( 5 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 5 , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 5 , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 5 , 4 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 5 , 5 , IBC_INTRPL ) * fi ( i - 4 ) + & coeff ( 5 , 6 , IBC_INTRPL ) * fi ( i - 5 ) end if !---------------------------------------------------------------------------------------------------------- i = np - 1 if ( is_bc2 ( 2 )) then fo ( i ) = coeff ( 4 , 1 , ibc ( 2 ) ) * ( fi ( i + 1 ) - fi ( i - 1 ) ) + & coeff ( 4 , 2 , ibc ( 2 ) ) * ( fp ( 1 ) - fi ( i - 2 ) ) else fo ( i ) = coeff ( 4 , 1 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 4 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 4 , 3 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 4 , 4 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 4 , 5 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 4 , 6 , IBC_INTRPL ) * fi ( i - 4 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd return end subroutine Prepare_TDMA_1deri_P2P_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !---------------------------------------------------------------------------------------------------------- ! 1st derivative on staggered grids C2P ! C2P ==> ! alpha * f'_{i'-1} + f'_i' + alpha * f'_{i'+1} = a/(h ) * ( f_{i}   - f_{i-1} ) + & !                                                 b/(3h) * ( f_{i+1} - f_{i-2} ) !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !> \\param[in]   np      the number of unknowns, here is np !> \\param[in]   ibc     the b.c. type at two ends of the unknown array !> \\param[in]   fbc     the b.c. values for the given ibc !> \\param[in]   coeff   the defined TDMA coefficients !> \\param[in]   dd      1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]   fi      the input variable to build up the RHS array !> \\param[out]  fo      the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_C2P_RHS_array ( fi , fo , np , coeff , dd , ibc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: np ! unknow numbers, np real ( WP ), intent ( out ) :: fo ( np ) real ( WP ), intent ( in ) :: coeff ( 1 : NL , 1 : 2 * NS , NBCS : NBCE ) real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) real ( WP ), intent ( in ) :: dd integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) ! used for IBC_NEUMANN, and interior integer :: i !, m, l real ( WP ) :: fc ( - 1 : 2 ) logical :: is_bc1 , is_bc2 , is_bc4 , is_bc5 fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- do i = 3 , np - 2 fo ( i ) = coeff ( 3 , 1 , IBC_PERIODIC ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( 3 , 2 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 2 ) ) end do !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>         -1     0      1     2            nc-1   nc    nc+1   nc+2 !---------------------------------------------------------------------------------------------------------- call buildup_ghost_cells_C ( fi (:), ibc (:), fc ( - 1 : 2 ), opt_fbc (:), opt_dp (:)) is_bc1 = ( ibc ( 1 ) == IBC_INTERIOR . or . & ibc ( 1 ) == IBC_PERIODIC . or . & ibc ( 1 ) == IBC_SYMMETRIC . or . & ibc ( 1 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc1 = ( is_bc1 . or . & ibc ( 1 ) == IBC_DIRICHLET ) end if is_bc2 = is_bc1 if ( bc_ghost_cd ) then is_bc2 = ( is_bc2 . or . & ibc ( 1 ) == IBC_DIRICHLET . or . & ibc ( 1 ) == IBC_NEUMANN ) end if is_bc5 = ( ibc ( 2 ) == IBC_INTERIOR . or . & ibc ( 2 ) == IBC_SYMMETRIC . or . & ibc ( 2 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc5 = ( is_bc5 . or . & ibc ( 2 ) == IBC_DIRICHLET ) end if is_bc4 = is_bc5 if ( bc_ghost_cd ) then is_bc4 = ( is_bc4 . or . & ibc ( 1 ) == IBC_DIRICHLET . or . & ibc ( 1 ) == IBC_NEUMANN ) end if !---------------------------------------------------------------------------------------------------------- i = 1 if ( is_bc1 ) then fo ( i ) = coeff ( 1 , 1 , ibc ( 1 ) ) * ( fi ( i ) - fc ( 0 ) ) + & coeff ( 1 , 2 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fc ( - 1 ) ) else if ( ibc ( 1 ) == IBC_NEUMANN ) then fo ( i ) = opt_fbc ( 1 ) / dd else fo ( i ) = coeff ( 1 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 1 , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 1 , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 1 , 4 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 1 , 5 , IBC_INTRPL ) * fi ( i + 4 ) + & coeff ( 1 , 6 , IBC_INTRPL ) * fi ( i + 5 ) end if !---------------------------------------------------------------------------------------------------------- i = 2 if ( is_bc2 ) then fo ( i ) = coeff ( 2 , 1 , ibc ( 1 ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( 2 , 2 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fc ( 0 ) ) else fo ( i ) = coeff ( 2 , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 2 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 2 , 3 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 2 , 4 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 2 , 5 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 2 , 6 , IBC_INTRPL ) * fi ( i + 4 ) end if !---------------------------------------------------------------------------------------------------------- i = np if ( is_bc5 ) then fo ( i ) = coeff ( 5 , 1 , ibc ( 2 ) ) * ( fc ( 1 ) - fi ( i - 1 ) ) + & coeff ( 5 , 2 , ibc ( 2 ) ) * ( fc ( 2 ) - fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 5 , 1 , IBC_PERIODIC ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( 5 , 2 , IBC_PERIODIC ) * ( fc ( 1 ) - fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_NEUMANN ) then fo ( i ) = opt_fbc ( 2 ) / dd else fo ( i ) = coeff ( 5 , 1 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 5 , 2 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 5 , 3 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 5 , 4 , IBC_INTRPL ) * fi ( i - 4 ) + & coeff ( 5 , 5 , IBC_INTRPL ) * fi ( i - 5 ) + & coeff ( 5 , 6 , IBC_INTRPL ) * fi ( i - 6 ) end if !---------------------------------------------------------------------------------------------------------- i = np - 1 if ( is_bc4 ) then fo ( i ) = coeff ( 4 , 1 , ibc ( 2 ) ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( 4 , 2 , ibc ( 2 ) ) * ( fc ( 1 ) - fi ( i - 2 ) ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 4 , 1 , IBC_PERIODIC ) * ( fi ( i ) - fi ( i - 1 ) ) + & coeff ( 4 , 2 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i - 2 ) ) else fo ( i ) = coeff ( 4 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 4 , 2 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 4 , 3 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 4 , 4 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 4 , 5 , IBC_INTRPL ) * fi ( i - 4 ) + & coeff ( 4 , 6 , IBC_INTRPL ) * fi ( i - 5 ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd return end subroutine Prepare_TDMA_1deri_C2P_RHS_array !========================================================================================================== !> \\brief Preparing the RHS array for the TDMA algorithm for 1st derivative - P2C. !> This subroutine is called repeatly to update the RHS of the TDMA algorithm !> \\param[in]   nc      the number of unknowns, here is nc !> \\param[in]   ibc     the b.c. type at two ends of the unknown array !> \\param[in]   fbc     the b.c. values for the given ibc !> \\param[in]   coeff   the defined TDMA coefficients !> \\param[in]   dd      1/spacing, ie. 1/dx, 1/dy, 1/dz !> \\param[in]   fi      the input variable to build up the RHS array !> \\param[out]  fo      the output RHS array !========================================================================================================== subroutine Prepare_TDMA_1deri_P2C_RHS_array ( fi , fo , nc , coeff , dd , ibc , opt_fbc , opt_dp ) use parameters_constant_mod implicit none real ( WP ), intent ( in ) :: fi (:) integer , intent ( in ) :: nc ! unknow numbers, nc real ( WP ), intent ( out ) :: fo ( nc ) real ( WP ), intent ( in ) :: coeff ( 1 : NL , 1 : 2 * NS , NBCS : NBCE ) real ( WP ), intent ( in ) :: dd real ( WP ), optional , intent ( in ) :: opt_dp ( 4 ) integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: opt_fbc ( 4 ) integer :: i !, l, m real ( WP ) :: fp ( - 1 : 2 ) logical :: is_bc1 , is_bc5 fo (:) = ZERO !---------------------------------------------------------------------------------------------------------- !   i = bulk !---------------------------------------------------------------------------------------------------------- do i = 2 , nc - 2 fo ( i ) = coeff ( 3 , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( 3 , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 1 ) ) end do !---------------------------------------------------------------------------------------------------------- !>                   BC                                BC !>      _|__.__|__.__||__.__|__.__|__...___|__.__|__.__||__.__|__.__|__.__ !>      -1     0      1     2     3      np-2   np-1  np    np+1  np+2 (non-periodic) !>      -1     0      1     2     3      np-1   np    np+1  np+2  np+3 (periodic) !---------------------------------------------------------------------------------------------------------- call buildup_ghost_cells_P ( fi (:), ibc (:), fp ( - 1 : 2 ), opt_fbc (:), opt_dp (:)) is_bc1 = ( ibc ( 1 ) == IBC_INTERIOR . or . & ibc ( 1 ) == IBC_PERIODIC . or . & ibc ( 1 ) == IBC_SYMMETRIC . or . & ibc ( 1 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc1 = ( is_bc1 . or . & ibc ( 1 ) == IBC_DIRICHLET . or . & ibc ( 1 ) == IBC_NEUMANN ) end if is_bc5 = ( ibc ( 2 ) == IBC_INTERIOR . or . & ibc ( 2 ) == IBC_SYMMETRIC . or . & ibc ( 2 ) == IBC_ASYMMETRIC ) if ( bc_ghost_cd ) then is_bc5 = ( is_bc5 . or . & ibc ( 2 ) == IBC_DIRICHLET . or . & ibc ( 2 ) == IBC_NEUMANN ) end if !---------------------------------------------------------------------------------------------------------- i = 1 if ( is_bc1 ) then fo ( i ) = coeff ( 1 , 1 , ibc ( 1 ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( 1 , 2 , ibc ( 1 ) ) * ( fi ( i + 2 ) - fp ( 0 ) ) else fo ( i ) = coeff ( 1 , 1 , IBC_INTRPL ) * fi ( i ) + & coeff ( 1 , 2 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 1 , 3 , IBC_INTRPL ) * fi ( i + 2 ) + & coeff ( 1 , 4 , IBC_INTRPL ) * fi ( i + 3 ) + & coeff ( 1 , 5 , IBC_INTRPL ) * fi ( i + 4 ) + & coeff ( 1 , 6 , IBC_INTRPL ) * fi ( i + 5 ) end if !---------------------------------------------------------------------------------------------------------- i = nc if ( is_bc5 ) then fo ( i ) = coeff ( 5 , 1 , ibc ( 2 ) ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( 5 , 2 , ibc ( 2 ) ) * ( fp ( 1 ) - fi ( i - 1 ) ) else if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 5 , 1 , IBC_PERIODIC ) * ( fp ( 1 ) - fi ( i ) ) + & coeff ( 5 , 2 , IBC_PERIODIC ) * ( fp ( 2 ) - fi ( i - 1 ) ) else fo ( i ) = coeff ( 5 , 1 , IBC_INTRPL ) * fi ( i + 1 ) + & coeff ( 5 , 2 , IBC_INTRPL ) * fi ( i ) + & coeff ( 5 , 3 , IBC_INTRPL ) * fi ( i - 1 ) + & coeff ( 5 , 4 , IBC_INTRPL ) * fi ( i - 2 ) + & coeff ( 5 , 5 , IBC_INTRPL ) * fi ( i - 3 ) + & coeff ( 5 , 6 , IBC_INTRPL ) * fi ( i - 4 ) end if !---------------------------------------------------------------------------------------------------------- i = nc - 1 if ( ibc ( 2 ) == IBC_PERIODIC ) then fo ( i ) = coeff ( 4 , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( 4 , 2 , IBC_PERIODIC ) * ( fp ( 1 ) - fi ( i - 1 ) ) else fo ( i ) = coeff ( 4 , 1 , IBC_PERIODIC ) * ( fi ( i + 1 ) - fi ( i ) ) + & coeff ( 4 , 2 , IBC_PERIODIC ) * ( fi ( i + 2 ) - fi ( i - 1 ) ) end if !---------------------------------------------------------------------------------------------------------- !   mesh-based scaling !---------------------------------------------------------------------------------------------------------- fo (:) = fo (:) * dd return end subroutine Prepare_TDMA_1deri_P2C_RHS_array !========================================================================================================== !> \\brief To caculate the mid-point interpolation in 1D. !> This subroutine is called as required to get the mid-point interpolation. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !_______________________________________________________________________________ subroutine Get_x_midp_C2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_xmidp_c2p_interior ( i ), 'IBC_INTERIOR' , 'Get_x_midp_C2P_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_xmidp_c2p_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_x_midp_C2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_xmidp_c2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_x_midp_C2P_1D' ) end select end if end do ixsub = dm % idom nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 1 ) dp ( 3 ) = dm % h ( 1 ) * TWO dp ( 2 ) = dm % h ( 1 ) dp ( 4 ) = dm % h ( 1 ) * TWO call Prepare_TDMA_interp_C2P_RHS_array ( fi (:), fo (:), nsz , m1rC2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & xtdma_lhs ( ixsub )% am1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% bm1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% cm1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% dm2x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if #ifdef DEBUG_ALGO do i = 1 , NL write ( * , '(A, 3I3.1, 5F7.3)' ) 'm1fC2P, bc, acc, ln, lhs, rhs:' , ibc ( 1 ), iacc , i , m1fC2P ( i , 1 : 3 , ibc ( 1 ), iacc ), & m1rC2P ( i , 1 : 2 , ibc ( 1 ), iacc ) end do #endif return end subroutine Get_x_midp_C2P_1D !========================================================================================================== subroutine Get_x_midp_P2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_xmidp_p2c_interior ( i ), 'IBC_INTERIOR' , 'Get_x_midp_P2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_xmidp_p2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_x_midp_P2C_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom dp ( 1 ) = dm % h ( 1 ) * TWO dp ( 3 ) = dm % h ( 1 ) * FOUR dp ( 2 ) = dm % h ( 1 ) * TWO dp ( 4 ) = dm % h ( 1 ) * FOUR call Prepare_TDMA_interp_P2C_RHS_array ( fi (:), fo (:), nsz , m1rP2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & xtdma_lhs ( ixsub )% am1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% bm1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% cm1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% dm2x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if #ifdef DEBUG_ALGO do i = 1 , NL write ( * , '(A, 3I3.1, 5F7.3)' ) 'm1fP2C, bc, acc, ln, lhs, rhs:' , ibc ( 1 ), iacc , i , m1fP2C ( i , 1 : 3 , ibc ( 1 ), iacc ), & m1rP2C ( i , 1 : 2 , ibc ( 1 ), iacc ) end do #endif return end subroutine Get_x_midp_P2C_1D !========================================================================================================== subroutine Get_y_midp_C2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic !---------------------------------------------------------------------- ! check the boundary conditions !---------------------------------------------------------------------- ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_ymidp_c2p_interior ( i ), 'IBC_INTERIOR' , 'Get_y_midp_C2P_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_ymidp_c2p_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_y_midp_C2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_ymidp_c2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_y_midp_C2P_1D' ) end select end if end do !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  f(y_i') = g(s_i') = interp of g(s_i) at s_i' !---------------------------------------------------------------------- !---------------------------------------------------------------------- ! prepare the physical spacing for neumann boundary conditions !---------------------------------------------------------------------- nsz = size ( fo ) fo = ZERO ! dp = physical spacings are used to build up ghost cells dp ( 1 ) = ( dm % yc ( 1 ) - dm % yp ( 1 )) * TWO dp ( 3 ) = ( dm % yc ( 2 ) - dm % yp ( 1 )) * TWO dp ( 2 ) = ( dm % yp ( dm % np ( 2 )) - dm % yc ( dm % nc ( 2 ) )) * TWO dp ( 4 ) = ( dm % yp ( dm % np ( 2 )) - dm % yc ( dm % nc ( 2 ) - 1 )) * TWO !---------------------------------------------------------------------- ! prepare the RHS array for the TDMA algorithm !---------------------------------------------------------------------- call Prepare_TDMA_interp_C2P_RHS_array ( fi (:), fo (:), nsz , m1rC2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & am1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bm1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cm1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dm1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_y_midp_C2P_1D !========================================================================================================== subroutine Get_y_midp_P2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic !---------------------------------------------------------------------- ! check the boundary conditions !---------------------------------------------------------------------- ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_ymidp_p2c_interior ( i ), 'IBC_INTERIOR' , 'Get_y_midp_P2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_ymidp_p2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_y_midp_P2C_1D' ) end select end if end do !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  f(y_i') = g(s_i') = interp of g(s_i) at s_i' !---------------------------------------------------------------------- !---------------------------------------------------------------------- ! prepare the physical spacing for neumann boundary conditions !---------------------------------------------------------------------- nsz = size ( fo ) fo = ZERO ! dp = physical spacings are used to build up ghost grids dp ( 1 ) = ( dm % yp ( 2 ) - dm % yp ( 1 ) ) * TWO dp ( 3 ) = ( dm % yp ( 3 ) - dm % yp ( 1 ) ) * TWO dp ( 2 ) = ( dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 1 ) ) * TWO dp ( 4 ) = ( dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 2 ) ) * TWO !---------------------------------------------------------------------- ! prepare the RHS array for the TDMA algorithm !---------------------------------------------------------------------- call Prepare_TDMA_interp_P2C_RHS_array ( fi (:), fo (:), nsz , m1rP2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), ibc (:), fbc (:), dp (:) ) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & am1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bm1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cm1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dm1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_y_midp_P2C_1D !========================================================================================================== subroutine Get_z_midp_C2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_zmidp_c2p_interior ( i ), 'IBC_INTERIOR' , 'Get_z_midp_C2P_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_zmidp_c2p_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_z_midp_C2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_zmidp_c2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_z_midp_C2P_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 3 ) dp ( 3 ) = dm % h ( 3 ) * TWO dp ( 2 ) = dm % h ( 3 ) dp ( 4 ) = dm % h ( 3 ) * TWO call Prepare_TDMA_interp_C2P_RHS_array ( fi (:), fo (:), nsz , m1rC2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & am1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bm1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cm1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dm2z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_z_midp_C2P_1D !========================================================================================================== subroutine Get_z_midp_P2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_zmidp_p2c_interior ( i ), 'IBC_INTERIOR' , 'Get_z_midp_P2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_zmidp_p2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_z_midp_P2C_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 3 ) * TWO dp ( 3 ) = dm % h ( 3 ) * FOUR dp ( 2 ) = dm % h ( 3 ) * TWO dp ( 4 ) = dm % h ( 3 ) * FOUR call Prepare_TDMA_interp_P2C_RHS_array ( fi (:), fo (:), nsz , m1rP2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & am1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bm1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cm1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dm2z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_z_midp_P2C_1D !========================================================================================================== !> \\brief To caculate the 1st derivative in 1D. !> This subroutine is called as required to get the 1st derivative !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_1der_C2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_c2c_interior ( i ), 'IBC_INTERIOR' , 'Get_x_1der_C2C_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_c2c_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_x_1der_C2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_c2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_x_1der_C2C_1D' ) end select end if end do ixsub = dm % idom nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 1 ) dp ( 3 ) = dm % h ( 1 ) * TWO dp ( 2 ) = dm % h ( 1 ) dp ( 4 ) = dm % h ( 1 ) * TWO call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo (:), nsz , d1rC2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 1 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & xtdma_lhs ( ixsub )% ad1x_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% bd1x_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% cd1x_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% dd1x_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if #ifdef DEBUG_ALGO do i = 1 , NL write ( * , '(A, 3I3.1, 5F7.3)' ) 'd1fC2C, bc, acc, ln, lhs, rhs:' , ibc ( 1 ), iacc , i , d1fC2C ( i , 1 : 3 , ibc ( 1 ), iacc ), & d1rC2C ( i , 1 : 2 , ibc ( 1 ), iacc ) end do #endif return end subroutine Get_x_1der_C2C_1D !========================================================================================================== subroutine Get_x_1der_P2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_p2p_interior ( i ), 'IBC_INTERIOR' , 'Get_x_1der_P2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_p2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_x_1der_P2P_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom dp ( 1 ) = dm % h ( 1 ) * TWO dp ( 3 ) = dm % h ( 1 ) * FOUR dp ( 2 ) = dm % h ( 1 ) * TWO dp ( 4 ) = dm % h ( 1 ) * FOUR call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo (:), nsz , d1rP2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 1 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & xtdma_lhs ( ixsub )% ad1x_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% bd1x_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% cd1x_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% dd1x_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if #ifdef DEBUG_ALGO do i = 1 , NL write ( * , '(A, 3I3.1, 5F7.3)' ) 'd1fP2P, bc, acc, ln, lhs, rhs:' , ibc ( 1 ), iacc , i , d1fP2P ( i , 1 : 3 , ibc ( 1 ), iacc ), & d1rP2P ( i , 1 : 2 , ibc ( 1 ), iacc ) end do #endif return end subroutine Get_x_1der_P2P_1D !========================================================================================================== subroutine Get_x_1der_C2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_c2p_interior ( i ), 'IBC_INTERIOR' , 'Get_x_1der_C2P_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_c2p_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_x_1der_C2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_c2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_x_1der_C2P_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom dp ( 1 ) = dm % h ( 1 ) dp ( 3 ) = dm % h ( 1 ) * TWO dp ( 2 ) = dm % h ( 1 ) dp ( 4 ) = dm % h ( 1 ) * TWO call Prepare_TDMA_1deri_C2P_RHS_array ( fi (:), fo (:), nsz , d1rC2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 1 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & xtdma_lhs ( ixsub )% ad1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% bd1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% cd1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% dd1x_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if #ifdef DEBUG_ALGO do i = 1 , NL write ( * , '(A, 3I3.1, 5F7.3)' ) 'd1fC2P, bc, acc, ln, lhs, rhs:' , ibc ( 1 ), iacc , i , d1fC2P ( i , 1 : 3 , ibc ( 1 ), iacc ), & d1rC2P ( i , 1 : 2 , ibc ( 1 ), iacc ) end do #endif return end subroutine Get_x_1der_C2P_1D !========================================================================================================== subroutine Get_x_1der_P2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: ixsub , nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_p2c_interior ( i ), 'IBC_INTERIOR' , 'Get_x_1der_P2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_x1der_p2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_x_1der_P2C_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO ixsub = dm % idom dp ( 1 ) = dm % h ( 1 ) * TWO dp ( 3 ) = dm % h ( 1 ) * FOUR dp ( 2 ) = dm % h ( 1 ) * TWO dp ( 4 ) = dm % h ( 1 ) * FOUR call Prepare_TDMA_1deri_P2C_RHS_array ( fi (:), fo (:), nsz , d1rP2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 1 ), ibc (:), fbc (:), dp (:) ) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & xtdma_lhs ( ixsub )% ad1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% bd1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% cd1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & xtdma_lhs ( ixsub )% dd1x_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if #ifdef DEBUG_ALGO do i = 1 , NL write ( * , '(A, 3I3.1, 5F7.3)' ) 'd1fP2C, bc, acc, ln, lhs, rhs:' , ibc ( 1 ), iacc , i , d1fP2C ( i , 1 : 3 , ibc ( 1 ), iacc ), & d1rP2C ( i , 1 : 2 , ibc ( 1 ), iacc ) end do #endif return end subroutine Get_x_1der_P2C_1D !========================================================================================================== ! y - Get_1der_1D !========================================================================================================== subroutine Get_y_1der_C2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic !---------------------------------------------------------------------- ! check the boundary conditions !---------------------------------------------------------------------- ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_c2c_interior ( i ), 'IBC_INTERIOR' , 'Get_y_1der_C2C_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_c2c_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_y_1der_C2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_c2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_y_1der_C2C_1D' ) end select end if end do !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- !---------------------------------------------------------------------- ! prepare the physical spacing for neumann boundary conditions !---------------------------------------------------------------------- nsz = size ( fo ) fo = ZERO ! dp = physical spacings are used to build up ghost cells dp ( 1 ) = ( dm % yc ( 1 ) - dm % yp ( 1 )) * TWO dp ( 3 ) = ( dm % yc ( 2 ) - dm % yp ( 1 )) * TWO dp ( 2 ) = ( dm % yp ( dm % np ( 2 )) - dm % yc ( dm % nc ( 2 ) )) * TWO dp ( 4 ) = ( dm % yp ( dm % np ( 2 )) - dm % yc ( dm % nc ( 2 ) - 1 )) * TWO !---------------------------------------------------------------------- ! prepare the RHS array for the TDMA algorithm !---------------------------------------------------------------------- call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo (:), nsz , d1rC2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 2 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1y_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1y_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1y_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1y_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingcc (:, 1 ) return end subroutine Get_y_1der_C2C_1D !========================================================================================================== subroutine Get_y_1der_P2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic !---------------------------------------------------------------------- ! check the boundary conditions !---------------------------------------------------------------------- ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_p2p_interior ( i ), 'IBC_INTERIOR' , 'Get_y_1der_P2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_p2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_y_1der_P2P_1D' ) end select end if end do !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- !---------------------------------------------------------------------- ! prepare the physical spacing for neumann boundary conditions !---------------------------------------------------------------------- nsz = size ( fo ) fo = ZERO ! dp = physical spacings are used to build up ghost grids dp ( 1 ) = ( dm % yp ( 2 ) - dm % yp ( 1 ) ) * TWO dp ( 3 ) = ( dm % yp ( 3 ) - dm % yp ( 1 ) ) * TWO dp ( 2 ) = ( dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 1 ) ) * TWO dp ( 4 ) = ( dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 2 ) ) * TWO !---------------------------------------------------------------------- ! prepare the RHS array for the TDMA algorithm !---------------------------------------------------------------------- call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo (:), nsz , d1rP2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 2 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1y_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1y_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1y_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1y_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingpt (:, 1 ) if ( ibc ( 1 ) == IBC_NEUMANN . and . present ( fbc )) fo ( 1 ) = fbc ( 1 ) if ( ibc ( 2 ) == IBC_NEUMANN . and . present ( fbc )) fo ( nsz ) = fbc ( 2 ) return end subroutine Get_y_1der_P2P_1D !========================================================================================================== subroutine Get_y_1der_C2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic !---------------------------------------------------------------------- ! check the boundary conditions !---------------------------------------------------------------------- ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_c2p_interior ( i ), 'IBC_INTERIOR' , 'Get_y_1der_C2P_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_c2p_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_y_1der_C2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_c2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_y_1der_C2P_1D' ) end select end if end do !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- !---------------------------------------------------------------------- ! prepare the physical spacing for neumann boundary conditions !---------------------------------------------------------------------- nsz = size ( fo ) fo = ZERO ! dp = physical spacings are used to build up ghost cells dp ( 1 ) = ( dm % yc ( 1 ) - dm % yp ( 1 )) * TWO dp ( 3 ) = ( dm % yc ( 2 ) - dm % yp ( 1 )) * TWO dp ( 2 ) = ( dm % yp ( dm % np ( 2 )) - dm % yc ( dm % nc ( 2 ) )) * TWO dp ( 4 ) = ( dm % yp ( dm % np ( 2 )) - dm % yc ( dm % nc ( 2 ) - 1 )) * TWO !---------------------------------------------------------------------- ! prepare the RHS array for the TDMA algorithm !---------------------------------------------------------------------- call Prepare_TDMA_1deri_C2P_RHS_array ( fi (:), fo (:), nsz , d1rC2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 2 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1y_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingpt (:, 1 ) if ( ibc ( 1 ) == IBC_NEUMANN . and . present ( fbc )) fo ( 1 ) = fbc ( 1 ) if ( ibc ( 2 ) == IBC_NEUMANN . and . present ( fbc )) fo ( nsz ) = fbc ( 2 ) return end subroutine Get_y_1der_C2P_1D !========================================================================================================== subroutine Get_y_1der_P2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic !---------------------------------------------------------------------- ! check the boundary conditions !---------------------------------------------------------------------- ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_p2c_interior ( i ), 'IBC_INTERIOR' , 'Get_y_1der_P2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_y1der_p2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_y_1der_P2C_1D' ) end select end if end do !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- !---------------------------------------------------------------------- ! prepare the physical spacing for neumann boundary conditions !---------------------------------------------------------------------- nsz = size ( fo ) fo = ZERO ! dp = physical spacings are used to build up ghost grids dp ( 1 ) = ( dm % yp ( 2 ) - dm % yp ( 1 ) ) * TWO dp ( 3 ) = ( dm % yp ( 3 ) - dm % yp ( 1 ) ) * TWO dp ( 2 ) = ( dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 1 ) ) * TWO dp ( 4 ) = ( dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 2 ) ) * TWO !---------------------------------------------------------------------- ! prepare the RHS array for the TDMA algorithm !---------------------------------------------------------------------- call Prepare_TDMA_1deri_P2C_RHS_array ( fi (:), fo (:), nsz , d1rP2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 2 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1y_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if !---------------------------------------------------------------------- ! mapping function: y_i = h(s_i) ! known: f(y_i) = f(h(s_i)) = g(s_i) ! then:  d(f(y_i))/dy = d(f(h(s_i)))/ds * ds/dy = d(g(s_i))/ds * (ds/dy) !---------------------------------------------------------------------- if ( dm % is_stretching ( 2 )) fo (:) = fo (:) * dm % yMappingcc (:, 1 ) return end subroutine Get_y_1der_P2C_1D !========================================================================================================== ! z - Get_1der_1D !========================================================================================================== subroutine Get_z_1der_C2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_c2c_interior ( i ), 'IBC_INTERIOR' , 'Get_z_1der_C2C_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_c2c_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_z_1der_C2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_c2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_z_1der_C2C_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 3 ) dp ( 3 ) = dm % h ( 3 ) * TWO dp ( 2 ) = dm % h ( 3 ) dp ( 4 ) = dm % h ( 3 ) * TWO call Prepare_TDMA_1deri_C2C_RHS_array ( fi (:), fo (:), nsz , d1rC2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 3 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1z_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1z_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1z_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1z_C2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_z_1der_C2C_1D !========================================================================================================== subroutine Get_z_1der_P2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_p2p_interior ( i ), 'IBC_INTERIOR' , 'Get_z_1der_P2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_p2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_z_1der_P2P_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 3 ) * TWO dp ( 3 ) = dm % h ( 3 ) * FOUR dp ( 2 ) = dm % h ( 3 ) * TWO dp ( 4 ) = dm % h ( 3 ) * FOUR call Prepare_TDMA_1deri_P2P_RHS_array ( fi (:), fo (:), nsz , d1rP2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 3 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1z_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1z_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1z_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1z_P2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_z_1der_P2P_1D !========================================================================================================== subroutine Get_z_1der_C2P_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_c2p_interior ( i ), 'IBC_INTERIOR' , 'Get_z_1der_C2P_1D' ) case ( IBC_DIRICHLET ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_c2p_dirichlet ( i ), 'IBC_DIRICHLET' , 'Get_z_1der_C2P_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_c2p_neumann ( i ), 'IBC_NEUMANN' , 'Get_z_1der_C2P_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 3 ) dp ( 3 ) = dm % h ( 3 ) * TWO dp ( 2 ) = dm % h ( 3 ) dp ( 4 ) = dm % h ( 3 ) * TWO call Prepare_TDMA_1deri_C2P_RHS_array ( fi (:), fo (:), nsz , d1rC2P ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 3 ), ibc (:), fbc (:), dp (:) ) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1z_C2P (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_z_1der_C2P_1D !========================================================================================================== subroutine Get_z_1der_P2C_1D ( fi , fo , dm , iacc , ibc0 , fbc ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi (:) real ( WP ), intent ( out ) :: fo (:) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc0 ( 2 ) real ( WP ), optional , intent ( in ) :: fbc ( 4 ) integer :: nsz integer :: i integer :: ibc ( 2 ) real ( WP ) :: dp ( 4 ) logical :: is_periodic ibc = ibc0 do i = 1 , 2 if (. not . present ( fbc )) then select case ( ibc ( i )) case ( IBC_INTERIOR ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_p2c_interior ( i ), 'IBC_INTERIOR' , 'Get_z_1der_P2C_1D' ) case ( IBC_NEUMANN ) call reduce_bc_to_interp ( ibc ( i ), flg_wrn_z1der_p2c_neumann ( i ), 'IBC_NEUMANN' , 'Get_z_1der_P2C_1D' ) end select end if end do nsz = size ( fo ) fo = ZERO dp ( 1 ) = dm % h ( 3 ) * TWO dp ( 3 ) = dm % h ( 3 ) * FOUR dp ( 2 ) = dm % h ( 3 ) * TWO dp ( 4 ) = dm % h ( 3 ) * FOUR call Prepare_TDMA_1deri_P2C_RHS_array ( fi (:), fo (:), nsz , d1rP2C ( 1 : NL , 1 : 2 * NS , NBCS : NBCE , iacc ), dm % h1r ( 3 ), ibc (:), fbc (:), dp (:)) if ( iacc == IACCU_CP4 . or . iacc == IACCU_CP6 ) then if ( ibc ( 1 ) == IBC_PERIODIC ) then is_periodic = . true . else is_periodic = . false . end if call Solve_TDMA ( is_periodic , fo (:), & ad1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & bd1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & cd1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & dd1z_P2C (:, ibc ( 1 ), ibc ( 2 ), iacc ), & nsz ) end if return end subroutine Get_z_1der_P2C_1D !========================================================================================================== !> \\brief To caculate the mid-point interpolation in 3D. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_midp_C2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use tridiagonal_matrix_algorithm use udf_type_mod implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_midp_C2P_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_midp_C2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_midp_C2P_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_midp_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_midp_C2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_x_midp_C2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_midp_C2P_3D !========================================================================================================== subroutine Get_x_midp_P2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) !2 layer each side real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) integer :: k , j real ( WP ) :: fbc ( 4 ) fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_midp_P2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_x_midp_P2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_midp_P2C_3D !========================================================================================================== subroutine Get_y_midp_C2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_midp_C2P_3D\" ) call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_midp_C2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_midp_C2P_3D\" ) call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_midp_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_midp_C2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_y_midp_C2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_midp_C2P_3D !========================================================================================================== subroutine Get_y_midp_P2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) integer :: k , i real ( WP ) :: fbc ( 4 ) !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_midp_P2C_3D\" ) call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_midp_P2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_midp_C2P_3D\" ) call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_midp_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_midp_P2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_y_midp_P2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_midp_P2C_3D !========================================================================================================== subroutine Get_z_midp_C2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_midp_C2P_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_midp_C2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_midp_C2P_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_midp_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_midp_C2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_z_midp_C2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_midp_C2P_3D !========================================================================================================== subroutine Get_z_midp_P2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) integer :: j , i real ( WP ) :: fbc ( 4 ) !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_midp_P2C_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_midp_P2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_midp_P2C_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_midp_P2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_midp_P2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_z_midp_P2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_midp_P2C_3D !========================================================================================================== !> \\brief To caculate the 1st-deriviate in 3D. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi            called-freq    xdomain     module !>       in-given pencil    needed       specified   pubic !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ixsub         x-subdomain index !> \\param[in]     ibc           bc type !> \\param[in]     fbc           bc value !> \\param[in]     inbr          the neibouring index of 4 bc nodes !> \\param[in]     fi            the input array of original variable !> \\param[out]    fo            the output array of interpolated variable !========================================================================================================== subroutine Get_x_1der_C2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_C2C_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_C2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_C2C_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_C2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1der_C2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_x_1der_C2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1der_C2C_3D !========================================================================================================== subroutine Get_x_1der_P2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_P2P_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_P2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_P2P_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_P2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1der_P2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_x_1der_P2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1der_P2P_3D !========================================================================================================== subroutine Get_x_1der_C2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_C2P_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_C2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_C2P_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1der_C2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_x_1der_C2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1der_C2P_3D !========================================================================================================== subroutine Get_x_1der_P2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 1 ) ) real ( WP ) :: fo ( size ( fo3d , 1 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , j !---------------------------------------------------------------------------------------------------------- !  default : x-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_P2C_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_P2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_x_1der_P2C_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_x_1der_P2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do j = 1 , size ( fi3d , 2 ) fi (:) = fi3d (:, j , k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( 1 : 4 , j , k ) call Get_x_1der_P2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_x_1der_P2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d (:, j , k ) = fo (:) end do end do return end subroutine Get_x_1der_P2C_3D !========================================================================================================== subroutine Get_y_1der_C2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_C2C_3D\" ) call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_C2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_C2C_3D\" ) call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_C2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1der_C2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_y_1der_C2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1der_C2C_3D !========================================================================================================== subroutine Get_y_1der_P2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_P2P_3D\" ) call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_P2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_P2P_3D\" ) call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_P2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1der_P2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_y_1der_P2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1der_P2P_3D !========================================================================================================== subroutine Get_y_1der_C2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_C2P_3D\" ) call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_C2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_C2P_3D\" ) call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1der_C2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_y_1der_C2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1der_C2P_3D !========================================================================================================== subroutine Get_y_1der_P2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 2 ) ) real ( WP ) :: fo ( size ( fo3d , 2 ) ) real ( WP ) :: fbc ( 4 ) integer :: k , i !---------------------------------------------------------------------------------------------------------- !  default : y-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_P2C_3D\" ) call check_size ( \"fo/fi\" , 3 , size ( fo3d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_P2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_y_1der_P2C_3D\" ) call check_size ( \"fbc/fi\" , 3 , size ( fbc2d , 3 ), size ( fi3d , 3 ), \"nz mismatch in Get_y_1der_P2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do k = 1 , size ( fi3d , 3 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , :, k ) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , 1 : 4 , k ) call Get_y_1der_P2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_y_1der_P2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , :, k ) = fo (:) end do end do return end subroutine Get_y_1der_P2C_3D !========================================================================================================== subroutine Get_z_1der_C2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_C2C_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_C2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_C2C_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_C2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1der_C2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_z_1der_C2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1der_C2C_3D !========================================================================================================== subroutine Get_z_1der_P2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_P2P_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_P2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_P2P_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_P2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1der_P2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_z_1der_P2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1der_P2P_3D !========================================================================================================== subroutine Get_z_1der_C2P_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_C2P_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_C2P_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_C2P_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_C2P_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1der_C2P_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_z_1der_C2P_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1der_C2P_3D !========================================================================================================== subroutine Get_z_1der_P2C_3D ( fi3d , fo3d , dm , iacc , ibc , fbc2d ) use parameters_constant_mod use udf_type_mod use tridiagonal_matrix_algorithm implicit none real ( WP ), intent ( in ) :: fi3d (:, :, :) real ( WP ), intent ( out ) :: fo3d (:, :, :) type ( t_domain ), intent ( in ) :: dm integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), optional , intent ( in ) :: fbc2d (:, :, :) real ( WP ) :: fi ( size ( fi3d , 3 ) ) real ( WP ) :: fo ( size ( fo3d , 3 ) ) real ( WP ) :: fbc ( 4 ) integer :: j , i !---------------------------------------------------------------------------------------------------------- !  default : z-pencil calculation !---------------------------------------------------------------------------------------------------------- ! Check sizes for fo3d and fi3d call check_size ( \"fo/fi\" , 1 , size ( fo3d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_P2C_3D\" ) call check_size ( \"fo/fi\" , 2 , size ( fo3d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_P2C_3D\" ) ! Check sizes for fbc2d if present if ( present ( fbc2d )) then call check_size ( \"fbc/fi\" , 1 , size ( fbc2d , 1 ), size ( fi3d , 1 ), \"nx mismatch in Get_z_1der_P2C_3D\" ) call check_size ( \"fbc/fi\" , 2 , size ( fbc2d , 2 ), size ( fi3d , 2 ), \"ny mismatch in Get_z_1der_P2C_3D\" ) end if !---------------------------------------------------------------------------------------------------------- fo3d (:, :, :) = ZERO do j = 1 , size ( fi3d , 2 ) do i = 1 , size ( fi3d , 1 ) fi (:) = fi3d ( i , j , :) if ( present ( fbc2d )) then fbc ( 1 : 4 ) = fbc2d ( i , j , 1 : 4 ) call Get_z_1der_P2C_1D ( fi , fo , dm , iacc , ibc , fbc ) else call Get_z_1der_P2C_1D ( fi , fo , dm , iacc , ibc ) end if fo3d ( i , j , :) = fo (:) end do end do return end subroutine Get_z_1der_P2C_3D !========================================================================================================== !========================================================================================================== !> \\brief To test this subroutine for mid-point interpolation. !> !> This subroutine is called in \\ref Test_algorithms. Define the logicals to choose !> which test section is required. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !_______________________________________________________________________________ subroutine test_function_setup ( ibc , dd , fbc , scale , shift ) use parameters_constant_mod use math_mod implicit none integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: dd real ( WP ), intent ( out ) :: fbc ( 4 ) real ( WP ), intent ( out ) :: scale real ( WP ), intent ( out ) :: shift integer :: i fbc = MAXP do i = 1 , 2 if ( ibc ( i ) == IBC_PERIODIC ) then ! f = sin(x/scale + shift) : f = sin(x) scale = ONE shift = ZERO else if ( ibc ( i ) == IBC_SYMMETRIC ) then ! f = sin(x/scale + shift) : f = sin(x + pi/2) scale = ONE shift = PI * HALF else if ( ibc ( i ) == IBC_ASYMMETRIC ) then ! f = sin(x/scale + shift) : f = sin(x/2) scale = TWO shift = ZERO else if ( ibc ( i ) == IBC_DIRICHLET ) then ! f = sin(x/scale + shift) : f = sin(x/2) scale = TWO shift = ZERO if ( i == 1 ) fbc ( 1 ) = ZERO if ( i == 2 ) fbc ( 2 ) = sin_wp ( TWOPI / TWO ) else if ( ibc ( i ) == IBC_NEUMANN ) then ! f = sin(x/scale + shift) : f = sin(x/2) : f'=1/2cos(x/2) scale = TWO shift = ZERO if ( i == 1 ) fbc ( 1 ) = HALF * cos_wp ( ZERO ) if ( i == 2 ) fbc ( 2 ) = HALF * cos_wp ( TWOPI * HALF ) else scale = TWO shift = ZERO if ( i == 1 ) fbc ( 1 ) = ZERO if ( i == 2 ) fbc ( 2 ) = sin_wp ( TWOPI * HALF ) end if end do return end subroutine subroutine test_interp_c2p_comparison ( nc , np , dd , scale , shift , iacc , ibc , fbc , dm , str ) use parameters_constant_mod use math_mod use udf_type_mod use typeconvert_mod implicit none integer , intent ( in ) :: nc integer , intent ( in ) :: np real ( WP ), intent ( in ) :: dd real ( WP ), intent ( in ) :: scale real ( WP ), intent ( in ) :: shift integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: fbc ( 4 ) character ( 1 ), intent ( in ) :: str type ( t_domain ), intent ( in ) :: dm integer :: i real ( WP ) :: xc , xp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 2 ) real ( WP ) :: fgxp ( np ), fxc ( nc ) open ( newunit = wrt_unit ( 1 ), file = 'test_interp_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_interp_' // trim ( str ) // '_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) ! x direction, xc do i = 1 , nc xc = dd * ( real ( i - 1 , WP ) + HALF ) fxc ( i ) = sin_wp ( xc / scale + shift ) end do ! x: c2p if ( trim ( str ) == 'x' ) then call Get_x_midp_C2P_1D ( fxc , fgxp , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'y' ) then call Get_y_midp_C2P_1D ( fxc , fgxp , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'z' ) then call Get_z_midp_C2P_1D ( fxc , fgxp , dm , iacc , ibc , fbc ) else end if ! x: error err_Linf = ZERO err_L2 = ZERO write ( wrt_unit ( 2 ), * ) '# interp-c2p-' // trim ( str ), ', iacc=' , iacc , ', np=' , np write ( wrt_unit ( 2 ), * ) '# i, xp, ref, cal, err' do i = 1 , np xp = dd * real ( i - 1 , WP ) ref = sin_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 2 ), * ) i , xp , ref , fgxp ( i ), err !test if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 end do err_L2 = sqrt_wp ( err_L2 / np ) write ( wrt_unit ( 1 ), '(A, 2I2, 1I5, 2ES15.7)' ) & '# interp-c2p-' // trim ( str ) // ', iacc, ibc, np, eInf, eL2: ' , iacc , ibc ( 1 ), np , err_Linf , err_L2 close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) return end subroutine subroutine test_interp_p2c_comparison ( nc , np , dd , scale , shift , iacc , ibc , fbc , dm , str ) use parameters_constant_mod use math_mod use udf_type_mod use typeconvert_mod implicit none integer , intent ( in ) :: nc integer , intent ( in ) :: np real ( WP ), intent ( in ) :: dd real ( WP ), intent ( in ) :: scale real ( WP ), intent ( in ) :: shift integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: fbc ( 4 ) character ( 1 ), intent ( in ) :: str type ( t_domain ), intent ( in ) :: dm integer :: i real ( WP ) :: xc , xp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 2 ) real ( WP ) :: fgxc ( nc ) real ( WP ) :: fxp ( np ) open ( newunit = wrt_unit ( 1 ), file = 'test_interp_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_interp_' // trim ( str ) // '_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) ! x direction, xp do i = 1 , np xp = dd * real ( i - 1 , WP ) fxp ( i ) = sin_wp ( xp / scale + shift ) end do ! x: p2c if ( trim ( str ) == 'x' ) then call Get_x_midp_P2C_1D ( fxp , fgxc , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'y' ) then call Get_y_midp_P2C_1D ( fxp , fgxc , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'z' ) then call Get_z_midp_P2C_1D ( fxp , fgxc , dm , iacc , ibc , fbc ) else end if err_Linf = ZERO err_L2 = ZERO write ( wrt_unit ( 2 ), * ) '# interp-p2c-' // trim ( str ), ', iacc=' , iacc , ', nc=' , nc write ( wrt_unit ( 2 ), * ) '# i, xc, ref, cal, err' do i = 1 , nc xc = dd * ( real ( i - 1 , WP ) + HALF ) ref = sin_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) write ( wrt_unit ( 2 ), * ) i , xc , ref , fgxc ( i ), err !test if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 end do err_L2 = sqrt_wp ( err_L2 / nc ) write ( wrt_unit ( 1 ), '(A, 2I2, 1I5, 2ES15.7)' ) & '# interp-p2c-' // trim ( str ) // ', iacc, ibc, nc, eInf, eL2: ' , iacc , ibc ( 1 ), nc , err_Linf , err_L2 close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) return end subroutine subroutine Test_interpolation ( dm ) use parameters_constant_mod use math_mod use EvenOdd_mod use udf_type_mod implicit none type ( t_domain ), intent ( inout ) :: dm real ( WP ) :: scale , shift real ( WP ) :: fbcx ( 4 ), fbcy ( 4 ), fbcz ( 4 ), fbc ( 4 ) integer :: ibcx ( 2 ), ibcy ( 2 ), ibcz ( 2 ), ibc ( 2 ) integer :: iacc , n , i character ( 1 ) :: str dm % h ( 1 ) = TWOPI / dm % nc ( 1 ) dm % h ( 2 ) = TWOPI / dm % nc ( 2 ) dm % h ( 3 ) = TWOPI / dm % nc ( 3 ) dm % h1r ( 1 ) = ONE / dm % h ( 1 ) dm % h1r ( 2 ) = ONE / dm % h ( 2 ) dm % h1r ( 3 ) = ONE / dm % h ( 3 ) ibcx (:) = dm % ibcx_nominal (:, 5 ) ibcy (:) = dm % ibcy_nominal (:, 5 ) ibcz (:) = dm % ibcz_nominal (:, 5 ) do i = 1 , 3 if ( i == 1 ) then ibc (:) = ibcx (:) str = 'x' else if ( i == 2 ) then ibc (:) = ibcy (:) str = 'y' else if ( i == 3 ) then ibc (:) = ibcz (:) str = 'z' else end if call test_function_setup ( ibc , dm % h ( i ), fbc , scale , shift ) do n = 1 , NACC iacc = n call test_interp_p2c_comparison ( dm % nc ( i ), dm % np ( i ), dm % h ( i ), scale , shift , iacc , ibc , fbc , dm , str ) end do do n = 1 , NACC iacc = n call test_interp_c2p_comparison ( dm % nc ( i ), dm % np ( i ), dm % h ( i ), scale , shift , iacc , ibc , fbc , dm , str ) end do end do return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To test this subroutine for mid-point interpolation. !> !> This subroutine is called in \\ref Test_algorithms. Define the logicals to choose !> which test section is required. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !_______________________________________________________________________________ subroutine test_1stder_p2c_comparison ( nc , np , dd , scale , shift , iacc , ibc , fbc , dm , str ) use parameters_constant_mod use math_mod use udf_type_mod use typeconvert_mod implicit none integer , intent ( in ) :: nc integer , intent ( in ) :: np real ( WP ), intent ( in ) :: dd real ( WP ), intent ( in ) :: scale real ( WP ), intent ( in ) :: shift integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: fbc ( 4 ) character ( 1 ), intent ( in ) :: str type ( t_domain ), intent ( in ) :: dm integer :: i real ( WP ) :: xc , xp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 2 ) real ( WP ) :: fgxc ( nc ) real ( WP ) :: fxp ( np ) open ( newunit = wrt_unit ( 1 ), file = 'test_1stder_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_1stder_' // trim ( str ) // '_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) do i = 1 , np xp = dd * real ( i - 1 , WP ) fxp ( i ) = sin_wp ( xp / scale + shift ) end do if ( trim ( str ) == 'x' ) then call Get_x_1der_P2C_1D ( fxp , fgxc , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'y' ) then call Get_y_1der_P2C_1D ( fxp , fgxc , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'z' ) then call Get_z_1der_P2C_1D ( fxp , fgxc , dm , iacc , ibc , fbc ) else end if err_Linf = ZERO err_L2 = ZERO write ( wrt_unit ( 2 ), * ) '# 1stder-p2c-' // trim ( str ), ', iacc=' , iacc , ', nc=' , nc write ( wrt_unit ( 2 ), * ) '# i, xc, ref, cal, err' do i = 1 , nc xc = dd * ( real ( i - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) write ( wrt_unit ( 2 ), * ) i , xc , ref , fgxc ( i ), err if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 end do err_L2 = sqrt_wp ( err_L2 / nc ) write ( wrt_unit ( 1 ), '(A, 2I2, 1I5, 2ES15.7)' ) & '# 1stder-p2c-' // trim ( str ) // ', iacc, ibc, nc, eInf, eL2: ' , iacc , ibc ( 1 ), nc , err_Linf , err_L2 close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) return end subroutine subroutine test_1stder_p2p_comparison ( nc , np , dd , scale , shift , iacc , ibc , fbc , dm , str ) use parameters_constant_mod use math_mod use udf_type_mod use typeconvert_mod implicit none integer , intent ( in ) :: nc integer , intent ( in ) :: np real ( WP ), intent ( in ) :: dd real ( WP ), intent ( in ) :: scale real ( WP ), intent ( in ) :: shift integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: fbc ( 4 ) character ( 1 ), intent ( in ) :: str type ( t_domain ), intent ( in ) :: dm integer :: i real ( WP ) :: xc , xp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 2 ) real ( WP ) :: fgxp ( np ) real ( WP ) :: fxp ( np ) open ( newunit = wrt_unit ( 1 ), file = 'test_1stder_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_1stder_' // trim ( str ) // '_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) do i = 1 , np xp = dd * real ( i - 1 , WP ) fxp ( i ) = sin_wp ( xp / scale + shift ) end do if ( trim ( str ) == 'x' ) then call Get_x_1der_P2P_1D ( fxp , fgxp , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'y' ) then call Get_y_1der_P2P_1D ( fxp , fgxp , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'z' ) then call Get_z_1der_P2P_1D ( fxp , fgxp , dm , iacc , ibc , fbc ) else end if err_Linf = ZERO err_L2 = ZERO write ( wrt_unit ( 2 ), * ) '# 1stder-p2p-' // trim ( str ), ', iacc=' , iacc , ', np=' , np write ( wrt_unit ( 2 ), * ) '# i, xp, ref, cal, err' do i = 1 , np xp = dd * real ( i - 1 , WP ) ref = ONE / scale * cos_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 2 ), * ) i , xp , ref , fgxp ( i ), err if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 end do err_L2 = sqrt_wp ( err_L2 / nc ) write ( wrt_unit ( 1 ), '(A, 2I2, 1I5, 2ES15.7)' ) & '# 1stder-p2p-' // trim ( str ) // ', iacc, ibc, np, eInf, eL2: ' , iacc , ibc ( 1 ), np , err_Linf , err_L2 close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) return end subroutine subroutine test_1stder_c2p_comparison ( nc , np , dd , scale , shift , iacc , ibc , fbc , dm , str ) use parameters_constant_mod use math_mod use udf_type_mod use typeconvert_mod implicit none integer , intent ( in ) :: nc integer , intent ( in ) :: np real ( WP ), intent ( in ) :: dd real ( WP ), intent ( in ) :: scale real ( WP ), intent ( in ) :: shift integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: fbc ( 4 ) character ( 1 ), intent ( in ) :: str type ( t_domain ), intent ( in ) :: dm integer :: i real ( WP ) :: xc , xp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 2 ) real ( WP ) :: fgxp ( np ) real ( WP ) :: fxc ( nc ) open ( newunit = wrt_unit ( 1 ), file = 'test_1stder_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_1stder_' // trim ( str ) // '_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) do i = 1 , nc xc = dm % h ( 1 ) * ( real ( i - 1 , WP ) + HALF ) fxc ( i ) = sin_wp ( xc / scale + shift ) end do if ( trim ( str ) == 'x' ) then call Get_x_1der_C2P_1D ( fxc , fgxp , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'y' ) then call Get_y_1der_C2P_1D ( fxc , fgxp , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'z' ) then call Get_z_1der_C2P_1D ( fxc , fgxp , dm , iacc , ibc , fbc ) else end if err_Linf = ZERO err_L2 = ZERO write ( wrt_unit ( 2 ), * ) '# 1stder-c2p-' // trim ( str ), ', iacc=' , iacc , ', np=' , np write ( wrt_unit ( 2 ), * ) '# i, xp, ref, cal, err' do i = 1 , np xp = dd * real ( i - 1 , WP ) ref = ONE / scale * cos_wp ( xp / scale + shift ) err = abs_wp ( fgxp ( i ) - ref ) write ( wrt_unit ( 2 ), * ) i , xp , ref , fgxp ( i ), err if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 end do err_L2 = sqrt_wp ( err_L2 / nc ) write ( wrt_unit ( 1 ), '(A, 2I2, 1I5, 2ES15.7)' ) & '# 1stder-c2p-' // trim ( str ) // ', iacc, ibc, np, eInf, eL2: ' , iacc , ibc ( 1 ), np , err_Linf , err_L2 close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) return end subroutine subroutine test_1stder_c2c_comparison ( nc , np , dd , scale , shift , iacc , ibc , fbc , dm , str ) use parameters_constant_mod use udf_type_mod use math_mod use typeconvert_mod implicit none integer , intent ( in ) :: nc integer , intent ( in ) :: np real ( WP ), intent ( in ) :: dd real ( WP ), intent ( in ) :: scale real ( WP ), intent ( in ) :: shift integer , intent ( in ) :: iacc integer , intent ( in ) :: ibc ( 2 ) real ( WP ), intent ( in ) :: fbc ( 4 ) character ( 1 ), intent ( in ) :: str type ( t_domain ), intent ( in ) :: dm integer :: i real ( WP ) :: xc , xp real ( WP ) :: ref real ( WP ) :: err , err_Linf , err_L2 integer :: wrt_unit ( 2 ) real ( WP ) :: fgxc ( nc ) real ( WP ) :: fxc ( nc ) open ( newunit = wrt_unit ( 1 ), file = 'test_1stder_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) open ( newunit = wrt_unit ( 2 ), file = 'test_1stder_' // trim ( str ) // '_' // trim ( int2str ( nc )) // '.dat' , position = \"append\" ) do i = 1 , nc xc = dd * ( real ( i - 1 , WP ) + HALF ) fxc ( i ) = sin_wp ( xc / scale + shift ) end do if ( trim ( str ) == 'x' ) then call Get_x_1der_C2C_1D ( fxc , fgxc , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'y' ) then call Get_y_1der_C2C_1D ( fxc , fgxc , dm , iacc , ibc , fbc ) else if ( trim ( str ) == 'z' ) then call Get_z_1der_C2C_1D ( fxc , fgxc , dm , iacc , ibc , fbc ) else end if err_Linf = ZERO err_L2 = ZERO write ( wrt_unit ( 2 ), * ) '# 1stder-c2c-' // trim ( str ), ', iacc=' , iacc , ', nc=' , nc write ( wrt_unit ( 2 ), * ) '# i, xc, ref, cal, err' do i = 1 , nc xc = dd * ( real ( i - 1 , WP ) + HALF ) ref = ONE / scale * cos_wp ( xc / scale + shift ) err = abs_wp ( fgxc ( i ) - ref ) write ( wrt_unit ( 2 ), * ) i , xc , ref , fgxc ( i ), err if ( err > err_Linf ) err_Linf = err err_L2 = err_L2 + err ** 2 end do err_L2 = sqrt_wp ( err_L2 / nc ) write ( wrt_unit ( 1 ), '(A, 2I2, 1I5, 2ES15.7)' ) & '# 1stder-c2c-' // trim ( str ) // ', iacc, ibc, nc, eInf, eL2: ' , iacc , ibc ( 1 ), nc , err_Linf , err_L2 close ( wrt_unit ( 1 )) close ( wrt_unit ( 2 )) return end subroutine subroutine Test_1st_derivative ( dm ) use parameters_constant_mod use EvenOdd_mod use udf_type_mod implicit none type ( t_domain ), intent ( inout ) :: dm real ( WP ) :: scale , shift real ( WP ) :: fbcx ( 4 ), fbcy ( 4 ), fbcz ( 4 ), fbc ( 4 ) integer :: ibcx ( 2 ), ibcy ( 2 ), ibcz ( 2 ), ibc ( 2 ) integer :: n , iacc , i character ( 1 ) :: str dm % h ( 1 ) = TWOPI / dm % nc ( 1 ) dm % h ( 2 ) = TWOPI / dm % nc ( 2 ) dm % h ( 3 ) = TWOPI / dm % nc ( 3 ) ibcx (:) = dm % ibcx_nominal (:, 5 ) ibcy (:) = dm % ibcy_nominal (:, 5 ) ibcz (:) = dm % ibcz_nominal (:, 5 ) do i = 1 , 3 if ( i == 1 ) then ibc (:) = ibcx (:) str = 'x' else if ( i == 2 ) then ibc (:) = ibcy (:) str = 'y' else if ( i == 3 ) then ibc (:) = ibcz (:) str = 'z' else end if call test_function_setup ( ibc , dm % h ( i ), fbc , scale , shift ) write ( * , * ) 'input=sin(x/' , scale , '+' , shift , ')' do n = 1 , NACC iacc = n call test_1stder_p2p_comparison ( dm % nc ( i ), dm % np ( i ), dm % h ( i ), scale , shift , iacc , ibc , fbc , dm , str ) end do do n = 1 , NACC iacc = n call test_1stder_c2c_comparison ( dm % nc ( i ), dm % np ( i ), dm % h ( i ), scale , shift , iacc , ibc , fbc , dm , str ) end do do n = 1 , NACC iacc = n call test_1stder_p2c_comparison ( dm % nc ( i ), dm % np ( i ), dm % h ( i ), scale , shift , iacc , ibc , fbc , dm , str ) end do do n = 1 , NACC iacc = n call test_1stder_c2p_comparison ( dm % nc ( i ), dm % np ( i ), dm % h ( i ), scale , shift , iacc , ibc , fbc , dm , str ) end do end do return end subroutine end module","tags":"","url":"sourcefile/basics_operations2.f90.html"},{"title":"eq_continuity.f90 – CHAPSim2","text":"Source Code module continuity_eq_mod use operations use decomp_2d public :: Calculate_drhodt public :: Get_divergence_vector public :: Get_divergence_flow public :: Get_divergence_vel_x2z public :: Check_element_mass_conservation contains !========================================================================================================== !========================================================================================================== !> \\brief To calculate d(\\rho)/dt in the continuity eq. !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]  dDens            density at the current time step !> \\param[in]  dDensm1          density at the t-1 time step !> \\param[in]  dDensm2          density at the t-2 time step !> \\param[out] drhodt           d(rho)/dt !> \\param[in]  itime            the sub-step in RK3 !_______________________________________________________________________________ subroutine Calculate_drhodt ( fl , dm ) use parameters_constant_mod use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl !real(WP), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ), intent(in)  :: dens, densm1 !real(WP), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ), intent(out) :: drhodt !real(WP), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ) :: div !real(WP), dimension( dm%dccc%xsz(1), dm%dccc%xsz(2), dm%dccc%xsz(3) ) :: div0 if ( . not . dm % is_thermo ) return ! thermal field is half time step ahead of the velocity field ! -----*-----$-----*-----$-----*-----$-----*-----$-----*-----$-----* !           d_(i-1)     d_i   u_i    d_(i+1) ! select case (dm%iTimeScheme) !   case (ITIME_EULER) ! 1st order !     fl%drhodt = fl%dDens - fl%dDensm1 !     fl%drhodt = fl%drhodt / dm%dt !   case (ITIME_AB2) ! 2nd order !     fl%drhodt = fl%dDens - fl%dDensm2 !     fl%drhodt = fl%drhodt / (TWO * dm%dt) !   case (ITIME_RK3, ITIME_RK3_CN) ! 3rd order !     fl%drhodt = -fl%dDensm2 + SIX * fl%dDensm1 - THREE * fl%dDens !     fl%drhodt = fl%drhodt / (dm%dt * SIX) !   case default !     fl%drhodt = fl%dDens - fl%dDensm1 !     fl%drhodt = fl%drhodt / dm%dt ! end select fl % drhodt = fl % dDens - fl % dDensm1 fl % drhodt = fl % drhodt / dm % dt !fl%drhodt = zero #ifdef DEBUG_STEPS write ( * , * ) 'rho   ' , fl % ddens ( 1 , 1 : 4 , 1 ) write ( * , * ) 'rhom1 ' , fl % ddensm1 ( 1 , 1 : 4 , 1 ) write ( * , * ) 'rhom2 ' , fl % ddensm2 ( 1 , 1 : 4 , 1 ) write ( * , * ) 'drhodt' , fl % drhodt ( 1 , 1 : 4 , 1 ) #endif return end subroutine Calculate_drhodt !========================================================================================================== !========================================================================================================== !> \\brief To calculate divergence of (rho * u) or divergence of (u) !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[out]    div          div(q) or div(g) !> \\param[in]     d            domain !_______________________________________________________________________________ subroutine Get_divergence_flow ( fl , div , dm ) use parameters_constant_mod use udf_type_mod use solver_tools_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )), intent ( out ) :: div real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) :: qx real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) :: qy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) :: qz real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) :: div0 real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: div0_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) :: div0_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: qy_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: qz_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: qz_zpencil if ( dm % is_thermo ) then qx = fl % gx qy = fl % gy qz = fl % gz else qx = fl % qx qy = fl % qy qz = fl % qz end if div = ZERO !---------------------------------------------------------------------------------------------------------- ! operation in x pencil, dqx/dx !---------------------------------------------------------------------------------------------------------- div0 = ZERO call Get_x_1der_P2C_3D ( qx , div0 , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx ) div (:, :, :) = div (:, :, :) + div0 (:, :, :) !---------------------------------------------------------------------------------------------------------- ! operation in y pencil, dqy/dy * (1/r) !---------------------------------------------------------------------------------------------------------- qy_ypencil = ZERO div0_ypencil = ZERO div0 = ZERO call transpose_x_to_y ( qy , qy_ypencil , dm % dcpc ) call Get_y_1der_P2C_3D ( qy_ypencil , div0_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_qy ) call transpose_y_to_x ( div0_ypencil , div0 , dm % dccc ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div0 , dm % dccc , dm % rci , 1 , IPENCIL ( 1 )) div (:, :, :) = div (:, :, :) + div0 (:, :, :) !---------------------------------------------------------------------------------------------------------- ! operation in z pencil, dw/dz * (1/r) !---------------------------------------------------------------------------------------------------------- qz_ypencil = ZERO qz_zpencil = ZERO div0_zpencil = ZERO div0_ypencil = ZERO div0 = ZERO call transpose_x_to_y ( qz , qz_ypencil , dm % dccp ) call transpose_y_to_z ( qz_ypencil , qz_zpencil , dm % dccp ) call Get_z_1der_P2C_3D ( qz_zpencil , div0_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , dm % fbcz_qz ) call transpose_z_to_y ( div0_zpencil , div0_ypencil , dm % dccc ) call transpose_y_to_x ( div0_ypencil , div0 , dm % dccc ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div0 , dm % dccc , dm % rci , 1 , IPENCIL ( 1 )) div (:, :, :) = div (:, :, :) + div0 (:, :, :) return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To calculate divergence of (rho * u) or divergence of (u) !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ux           ux or gx !> \\param[in]     uy           uy or gy !> \\param[in]     uz           uz or gz !> \\param[out]    div          div(u) or div(g) !> \\param[in]     d            domain !_______________________________________________________________________________ subroutine Get_divergence_vector ( ux , uy , uz , div , dm ) use parameters_constant_mod use udf_type_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )), intent ( in ) :: ux real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )), intent ( in ) :: uy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )), intent ( in ) :: uz real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )), intent ( out ) :: div real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) :: div0 real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: div0_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) :: div0_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: uy_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: uz_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: uz_zpencil div = ZERO !---------------------------------------------------------------------------------------------------------- ! operation in x pencil, du/dx !---------------------------------------------------------------------------------------------------------- div0 = ZERO call Get_x_1der_P2C_3D ( ux , div0 , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx ) div (:, :, :) = div (:, :, :) + div0 (:, :, :) !write(*,*) 'div, x', div0(1, 1, 1), div0(2, 2, 2), div0(8, 8, 8)!, div0(16, 8, 8), div0(32, 8, 8) !---------------------------------------------------------------------------------------------------------- ! operation in y pencil, dqy/dy * (1/r) !---------------------------------------------------------------------------------------------------------- uy_ypencil = ZERO div0_ypencil = ZERO div0 = ZERO call transpose_x_to_y ( uy , uy_ypencil , dm % dcpc ) call Get_y_1der_P2C_3D ( uy_ypencil , div0_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_qy ) call transpose_y_to_x ( div0_ypencil , div0 , dm % dccc ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div0 , dm % dccc , dm % rci , 1 , IPENCIL ( 1 )) div (:, :, :) = div (:, :, :) + div0 (:, :, :) !write(*,*) 'div, y', div0(1, 1, 1), div0(2, 2, 2), div0(8, 8, 8)!, div0(16, 8, 8), div0(32, 8, 8) !---------------------------------------------------------------------------------------------------------- ! operation in z pencil, dw/dz * (1/r) !---------------------------------------------------------------------------------------------------------- uz_ypencil = ZERO uz_zpencil = ZERO div0_zpencil = ZERO div0_ypencil = ZERO div0 = ZERO call transpose_x_to_y ( uz , uz_ypencil , dm % dccp ) call transpose_y_to_z ( uz_ypencil , uz_zpencil , dm % dccp ) call Get_z_1der_P2C_3D ( uz_zpencil , div0_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_qz ) call transpose_z_to_y ( div0_zpencil , div0_ypencil , dm % dccc ) call transpose_y_to_x ( div0_ypencil , div0 , dm % dccc ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div0 , dm % dccc , dm % rci , 1 , IPENCIL ( 1 )) div (:, :, :) = div (:, :, :) + div0 (:, :, :) !write(*,*) 'div, z', div0(1, 1, 1), div0(2, 2, 2), div0(8, 8, 8)!, div0(16, 8, 8), div0(32, 8, 8) !write(*,*) 'divall', div0(1, 1, 1), div(8, 8, 8) return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To calculate divergence of (rho * u) or divergence of (u) !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ux           ux or gx !> \\param[in]     uy           uy or gy !> \\param[in]     uz           uz or gz !> \\param[out]    div          div(u) or div(g) !> \\param[in]     d            domain !_______________________________________________________________________________ subroutine Get_divergence_vel_x2z ( ux , uy , uz , div_zpencil_ggg , dm ) use parameters_constant_mod use udf_type_mod use decomp_extended_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )), intent ( in ) :: ux real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )), intent ( in ) :: uy real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )), intent ( in ) :: uz real ( WP ), dimension ( dm % dccc % zst ( 1 ) : dm % dccc % zen ( 1 ), & dm % dccc % zst ( 2 ) : dm % dccc % zen ( 2 ), & dm % dccc % zst ( 3 ) : dm % dccc % zen ( 3 )), intent ( out ) :: div_zpencil_ggg real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) :: div0 real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 )) :: div0_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 )) :: div0_zpencil real ( WP ), dimension ( dm % dccc % yst ( 1 ) : dm % dccc % yen ( 1 ), & dm % dccc % yst ( 2 ) : dm % dccc % yen ( 2 ), & dm % dccc % ysz ( 3 )) :: div0_ypencil_ggl real ( WP ), dimension ( dm % dccc % yst ( 1 ) : dm % dccc % yen ( 1 ), & dm % dccc % yst ( 2 ) : dm % dccc % yen ( 2 ), & dm % dccc % ysz ( 3 )) :: div_ypencil_ggl real ( WP ), dimension ( dm % dccc % zst ( 1 ) : dm % dccc % zen ( 1 ), & dm % dccc % zst ( 2 ) : dm % dccc % zen ( 2 ), & dm % dccc % zst ( 3 ) : dm % dccc % zen ( 3 )) :: div0_zpencil_ggg real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 )) :: uy_ypencil !real(WP), dimension(dm%dccp%yst(1) : dm%dccp%yen(1), dm%dccp%ysz(2), dm%dccp%ysz(3)) :: uz_ypencil_ggl real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 )) :: uz_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 )) :: uz_zpencil !---------------------------------------------------------------------------------------------------------- ! operation in x pencil, du/dx !---------------------------------------------------------------------------------------------------------- div0 = ZERO div0_ypencil_ggl = ZERO div_ypencil_ggl = ZERO call Get_x_1der_P2C_3D ( ux , div0 , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx ) call transpose_x_to_y ( div0 , div0_ypencil_ggl , dm % dccc ) div_ypencil_ggl = div0_ypencil_ggl !---------------------------------------------------------------------------------------------------------- ! operation in y pencil, dv/dy * (1/r) !---------------------------------------------------------------------------------------------------------- uy_ypencil = ZERO div0_ypencil = ZERO div0_ypencil_ggl = ZERO call transpose_x_to_y ( uy , uy_ypencil , dm % dcpc ) call Get_y_1der_P2C_3D ( uy_ypencil , div0_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qy ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div0_ypencil , dm % dccc , dm % rci , 1 , IPENCIL ( 2 )) call ypencil_index_lgl2ggl ( div0_ypencil , div0_ypencil_ggl , dm % dccc ) div_ypencil_ggl = div_ypencil_ggl + div0_ypencil_ggl call transpose_y_to_z ( div_ypencil_ggl , div_zpencil_ggg , dm % dccc ) !---------------------------------------------------------------------------------------------------------- ! operation in z pencil, dw/dz * (1/r) !---------------------------------------------------------------------------------------------------------- uz_ypencil = ZERO uz_zpencil = ZERO div0_zpencil = ZERO div0_zpencil_ggg = ZERO call transpose_x_to_y ( uz , uz_ypencil , dm % dccp ) call transpose_y_to_z ( uz_ypencil , uz_zpencil , dm % dccp ) call Get_z_1der_P2C_3D ( uz_zpencil , div0_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_qz ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( div0_zpencil , dm % dccc , dm % rci , 1 , IPENCIL ( 3 )) call zpencil_index_llg2ggg ( div0_zpencil , div0_zpencil_ggg , dm % dccc ) div_zpencil_ggg = div_zpencil_ggg + div0_zpencil_ggg return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief To calculate divergence of (rho * u) or divergence of (u) !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     ux           ux or gx !> \\param[in]     uy           uy or gy !> \\param[in]     uz           uz or gz !> \\param[out]    div          div(u) or div(g) !> \\param[in]     d            domain !_______________________________________________________________________________ subroutine Check_element_mass_conservation ( fl , dm , iter , opt_isub , opt_str ) use precision_mod use udf_type_mod use input_general_mod use parameters_constant_mod use math_mod use mpi_mod use solver_tools_mod use wtformat_mod use io_visualisation_mod use find_max_min_ave_mod use typeconvert_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl integer , intent ( in ) :: iter integer , intent ( in ), optional :: opt_isub character ( * ), intent ( in ), optional :: opt_str character ( 32 ) :: str integer :: n , nlayer , isub real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) :: div , drhodt if ( present ( opt_str )) then str = trim ( opt_str ) // '_iter_' // int2str ( iter ) else str = 'at iter = ' // int2str ( iter ) end if if ( present ( opt_isub )) then isub = opt_isub else isub = 0 end if !fl%pcor = ZERO div (:, :, :) = ZERO !---------------------------------------------------------------------------------------------------------- ! $d\\rho / dt$ at cell centre !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then drhodt = fl % drhodt else drhodt = ZERO end if !---------------------------------------------------------------------------------------------------------- ! $d(\\rho u_i)) / dx_i $ at cell centre !---------------------------------------------------------------------------------------------------------- call Get_divergence_flow ( fl , div , dm ) write ( * , * ) 'test, dddt, div, plus' , drhodt ( 4 , 4 , 4 ), div ( 4 , 4 , 4 ), drhodt ( 4 , 4 , 4 ) + div ( 4 , 4 , 4 ) write ( * , * ) 'test, d0, d1, d2     ' , fl % dDens ( 4 , 4 , 4 ), fl % dDensm1 ( 4 , 4 , 4 ), fl % dDensm2 ( 4 , 4 , 4 ) div = div + drhodt #ifdef DEBUG_STEPS if ( MOD ( iter , dm % visu_nfre ) == 0 ) & call write_visu_any3darray ( div , 'divU' , 'debug' // trim ( str ), dm % dccc , dm , fl % iteration ) #endif n = dm % dccc % xsz ( 1 ) nlayer = 4 call Find_maximum_absvar3d ( div ( 1 : nlayer , :, :), fl % mcon ( 1 ), dm % dccc , \"Mass Consv. (inlet  4) =\" , 1 ) call Find_maximum_absvar3d ( div ( nlayer + 1 : n - nlayer , :, :), fl % mcon ( 2 ), dm % dccc , \"Mass Consv. (bulk    ) =\" , nlayer + 1 ) call Find_maximum_absvar3d ( div ( n - nlayer + 1 : n , :, :), fl % mcon ( 3 ), dm % dccc , \"Mass Consv. (outlet 4) =\" , n - nlayer + 1 ) if ( nrank == 0 ) then if ( fl % mcon ( 2 ) > 5.0E-13_WP . and . fl % iteration > 100 ) & call Print_error_msg ( \"Mass conservation is not strictly satisfied at the machine precision level.\" ) end if ! if(nrank == 0) then !   write (*, wrtfmt1e) \"  Check Mass Conservation:\", divmax ! end if return end subroutine Check_element_mass_conservation end module continuity_eq_mod","tags":"","url":"sourcefile/eq_continuity.f90.html"},{"title":"bc_general.f90 – CHAPSim2","text":"Source Code module boundary_conditions_mod use bc_dirichlet_mod use bc_convective_outlet_mod use bc_ndomain_interior_mod use udf_type_mod use parameters_constant_mod use print_msg_mod implicit none integer , save :: mbcx_cov1 ( 2 ), & mbcy_cov1 ( 2 ), & mbcz_cov1 ( 2 ), & mbcx_tau1 ( 2 ), & mbcy_tau1 ( 2 ), & mbcz_tau1 ( 2 ), & mbcx_cov2 ( 2 ), & mbcy_cov2 ( 2 ), & mbcz_cov2 ( 2 ), & mbcr_cov2 ( 2 ), & mbcy_tau2 ( 2 ), & mbcx_tau2 ( 2 ), & mbcz_tau2 ( 2 ), & mbcr_tau2 ( 2 ), & mbcx_cov3 ( 2 ), & mbcy_cov3 ( 2 ), & mbcz_cov3 ( 2 ), & mbcr_cov3 ( 2 ), & mbcy_tau3 ( 2 ), & mbcx_tau3 ( 2 ), & mbcz_tau3 ( 2 ), & mbcr_tau3 ( 2 ), & ebcx_conv ( 2 ), & ebcy_conv ( 2 ), & ebcz_conv ( 2 ), & ebcx_difu ( 2 ), & ebcy_difu ( 2 ), & ebcz_difu ( 2 ) logical , save :: is_fbcx_velo_required , & is_fbcy_velo_required , & is_fbcz_velo_required private :: reassign_ibc ! re-assign calcuation ibc and keep the nominal bc public :: config_calc_basic_ibc ! applied once only, just before calculation public :: allocate_fbc_flow ! applied once only public :: allocate_fbc_thermo ! applied once only private :: axis_mirroring_interior_fbcy public :: update_fbcy_cc_flow_halo ! for pipe only, applied every NS, cc for circle central point and var stored in xcx public :: update_fbcy_cc_thermo_halo ! for pipe only, applied every NS, cc for circle central point and var stored in xcx public :: build_bc_symm_operation ! applied if necessary public :: config_calc_eqs_ibc public :: get_fbcx_iTh public :: get_fbcy_iTh public :: get_fbcz_iTh private :: get_name_bc contains !========================================================================================================== function get_name_bc ( ibc ) result ( str ) integer , intent ( in ) :: ibc character ( 14 ) :: str select case ( ibc ) case ( IBC_INTERIOR ) str = 'IBC_INTERIOR' case ( IBC_PERIODIC ) str = 'IBC_PERIODIC' case ( IBC_SYMMETRIC ) str = 'IBC_SYMMETRIC' case ( IBC_ASYMMETRIC ) str = 'IBC_ASYMMETRIC' case ( IBC_DIRICHLET ) str = 'IBC_DIRICHLET' case ( IBC_NEUMANN ) str = 'IBC_NEUMANN' case ( IBC_INTRPL ) str = 'IBC_INTRPL' case ( IBC_CONVECTIVE ) str = 'IBC_CONVECTIVE' case ( IBC_TURBGEN ) str = 'IBC_TURBGEN' case ( IBC_PROFILE1D ) str = 'IBC_PROFILE1D' case ( IBC_DATABASE ) str = 'IBC_DATABASE' case default call Print_error_msg ( 'Boundary Conditions Not Supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== subroutine reassign_ibc ( bc_nominal , ibc ) integer , intent ( in ) :: bc_nominal ( 2 , 5 ) integer , intent ( out ) :: ibc ( 2 , 5 ) integer :: n , m do n = 1 , 2 do m = 1 , 5 if ( bc_nominal ( n , m ) == IBC_PROFILE1D ) then ibc ( n , m ) = IBC_DIRICHLET else if ( bc_nominal ( n , m ) == IBC_TURBGEN ) then if ( m == 5 ) then ibc ( n , m ) = IBC_DIRICHLET ! for temperature, default is no incoming thermal flow, it is initilazed temperature else if ( m == 4 ) then ibc ( n , m ) = IBC_NEUMANN ! for p else ibc ( n , m ) = IBC_DIRICHLET ! for u, v, w end if else if ( bc_nominal ( n , m ) == IBC_DATABASE ) then if ( m == 5 ) then ibc ( n , m ) = IBC_DIRICHLET ! for temperature, default is no incoming thermal flow, it is initilazed temperature else if ( m == 4 ) then ibc ( n , m ) = IBC_NEUMANN ! for p else ibc ( n , m ) = IBC_DIRICHLET ! for u, v, w, p, check!! end if else if ( bc_nominal ( n , m ) == IBC_CONVECTIVE ) then ! check for convetive outlet ibc ( n , m ) = IBC_DIRICHLET else ibc ( n , m ) = bc_nominal ( n , m ) end if end do end do return end subroutine !========================================================================================================== !========================================================================================================== ! to get all ibc for calculation !========================================================================================================== subroutine config_calc_basic_ibc ( dm ) use wtformat_mod type ( t_domain ), intent ( inout ) :: dm integer :: n integer :: ibcx ( 2 , 5 ), ibcy ( 2 , 5 ), ibcz ( 2 , 5 ) character ( len = 38 ) :: fmt = '(2X, A10, 2(A3, A14, A3, A14), 2F13.4)' !---------------------------------------------------------------------------------------------------------- ! to check velocity symmetric and asymmetric !---------------------------------------------------------------------------------------------------------- do n = 1 , 2 if ( dm % ibcx_nominal ( n , 1 ) == IBC_SYMMETRIC ) & dm % ibcx_nominal ( n , 1 ) = IBC_ASYMMETRIC if ( dm % ibcy_nominal ( n , 2 ) == IBC_SYMMETRIC ) & dm % ibcy_nominal ( n , 2 ) = IBC_ASYMMETRIC if ( dm % ibcz_nominal ( n , 3 ) == IBC_SYMMETRIC ) & dm % ibcz_nominal ( n , 3 ) = IBC_ASYMMETRIC end do !---------------------------------------------------------------------------------------------------------- ! to set up real bc for calculation from given nominal b.c. !---------------------------------------------------------------------------------------------------------- call reassign_ibc ( dm % ibcx_nominal , ibcx ( 1 : 2 , 1 : 5 )) call reassign_ibc ( dm % ibcy_nominal , ibcy ( 1 : 2 , 1 : 5 )) call reassign_ibc ( dm % ibcz_nominal , ibcz ( 1 : 2 , 1 : 5 )) !---------------------------------------------------------------------------------------------------------- ! allocate bc to variables !---------------------------------------------------------------------------------------------------------- do n = 1 , 2 dm % ibcx_qx ( n ) = ibcx ( n , 1 ) dm % ibcx_qy ( n ) = ibcx ( n , 2 ) dm % ibcx_qz ( n ) = ibcx ( n , 3 ) dm % ibcx_pr ( n ) = ibcx ( n , 4 ) dm % ibcx_Tm ( n ) = ibcx ( n , 5 ) dm % ibcy_qx ( n ) = ibcy ( n , 1 ) dm % ibcy_qy ( n ) = ibcy ( n , 2 ) dm % ibcy_qz ( n ) = ibcy ( n , 3 ) dm % ibcy_pr ( n ) = ibcy ( n , 4 ) dm % ibcy_Tm ( n ) = ibcy ( n , 5 ) dm % ibcz_qx ( n ) = ibcz ( n , 1 ) dm % ibcz_qy ( n ) = ibcz ( n , 2 ) dm % ibcz_qz ( n ) = ibcz ( n , 3 ) dm % ibcz_pr ( n ) = ibcz ( n , 4 ) dm % ibcz_Tm ( n ) = ibcz ( n , 5 ) dm % ibcx_ftp ( n ) = dm % ibcx_Tm ( n ) dm % ibcy_ftp ( n ) = dm % ibcy_Tm ( n ) dm % ibcz_ftp ( n ) = dm % ibcz_Tm ( n ) if ( dm % ibcx_Tm ( n ) == IBC_NEUMANN ) dm % ibcx_ftp ( n ) = IBC_DIRICHLET if ( dm % ibcy_Tm ( n ) == IBC_NEUMANN ) dm % ibcy_ftp ( n ) = IBC_DIRICHLET if ( dm % ibcz_Tm ( n ) == IBC_NEUMANN ) dm % ibcz_ftp ( n ) = IBC_DIRICHLET if ( dm % ibcx_qx ( n ) == IBC_DIRICHLET ) then dm % ibcx_pr ( n ) = IBC_NEUMANN dm % fbcx_const ( n , 4 ) = ZERO end if if ( dm % ibcy_qy ( n ) == IBC_DIRICHLET ) then dm % ibcy_pr ( n ) = IBC_NEUMANN dm % fbcy_const ( n , 4 ) = ZERO end if if ( dm % ibcz_qz ( n ) == IBC_DIRICHLET ) then dm % ibcz_pr ( n ) = IBC_NEUMANN dm % fbcz_const ( n , 4 ) = ZERO end if end do if ( dm % icase == ICASE_PIPE ) then ! already done in input_general.f90 end if if ( nrank == 0 ) then call Print_debug_start_msg ( 'Norminal and calculated boundary conditions' ) write ( * , * ) '      is periodic in xyz? ' , dm % is_periodic ( 1 : 3 ) write ( * , * ) '      BC in the X direction: norminal BC Left, calc BC Left, norminal BC Right, calc BC Right' write ( * , fmt ) '  u-bc :' , '||' , get_name_bc ( dm % ibcx_nominal ( 1 , 1 )), '=> ' , get_name_bc ( dm % ibcx_qx ( 1 )), & '||' , get_name_bc ( dm % ibcx_nominal ( 2 , 1 )), '=> ' , get_name_bc ( dm % ibcx_qx ( 2 )), dm % fbcx_const ( 1 : 2 , 1 ) write ( * , fmt ) '  v-bc :' , '||' , get_name_bc ( dm % ibcx_nominal ( 1 , 2 )), '=> ' , get_name_bc ( dm % ibcx_qy ( 1 )), & '||' , get_name_bc ( dm % ibcx_nominal ( 2 , 2 )), '=> ' , get_name_bc ( dm % ibcx_qy ( 2 )), dm % fbcx_const ( 1 : 2 , 2 ) write ( * , fmt ) '  w-bc :' , '||' , get_name_bc ( dm % ibcx_nominal ( 1 , 3 )), '=> ' , get_name_bc ( dm % ibcx_qz ( 1 )), & '||' , get_name_bc ( dm % ibcx_nominal ( 2 , 3 )), '=> ' , get_name_bc ( dm % ibcx_qz ( 2 )), dm % fbcx_const ( 1 : 2 , 3 ) write ( * , fmt ) '  p-bc :' , '||' , get_name_bc ( dm % ibcx_nominal ( 1 , 4 )), '=> ' , get_name_bc ( dm % ibcx_pr ( 1 )), & '||' , get_name_bc ( dm % ibcx_nominal ( 2 , 4 )), '=> ' , get_name_bc ( dm % ibcx_pr ( 2 )), dm % fbcx_const ( 1 : 2 , 4 ) if ( dm % is_thermo ) & write ( * , fmt ) '  T-bc :' , '||' , get_name_bc ( dm % ibcx_nominal ( 1 , 5 )), '=> ' , get_name_bc ( dm % ibcx_Tm ( 1 )), & '||' , get_name_bc ( dm % ibcx_nominal ( 2 , 5 )), '=> ' , get_name_bc ( dm % ibcx_Tm ( 2 )), dm % fbcx_const ( 1 : 2 , 5 ) write ( * , wrtfmt1s ) '      BC in the Y direction: norminal BC, calc BC' write ( * , fmt ) '  u-bc :' , '||' , get_name_bc ( dm % ibcy_nominal ( 1 , 1 )), '=> ' , get_name_bc ( dm % ibcy_qx ( 1 )), & '||' , get_name_bc ( dm % ibcy_nominal ( 2 , 1 )), '=> ' , get_name_bc ( dm % ibcy_qx ( 2 )), dm % fbcy_const ( 1 : 2 , 1 ) write ( * , fmt ) '  v-bc :' , '||' , get_name_bc ( dm % ibcy_nominal ( 1 , 2 )), '=> ' , get_name_bc ( dm % ibcy_qy ( 1 )), & '||' , get_name_bc ( dm % ibcy_nominal ( 2 , 2 )), '=> ' , get_name_bc ( dm % ibcy_qy ( 2 )), dm % fbcy_const ( 1 : 2 , 2 ) write ( * , fmt ) '  w-bc :' , '||' , get_name_bc ( dm % ibcy_nominal ( 1 , 3 )), '=> ' , get_name_bc ( dm % ibcy_qz ( 1 )), & '||' , get_name_bc ( dm % ibcy_nominal ( 2 , 3 )), '=> ' , get_name_bc ( dm % ibcy_qz ( 2 )), dm % fbcy_const ( 1 : 2 , 3 ) write ( * , fmt ) '  p-bc :' , '||' , get_name_bc ( dm % ibcy_nominal ( 1 , 4 )), '=> ' , get_name_bc ( dm % ibcy_pr ( 1 )), & '||' , get_name_bc ( dm % ibcy_nominal ( 2 , 4 )), '=> ' , get_name_bc ( dm % ibcy_pr ( 2 )), dm % fbcy_const ( 1 : 2 , 4 ) if ( dm % is_thermo ) & write ( * , fmt ) '  T-bc :' , '||' , get_name_bc ( dm % ibcy_nominal ( 1 , 5 )), '=> ' , get_name_bc ( dm % ibcy_Tm ( 1 )), & '||' , get_name_bc ( dm % ibcy_nominal ( 2 , 5 )), '=> ' , get_name_bc ( dm % ibcy_Tm ( 2 )), dm % fbcy_const ( 1 : 2 , 5 ) write ( * , wrtfmt1s ) '      BC in the Z direction: norminal BC, calc BC' write ( * , fmt ) '  u-bc :' , '||' , get_name_bc ( dm % ibcz_nominal ( 1 , 1 )), '=> ' , get_name_bc ( dm % ibcz_qx ( 1 )), & '||' , get_name_bc ( dm % ibcz_nominal ( 2 , 1 )), '=> ' , get_name_bc ( dm % ibcz_qx ( 2 )), dm % fbcz_const ( 1 : 2 , 1 ) write ( * , fmt ) '  v-bc :' , '||' , get_name_bc ( dm % ibcz_nominal ( 1 , 2 )), '=> ' , get_name_bc ( dm % ibcz_qy ( 1 )), & '||' , get_name_bc ( dm % ibcz_nominal ( 2 , 2 )), '=> ' , get_name_bc ( dm % ibcz_qy ( 2 )), dm % fbcz_const ( 1 : 2 , 2 ) write ( * , fmt ) '  w-bc :' , '||' , get_name_bc ( dm % ibcz_nominal ( 1 , 3 )), '=> ' , get_name_bc ( dm % ibcz_qz ( 1 )), & '||' , get_name_bc ( dm % ibcz_nominal ( 2 , 3 )), '=> ' , get_name_bc ( dm % ibcz_qz ( 2 )), dm % fbcz_const ( 1 : 2 , 3 ) write ( * , fmt ) '  p-bc :' , '||' , get_name_bc ( dm % ibcz_nominal ( 1 , 4 )), '=> ' , get_name_bc ( dm % ibcz_pr ( 1 )), & '||' , get_name_bc ( dm % ibcz_nominal ( 2 , 4 )), '=> ' , get_name_bc ( dm % ibcz_pr ( 2 )), dm % fbcz_const ( 1 : 2 , 4 ) if ( dm % is_thermo ) & write ( * , fmt ) '  T-bc :' , '||' , get_name_bc ( dm % ibcz_nominal ( 1 , 5 )), '=> ' , get_name_bc ( dm % ibcz_Tm ( 1 )), & '||' , get_name_bc ( dm % ibcz_nominal ( 2 , 5 )), '=> ' , get_name_bc ( dm % ibcz_Tm ( 2 )), dm % fbcz_const ( 1 : 2 , 5 ) end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine allocate_fbc_flow ( dm ) type ( t_domain ), intent ( inout ) :: dm !---------------------------------------------------------------------------------------------------------- ! to set up real bc values for calculation from given nominal b.c. values ! bc always saved on the boundar face centre ! warning: this bc treatment is not proper for a inlet plane with field data.... to check and to update !---------------------------------------------------------------------------------------------------------- allocate ( dm % fbcx_qx ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_qx ( dm % dpcc % ysz ( 1 ), 4 , dm % dpcc % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcz_qx ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( dm % fbcx_qy ( 4 , dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_qy ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcz_qy ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( dm % fbcx_qz ( 4 , dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_qz ( dm % dccp % ysz ( 1 ), 4 , dm % dccp % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcz_qz ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( dm % fbcx_pr ( 4 , dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_pr ( dm % dccc % ysz ( 1 ), 4 , dm % dccc % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcz_pr ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), 4 ) ) ! default z pencil if ( dm % icoordinate == ICYLINDRICAL ) then allocate ( dm % fbcy_qyr ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) allocate ( dm % fbcz_qyr ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), 4 ) ) allocate ( dm % fbcy_qzr ( dm % dccp % ysz ( 1 ), 4 , dm % dccp % ysz ( 3 )) ) allocate ( dm % fbcz_qzr ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) end if if ( dm % is_record_xoutlet ) then allocate ( dm % fbcx_qx_outl1 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) allocate ( dm % fbcx_qx_outl2 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) allocate ( dm % fbcx_qy_outl1 ( dm % dxpc % xsz ( 1 ), dm % dxpc % xsz ( 2 ), dm % dxpc % xsz ( 3 )) ) allocate ( dm % fbcx_qy_outl2 ( dm % dxpc % xsz ( 1 ), dm % dxpc % xsz ( 2 ), dm % dxpc % xsz ( 3 )) ) allocate ( dm % fbcx_qz_outl1 ( dm % dxcp % xsz ( 1 ), dm % dxcp % xsz ( 2 ), dm % dxcp % xsz ( 3 )) ) allocate ( dm % fbcx_qz_outl2 ( dm % dxcp % xsz ( 1 ), dm % dxcp % xsz ( 2 ), dm % dxcp % xsz ( 3 )) ) allocate ( dm % fbcx_pr_outl1 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) allocate ( dm % fbcx_pr_outl2 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) end if if ( dm % is_read_xinlet ) then allocate ( dm % fbcx_qx_inl1 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) allocate ( dm % fbcx_qx_inl2 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) allocate ( dm % fbcx_qy_inl1 ( dm % dxpc % xsz ( 1 ), dm % dxpc % xsz ( 2 ), dm % dxpc % xsz ( 3 )) ) allocate ( dm % fbcx_qy_inl2 ( dm % dxpc % xsz ( 1 ), dm % dxpc % xsz ( 2 ), dm % dxpc % xsz ( 3 )) ) allocate ( dm % fbcx_qz_inl1 ( dm % dxcp % xsz ( 1 ), dm % dxcp % xsz ( 2 ), dm % dxcp % xsz ( 3 )) ) allocate ( dm % fbcx_qz_inl2 ( dm % dxcp % xsz ( 1 ), dm % dxcp % xsz ( 2 ), dm % dxcp % xsz ( 3 )) ) allocate ( dm % fbcx_pr_inl1 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) allocate ( dm % fbcx_pr_inl2 ( dm % dxcc % xsz ( 1 ), dm % dxcc % xsz ( 2 ), dm % dxcc % xsz ( 3 )) ) end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine allocate_fbc_thermo ( dm ) type ( t_domain ), intent ( inout ) :: dm if ( . not . dm % is_thermo ) return allocate ( dm % fbcx_gx ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcx_gy ( 4 , dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcx_gz ( 4 , dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_gx ( dm % dpcc % ysz ( 1 ), 4 , dm % dpcc % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcy_gy ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcy_gz ( dm % dccp % ysz ( 1 ), 4 , dm % dccp % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcz_gx ( dm % dpcc % zsz ( 1 ), dm % dpcc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( dm % fbcz_gy ( dm % dcpc % zsz ( 1 ), dm % dcpc % zsz ( 2 ), 4 ) ) ! default z pencil allocate ( dm % fbcz_gz ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) ! default z pencil !if(dm%icoordinate == ICYLINDRICAL) then !allocate( dm%fbcy_gyr(dm%dcpc%ysz(1), 4, dm%dcpc%ysz(3)) ) !allocate( dm%fbcy_gzr(dm%dccp%ysz(1), 4, dm%dccp%ysz(3)) ) !allocate( dm%fbcz_gyr(dm%dcpc%zsz(1), dm%dcpc%zsz(2), 4) ) !allocate( dm%fbcz_gzr(dm%dccp%zsz(1), dm%dccp%zsz(2), 4) ) !end if allocate ( dm % fbcx_qw ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcx_ftp ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_qw ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) ! default x pencil allocate ( dm % fbcy_ftp ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) ) ! default y pencil allocate ( dm % fbcz_qw ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) ! default x pencil allocate ( dm % fbcz_ftp ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) ) ! default z pencil return end subroutine !========================================================================================================== !========================================================================================================== subroutine axis_mirroring_interior_fbcy ( var_xpencil , fbcy , ksym , dtmp , is_qr_qrdr , is_reversed ) type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), intent ( in ) :: var_xpencil (:, :, :) real ( WP ), intent ( inout ) :: fbcy (:, :, :) integer , intent ( in ) :: ksym (:) logical , intent ( in ), optional :: is_reversed integer , intent ( in ), optional :: is_qr_qrdr real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 ) ) :: var_ypencil , var_ypencil1 real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 ) ) :: var_zpencil , var_zpencil1 integer :: k real ( WP ) :: sign !if (dm%icase /= ICASE_PIPE .or. dm%icoordinate /= ICYLINDRICAL) return sign = ONE !---------------------------------------------------------------------------------------------------------- !   transpose from x to z !---------------------------------------------------------------------------------------------------------- if ( present ( is_reversed )) then if ( is_reversed ) sign = - ONE end if call transpose_x_to_y ( var_xpencil , var_ypencil , dtmp ) call transpose_y_to_z ( var_ypencil , var_zpencil , dtmp ) do k = 1 , dtmp % zsz ( 3 ) var_zpencil1 (:, :, k ) = sign * var_zpencil (:, :, ksym ( k )) end do call transpose_z_to_y ( var_zpencil1 , var_ypencil1 , dtmp ) fbcy (:, 1 , :) = var_ypencil1 (:, 1 , :) fbcy (:, 3 , :) = var_ypencil1 (:, 2 , :) if ( present ( is_qr_qrdr )) then ! for qy/r if ( is_qr_qrdr == 1 ) then fbcy (:, 1 , :) = ZERO else if ( is_qr_qrdr == 2 ) then fbcy (:, 1 , :) = ( var_ypencil1 (:, 2 , :) + var_ypencil (:, 2 , :)) * HALF else end if end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine update_fbcy_cc_flow_halo ( fl , dm ) ! for cylindrical only use find_max_min_ave_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ) ) :: acpc_xpencil ! Check if the case and coordinate system are valid if ( dm % icase /= ICASE_PIPE . or . dm % icoordinate /= ICYLINDRICAL ) return #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_inline_msg ( 'Update boundary conditions in y-direction for the centre of the pipe.' ) #endif !---------------------------------------------------------------------------------------------------------- !   ! Update qx boundary condition in y-direction (interior cell center) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qx ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_qx for the centre of the pipe.' ) call axis_mirroring_interior_fbcy ( fl % qx , dm % fbcy_qx , dm % knc_sym , dm % dpcc ) !---------------------------------------------------------------------------------------------------------- !   ! Update qy and qy/r boundary conditions in y-direction (on nodes) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qy ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_qy for the centre of the pipe.' ) call axis_mirroring_interior_fbcy ( fl % qy , dm % fbcy_qy , dm % knc_sym , dm % dcpc , & is_qr_qrdr = 1 , is_reversed = . true .) acpc_xpencil = fl % qy call multiple_cylindrical_rn ( acpc_xpencil , dm % dcpc , dm % rpi , 1 , IPENCIL ( 1 )) ! qr/r call axis_mirroring_interior_fbcy ( acpc_xpencil , dm % fbcy_qyr , dm % knc_sym , dm % dcpc , & is_qr_qrdr = 2 , is_reversed = . true .) !---------------------------------------------------------------------------------------------------------- !   Update qz boundary condition in y-direction (interior cell center) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qz ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_qz for the centre of the pipe.' ) ! call axis_mirroring_interior_fbcy ( fl % qz , dm % fbcy_qz , dm % knc_sym , dm % dccp , is_reversed = . true .) ! check dm % fbcy_qzr (:, 1 , :) = dm % fbcy_qz (:, 1 , :) * dm % rci ( 1 ) ! interior, not at axis dm % fbcy_qzr (:, 3 , :) = dm % fbcy_qz (:, 3 , :) * dm % rci ( 2 ) !---------------------------------------------------------------------------------------------------------- !   Update pressure boundary condition in y-direction (interior) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_pr ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_pr for the centre of the pipe.' ) ! call axis_mirroring_interior_fbcy ( fl % pres , dm % fbcy_pr , dm % knc_sym , dm % dccc ) !---------------------------------------------------------------------------------------------------------- !   Thermal variables !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then !---------------------------------------------------------------------------------------------------------- !   ! Update gx boundary condition in y-direction (interior) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qx ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_gx for the centre of the pipe.' ) call axis_mirroring_interior_fbcy ( fl % gx , dm % fbcy_gx , dm % knc_sym , dm % dpcc ) !---------------------------------------------------------------------------------------------------------- !   ! Update gy ang gy/r boundary condition in y-direction (interior) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qy ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_gy for the centre of the pipe.' ) call axis_mirroring_interior_fbcy ( fl % gy , dm % fbcy_gy , dm % knc_sym , dm % dcpc , & is_qr_qrdr = 1 , is_reversed = . true .) !---------------------------------------------------------------------------------------------------------- !   ! Update gz boundary condition in y-direction (interior) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_qz ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_qz for the centre of the pipe.' ) ! call axis_mirroring_interior_fbcy ( fl % gz , dm % fbcy_gz , dm % knc_sym , dm % dccp , is_reversed = . true .) !dm%fbcy_gzr(:, 1, :) = dm%fbcy_gz(:, 1, :) * dm%rci(1) !dm%fbcy_gzr(:, 3, :) = dm%fbcy_gz(:, 3, :) * dm%rci(2) end if #ifdef DEBUG_STEPS if ( nrank == 0 ) & call Print_debug_end_msg () #endif return end subroutine !========================================================================================================== !========================================================================================================== subroutine update_fbcy_cc_thermo_halo ( fl , tm , dm ) ! for cylindrical only use thermo_info_mod use find_max_min_ave_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_thermo ), intent ( in ) :: tm type ( t_flow ), intent ( inout ) :: fl real ( WP ) :: fbcy ( dm % dccc % ysz ( 1 ), 4 , dm % dccc % ysz ( 3 )) real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil ! Check if thermo is enabled and the case and coordinate system are valid if (. not . dm % is_thermo . or . dm % icase /= ICASE_PIPE . or . dm % icoordinate /= ICYLINDRICAL ) return !---------------------------------------------------------------------------------------------------------- !   ! Update thermo boundary condition in y-direction (interior) !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_Tm ( 1 ) /= IBC_INTERIOR ) call Print_error_msg ( 'Error in ibcy_Tm for the centre of the pipe.' ) ! fbcy = dm % fbcy_ftp % t call axis_mirroring_interior_fbcy ( tm % tTemp , fbcy , dm % knc_sym , dm % dccc ) dm % fbcy_ftp % t = fbcy call ftp_refresh_thermal_properties_from_T_undim_3D ( dm % fbcy_ftp ) return end subroutine !========================================================================================================== ! to calculate boundary during calculation from primary boundary subroutine build_bc_symm_operation ( ibc , mbc , jbc ) integer , intent ( in ) :: ibc ( 2 ) integer , intent ( out ) :: mbc ( 2 , 3 ) integer , intent ( in ), optional :: jbc ( 2 ) integer :: i mbc (:, JBC_SELF ) = ibc (:) mbc (:, JBC_GRAD ) = ibc (:) mbc (:, JBC_PROD ) = ibc (:) do i = 1 , 2 if ( present ( jbc )) then if ( ibc ( i ) == IBC_SYMMETRIC . and . jbc ( i ) == IBC_SYMMETRIC ) then mbc ( i , JBC_PROD ) = IBC_SYMMETRIC else if ( ibc ( i ) == IBC_SYMMETRIC . and . jbc ( i ) == IBC_ASYMMETRIC ) then mbc ( i , JBC_PROD ) = IBC_ASYMMETRIC else if ( ibc ( i ) == IBC_ASYMMETRIC . and . jbc ( i ) == IBC_SYMMETRIC ) then mbc ( i , JBC_PROD ) = IBC_ASYMMETRIC else if ( ibc ( i ) == IBC_ASYMMETRIC . and . jbc ( i ) == IBC_ASYMMETRIC ) then mbc ( i , JBC_PROD ) = IBC_SYMMETRIC else if ( ibc ( i ) /= jbc ( i )) then if ( ibc ( i ) == IBC_DIRICHLET ) mbc ( i , :) = ibc ( i ) if ( jbc ( i ) == IBC_DIRICHLET ) mbc ( i , :) = jbc ( i ) if ( ibc ( i ) == IBC_PERIODIC . or . jbc ( i ) == IBC_PERIODIC ) then if ( nrank == 0 ) write ( * , '(A20, I2.1, A5, I2.1)' ) \"BCs for the side \" , i , \" are \" , ibc ( i ), jbc ( i ) call Print_warning_msg ( \"The two operational variables have different boundary conditions.\" ) end if else mbc ( i , :) = ibc ( i ) end if end if else if ( ibc ( i ) == IBC_SYMMETRIC ) then mbc ( i , JBC_SELF ) = ibc ( i ) ! variable itself mbc ( i , JBC_GRAD ) = IBC_ASYMMETRIC ! d(var)/dn, mbc ( i , JBC_PROD ) = ibc ( i ) ! var * var else if ( ibc ( i ) == IBC_ASYMMETRIC ) then mbc ( i , JBC_SELF ) = ibc ( i ) ! variable itself mbc ( i , JBC_GRAD ) = IBC_SYMMETRIC ! d(var)/dn, mbc ( i , JBC_PROD ) = IBC_SYMMETRIC ! var * var else mbc ( i , :) = ibc ( i ) end if end if end do return end subroutine !========================================================================================================== subroutine config_calc_eqs_ibc ( dm ) use wtformat_mod type ( t_domain ), intent ( inout ) :: dm integer :: mbc ( 2 , 3 ), mbc0 ( 2 , 3 ) integer :: bc ( 2 ), n !---------------------------------------------------------------------------------------------------------- !   x-mom !---------------------------------------------------------------------------------------------------------- call build_bc_symm_operation ( dm % ibcx_qx , mbc , dm % ibcx_qx ) mbcx_cov1 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for x-mom x-convection :\" , get_name_bc ( mbcx_cov1 ( 1 )), get_name_bc ( mbcx_cov1 ( 2 )) call build_bc_symm_operation ( dm % ibcy_qy , mbc , dm % ibcy_qx ) mbcy_cov1 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for x-mom y-convection :\" , get_name_bc ( mbcy_cov1 ( 1 )), get_name_bc ( mbcy_cov1 ( 2 )) call build_bc_symm_operation ( dm % ibcz_qz , mbc , dm % ibcz_qx ) mbcz_cov1 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for x-mom z-convection :\" , get_name_bc ( mbcz_cov1 ( 1 )), get_name_bc ( mbcz_cov1 ( 2 )) call build_bc_symm_operation ( dm % ibcx_qx , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcx_ftp , mbc , bc ) mbcx_tau1 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for x-mom x-diffusion  :\" , get_name_bc ( mbcx_tau1 ( 1 )), get_name_bc ( mbcx_tau1 ( 2 )) call build_bc_symm_operation ( dm % ibcy_qx , mbc ) !du/dy_ppc bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc , bc ) ! mu_ppc * du/dy_ppc call build_bc_symm_operation ( dm % ibcy_ftp , mbc0 , dm % ibcy_qy ) ! mu_ppc * dv/dx_ppc !if(dm%icase == ICASE_PIPE) mbc(1, JBC_PROD) = IBC_DIRICHLET if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BCy in mbcy_tau1 is wrong.\" ) mbcy_tau1 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for x-mom y-diffusion  :\" , get_name_bc ( mbcy_tau1 ( 1 )), get_name_bc ( mbcy_tau1 ( 2 )) call build_bc_symm_operation ( dm % ibcz_qx , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc0 , dm % ibcz_qz ) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BCz in mbcy_tau1 is wrong.\" ) mbcz_tau1 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for x-mom z-diffusion  :\" , get_name_bc ( mbcz_tau1 ( 1 )), get_name_bc ( mbcz_tau1 ( 2 )) !---------------------------------------------------------------------------------------------------------- !   y-mom !---------------------------------------------------------------------------------------------------------- call build_bc_symm_operation ( dm % ibcx_qx , mbc , dm % ibcx_qy ) mbcx_cov2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom x-convection :\" , get_name_bc ( mbcx_cov2 ( 1 )), get_name_bc ( mbcx_cov2 ( 2 )) call build_bc_symm_operation ( dm % ibcy_qy , mbc , dm % ibcy_qy ) mbcy_cov2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom y-convection :\" , get_name_bc ( mbcy_cov2 ( 1 )), get_name_bc ( mbcy_cov2 ( 2 )) call build_bc_symm_operation ( dm % ibcz_qz , mbc , dm % ibcz_qy ) mbcz_cov2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom z-convection :\" , get_name_bc ( mbcz_cov2 ( 1 )), get_name_bc ( mbcz_cov2 ( 2 )) if ( dm % icoordinate == ICYLINDRICAL ) then call build_bc_symm_operation ( dm % ibcy_qz , mbc , dm % ibcy_qz ) mbcr_cov2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom r-convection :\" , get_name_bc ( mbcr_cov2 ( 1 )), get_name_bc ( mbcr_cov2 ( 2 )) end if call build_bc_symm_operation ( dm % ibcx_qy , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcx_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcx_ftp , mbc0 , dm % ibcx_qx ) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BC in mbcx_tau2 is wrong.\" ) mbcx_tau2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom x-diffusion  :\" , get_name_bc ( mbcx_tau2 ( 1 )), get_name_bc ( mbcx_tau2 ( 2 )) call build_bc_symm_operation ( dm % ibcy_qy , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc , bc ) mbcy_tau2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom y-diffusion  :\" , get_name_bc ( mbcy_tau2 ( 1 )), get_name_bc ( mbcy_tau2 ( 2 )) call build_bc_symm_operation ( dm % ibcz_qy , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc0 , dm % ibcz_qz ) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BC in mbcz_tau2 is wrong.\" ) mbcz_tau2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom z-diffusion  :\" , get_name_bc ( mbcz_tau2 ( 1 )), get_name_bc ( mbcz_tau2 ( 2 )) if ( dm % icoordinate == ICYLINDRICAL ) then call build_bc_symm_operation ( dm % ibcy_qz , mbc , dm % ibcy_ftp ) mbcr_tau2 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for y-mom r-diffusion  :\" , get_name_bc ( mbcr_tau2 ( 1 )), get_name_bc ( mbcr_tau2 ( 2 )) end if !---------------------------------------------------------------------------------------------------------- !   z-mom !---------------------------------------------------------------------------------------------------------- call build_bc_symm_operation ( dm % ibcx_qx , mbc , dm % ibcx_qz ) mbcx_cov3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom x-convection :\" , get_name_bc ( mbcx_cov3 ( 1 )), get_name_bc ( mbcx_cov3 ( 2 )) call build_bc_symm_operation ( dm % ibcy_qy , mbc , dm % ibcy_qz ) mbcy_cov3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom y-convection :\" , get_name_bc ( mbcy_cov3 ( 1 )), get_name_bc ( mbcy_cov3 ( 2 )) call build_bc_symm_operation ( dm % ibcz_qz , mbc , dm % ibcz_qz ) mbcz_cov3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom z-convection :\" , get_name_bc ( mbcz_cov3 ( 1 )), get_name_bc ( mbcz_cov3 ( 2 )) if ( dm % icoordinate == ICYLINDRICAL ) then call build_bc_symm_operation ( dm % ibcy_qy , mbc , dm % ibcy_qz ) mbcr_cov3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom r-convection :\" , get_name_bc ( mbcr_cov3 ( 1 )), get_name_bc ( mbcr_cov3 ( 2 )) end if call build_bc_symm_operation ( dm % ibcx_qz , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcx_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcx_ftp , mbc0 , dm % ibcx_qx ) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BCx in mbcx_tau3 is wrong.\" ) mbcx_tau3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom x-diffusion  :\" , get_name_bc ( mbcx_tau3 ( 1 )), get_name_bc ( mbcx_tau3 ( 2 )) call build_bc_symm_operation ( dm % ibcy_qz , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc0 , dm % ibcy_qy ) !write(*,*) get_name_bc(mbc0(1, JBC_PROD)), get_name_bc(mbc(1, JBC_PROD)) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BCy in mbcy_tau3 is wrong.\" ) mbcy_tau3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom y-diffusion  :\" , get_name_bc ( mbcy_tau3 ( 1 )), get_name_bc ( mbcy_tau3 ( 2 )) call build_bc_symm_operation ( dm % ibcz_qz , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc0 , dm % ibcz_qz ) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BCz in mbcy_tau3 is wrong.\" ) mbcz_tau3 = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom z-diffusion  :\" , get_name_bc ( mbcz_tau3 ( 1 )), get_name_bc ( mbcz_tau3 ( 2 )) if ( dm % icoordinate == ICYLINDRICAL ) then call build_bc_symm_operation ( dm % ibcy_qz , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc , bc ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc0 , dm % ibcy_qz ) if ( mbc0 ( 1 , JBC_PROD ) /= mbc ( 1 , JBC_PROD )) call Print_error_msg ( \"BCr in mbcy_tau3 is wrong.\" ) mbcr_tau3 ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for z-mom r-diffusion  :\" , get_name_bc ( mbcr_tau3 ( 1 )), get_name_bc ( mbcr_tau3 ( 2 )) end if !---------------------------------------------------------------------------------------------------------- !   energy-eqs !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then call build_bc_symm_operation ( dm % ibcx_qx , mbc , dm % ibcx_ftp ) ebcx_conv ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for energy x-convection :\" , get_name_bc ( ebcx_conv ( 1 )), get_name_bc ( ebcx_conv ( 2 )) call build_bc_symm_operation ( dm % ibcy_qy , mbc , dm % ibcy_ftp ) ebcy_conv ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for energy y-convection :\" , get_name_bc ( ebcy_conv ( 1 )), get_name_bc ( ebcy_conv ( 2 )) call build_bc_symm_operation ( dm % ibcz_qz , mbc , dm % ibcz_ftp ) ebcz_conv ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for energy z-convection :\" , get_name_bc ( ebcz_conv ( 1 )), get_name_bc ( ebcz_conv ( 2 )) call build_bc_symm_operation ( dm % ibcx_Tm , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcx_ftp , mbc , bc ) ebcx_difu = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for energy x-diffusion  :\" , get_name_bc ( ebcx_difu ( 1 )), get_name_bc ( ebcx_difu ( 2 )) call build_bc_symm_operation ( dm % ibcy_Tm , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcy_ftp , mbc , bc ) ebcy_difu ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for energy y-diffusion  :\" , get_name_bc ( ebcy_difu ( 1 )), get_name_bc ( ebcy_difu ( 2 )) call build_bc_symm_operation ( dm % ibcz_Tm , mbc ) bc ( 1 : 2 ) = mbc ( 1 : 2 , JBC_GRAD ) call build_bc_symm_operation ( dm % ibcz_ftp , mbc , bc ) ebcz_difu ( 1 : 2 ) = mbc ( 1 : 2 , JBC_PROD ) if ( nrank == 0 ) write ( * , wrtfmt3s ) \"The bc for energy z-diffusion  :\" , get_name_bc ( ebcz_difu ( 1 )), get_name_bc ( ebcz_difu ( 2 )) end if !---------------------------------------------------------------------------------------------------------- ! preparation for b.c. - Dirichlet !---------------------------------------------------------------------------------------------------------- is_fbcx_velo_required = . false . if ( dm % ibcx_qx ( 1 ) == IBC_DIRICHLET . or . & dm % ibcx_qx ( 2 ) == IBC_DIRICHLET . or . & dm % ibcx_qy ( 1 ) == IBC_DIRICHLET . or . & dm % ibcx_qy ( 2 ) == IBC_DIRICHLET . or . & dm % ibcx_qz ( 1 ) == IBC_DIRICHLET . or . & dm % ibcx_qz ( 2 ) == IBC_DIRICHLET ) then is_fbcx_velo_required = . true . ! to add neumann later, check end if is_fbcy_velo_required = . false . if ( dm % ibcy_qx ( 1 ) == IBC_DIRICHLET . or . & dm % ibcy_qx ( 2 ) == IBC_DIRICHLET . or . & dm % ibcy_qy ( 1 ) == IBC_DIRICHLET . or . & dm % ibcy_qy ( 2 ) == IBC_DIRICHLET . or . & dm % ibcy_qz ( 1 ) == IBC_DIRICHLET . or . & dm % ibcy_qz ( 2 ) == IBC_DIRICHLET ) then is_fbcy_velo_required = . true . ! to add neumann later, check end if is_fbcz_velo_required = . false . if ( dm % ibcz_qx ( 1 ) == IBC_DIRICHLET . or . & dm % ibcz_qx ( 2 ) == IBC_DIRICHLET . or . & dm % ibcz_qy ( 1 ) == IBC_DIRICHLET . or . & dm % ibcz_qy ( 2 ) == IBC_DIRICHLET . or . & dm % ibcz_qz ( 1 ) == IBC_DIRICHLET . or . & dm % ibcz_qz ( 2 ) == IBC_DIRICHLET ) then is_fbcz_velo_required = . true . ! to add neumann later, check end if !---------------------------------------------------------------------------------------------------------- ! preparation for b.c. - INTERIOR - check here!!! to do! !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_qx ( 1 ) == IBC_INTERIOR . or . & dm % ibcx_qx ( 2 ) == IBC_INTERIOR . or . & dm % ibcx_qy ( 1 ) == IBC_INTERIOR . or . & dm % ibcx_qy ( 2 ) == IBC_INTERIOR . or . & dm % ibcx_qz ( 1 ) == IBC_INTERIOR . or . & dm % ibcx_qz ( 2 ) == IBC_INTERIOR ) then is_fbcx_velo_required = . true . ! to add neumann later, check end if if ( dm % ibcy_qx ( 1 ) == IBC_INTERIOR . or . & dm % ibcy_qx ( 2 ) == IBC_INTERIOR . or . & dm % ibcy_qy ( 1 ) == IBC_INTERIOR . or . & dm % ibcy_qy ( 2 ) == IBC_INTERIOR . or . & dm % ibcy_qz ( 1 ) == IBC_INTERIOR . or . & dm % ibcy_qz ( 2 ) == IBC_INTERIOR ) then is_fbcy_velo_required = . true . ! to add neumann later, check end if if ( dm % ibcz_qx ( 1 ) == IBC_INTERIOR . or . & dm % ibcz_qx ( 2 ) == IBC_INTERIOR . or . & dm % ibcz_qy ( 1 ) == IBC_INTERIOR . or . & dm % ibcz_qy ( 2 ) == IBC_INTERIOR . or . & dm % ibcz_qz ( 1 ) == IBC_INTERIOR . or . & dm % ibcz_qz ( 2 ) == IBC_INTERIOR ) then is_fbcz_velo_required = . true . ! to add neumann later, check end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine get_fbcx_iTh ( ibc , dm , fbc ) use udf_type_mod use parameters_constant_mod implicit none integer , intent ( in ) :: ibc ( 2 ) type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( out ) :: fbc ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) integer :: n fbc = ZERO do n = 1 , 2 if ( ibc ( n ) == IBC_DIRICHLET ) then fbc ( n , :, :) = dm % fbcx_ftp ( n , :, :)% t else if ( ibc ( n ) == IBC_NEUMANN ) then fbc ( n , :, :) = dm % fbcx_qw ( n , :, :) else fbc ( n , :, :) = ZERO end if end do return end subroutine !========================================================================================================== subroutine get_fbcy_iTh ( ibc , dm , fbc ) use udf_type_mod use parameters_constant_mod implicit none integer , intent ( in ) :: ibc ( 2 ) type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( out ) :: fbc ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 )) integer :: n fbc = ZERO do n = 1 , 2 if ( ibc ( n ) == IBC_DIRICHLET ) then fbc (:, n , :) = dm % fbcy_ftp (:, n , :)% t else if ( ibc ( n ) == IBC_NEUMANN ) then fbc (:, n , :) = dm % fbcy_qw (:, n , :) else fbc (:, n , :) = ZERO end if end do return end subroutine !========================================================================================================== subroutine get_fbcz_iTh ( ibc , dm , fbc ) use udf_type_mod use parameters_constant_mod implicit none integer , intent ( in ) :: ibc ( 2 ) type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( out ) :: fbc ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) integer :: n fbc = ZERO do n = 1 , 2 if ( ibc ( n ) == IBC_DIRICHLET ) then fbc (:, :, n ) = dm % fbcz_ftp (:, :, n )% t else if ( ibc ( n ) == IBC_NEUMANN ) then fbc (:, :, n ) = dm % fbcz_qw (:, :, n ) else fbc (:, :, n ) = ZERO end if end do return end subroutine !========================================================================================================== !========================================================================================================== end module","tags":"","url":"sourcefile/bc_general.f90.html"},{"title":"input_general.f90 – CHAPSim2","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !                      CHAPSim version 2.0.0 !                      -------------------------- ! This file is part of CHAPSim, a general-purpose CFD tool. ! ! This program is free software; you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation; either version 3 of the License, or (at your option) any later ! version. ! ! This program is distributed in the hope that it will be useful, but WITHOUT ! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS ! FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more ! details. ! ! You should have received a copy of the GNU General Public License along with ! this program; if not, write to the Free Software Foundation, Inc., 51 Franklin ! Street, Fifth Floor, Boston, MA 02110-1301, USA. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !========================================================================================================== !> \\file input_general.f90 !> \\brief Reading the input parameters from the given file. !> \\author Wei Wang wei.wang@stfc.ac.uk !> \\date 11-05-2022, checked. !========================================================================================================== module input_general_mod use print_msg_mod use parameters_constant_mod implicit none logical :: is_prerun , is_postprocess public :: Read_input_parameters private :: get_name_case private :: get_name_cs private :: get_name_mesh private :: get_name_iacc private :: get_name_initial private :: get_name_fluid private :: get_name_fft private :: get_name_mstret contains !========================================================================================================== function get_name_case ( icase ) result ( str ) integer , intent ( in ) :: icase character ( 72 ) :: str select case ( icase ) case ( ICASE_OTHERS ) str = 'ICASE_OTHERS' case ( ICASE_CHANNEL ) str = 'Channel flow' case ( ICASE_PIPE ) str = 'Pipe flow' case ( ICASE_ANNULAR ) str = 'Annular flow' case ( ICASE_TGV2D ) str = '2D Taylor Green Vortex' case ( ICASE_TGV3D ) str = '3D Taylor Green Vortex' case ( ICASE_BURGERS ) str = 'Burgers flow' case ( ICASE_ALGTEST ) str = 'Analytical test' case default call Print_error_msg ( 'The required case type is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_cs ( ics ) result ( str ) integer , intent ( in ) :: ics character ( 72 ) :: str select case ( ics ) case ( ICARTESIAN ) str = 'Cartesian coordinate system' case ( ICYLINDRICAL ) str = 'Cylindrical coordinate system' case default call Print_error_msg ( 'The required coordinate system is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_mesh ( ist ) result ( str ) integer , intent ( in ) :: ist character ( 72 ) :: str select case ( ist ) case ( ISTRET_NO ) str = 'Uniform mesh without stretching' case ( ISTRET_CENTRE ) str = 'Mesh clusted towards centre of y-domain' case ( ISTRET_2SIDES ) str = 'Mesh clusted twowards two sides of y-domain' case ( ISTRET_BOTTOM ) str = 'Mesh clusted twowards the bottom of y-domain' case ( ISTRET_TOP ) str = 'Mesh clusted twowards the top of y-domain' case default call Print_error_msg ( 'The required mesh stretching is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_mstret ( ist ) result ( str ) integer , intent ( in ) :: ist character ( 72 ) :: str select case ( ist ) case ( MSTRET_3FMD ) str = 'Stretched mesh has only 3 Fourier modes. Suitable for 3-D FFT.' case ( MSTRET_TANH ) str = 'Stretched mesh follows tanh.' case ( MSTRET_POWL ) str = 'Stretched mesh follows powerlaw.' case default call Print_warning_msg ( 'The required mesh stretching method is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_fft ( ist ) result ( str ) integer , intent ( in ) :: ist character ( 72 ) :: str select case ( ist ) case ( FFT_2DECOMP_3DFFT ) str = '3-D FFT using 2DECOMP&FFT' case ( FFT_FISHPACK_2DFFT ) str = '2-D FFT using Fishpack FFT' case default call Print_error_msg ( 'The required FFT lib is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_iacc ( iacc ) result ( str ) integer , intent ( in ) :: iacc character ( 72 ) :: str select case ( iacc ) case ( IACCU_CD2 ) str = '2nd order Centrail Difference' case ( IACCU_CD4 ) str = '4th order Central Difference' case ( IACCU_CP4 ) str = '4th order Compact Scheme' case ( IACCU_CP6 ) str = '6th order Compact Scheme' case default call Print_error_msg ( 'The required numerical scheme is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_initial ( irst ) result ( str ) integer , intent ( in ) :: irst character ( 72 ) :: str select case ( irst ) case ( INIT_RESTART ) str = 'Initialised from restart' case ( INIT_INTERPL ) str = 'Initialised from interpolation of an existing field' case ( INIT_RANDOM ) str = 'Initialised from random numbers' case ( INIT_INLET ) str = 'Initialised from inlet' case ( INIT_GVCONST ) str = 'Initialised from given values' case ( INIT_POISEUILLE ) str = 'Initialised from a poiseuille flow' case ( INIT_FUNCTION ) str = 'Initialised from a given function' case default call Print_error_msg ( 'The required initialisation method is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_fluid ( ifl ) result ( str ) integer , intent ( in ) :: ifl character ( 72 ) :: str select case ( ifl ) case ( ISCP_WATER ) str = 'Supercritical water' case ( ISCP_CO2 ) str = 'Supercritical CO2' case ( ILIQUID_BISMUTH ) str = 'Liquid Bismuth' case ( ILIQUID_LBE ) str = 'Liquid LBE' case ( ILIQUID_LEAD ) str = 'Liquid Lead' case ( ILIQUID_SODIUM ) str = 'Liquid Sodium' case ( ILIQUID_WATER ) str = 'Liquid Water' case default call Print_error_msg ( 'The required flow medium is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== function get_name_drivenforce ( ifl ) result ( str ) integer , intent ( in ) :: ifl character ( 72 ) :: str select case ( ifl ) case ( IDRVF_NO ) str = 'no external driven force' case ( IDRVF_X_MASSFLUX ) str = 'constant mass flux driven in x-direction' case ( IDRVF_X_TAUW ) str = 'constant skin friction driven in x-direction' case ( IDRVF_X_DPDX ) str = 'pressure gradient driven in x-direction' case ( IDRVF_Z_MASSFLUX ) str = 'constant mass flux driven in z-direction' case ( IDRVF_Z_TAUW ) str = 'constant skin friction driven in z-direction' case ( IDRVF_Z_DPDZ ) str = 'pressure gradient driven in z-direction' case default call Print_error_msg ( 'The required flow-driven method is not supported.' ) end select str = ' ' // trim ( adjustl ( str )) return end function !========================================================================================================== !> \\brief Reading the input parameters from the given file. !! Scope:  mpi    called-freq    xdomain !!         all    once           all !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     none          NA !> \\param[out]    none          NA !========================================================================================================== subroutine Read_input_parameters use wtformat_mod use mpi_mod use parameters_constant_mod use vars_df_mod use thermo_info_mod use boundary_conditions_mod use code_performance_mod use EvenOdd_mod implicit none character ( len = 18 ) :: flinput = 'input_chapsim.ini' integer , parameter :: IOMSG_LEN = 200 character ( len = IOMSG_LEN ) :: iotxt integer :: ioerr , inputUnit integer :: slen character ( len = 80 ) :: secname character ( len = 80 ) :: varname integer :: itmp real ( WP ) :: rtmp real ( WP ), allocatable :: rtmpx (:) integer , allocatable :: itmpx (:) integer :: i , j , m , n logical :: is_tmp logical :: is_any_energyeq if ( nrank == 0 ) then call Print_debug_start_msg ( \"CHAPSim2.0 Starts ...\" ) write ( * , wrtfmt1i ) 'The precision is REAL * ' , WP end if is_any_energyeq = . false . !---------------------------------------------------------------------------------------------------------- ! open file !---------------------------------------------------------------------------------------------------------- open ( newunit = inputUnit , & file = flinput , & status = 'old' , & action = 'read' , & iostat = ioerr , & iomsg = iotxt ) if ( ioerr /= 0 ) then ! write (*, *) 'Problem openning : ', flinput, ' for reading.' ! write (*, *) 'Message: ', trim (iotxt) call Print_error_msg ( 'Error in opening the input file: input_chapsim.ini' ) end if if ( nrank == 0 ) & call Print_debug_start_msg ( \"Reading General Parameters from \" // flinput // \" ...\" ) !---------------------------------------------------------------------------------------------------------- ! reading input !---------------------------------------------------------------------------------------------------------- do !---------------------------------------------------------------------------------------------------------- ! reading headings/comments !---------------------------------------------------------------------------------------------------------- read ( inputUnit , '(a)' , iostat = ioerr ) secname slen = len_trim ( secname ) if ( ioerr /= 0 ) exit if ( ( secname ( 1 : 1 ) == ';' ) . or . & ( secname ( 1 : 1 ) == '#' ) . or . & ( secname ( 1 : 1 ) == ' ' ) . or . & ( slen == 0 ) ) then cycle end if if ( nrank == 0 ) call Print_debug_mid_msg ( \"Reading \" // secname ( 1 : slen )) !---------------------------------------------------------------------------------------------------------- ! [ioparams] !---------------------------------------------------------------------------------------------------------- if ( secname ( 1 : slen ) == '[process]' ) then read ( inputUnit , * , iostat = ioerr ) varname , is_prerun read ( inputUnit , * , iostat = ioerr ) varname , is_postprocess if ( nrank == 0 ) then write ( * , wrtfmt1l ) 'is_prerun :' , is_prerun write ( * , wrtfmt1l ) 'is_postprocess :' , is_postprocess end if !---------------------------------------------------------------------------------------------------------- ! [decomposition] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[decomposition]' ) then read ( inputUnit , * , iostat = ioerr ) varname , nxdomain read ( inputUnit , * , iostat = ioerr ) varname , p_row read ( inputUnit , * , iostat = ioerr ) varname , p_col if ( nxdomain /= 1 . and . nrank == 0 ) call Print_error_msg ( \"Set up nxdomain = 1.\" ) allocate ( domain ( nxdomain ) ) allocate ( flow ( nxdomain ) ) allocate ( itmpx ( nxdomain ) ); itmpx = 0 allocate ( rtmpx ( nxdomain ) ); rtmpx = ZERO domain (:)% is_thermo = . false . domain (:)% icht = 0 domain (:)% is_mhd = . false . do i = 1 , nxdomain domain ( i )% idom = i end do if ( nrank == 0 ) then call Print_note_msg ( 'if p_row = p_col = 0, the system will employ a default, automatic domain decomposition strategy.' ) write ( * , wrtfmt1i ) 'x-dir domain number             :' , nxdomain write ( * , wrtfmt1i ) 'y-dir domain number (mpi Row)   :' , p_row write ( * , wrtfmt1i ) 'z-dir domain number (mpi Column):' , p_col end if !---------------------------------------------------------------------------------------------------------- ! [domain] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[domain]' ) then read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% icase domain (:)% icase = domain ( 1 )% icase read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% lxx read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% lyt domain (:)% lyt = domain ( 1 )% lyt read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% lyb domain (:)% lyb = domain ( 1 )% lyb read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% lzz domain (:)% lzz = domain ( 1 )% lzz !---------------------------------------------------------------------------------------------------------- !     restore domain size to default if not set properly !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain if ( domain ( i )% icase == ICASE_CHANNEL ) then domain ( i )% lyb = - ONE domain ( i )% lyt = ONE else if ( domain ( i )% icase == ICASE_PIPE ) then domain ( i )% lyb = ZERO domain ( i )% lyt = ONE domain ( i )% lzz = TWOPI else if ( domain ( i )% icase == ICASE_ANNULAR ) then domain ( i )% lyt = ONE domain ( i )% lzz = TWOPI else if ( domain ( i )% icase == ICASE_TGV2D . or . domain ( i )% icase == ICASE_TGV3D ) then domain ( i )% lxx = TWOPI domain ( i )% lzz = TWOPI domain ( i )% lyt = PI domain ( i )% lyb = - PI else if ( domain ( i )% icase == ICASE_BURGERS ) then domain ( i )% lxx = TWO domain ( i )% lzz = TWO domain ( i )% lyt = TWO domain ( i )% lyb = ZERO else if ( domain ( i )% icase == ICASE_ALGTEST ) then domain ( i )% lxx = TWOPI domain ( i )% lzz = TWOPI domain ( i )% lyt = TWOPI domain ( i )% lyb = ZERO else ! do nothing... end if !---------------------------------------------------------------------------------------------------------- ! coordinates type !---------------------------------------------------------------------------------------------------------- if ( domain ( i )% icase == ICASE_PIPE ) then domain ( i )% icoordinate = ICYLINDRICAL else if ( domain ( i )% icase == ICASE_ANNULAR ) then domain ( i )% icoordinate = ICYLINDRICAL else domain ( i )% icoordinate = ICARTESIAN end if end do if ( nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt2s ) 'current icase id :' , get_name_case ( domain ( i )% icase ) write ( * , wrtfmt2s ) 'current coordinates system :' , get_name_cs ( domain ( i )% icoordinate ) write ( * , wrtfmt1r ) 'scaled length in x-direction :' , domain ( i )% lxx write ( * , wrtfmt1r ) 'scaled length in y-direction :' , domain ( i )% lyt - domain ( i )% lyb if (( domain ( i )% lyt - domain ( i )% lyb ) < ZERO ) call Print_error_msg ( \"Y length is smaller than zero.\" ) write ( * , wrtfmt1r ) 'scaled length in z-direction :' , domain ( i )% lzz end do end if !---------------------------------------------------------------------------------------------------------- ! [boundary] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[bc]' ) then do i = 1 , nxdomain read ( inputUnit , * , iostat = ioerr ) varname , domain ( i )% ibcx_nominal ( 1 : 2 , 1 ), domain ( i )% fbcx_const ( 1 : 2 , 1 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( i )% ibcx_nominal ( 1 : 2 , 2 ), domain ( i )% fbcx_const ( 1 : 2 , 2 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( i )% ibcx_nominal ( 1 : 2 , 3 ), domain ( i )% fbcx_const ( 1 : 2 , 3 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( i )% ibcx_nominal ( 1 : 2 , 4 ), domain ( i )% fbcx_const ( 1 : 2 , 4 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( i )% ibcx_nominal ( 1 : 2 , 5 ), domain ( i )% fbcx_const ( 1 : 2 , 5 ) ! dimensional end do read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcy_nominal ( 1 : 2 , 1 ), domain ( 1 )% fbcy_const ( 1 : 2 , 1 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcy_nominal ( 1 : 2 , 2 ), domain ( 1 )% fbcy_const ( 1 : 2 , 2 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcy_nominal ( 1 : 2 , 3 ), domain ( 1 )% fbcy_const ( 1 : 2 , 3 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcy_nominal ( 1 : 2 , 4 ), domain ( 1 )% fbcy_const ( 1 : 2 , 4 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcy_nominal ( 1 : 2 , 5 ), domain ( 1 )% fbcy_const ( 1 : 2 , 5 ) ! dimensional read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcz_nominal ( 1 : 2 , 1 ), domain ( 1 )% fbcz_const ( 1 : 2 , 1 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcz_nominal ( 1 : 2 , 2 ), domain ( 1 )% fbcz_const ( 1 : 2 , 2 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcz_nominal ( 1 : 2 , 3 ), domain ( 1 )% fbcz_const ( 1 : 2 , 3 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcz_nominal ( 1 : 2 , 4 ), domain ( 1 )% fbcz_const ( 1 : 2 , 4 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ibcz_nominal ( 1 : 2 , 5 ), domain ( 1 )% fbcz_const ( 1 : 2 , 5 ) ! dimensional read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% idriven read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% drvfc do i = 2 , nxdomain domain ( i )% ibcy_nominal (:, :) = domain ( 1 )% ibcy_nominal (:, :) domain ( i )% ibcz_nominal (:, :) = domain ( 1 )% ibcz_nominal (:, :) domain ( i )% fbcy_const (:, :) = domain ( 1 )% fbcy_const (:, :) domain ( i )% fbcz_const (:, :) = domain ( 1 )% fbcz_const (:, :) end do do i = 1 , nxdomain domain ( i )% is_periodic (:) = . false . do m = 1 , 3 if ( domain ( i )% ibcx_nominal ( 1 , m ) == IBC_PERIODIC . or . & domain ( i )% ibcx_nominal ( 2 , m ) == IBC_PERIODIC ) then domain ( i )% ibcx_nominal ( 1 : 2 , m ) = IBC_PERIODIC domain ( i )% is_periodic ( 1 ) = . true . end if if ( domain ( i )% ibcy_nominal ( 1 , m ) == IBC_PERIODIC . or . & domain ( i )% ibcy_nominal ( 2 , m ) == IBC_PERIODIC ) then domain ( i )% ibcy_nominal ( 1 : 2 , m ) = IBC_PERIODIC domain ( i )% is_periodic ( 2 ) = . true . end if if ( domain ( i )% ibcz_nominal ( 1 , m ) == IBC_PERIODIC . or . & domain ( i )% ibcz_nominal ( 2 , m ) == IBC_PERIODIC ) then domain ( i )% ibcz_nominal ( 1 : 2 , m ) = IBC_PERIODIC domain ( i )% is_periodic ( 3 ) = . true . end if end do if ( domain ( i )% icase == ICASE_PIPE ) then domain ( i )% ibcy_nominal ( 1 , :) = IBC_INTERIOR domain ( i )% ibcy_nominal ( 1 , 2 ) = IBC_INTERIOR !IBC_DIRICHLET domain ( i )% fbcx_const ( 1 , 2 ) = ZERO domain ( i )% is_periodic ( 2 ) = . false . end if if ( domain ( i )% ibcx_nominal ( 1 , 1 ) == IBC_DATABASE ) then domain ( i )% ibcx_nominal ( 1 , 2 : 3 ) = IBC_DATABASE domain ( i )% ibcx_nominal ( 1 , 4 : 5 ) = IBC_NEUMANN end if if ( domain ( i )% ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) then domain ( i )% ibcx_nominal ( 2 , 2 : 3 ) = IBC_CONVECTIVE domain ( i )% ibcx_nominal ( 2 , 4 : 5 ) = IBC_NEUMANN end if !---------------------------------------------------------------------------------------------------------- ! to exclude non-resonable input !---------------------------------------------------------------------------------------------------------- domain ( i )% is_conv_outlet = . false . do m = 1 , NBC if ( domain ( i )% ibcx_nominal ( 2 , m ) == IBC_PROFILE1D ) call Print_error_msg ( \" This BC IBC_PROFILE1D is not supported.\" ) do n = 1 , 2 if ( domain ( i )% ibcx_nominal ( n , m ) > IBC_OTHERS ) call Print_error_msg ( \" This xBC is not suported.\" ) if ( domain ( i )% ibcy_nominal ( n , m ) > IBC_OTHERS ) call Print_error_msg ( \" This yBC is not suported.\" ) if ( domain ( i )% ibcz_nominal ( n , m ) > IBC_OTHERS ) call Print_error_msg ( \" This zBC is not suported.\" ) if ( domain ( i )% ibcy_nominal ( n , m ) == IBC_PROFILE1D ) call Print_error_msg ( \" This yBC IBC_PROFILE1D is not supported.\" ) if ( domain ( i )% ibcz_nominal ( n , m ) == IBC_PROFILE1D ) call Print_error_msg ( \" This zBC IBC_PROFILE1D is not supported.\" ) end do if ( domain ( i )% ibcx_nominal ( 2 , m ) == IBC_CONVECTIVE ) domain ( i )% is_conv_outlet = . true . end do end do do i = 1 , nxdomain if ( domain ( i )% icase /= ICASE_CHANNEL . and . & domain ( i )% icase /= ICASE_ANNULAR . and . & domain ( i )% icase /= ICASE_PIPE ) then flow ( i )% idriven = IDRVF_NO end if if ( domain ( i )% ibcx_nominal ( 1 , 1 ) /= IBC_PERIODIC . or . & domain ( i )% ibcx_nominal ( 2 , 1 ) /= IBC_PERIODIC ) then flow ( i )% idriven = IDRVF_NO end if end do if ( nrank == 0 ) then do i = 1 , nxdomain write ( * , wrtfmt2s ) 'flow driven force type :' , get_name_drivenforce ( flow ( i )% idriven ) if ( flow ( i )% idriven /= IDRVF_NO . and . & flow ( i )% idriven /= IDRVF_X_MASSFLUX . and . & flow ( i )% idriven /= IDRVF_Z_MASSFLUX ) then write ( * , wrtfmt1r ) 'flow driven force(cf):' , flow ( i )% drvfc end if end do end if !---------------------------------------------------------------------------------------------------------- ! [mesh] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[mesh]' ) then read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% nc ( 1 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% nc ( 2 ) domain (:)% nc ( 2 ) = domain ( 1 )% nc ( 2 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% nc ( 3 ) domain (:)% nc ( 3 ) = domain ( 1 )% nc ( 3 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% istret domain (:)% istret = domain ( 1 )% istret read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% mstret , domain ( 1 )% rstret domain (:)% rstret = domain ( 1 )% rstret domain (:)% mstret = domain ( 1 )% mstret read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ifft_lib domain (:)% ifft_lib = domain ( 1 )% ifft_lib do i = 1 , nxdomain if ( domain ( i )% icoordinate == ICYLINDRICAL ) then if (. not . is_even ( domain ( i )% nc ( 3 ))) domain ( i )% nc ( 3 ) = domain ( i )% nc ( 3 ) + 1 end if !---------------------------------------------------------------------------------------------------------- !     stretching !---------------------------------------------------------------------------------------------------------- domain ( i )% is_stretching (:) = . false . if ( domain ( i )% istret /= ISTRET_NO ) domain ( i )% is_stretching ( 2 ) = . true . if ( domain ( i )% icase == ICASE_CHANNEL . and . & domain ( i )% istret /= ISTRET_2SIDES . and . & domain ( i )% istret /= ISTRET_NO ) then if ( nrank == 0 ) call Print_warning_msg ( \"Grids are neither uniform nor two-side clustered.\" ) else if ( domain ( i )% icase == ICASE_PIPE . and . & domain ( i )% istret /= ISTRET_TOP ) then if ( nrank == 0 ) call Print_warning_msg ( \"Grids are not near-wall clustered.\" ) else if ( domain ( i )% icase == ICASE_ANNULAR . and . & domain ( i )% istret /= ISTRET_2SIDES . and . & domain ( i )% istret /= ISTRET_NO ) then if ( nrank == 0 ) call Print_warning_msg ( \"Grids are neither uniform nor two-side clustered.\" ) else if ( domain ( i )% icase == ICASE_TGV2D . or . & domain ( i )% icase == ICASE_TGV3D . or . & domain ( i )% icase == ICASE_ALGTEST ) then if ( domain ( i )% istret /= ISTRET_NO . and . nrank == 0 ) & call Print_warning_msg ( \"Grids are clustered.\" ) else ! do nothing... end if ! if ( domain ( i )% mstret == MSTRET_TANH ) domain ( i )% ifft_lib = FFT_FISHPACK_2DFFT if ( domain ( i )% ifft_lib == FFT_2DECOMP_3DFFT ) domain ( i )% mstret = MSTRET_3FMD end do if ( nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt1i ) 'mesh cell number - x :' , domain ( i )% nc ( 1 ) write ( * , wrtfmt1i ) 'mesh cell number - y :' , domain ( i )% nc ( 2 ) write ( * , wrtfmt1i ) 'mesh cell number - z :' , domain ( i )% nc ( 3 ) write ( * , wrtfmt2s ) 'FFT lib :' , get_name_fft ( domain ( i )% ifft_lib ) write ( * , wrtfmt3l ) 'is mesh stretching in xyz :' , domain ( i )% is_stretching ( 1 : 3 ) write ( * , wrtfmt2s ) 'mesh y-stretching type :' , get_name_mesh ( domain ( i )% istret ) if ( domain ( i )% istret /= ISTRET_NO ) then write ( * , wrtfmt1r ) 'mesh y-stretching factor :' , domain ( i )% rstret write ( * , wrtfmt2s ) 'mesh y-stretching method :' , get_name_mstret ( domain ( i )% mstret ) end if end do end if !---------------------------------------------------------------------------------------------------------- ! [timestepping] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[scheme]' ) then read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% dt domain (:)% dt = domain ( 1 )% dt read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% iTimeScheme domain (:)% iTimeScheme = domain ( 1 )% iTimeScheme read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% iAccuracy domain (:)% iAccuracy = domain ( 1 )% iAccuracy read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% iviscous domain (:)% iviscous = domain ( 1 )% iviscous ! some schemes are still testing, check >>> if ( domain ( 1 )% icase == ICASE_PIPE ) then domain ( 1 )% iAccuracy = IACCU_CD2 end if ! if ( domain ( 1 )% icase == ICASE_CHANNEL ) then if ( domain ( 1 )% iAccuracy == IACCU_CP4 . or . & domain ( 1 )% iAccuracy == IACCU_CP6 ) then domain ( 1 )% iAccuracy = IACCU_CD4 end if end if ! some schemes are still testing, check <<< if ( domain ( 1 )% iAccuracy == IACCU_CD2 . or . & domain ( 1 )% iAccuracy == IACCU_CD4 ) then domain (:)% is_compact_scheme = . false . else if ( domain ( 1 )% iAccuracy == IACCU_CP4 . or . & domain ( 1 )% iAccuracy == IACCU_CP6 ) then domain (:)% is_compact_scheme = . true . else call Print_error_msg ( \"Input error for numerical schemes.\" ) end if if ( nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt1e ) 'physical time step(dt, unit = second) :' , domain ( i )% dt write ( * , wrtfmt1i ) 'time marching scheme :' , domain ( i )% iTimeScheme write ( * , wrtfmt2s ) 'current spatial accuracy scheme :' , get_name_iacc ( domain ( i )% iAccuracy ) write ( * , wrtfmt1i ) 'viscous term treatment  :' , domain ( i )% iviscous end do end if !---------------------------------------------------------------------------------------------------------- ! [flow] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[flow]' ) then read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% inittype read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% iterfrom read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 )% init_velo3d ( 1 : 3 ) read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% noiselevel read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% reninit read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% initReTo read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% ren do i = 1 , nxdomain if ( flow ( i )% inittype /= INIT_RESTART ) flow ( i )% iterfrom = 0 flow ( i )% init_velo3d ( 1 : 3 ) = flow ( 1 )% init_velo3d ( 1 : 3 ) end do if ( nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i call print_note_msg ( \"The Reynolds number is based on half channel hight or radius of a pipe.\" ) write ( * , wrtfmt2s ) 'flow initial type :' , get_name_initial ( flow ( i )% inittype ) write ( * , wrtfmt1i ) 'iteration starting from :' , flow ( i )% iterfrom if ( flow ( i )% inittype == INIT_GVCONST ) then write ( * , wrtfmt3r ) 'initial velocity u, v, w :' , flow ( i )% init_velo3d ( 1 : 3 ) end if write ( * , wrtfmt1r ) 'Initial velocity influction level :' , flow ( i )% noiselevel write ( * , wrtfmt1r ) 'Initial Reynolds No. :' , flow ( i )% reninit write ( * , wrtfmt1i ) 'Iteration for initial Reynolds No.:' , flow ( i )% initReTo write ( * , wrtfmt1r ) 'flow Reynolds number :' , flow ( i )% ren end do end if !---------------------------------------------------------------------------------------------------------- ! [thermo] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[thermo]' ) then read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% is_thermo read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% icht read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% igravity if ( ANY ( domain (:)% is_thermo )) is_any_energyeq = . true . if ( is_any_energyeq ) allocate ( thermo ( nxdomain ) ) read ( inputUnit , * , iostat = ioerr ) varname , itmp if ( is_any_energyeq ) thermo ( 1 : nxdomain )% ifluid = itmp read ( inputUnit , * , iostat = ioerr ) varname , rtmp if ( is_any_energyeq ) thermo ( 1 : nxdomain )% ref_l0 = rtmp read ( inputUnit , * , iostat = ioerr ) varname , rtmp if ( is_any_energyeq ) thermo ( 1 : nxdomain )% ref_T0 = rtmp read ( inputUnit , * , iostat = ioerr ) varname , itmp if ( is_any_energyeq ) thermo ( 1 : nxdomain )% inittype = itmp read ( inputUnit , * , iostat = ioerr ) varname , itmp if ( is_any_energyeq ) thermo ( 1 : nxdomain )% iterfrom = itmp read ( inputUnit , * , iostat = ioerr ) varname , rtmpx ( 1 : nxdomain ) if ( is_any_energyeq ) thermo ( 1 : nxdomain )% init_T0 = rtmpx ( 1 : nxdomain ) if ( is_any_energyeq . and . nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt1l ) 'is thermal field solved ?' , domain ( i )% is_thermo write ( * , wrtfmt1l ) 'is CHT solved ?' , domain ( i )% icht write ( * , wrtfmt1i ) 'gravity direction ' , flow ( i )% igravity write ( * , wrtfmt2s ) 'fluid medium :' , get_name_fluid ( thermo ( i )% ifluid ) write ( * , wrtfmt1r ) 'reference length (m) :' , thermo ( i )% ref_l0 write ( * , wrtfmt1r ) 'reference temperature (K) :' , thermo ( i )% ref_T0 write ( * , wrtfmt1i ) 'thermo field initial type :' , thermo ( i )% inittype write ( * , wrtfmt1i ) 'iteration starting from :' , thermo ( i )% iterfrom write ( * , wrtfmt1r ) 'initial temperature (K) :' , thermo ( i )% init_T0 end do else if ( nrank == 0 ) then call Print_note_msg ( 'Thermal field is not considered. ' ) end if !---------------------------------------------------------------------------------------------------------- ! [mhd] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[mhd]' ) then read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% is_mhd if ( domain ( 1 )% is_mhd ) then allocate ( mhd ( nxdomain )) read ( inputUnit , * , iostat = ioerr ) varname , mhd ( 1 )% is_NStuart , mhd ( 1 )% NStuart read ( inputUnit , * , iostat = ioerr ) varname , mhd ( 1 )% is_NHartmn , mhd ( 1 )% NHartmn read ( inputUnit , * , iostat = ioerr ) varname , mhd ( 1 )% B_static ( 1 : 3 ) if ( ( mhd ( 1 )% is_NStuart . and . mhd ( 1 )% is_NHartmn ) . or . & ( (. not . mhd ( 1 )% is_NStuart ) . and . (. not . mhd ( 1 )% is_NHartmn )) ) & call Print_error_msg ( 'Please provide either Stuart Number or Hartmann Number' ) else read ( inputUnit , * , iostat = ioerr ) varname , is_tmp , rtmp read ( inputUnit , * , iostat = ioerr ) varname , is_tmp , rtmp read ( inputUnit , * , iostat = ioerr ) varname , rtmp , rtmp , rtmp end if if ( domain ( 1 )% is_mhd . and . nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt1l ) 'is thermal field solved?' , domain ( i )% is_mhd if ( mhd ( 1 )% is_NStuart ) & write ( * , wrtfmt1r ) 'given Stuart Number :' , mhd ( 1 )% NStuart if ( mhd ( 1 )% is_NHartmn ) & write ( * , wrtfmt1r ) 'given Hartmann Number :' , mhd ( 1 )% NHartmn write ( * , wrtfmt3r ) 'Static Magnetic field :' , mhd ( 1 )% B_static ( 1 : 3 ) end do else if ( nrank == 0 ) then call Print_note_msg ( ' MHD is not considered. ' ) end if !---------------------------------------------------------------------------------------------------------- ! [simcontrol] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[simcontrol]' ) then read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% nIterFlowStart read ( inputUnit , * , iostat = ioerr ) varname , flow ( 1 : nxdomain )% nIterFlowEnd read ( inputUnit , * , iostat = ioerr ) varname , itmpx ( 1 : nxdomain ) if ( is_any_energyeq ) thermo ( 1 : nxdomain )% nIterThermoStart = itmpx ( 1 : nxdomain ) read ( inputUnit , * , iostat = ioerr ) varname , itmpx ( 1 : nxdomain ) if ( is_any_energyeq ) thermo ( 1 : nxdomain )% nIterThermoEnd = itmpx ( 1 : nxdomain ) if ( nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt1i ) 'flow simulation starting from :' , flow ( i )% nIterFlowStart write ( * , wrtfmt1i ) 'flow simulation ending   at   :' , flow ( i )% nIterFlowEnd if ( is_any_energyeq ) then write ( * , wrtfmt1i ) 'thermal simulation starting from :' , thermo ( i )% nIterThermoStart write ( * , wrtfmt1i ) 'thermal simulation ending   at   :' , thermo ( i )% nIterThermoEnd end if end do end if !---------------------------------------------------------------------------------------------------------- ! [ioparams] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[io]' ) then read ( inputUnit , * , iostat = ioerr ) varname , cpu_nfre read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% ckpt_nfre read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% visu_idim read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% visu_nfre read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% visu_nskip ( 1 : 3 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 : nxdomain )% stat_istart read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% stat_nskip ( 1 : 3 ) read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% is_record_xoutlet , domain ( 1 )% is_read_xinlet read ( inputUnit , * , iostat = ioerr ) varname , domain ( 1 )% ndbfre , domain ( 1 )% ndbend do i = 1 , nxdomain domain ( i )% visu_nskip ( 1 : 3 ) = domain ( 1 )% visu_nskip ( 1 : 3 ) domain ( i )% stat_nskip ( 1 : 3 ) = domain ( 1 )% stat_nskip ( 1 : 3 ) if ( domain ( i )% is_stretching ( 2 )) domain ( i )% visu_nskip ( 2 ) = 1 if ( domain ( i )% is_stretching ( 2 )) domain ( i )% stat_nskip ( 2 ) = 1 end do if ( nrank == 0 ) then do i = 1 , nxdomain !write (*, wrtfmt1i) '------For the domain-x------ ', i write ( * , wrtfmt1i ) 'data check freqency :' , domain ( i )% ckpt_nfre write ( * , wrtfmt1i ) 'visu data dimensions :' , domain ( i )% visu_idim write ( * , wrtfmt1i ) 'visu data written freqency :' , domain ( i )% visu_nfre write ( * , wrtfmt3i ) 'visu data skips in xyz :' , domain ( i )% visu_nskip ( 1 : 3 ) write ( * , wrtfmt1i ) 'statistics written from :' , domain ( i )% stat_istart write ( * , wrtfmt3i ) 'statistics skips in xyz :' , domain ( i )% stat_nskip ( 1 : 3 ) write ( * , wrtfmt1l ) 'recording outlet plane? :' , domain ( 1 )% is_record_xoutlet write ( * , wrtfmt1l ) 'reading inlet plane? :' , domain ( 1 )% is_read_xinlet write ( * , wrtfmt1i ) 'reading/recording plane freqency :' , domain ( 1 )% ndbfre write ( * , wrtfmt1i ) 'reading/recording plane period :' , domain ( 1 )% ndbend end do end if !---------------------------------------------------------------------------------------------------------- ! [probe] !---------------------------------------------------------------------------------------------------------- else if ( secname ( 1 : slen ) == '[probe]' ) then do i = 1 , nxdomain read ( inputUnit , * , iostat = ioerr ) varname , itmp domain ( i )% proben = itmp if ( domain ( i )% proben > 0 ) then allocate ( domain ( i )% probexyz ( 3 , itmp )) !if( nrank == 0) !write (*, wrtfmt1i) '------For the domain-x------ ', i do j = 1 , domain ( i )% proben read ( inputUnit , * , iostat = ioerr ) varname , domain ( i )% probexyz ( 1 : 3 , j ) if ( domain ( i )% probexyz ( 1 , j ) > domain ( i )% lxx ) then call Print_warning_msg ( 'probed points x > lx_max, adjusted.' ) domain ( i )% probexyz ( 1 , j ) = domain ( i )% lxx / real ( domain ( i )% proben + 1 , WP ) * real ( j , WP ) end if if ( domain ( i )% probexyz ( 2 , j ) > domain ( i )% lyt . or . domain ( i )% probexyz ( 2 , j ) < domain ( i )% lyb ) then call Print_warning_msg ( 'probed points y not in (lyb, lyt), adjusted.' ) domain ( i )% probexyz ( 2 , j ) = ( domain ( i )% lyt - domain ( i )% lyb ) / real ( domain ( i )% proben + 1 , WP ) * real ( j , WP ) end if if ( domain ( i )% probexyz ( 3 , j ) > domain ( i )% lzz ) then call Print_warning_msg ( 'probed points z > lz_max, adjusted.' ) domain ( i )% probexyz ( 3 , j ) = domain ( i )% lzz / real ( domain ( i )% proben + 1 , WP ) * real ( j , WP ) end if if ( nrank == 0 ) write ( * , wrtfmt3r ) 'probed points x, y, z :' , domain ( i )% probexyz ( 1 : 3 , j ) end do end if end do else exit end if end do !---------------------------------------------------------------------------------------------------------- ! end of reading, clearing dummies !---------------------------------------------------------------------------------------------------------- if (. not . IS_IOSTAT_END ( ioerr )) & call Print_error_msg ( 'Problem reading ' // flinput // & 'in Subroutine: ' // \"Read_general_input\" ) close ( inputUnit ) if ( allocated ( itmpx )) deallocate ( itmpx ) if ( allocated ( rtmpx )) deallocate ( rtmpx ) !---------------------------------------------------------------------------------------------------------- ! convert the input dimensional temperature/heat flux into undimensional !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain if (. not . is_any_energyeq ) then domain ( i )% ibcx_nominal ( 1 : 2 , 5 ) = domain ( i )% ibcx_nominal ( 1 : 2 , 1 ) domain ( i )% ibcy_nominal ( 1 : 2 , 5 ) = domain ( i )% ibcy_nominal ( 1 : 2 , 2 ) domain ( i )% ibcz_nominal ( 1 : 2 , 5 ) = domain ( i )% ibcz_nominal ( 1 : 2 , 3 ) end if call config_calc_basic_ibc ( domain ( i )) call config_calc_eqs_ibc ( domain ( i )) end do !---------------------------------------------------------------------------------------------------------- ! set up constant for time step marching !---------------------------------------------------------------------------------------------------------- do i = 1 , nxdomain !option 1: to set up pressure treatment, for O(dt&#94;2) !domain(i)%sigma1p = ONE !domain(i)%sigma2p = HALF !option 2: to set up pressure treatment, for O(dt) domain ( i )% sigma1p = ONE domain ( i )% sigma2p = ONE if ( domain ( i )% iTimeScheme == ITIME_RK3 . or . & domain ( i )% iTimeScheme == ITIME_RK3_CN ) then domain ( i )% nsubitr = 3 domain ( i )% tGamma ( 0 ) = ONE domain ( i )% tGamma ( 1 ) = EIGHT / FIFTEEN domain ( i )% tGamma ( 2 ) = FIVE / TWELVE domain ( i )% tGamma ( 3 ) = THREE * QUARTER domain ( i )% tZeta ( 0 ) = ZERO domain ( i )% tZeta ( 1 ) = ZERO domain ( i )% tZeta ( 2 ) = - SEVENTEEN / SIXTY domain ( i )% tZeta ( 3 ) = - FIVE / TWELVE else if ( domain ( i )% iTimeScheme == ITIME_AB2 ) then !Adams-Bashforth domain ( i )% nsubitr = 1 domain ( i )% tGamma ( 0 ) = ONE domain ( i )% tGamma ( 1 ) = ONEPFIVE domain ( i )% tGamma ( 2 ) = ZERO domain ( i )% tGamma ( 3 ) = ZERO domain ( i )% tZeta ( 0 ) = ZERO domain ( i )% tZeta ( 1 ) = - HALF domain ( i )% tZeta ( 2 ) = ZERO domain ( i )% tZeta ( 3 ) = ZERO else domain ( i )% nsubitr = 0 domain ( i )% tGamma (:) = ZERO domain ( i )% tZeta (:) = ZERO end if domain ( i )% tAlpha ( 0 : 3 ) = domain ( i )% tGamma ( 0 : 3 ) + domain ( i )% tZeta ( 0 : 3 ) end do if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine end module !========================================================================================================== !========================================================================================================== module apx_prerun_mod use parameters_constant_mod use math_mod use input_general_mod use wtformat_mod use mpi_mod implicit none real ( WP ), parameter :: dxplus_max = 1 0.0_WP real ( WP ), parameter :: dzplus_max = 5.0_WP real ( WP ), parameter :: dyplus_max = 1.0_WP real ( WP ), parameter :: Cflmax = 0.714_WP real ( WP ), parameter :: Ctmmax = 0.1_WP real ( WP ), save :: dymax , dymin , rmin , rmax , Re_tau , u_tau private :: solve_Prandtl_vonKarman_eq_for_cf private :: estimate_skin_friction_factor public :: estimate_temporal_resolution public :: estimate_spacial_resolution contains !========================================================================================================== subroutine solve_Prandtl_vonKarman_eq_for_cf ( cf , Re , icase ) implicit none real ( WP ), intent ( in ) :: Re integer , intent ( in ) :: icase real ( WP ), intent ( out ) :: cf real ( 8 ) :: Cf_new , f , df , tol , a , b integer :: i , max_iter if ( icase == ICASE_ANNULAR . or . icase == ICASE_PIPE ) then a = 2.0_WP b = - 0.8_WP else if ( icase == ICASE_CHANNEL ) then a = 2.12_WP b = - 0.65_WP else a = 2.12_WP b = - 0.65_WP end if ! Initial guess for Cf Cf = 0.005d0 ! Convergence criteria tol = 1.0d-6 max_iter = 50 ! Iterative Newton-Raphson method do i = 1 , max_iter f = 1.0d0 / sqrt ( Cf ) - a * log10 ( Re * sqrt ( Cf )) + b df = - 0.5d0 / ( Cf ** 1.5d0 ) - ( a / ( log ( 1 0.0d0 ) * ( Re * sqrt ( Cf )) * 2.0d0 * sqrt ( Cf ))) ! Update Cf Cf_new = Cf - f / df ! Check for convergence if ( abs ( Cf_new - Cf ) < tol ) then exit end if Cf = Cf_new end do return end subroutine !========================================================================================================== subroutine estimate_skin_friction_factor ( cf , Re , icase ) implicit none real ( WP ), intent ( in ) :: Re integer , intent ( in ) :: icase real ( WP ), intent ( out ) :: cf if ( icase == ICASE_PIPE . or . & icase == ICASE_ANNULAR ) then if ( Re < 230 0.0_WP ) then ! laminar cf = 6 4.0_WP / Re else if ( Re < 3.0e4_WP ) then ! the Blasius relation cf = 0.316_WP * Re ** ( - 0.25_WP ) else if ( Re < 1.0e6_WP ) then ! the McAdmas relation cf = 0.814_WP * Re ** ( - 0.2_WP ) else !  the Prandtl–von Kármán equation call solve_Prandtl_vonKarman_eq_for_cf ( cf , Re , icase ) end if else if ( icase == ICASE_CHANNEL ) then if ( Re < 1.0e4_WP ) then ! laminar cf = 0.079_WP * Re ** ( - 0.25_WP ) else !  the Prandtl–von Kármán equation call solve_Prandtl_vonKarman_eq_for_cf ( cf , Re , icase ) end if else cf = MAXP end if return end subroutine !========================================================================================================== subroutine estimate_spacial_resolution ( fl , dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl real ( WP ) :: dx_max , dy_max , dz_max real ( WP ) :: cf , dy1 , dy2 , dy3 , dy32 , dy33 real ( WP ) :: yplus1 , yplus2 , yplus3 , dxplus , dzplus , dzplus2 integer :: nx_min , ny_min , nz_min if ( nrank /= 0 ) return if ( dm % icase /= ICASE_PIPE . and . & dm % icase /= ICASE_ANNULAR . and . & dm % icase /= ICASE_CHANNEL ) return ! estimate yplus etc rmax = ONE rmin = ONE if ( dm % icoordinate == ICYLINDRICAL ) then rmin = dm % yc ( 1 ) rmax = dm % yp ( dm % np ( 2 )) end if call estimate_skin_friction_factor ( cf , fl % ren , dm % icase ) Re_tau = fl % ren * sqrt_wp ( cf / TWO ) if ( dm % icase == ICASE_PIPE ) Re_tau = Re_tau / TWO u_tau = Re_tau / fl % ren dy1 = dm % yp ( 2 ) - dm % yp ( 1 ) dy2 = dm % yp ( dm % np ( 2 ) / 2 ) - dm % yp ( dm % np ( 2 ) / 2 - 1 ) dy3 = dm % yp ( dm % np ( 2 )) - dm % yp ( dm % np ( 2 ) - 1 ) dy32 = dm % yp ( dm % np ( 2 ) - 1 ) - dm % yp ( dm % np ( 2 ) - 2 ) dy33 = dm % yp ( dm % np ( 2 ) - 2 ) - dm % yp ( dm % np ( 2 ) - 3 ) yplus1 = Re_tau * dy1 yplus2 = Re_tau * dy2 yplus3 = Re_tau * dy3 dxplus = Re_tau * ( dm % h ( 1 ) ) dzplus = Re_tau * ( dm % h ( 3 ) ) * rmax if ( dm % icoordinate == ICYLINDRICAL ) then dzplus2 = Re_tau * ( dm % h ( 3 ) ) * rmin end if dymax = MAX ( dy1 , dy2 , dy3 ) dymin = MIN ( dy1 , dy2 , dy3 ) ! estimate mesh size dx_max = dxplus_max / Re_tau dz_max = dzplus_max / Re_tau / rmax dy_max = dyplus_max / Re_tau nx_min = ceiling ( dm % lxx / dx_max ) nz_min = ceiling ( dm % lzz / dz_max ) ny_min = ceiling ( dm % nc ( 2 ) * dymin / dy_max ) ! write out call print_note_msg ( \"The recom. values are based on empirical functions listed in [apx_prerun_mod]\" ) call Print_debug_mid_msg ( \"Checking domain length\" ) write ( * , wrtfmt2r ) 'current => rec. min. domain length in x :' , dm % lxx , TWOPI if ( dm % icoordinate == ICARTESIAN ) & write ( * , wrtfmt2r ) 'current => rec. min. domain length in z :' , dm % lzz , PI write ( * , wrtfmt2r ) 'current dy growth rate at 2 layers :' , abs_wp ( dy33 - dy32 ) / MIN ( dy33 , dy32 ), abs_wp ( dy32 - dy3 ) / MIN ( dy32 , dy3 ) if ( dy33 / dy32 > 1.3_WP . or . dy32 / dy3 > 1.3_WP ) & call Print_warning_msg ( \"Grid spacing growth rate is too big for DNS. Consider to reduce the stretching factor.\" ) call Print_debug_mid_msg ( \"Estimating more flow information based on Re.\" ) write ( * , wrtfmt1r ) 'Re_tau :' , Re_tau write ( * , wrtfmt1r ) ' u_tau :' , u_tau ! write out call Print_debug_mid_msg ( \"Estimating the current mesh resolution (based on isothermal flow)\" ) write ( * , wrtfmt1r ) 'dy_plus_1    :' , yplus1 write ( * , wrtfmt1r ) 'dy_plus_np   :' , yplus3 write ( * , wrtfmt1r ) 'dy_plus_np/2 :' , yplus2 write ( * , wrtfmt1r ) 'dx_plus      :' , dxplus write ( * , wrtfmt1r ) 'dz_plus      :' , dzplus if ( dm % icoordinate == ICYLINDRICAL ) then write ( * , wrtfmt1r ) 'dz_plus_min  :' , dzplus2 end if if ( yplus3 > ONE ) write ( * , * ) 'Warning: Adjust Ny and stretching factor to keep yplus at wall < 1' write ( * , wrtfmt1il ) 'Current Ncell:' , dm % nc ( 1 ) * dm % nc ( 2 ) * dm % nc ( 2 ) write ( * , wrtfmt3i ) \"rec. min cell numbers in xyz :\" , nx_min , ny_min , nz_min write ( * , wrtfmt1il ) 'rec. Ncell:' , nx_min * ny_min * nz_min !write(*, wrtfmt2il)\"rec. min N(Re9/4) and Ncell  :\", ceiling(fl%ren**(9.0_WP/4.0_WP)), nx_min * ny_min * nz_min return end subroutine !========================================================================================================== subroutine estimate_temporal_resolution ( fl , dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl real ( WP ) :: dt_max_cfl1 , dt_max_cfl2 , dt_max_phy , dxyz_max , dt_min real ( WP ) :: t_flth integer :: nt_cur , nt_est if ( nrank /= 0 ) return if ( dm % icase /= ICASE_PIPE . and . & dm % icase /= ICASE_ANNULAR . and . & dm % icase /= ICASE_CHANNEL ) return ! dt limits dt_max_cfl1 = Cflmax * dm % h ( 1 ) / TWO dxyz_max = ONE / ( dm % h ( 1 ) ** 2 ) + ONE / ( dymin ** 2 ) + ONE / (( rmin * dm % h ( 3 )) ** 2 ) dt_max_cfl2 = fl % ren / TWO / dxyz_max !\\Delta t \\approx 0.1 \\frac{h&#94;2}{\\nu Re_{\\tau}&#94;2} dt_max_phy = Ctmmax * ( fl % ren / Re_tau / Re_tau ) ! * dymin / dymax dt_min = MIN ( dt_max_cfl1 , dt_max_cfl2 , dt_max_phy ) call Print_debug_mid_msg ( \"Estimating the temporal resolution (based on isothermal flow)\" ) write ( * , wrtfmt1e ) 'current dt :' , dm % dt write ( * , wrtfmt1e ) 'dt_max (convection CFL  ) :' , dt_max_cfl1 write ( * , wrtfmt1e ) 'dt_max (diffusion  CFL  ) :' , dt_max_cfl2 write ( * , wrtfmt1e ) 'dt_max (Kolmogorov limit) :' , dt_max_phy !write(*, wrtfmt1e) 'dt_max (dt+ = 1) :', ONE/u_tau ! iteration t_flth = dm % lxx / 1.2_wp nt_cur = ceiling ( t_flth / dm % dt ) nt_est = ceiling ( t_flth / dt_min ) call Print_debug_mid_msg ( \"Estimating the required time steps\" ) write ( * , wrtfmt1r ) 'flow throught time :' , t_flth write ( * , wrtfmt1il1r ) '1-flthr iter. at the estimated dtmax   :' , nt_est , dt_min write ( * , wrtfmt1il1r ) '1-flthr iter. at the      current dt   :' , nt_cur , dm % dt write ( * , wrtfmt1il1r ) 'rec.[25]-flthr iter. for statistics    :' , nt_cur * 25 , dm % dt if ( dm % is_record_xoutlet . or . dm % is_read_xinlet ) & write ( * , wrtfmt1il1r ) 'rec. [5]-flthr iter. for db recording  :' , nt_cur * 5 , dm % dt write ( * , * ) \"Note: Statistics can start from any iteration when using running average postprocessing. Otherwise:\" write ( * , wrtfmt1il1r ) 'rec.[6]-flthr iter. before statistics  :' , nt_cur * 6 , dm % dt call Print_debug_mid_msg ( \"folder structure\" ) write ( * , * ) '1_data: all raw data(.bin), time averaged data(.bin) and time-space averaged data (.dat)' write ( * , * ) '2_visu: visulisation script (.xdmf)' write ( * , * ) '3_monitor: monitored bulk properties, probed points, and mass conservation' write ( * , * ) '4_check: check mesh grid distribution, initial velocity profiles' call Print_debug_start_msg () return end subroutine end module","tags":"","url":"sourcefile/input_general.f90.html"},{"title":"eq_energy.f90 – CHAPSim2","text":"Source Code module eq_energy_mod use operations use decomp_2d use wrt_debug_field_mod implicit none private :: Compute_energy_rhs private :: Calculate_energy_fractional_step public :: Update_thermal_properties public :: Solve_energy_eq contains !========================================================================================================== subroutine Update_thermal_properties ( fl , tm , dm ) use parameters_constant_mod use udf_type_mod use operations use thermo_info_mod use cylindrical_rn_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: dh_pcc real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: dh_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: dh_cpc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: dh_zpencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: dh_ccp_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_c4c integer :: i , j , k type ( t_fluidThermoProperty ) :: ftp !---------------------------------------------------------------------------------------------------------- !   main field !---------------------------------------------------------------------------------------------------------- do k = 1 , dm % dccc % xsz ( 3 ) do j = 1 , dm % dccc % xsz ( 2 ) do i = 1 , dm % dccc % xsz ( 1 ) ftp % rhoh = tm % rhoh ( i , j , k ) call ftp_refresh_thermal_properties_from_DH ( ftp ) tm % hEnth ( i , j , k ) = ftp % h tm % tTemp ( i , j , k ) = ftp % T tm % kCond ( i , j , k ) = ftp % k fl % dDens ( i , j , k ) = ftp % d fl % mVisc ( i , j , k ) = ftp % m end do end do end do !---------------------------------------------------------------------------------------------------------- !  BC - x !---------------------------------------------------------------------------------------------------------- if ( dm % ibcx_Tm ( 1 ) == IBC_NEUMANN . or . & dm % ibcx_Tm ( 2 ) == IBC_NEUMANN ) then call Get_x_midp_C2P_3D ( tm % rhoh , dh_pcc , dm , dm % iAccuracy , dm % ibcx_ftp ) ! exterpolation, check if ( dm % ibcx_Tm ( 1 ) == IBC_NEUMANN . and . & dm % dpcc % xst ( 1 ) == 1 ) then do j = 1 , size ( dm % fbcx_ftp , 2 ) do k = 1 , size ( dm % fbcx_ftp , 3 ) ftp % rhoh = dh_pcc ( 1 , j , k ) call ftp_refresh_thermal_properties_from_DH ( ftp ) dm % fbcx_ftp ( 1 , j , k ) = ftp dm % fbcx_ftp ( 3 , j , k ) = ftp end do end do end if if ( dm % ibcx_Tm ( 2 ) == IBC_NEUMANN . and . & dm % dpcc % xen ( 1 ) == dm % np ( 1 )) then do j = 1 , size ( dm % fbcx_ftp , 2 ) do k = 1 , size ( dm % fbcx_ftp , 3 ) ftp % rhoh = dh_pcc ( dm % np ( 1 ), j , k ) call ftp_refresh_thermal_properties_from_DH ( ftp ) dm % fbcx_ftp ( 2 , j , k ) = ftp dm % fbcx_ftp ( 4 , j , k ) = ftp end do end do end if end if !---------------------------------------------------------------------------------------------------------- !  BC - y !---------------------------------------------------------------------------------------------------------- if ( dm % ibcy_Tm ( 1 ) == IBC_NEUMANN . or . & dm % ibcy_Tm ( 2 ) == IBC_NEUMANN ) then call transpose_x_to_y ( tm % rhoh , dh_ypencil , dm % dccc ) call Get_y_midp_C2P_3D ( dh_ypencil , dh_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp ) ! exterpolation, check call axis_estimating_radial_xpx ( dh_cpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 1 )) if ( dm % ibcy_Tm ( 1 ) == IBC_NEUMANN . and . & dm % dcpc % yst ( 2 ) == 1 ) then do i = 1 , size ( dm % fbcy_ftp , 1 ) do k = 1 , size ( dm % fbcy_ftp , 3 ) ftp % rhoh = dh_cpc_ypencil ( i , 1 , k ) call ftp_refresh_thermal_properties_from_DH ( ftp ) dm % fbcy_ftp ( i , 1 , k ) = ftp dm % fbcy_ftp ( i , 3 , k ) = ftp end do end do end if if ( dm % ibcy_Tm ( 2 ) == IBC_NEUMANN . and . & dm % dcpc % yen ( 2 ) == dm % np ( 2 )) then do i = 1 , size ( dm % fbcy_ftp , 1 ) do k = 1 , size ( dm % fbcy_ftp , 3 ) ftp % rhoh = dh_cpc_ypencil ( i , dm % np ( 2 ), k ) call ftp_refresh_thermal_properties_from_DH ( ftp ) dm % fbcy_ftp ( i , 2 , k ) = ftp dm % fbcy_ftp ( i , 4 , k ) = ftp end do end do end if end if !---------------------------------------------------------------------------------------------------------- !  BC - z !---------------------------------------------------------------------------------------------------------- if ( dm % ibcz_Tm ( 1 ) == IBC_NEUMANN . or . & dm % ibcz_Tm ( 2 ) == IBC_NEUMANN ) then call transpose_x_to_y ( tm % rhoh , dh_ypencil , dm % dccc ) call transpose_y_to_z ( dh_ypencil , dh_zpencil , dm % dccc ) call Get_z_midp_C2P_3D ( dh_zpencil , dh_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp ) ! exterpolation, check if ( dm % ibcz_Tm ( 1 ) == IBC_NEUMANN . and . & dm % dccp % zst ( 1 ) == 1 ) then do j = 1 , size ( dm % fbcz_ftp , 2 ) do i = 1 , size ( dm % fbcz_ftp , 1 ) ftp % rhoh = dh_ccp_zpencil ( i , j , 1 ) call ftp_refresh_thermal_properties_from_DH ( ftp ) dm % fbcz_ftp ( i , j , 1 ) = ftp dm % fbcz_ftp ( i , j , 3 ) = ftp end do end do end if if ( dm % ibcz_Tm ( 2 ) == IBC_NEUMANN . and . & dm % dccp % zen ( 1 ) == dm % np ( 3 )) then do j = 1 , size ( dm % fbcz_ftp , 2 ) do i = 1 , size ( dm % fbcz_ftp , 1 ) ftp % rhoh = dh_ccp_zpencil ( i , j , dm % np ( 3 )) call ftp_refresh_thermal_properties_from_DH ( ftp ) dm % fbcz_ftp ( i , j , 2 ) = ftp dm % fbcz_ftp ( i , j , 4 ) = ftp end do end do end if end if return end subroutine Update_thermal_properties !========================================================================================================== subroutine Calculate_energy_fractional_step ( rhs0 , rhs1 , dtmp , dm , isub ) use parameters_constant_mod use udf_type_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: rhs0 , rhs1 integer , intent ( in ) :: isub real ( WP ) :: rhs_explicit_current , rhs_explicit_last , rhs_total integer :: i , j , k do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) do i = 1 , dtmp % xsz ( 1 ) ! add explicit terms : convection+viscous rhs rhs_explicit_current = rhs1 ( i , j , k ) ! not (*dt) rhs_explicit_last = rhs0 ( i , j , k ) ! not (*dt) rhs_total = dm % tGamma ( isub ) * rhs_explicit_current + & dm % tZeta ( isub ) * rhs_explicit_last rhs0 ( i , j , k ) = rhs_explicit_current ! times the time step rhs1 ( i , j , k ) = dm % dt * rhs_total ! * dt end do end do end do return end subroutine !========================================================================================================== subroutine Compute_energy_rhs ( fl , tm , dm , isub ) use operations use udf_type_mod use thermo_info_mod use boundary_conditions_mod use wrt_debug_field_mod use cylindrical_rn_mod use wrt_debug_field_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl type ( t_thermo ), intent ( inout ) :: tm integer , intent ( in ) :: isub real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc_xpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: apcc_xpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: gy_cpc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: gz_ccp_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: hEnth_pcc_xpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: hEnth_cpc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: hEnth_ccp_zpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: Ttemp_ccc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: Ttemp_ccc_zpencil real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dppc % xsz ( 3 ) ) :: kCond_pcc_xpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: kCond_cpc_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: kCond_ccp_zpencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: kCond_ccc_zpencil real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: ene_rhs_ccc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: ene_rhs_ccc_zpencil real ( WP ), dimension ( 4 , dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ) ) :: fbcx_4cc real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: fbcy_c4c real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: fbcz_cc4 integer :: n , i , j , k integer :: mbc ( 1 : 2 , 1 : 3 ) !========================================================================================================== !   preparation !========================================================================================================== call transpose_x_to_y ( fl % gy , gy_cpc_ypencil , dm % dcpc ) ! for d(g_y h)/dy call transpose_x_to_y ( fl % gz , accp_ypencil , dm % dccp ) ! intermediate, accp_ypencil = gz_ypencil call transpose_y_to_z ( accp_ypencil , gz_ccp_zpencil , dm % dccp ) ! for d(g_z h)/dz !---------------------------------------------------------------------------------------------------------- !    h --> h_pcc !      --> h_ypencil --> h_cpc_ypencil !                    --> h_zpencil --> h_ccp_zpencil !---------------------------------------------------------------------------------------------------------- fbcx_4cc = MAXP fbcy_c4c = MAXP fbcz_cc4 = MAXP fbcx_4cc (:, :, :) = dm % fbcx_ftp (:, :, :)% h fbcy_c4c (:, :, :) = dm % fbcy_ftp (:, :, :)% h fbcz_cc4 (:, :, :) = dm % fbcz_ftp (:, :, :)% h call Get_x_midp_C2P_3D ( tm % hEnth , hEnth_pcc_xpencil , dm , dm % iAccuracy , dm % ibcx_ftp (:), fbcx_4cc ) ! for d(g_x h_pcc))/dy call transpose_x_to_y ( tm % hEnth , accc_ypencil , dm % dccc ) !accc_ypencil = hEnth_ypencil call Get_y_midp_C2P_3D ( accc_ypencil , hEnth_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp (:), fbcy_c4c ) ! for d(g_y h_cpc)/dy call axis_estimating_radial_xpx ( hEnth_cpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 1 )) call transpose_y_to_z ( accc_ypencil , accc_zpencil , dm % dccc ) !ccc_zpencil = hEnth_zpencil call Get_z_midp_C2P_3D ( accc_zpencil , hEnth_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp (:), fbcz_cc4 ) ! for d(g_z h_ccp)/dz !---------------------------------------------------------------------------------------------------------- !    k --> k_pcc !      --> k_ypencil --> k_cpc_ypencil !                    --> k_zpencil --> k_ccp_zpencil !---------------------------------------------------------------------------------------------------------- fbcx_4cc = MAXP fbcy_c4c = MAXP fbcz_cc4 = MAXP fbcx_4cc (:, :, :) = dm % fbcx_ftp (:, :, :)% k fbcy_c4c (:, :, :) = dm % fbcy_ftp (:, :, :)% k fbcz_cc4 (:, :, :) = dm % fbcz_ftp (:, :, :)% k call Get_x_midp_C2P_3D ( tm % kCond , kCond_pcc_xpencil , dm , dm % iAccuracy , dm % ibcx_ftp (:), fbcx_4cc ) ! for d(k_pcc * (dT/dx) )/dx call transpose_x_to_y ( tm % kCond , accc_ypencil , dm % dccc ) ! for k d2(T)/dy&#94;2 call Get_y_midp_C2P_3D ( accc_ypencil , kCond_cpc_ypencil , dm , dm % iAccuracy , dm % ibcy_ftp (:), fbcy_c4c ) call axis_estimating_radial_xpx ( kCond_cpc_ypencil , dm % dcpc , IPENCIL ( 2 ), dm , IDIM ( 1 )) call transpose_y_to_z ( accc_ypencil , kCond_ccc_zpencil , dm % dccc ) call Get_z_midp_C2P_3D ( kCond_ccc_zpencil , kCond_ccp_zpencil , dm , dm % iAccuracy , dm % ibcz_ftp (:), fbcz_cc4 ) !---------------------------------------------------------------------------------------------------------- !    T --> T_ypencil --> T_zpencil !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( tm % Ttemp , Ttemp_ccc_ypencil , dm % dccc ) ! for k d2(T)/dy&#94;2 call transpose_y_to_z ( Ttemp_ccc_ypencil , Ttemp_ccc_zpencil , dm % dccc ) ! for k d2(T)/dz&#94;2 !========================================================================================================== ! the RHS of energy equation : convection terms !========================================================================================================== tm % ene_rhs = ZERO ene_rhs_ccc_ypencil = ZERO ene_rhs_ccc_zpencil = ZERO !---------------------------------------------------------------------------------------------------------- ! conv-x-e, x-pencil : d (gx * h_pcc) / dx !---------------------------------------------------------------------------------------------------------- ! !------b.c.------ ! if(is_fbcx_velo_required) then !   fbcx_4cc(:, :, :) = dm%fbcx_ftp(:, :, :)%h !   fbcx_4cc = - fbcx_4cc * dm%fbcx_gx ! else !   fbcx_4cc = MAXP ! end if !------bulk------ apcc_xpencil = - fl % gx * hEnth_pcc_xpencil !------b.c.------ if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4cc , apcc_xpencil , dm % dpcc ) else fbcx_4cc = MAXP end if !------PDE------ call Get_x_1der_P2C_3D ( apcc_xpencil , accc_xpencil , dm , dm % iAccuracy , ebcx_conv , fbcx_4cc ) tm % ene_rhs = tm % ene_rhs + accc_xpencil #ifdef DEBUG_STEPS write ( * , * ) 'conx-e' , accc_xpencil ( 4 , 1 : 4 , 4 ) #endif !---------------------------------------------------------------------------------------------------------- ! conv-y-e, y-pencil : d (gy * h_cpc) / dy  * (1/r) !---------------------------------------------------------------------------------------------------------- !------bulk------ acpc_ypencil = - gy_cpc_ypencil * hEnth_cpc_ypencil !------b.c.------ if ( is_fbcy_velo_required ) then call extract_dirichlet_fbcy ( fbcy_c4c , acpc_ypencil , dm % dcpc , dm , is_reversed = . true .) else fbcy_c4c = MAXP end if !------PDE------ call Get_y_1der_P2C_3D ( acpc_ypencil , accc_ypencil , dm , dm % iAccuracy , ebcy_conv , fbcy_c4c ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accc_ypencil , dm % dccc , dm % rci , 1 , IPENCIL ( 2 )) ene_rhs_ccc_ypencil = ene_rhs_ccc_ypencil + accc_ypencil #ifdef DEBUG_STEPS write ( * , * ) 'cony-e' , accc_ypencil ( 4 , 1 : 4 , 4 ) #endif !---------------------------------------------------------------------------------------------------------- ! conv-z-e, z-pencil : d (gz * h_ccp) / dz   * (1/r) !---------------------------------------------------------------------------------------------------------- !------bulk------ accp_zpencil = - gz_ccp_zpencil * hEnth_ccp_zpencil ! if(dm%icoordinate == ICYLINDRICAL) & ! call multiple_cylindrical_rn(accp_zpencil, dm%dccp, dm%rci, 1, IPENCIL(3)) if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_cc4 , accp_zpencil , dm % dccp ) else fbcz_cc4 = MAXP end if !------PDE------ call Get_z_1der_P2C_3D ( accp_zpencil , accc_zpencil , dm , dm % iAccuracy , ebcz_conv , fbcz_cc4 ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accc_zpencil , dm % dccc , dm % rci , 1 , IPENCIL ( 3 )) ene_rhs_ccc_zpencil = ene_rhs_ccc_zpencil + accc_zpencil #ifdef DEBUG_STEPS write ( * , * ) 'conz-e' , accc_zpencil ( 4 , 1 : 4 , 4 ) #endif !========================================================================================================== ! the RHS of energy equation : diffusion terms !========================================================================================================== !---------------------------------------------------------------------------------------------------------- ! diff-x-e, d ( k_pcc * d (T) / dx ) dx !---------------------------------------------------------------------------------------------------------- !------bulk------ call get_fbcx_iTh ( dm % ibcx_Tm , dm , fbcx_4cc ) call Get_x_1der_C2P_3D ( tm % tTemp , apcc_xpencil , dm , dm % iAccuracy , dm % ibcx_Tm , fbcx_4cc ) apcc_xpencil = apcc_xpencil * kCond_pcc_xpencil !------B.C.------ if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcx ( fbcx_4cc , apcc_xpencil , dm % dpcc ) else fbcx_4cc = MAXP end if !------PDE------ call Get_x_1der_P2C_3D ( apcc_xpencil , accc_xpencil , dm , dm % iAccuracy , ebcx_difu , fbcx_4cc ) tm % ene_rhs = tm % ene_rhs + accc_xpencil * tm % rPrRen #ifdef DEBUG_STEPS write ( * , * ) 'difx-e' , accc_xpencil ( 4 , 1 : 4 , 4 ) #endif !---------------------------------------------------------------------------------------------------------- ! diff-y-e, d ( r * k_cpc * d (T) / dy ) dy * 1/r !---------------------------------------------------------------------------------------------------------- !------bulk------ call get_fbcy_iTh ( dm % ibcy_Tm , dm , fbcy_c4c ) call Get_y_1der_C2P_3D ( tTemp_ccc_ypencil , acpc_ypencil , dm , dm % iAccuracy , dm % ibcy_Tm , fbcy_c4c ) acpc_ypencil = acpc_ypencil * kCond_cpc_ypencil #ifdef DEBUG_STEPS write ( * , * ) 'diy-dT' , acpc_ypencil ( 4 , 1 : 4 , 4 ) write ( * , * ) 'dify-k' , kCond_cpc_ypencil ( 4 , 1 : 4 , 4 ) #endif if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( acpc_ypencil , dm % dcpc , dm % rp , 1 , IPENCIL ( 2 )) !------B.C.------ if ( is_fbcx_velo_required ) then call extract_dirichlet_fbcy ( fbcy_c4c , acpc_ypencil , dm % dcpc , dm , is_reversed = . true .) else fbcy_c4c = MAXP end if !------PDE------ call Get_y_1der_P2C_3D ( acpc_ypencil , accc_ypencil , dm , dm % iAccuracy , ebcy_difu , fbcy_c4c ) ! check, dirichlet, r treatment if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accc_ypencil , dm % dccc , dm % rci , 1 , IPENCIL ( 2 )) ene_rhs_ccc_ypencil = ene_rhs_ccc_ypencil + accc_ypencil * tm % rPrRen #ifdef DEBUG_STEPS write ( * , * ) 'dify-e' , accc_ypencil ( 4 , 1 : 4 , 4 ) #endif !---------------------------------------------------------------------------------------------------------- ! diff-z-e, d (1/r* k_ccp * d (T) / dz ) / dz * 1/r !---------------------------------------------------------------------------------------------------------- !------bulk------ call get_fbcz_iTh ( dm % ibcz_Tm , dm , fbcz_cc4 ) call Get_z_1der_C2P_3D ( tTemp_ccc_zpencil , accp_zpencil , dm , dm % iAccuracy , dm % ibcz_Tm , fbcz_cc4 ) accp_zpencil = accp_zpencil * kCond_ccp_zpencil if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accp_zpencil , dm % dccp , dm % rci , 1 , IPENCIL ( 3 )) if ( is_fbcz_velo_required ) then call extract_dirichlet_fbcz ( fbcz_cc4 , accp_zpencil , dm % dccp ) else fbcz_cc4 = MAXP end if !------PDE------ call Get_z_1der_P2C_3D ( accp_zpencil , accc_zpencil , dm , dm % iAccuracy , ebcz_difu , fbcz_cc4 ) if ( dm % icoordinate == ICYLINDRICAL ) & call multiple_cylindrical_rn ( accc_zpencil , dm % dccc , dm % rci , 1 , IPENCIL ( 3 )) ene_rhs_ccc_zpencil = ene_rhs_ccc_zpencil + accc_zpencil * tm % rPrRen #ifdef DEBUG_STEPS write ( * , * ) 'difz-e' , accc_zpencil ( 4 , 1 : 4 , 4 ) #endif !========================================================================================================== ! all convert into x-pencil !========================================================================================================== call transpose_z_to_y ( ene_rhs_ccc_zpencil , accc_ypencil , dm % dccc ) ene_rhs_ccc_ypencil = ene_rhs_ccc_ypencil + accc_ypencil call transpose_y_to_x ( ene_rhs_ccc_ypencil , accc_xpencil , dm % dccc ) tm % ene_rhs = tm % ene_rhs + accc_xpencil !========================================================================================================== ! time approaching !========================================================================================================== #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( tm % tTemp , dm % dccc , fl % iteration , isub , 'T@bf stepping' ) ! debug_ww call wrt_3d_pt_debug ( tm % ene_rhs , dm % dccc , fl % iteration , isub , 'energy_rhs@bf stepping' ) ! debug_ww write ( * , * ) 'rhs-e' , tm % ene_rhs ( 1 , 1 : 4 , 1 ) #endif call Calculate_energy_fractional_step ( tm % ene_rhs0 , tm % ene_rhs , dm % dccc , dm , isub ) return end subroutine Compute_energy_rhs !========================================================================================================== !========================================================================================================== subroutine Solve_energy_eq ( fl , tm , dm , isub ) use udf_type_mod use thermo_info_mod use solver_tools_mod use boundary_conditions_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm integer , intent ( in ) :: isub real ( WP ) :: uxdx integer :: j , k !if(isub==1) then fl % dDensm2 (:, :, :) = fl % dDensm1 (:, :, :) fl % dDensm1 (:, :, :) = fl % dDens (:, :, :) !end if !---------------------------------------------------------------------------------------------------------- ! to set up halo b.c. for cylindrical pipe !---------------------------------------------------------------------------------------------------------- call update_fbcy_cc_thermo_halo ( fl , tm , dm ) !---------------------------------------------------------------------------------------------------------- ! to set up convective outlet b.c. assume x direction !---------------------------------------------------------------------------------------------------------- call update_fbcx_convective_outlet_thermo ( fl , tm , dm , isub ) !---------------------------------------------------------------------------------------------------------- !   calculate rhs of energy equation !---------------------------------------------------------------------------------------------------------- call Compute_energy_rhs ( fl , tm , dm , isub ) !---------------------------------------------------------------------------------------------------------- !   update rho * h !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_STEPS write ( * , * ) 'rhoh-e-bf' , tm % rhoh ( 1 , 1 : 4 , 1 ) #endif tm % rhoh = tm % rhoh + tm % ene_rhs #ifdef DEBUG_STEPS write ( * , * ) 'rhoh-e-af' , tm % rhoh ( 1 , 1 : 4 , 1 ) call wrt_3d_pt_debug ( tm % rhoh , dm % dccc , fl % iteration , isub , 'rhoh@af stepping' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- !   update other properties from rho * h !---------------------------------------------------------------------------------------------------------- call Update_thermal_properties ( fl , tm , dm ) call update_fbcy_cc_thermo_halo ( fl , tm , dm ) #ifdef DEBUG_STEPS write ( * , * ) 'T-e' , tm % tTemp ( 1 , 1 : 4 , 1 ) call wrt_3d_pt_debug ( tm % tTemp , dm % dccc , fl % iteration , isub , 'T@af stepping' ) ! debug_ww #endif return end subroutine end module eq_energy_mod","tags":"","url":"sourcefile/eq_energy.f90.html"},{"title":".poisson_1stderivcomp_reform.f90 – CHAPSim2","text":"Source Code !Copyright (c) 2012-2022, Xcompact3d !This file is part of Xcompact3d (xcompact3d.com) !SPDX-License-Identifier: BSD 3-Clause module decomp_2d_poisson use decomp_2d use decomp_2d_fft use poisson_interface_mod !use param !use variables implicit none private ! Make everything private unless declared public !  real(mytype), private, parameter :: PI = 3.14159265358979323846_mytype #ifdef DOUBLE_PREC real ( mytype ), parameter :: epsilon = 1.e-20_mytype #else real ( mytype ), parameter :: epsilon = 1.e-8_mytype #endif ! boundary conditions integer , save :: bcx , bcy , bcz ! decomposition object for physical space type ( DECOMP_INFO ), save :: ph ! decomposition object for spectral space type ( DECOMP_INFO ), save :: sp ! store sine/cosine factors complex ( mytype ), save , allocatable , dimension (:) :: cplx_circle_unit_halfx (:), & cplx_circle_unit_halfy (:), & cplx_circle_unit_halfz (:) real ( mytype ), save , allocatable , dimension (:) :: wx (:), wy (:), wz (:) ! wave numbers complex ( mytype ), save , allocatable , dimension (:,:,:) :: kxyz !wave numbers for stretching in a pentadiagonal matrice complex ( mytype ), save , allocatable , dimension (:,:,:,:) :: a , a2 , a3 ! work arrays, ! naming convention: cw (complex); rw (real); !                    1 = X-pencil; 2 = Y-pencil; 3 = Z-pencil real ( mytype ), allocatable , dimension (:,:,:) :: rw1 , rw1b , rw2 , rw2b , rw3 complex ( mytype ), allocatable , dimension (:,:,:) :: cw1 , cw1b , cw2 , cw22 , cw2b , cw2c ! underlying FFT library only needs to be initialised once logical , save :: fft_initialised = . false . abstract interface subroutine poisson_xxx ( rhs ) use decomp_2d , only : mytype real ( mytype ), dimension (:,:,:), intent ( inout ) :: rhs end subroutine poisson_xxx end interface procedure ( poisson_xxx ), pointer :: poisson public :: decomp_2d_poisson_init , decomp_2d_poisson_finalize , poisson private :: fft_shift_ppp2ccc private :: complex_half_unit contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Initialise Poisson solver for given boundary conditions !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine decomp_2d_poisson_init () implicit none integer :: nx , ny , nz , i real ( mytype ) :: rl , iy external rl , iy if ( nclx ) then bcx = 0 else bcx = 1 endif if ( ncly ) then bcy = 0 else bcy = 1 endif if ( nclz ) then bcz = 0 else bcz = 1 endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Top level wrapper !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( bcx == 0 . and . bcy == 0 . and . bcz == 0 ) then poisson => poisson_000 else if ( bcx == 1 . and . bcy == 0 . and . bcz == 0 ) then poisson => poisson_100 else if ( bcx == 0 . and . bcy == 1 . and . bcz == 0 ) then poisson => poisson_010 else if ( bcx == 1 . and . bcy == 1 ) then ! 110 & 111 poisson => poisson_11x else stop 'boundary condition not supported' end if nx = nx_global ny = ny_global nz = nz_global ! pressure-grid having 1 fewer point for non-periodic directions if ( bcx == 1 ) nx = nx - 1 if ( bcy == 1 ) ny = ny - 1 if ( bcz == 1 ) nz = nz - 1 #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init start' #endif allocate ( cmplx_circle_unit_halfx ( nx ) ) ! unit circle in complex plane = (cos(wx), sin(wx) ) allocate ( cmplx_circle_unit_halfy ( ny ) ) ! unit circle in complex plane = (cos(wy), sin(wy) ) allocate ( cmplx_circle_unit_halfz ( nz ) ) ! unit circle in complex plane = (cos(wz), sin(wz) ) allocate ( wx ( nx ) ) ! angle = (i-1) * pi/n for periodic, (i-1) * pi/2/n for non-periodic allocate ( wy ( ny ) ) ! angle = (j-1) * pi/n for periodic, (i-1) * pi/2/n for non-periodic allocate ( wz ( nz ) ) ! angle = (k-1) * pi/n for periodic, (i-1) * pi/2/n for non-periodic call complex_half_unit #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init decomp_info_init' #endif call decomp_info_init ( nx , ny , nz , ph ) call decomp_info_init ( nx , ny , nz / 2 + 1 , sp ) #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init decomp_info_init ok' #endif ! allocate work space if ( bcx == 0 . and . bcy == 0 . and . bcz == 0 ) then allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( kxyz ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), ny , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) else if ( bcx == 1 . and . bcy == 0 . and . bcz == 0 ) then allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw1b ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( rw1 ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw1b ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw2 ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( kxyz ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), ny , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) else if ( bcx == 0 . and . bcy == 1 . and . bcz == 0 ) then allocate ( rw2 ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( rw2b ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw2 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw22 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2b ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2c ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( kxyz ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), ny , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) else if ( bcx == 1 . and . bcy == 1 ) then allocate ( cw1 ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw1b ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( cw2 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw22 ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2b ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( cw2c ( sp % yst ( 1 ): sp % yen ( 1 ), sp % yst ( 2 ): sp % yen ( 2 ), & sp % yst ( 3 ): sp % yen ( 3 ))) allocate ( rw1 ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw1b ( ph % xst ( 1 ): ph % xen ( 1 ), ph % xst ( 2 ): ph % xen ( 2 ), & ph % xst ( 3 ): ph % xen ( 3 ))) allocate ( rw2 ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) allocate ( rw2b ( ph % yst ( 1 ): ph % yen ( 1 ), ph % yst ( 2 ): ph % yen ( 2 ), & ph % yst ( 3 ): ph % yen ( 3 ))) if ( bcz == 1 ) then allocate ( rw3 ( ph % zsz ( 1 ), ph % zsz ( 2 ), ph % zsz ( 3 ))) end if allocate ( kxyz ( sp % xst ( 1 ): sp % xen ( 1 ), sp % xst ( 2 ): sp % xen ( 2 ), & sp % xst ( 3 ): sp % xen ( 3 ))) allocate ( a ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a2 ( sp % yst ( 1 ): sp % yen ( 1 ), ny / 2 , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) allocate ( a3 ( sp % yst ( 1 ): sp % yen ( 1 ), nym , sp % yst ( 3 ): sp % yen ( 3 ), 5 )) end if #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init before waves' #endif call waves () if ( bcy == 1 . and . istret /= ISTRET_NO ) call matrice_refinement () !write(*,*) 'POinit ii1 arl ', rl(a(1,1,1,1)),rl(a(1,1,1,2)),rl(a(1,1,1,3)),& !                              rl(a(1,1,1,4)),rl(a(1,1,1,5)) !write(*,*) 'POinit ii1 aiy ', iy(a(1,1,1,1)),iy(a(1,1,1,2)),iy(a(1,1,1,3)),& !                              iy(a(1,1,1,4)),iy(a(1,1,1,5)) !! !write(*,*) 'POinit ii5 arl ', rl(a(5,5,5,1)),rl(a(5,5,5,2)),rl(a(5,5,5,3)),& !                              rl(a(5,5,5,4)),rl(a(5,5,5,5)) !write(*,*) 'POinit ii5 aiy ', iy(a(5,5,5,1)),iy(a(5,5,5,2)),iy(a(5,5,5,3)),& !                              iy(a(5,5,5,4)),iy(a(5,5,5,5)) !!! !write(*,*) 'POinit ii1 a2rl ', rl(a2(1,1,1,1)),rl(a2(1,1,1,2)),rl(a2(1,1,1,3)),& !                               rl(a2(1,1,1,4)),rl(a2(1,1,1,5)) !write(*,*) 'POinit ii1 a2iy ', iy(a2(1,1,1,1)),iy(a2(1,1,1,2)),iy(a2(1,1,1,3)),& !                               iy(a2(1,1,1,4)),iy(a2(1,1,1,5)) !! !write(*,*) 'POinit ii5 a2rl ', rl(a2(5,5,5,1)),rl(a2(5,5,5,2)),rl(a2(5,5,5,3)),& !                               rl(a2(5,5,5,4)),rl(a2(5,5,5,5)) !write(*,*) 'POinit ii5 a2iy ', iy(a2(5,5,5,1)),iy(a2(5,5,5,2)),iy(a2(5,5,5,3)),& !                               iy(a2(5,5,5,4)),iy(a2(5,5,5,5)) !!! !write(*,*) 'POinit ii1 a3rl ', rl(a3(1,1,1,1)),rl(a3(1,1,1,2)),rl(a3(1,1,1,3)),& !                               rl(a3(1,1,1,4)),rl(a3(1,1,1,5)) !write(*,*) 'POinit ii1 a3iy ', iy(a3(1,1,1,1)),iy(a3(1,1,1,2)),iy(a3(1,1,1,3)),& !                               iy(a3(1,1,1,4)),iy(a3(1,1,1,5)) !! !write(*,*) 'POinit ii5 a3rl ', rl(a3(5,5,5,1)),rl(a3(5,5,5,2)),rl(a3(5,5,5,3)),& !                               rl(a3(5,5,5,4)),rl(a3(5,5,5,5)) !write(*,*) 'POinit ii5 a3iy ', iy(a3(5,5,5,1)),iy(a3(5,5,5,2)),iy(a3(5,5,5,3)),& !                               iy(a3(5,5,5,4)),iy(a3(5,5,5,5)) #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# decomp_2d_poisson_init end' #endif return end subroutine decomp_2d_poisson_init !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Release memory used by Poisson solver !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine decomp_2d_poisson_finalize implicit none deallocate ( ax , bx , ay , by , az , bz ) call decomp_info_finalize ( ph ) call decomp_info_finalize ( sp ) call decomp_2d_fft_finalize fft_initialised = . false . deallocate ( kxyz ) if ( bcx == 0 . and . bcy == 0 . and . bcz == 0 ) then deallocate ( cw1 ) deallocate ( a , a2 , a3 ) else if ( bcx == 1 . and . bcy == 0 . and . bcz == 0 ) then deallocate ( cw1 , cw1b , rw1 , rw1b , rw2 ) deallocate ( a , a2 , a3 ) else if ( bcx == 0 . and . bcy == 1 . and . bcz == 0 ) then deallocate ( cw1 , cw2 , cw2b , rw2 , rw2b ) deallocate ( a , a2 , a3 ) else if ( bcx == 1 . and . bcy == 1 ) then deallocate ( cw1 , cw1b , cw2 , cw2b , rw1 , rw1b , rw2 , rw2b ) deallocate ( a , a2 , a3 ) if ( bcz == 1 ) then deallocate ( rw3 ) end if end if return end subroutine decomp_2d_poisson_finalize !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Solving 3D Poisson equation with periodic B.C in all 3 dimensions !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine poisson_000 ( rhs ) !use derivX !use derivY !use derivZ ! right-hand-side of Poisson as input ! solution of Poisson as output real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs integer , dimension ( 3 ) :: fft_start , fft_end , fft_size complex ( mytype ) :: xyzk complex ( mytype ) :: ytt , xtt , ztt , yt1 , xt1 , yt2 , xt2 complex ( mytype ) :: xtt1 , ytt1 , ztt1 , zt1 , zt2 real ( mytype ) :: tmp1 , tmp2 , x , y , z , avg_param integer :: nx , ny , nz , i , j , k complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy nx = nx_global ny = ny_global nz = nz_global if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z ) fft_initialised = . true . end if #ifdef DEBUG_FFT avg_param = zero call avg3d ( rhs , avg_param ) if ( nrank == 0 ) write ( * , * ) '## rhs_ijk physical ' , avg_param #endif ! #ifdef DEBUG_FFT !     do k = ph%zst(3), ph%zen(3) !       do j = ph%zst(2), ph%zen(2) !         do i = ph%zst(1), ph%zen(1) !           write(*, *) 'd-orgn', k, j, i, rhs(i, j, k) !         end do !       end do !     end do ! #endif !---------------------------------------------------------------------------------------------------------- ! FFT of data sequence without grid information ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## hat_lmn(rhs_ijk) ' , avg_param #endif !---------------------------------------------------------------------------------------------------------- ! FFT of data located at cell centre call fft3d_sp_shift_half_z0 ( cw1 , IBACKWARD ) call fft3d_sp_shift_half_y0 ( cw1 , IBACKWARD ) call fft3d_sp_shift_half_x0 ( cw1 , IBACKWARD ) !---------------------------------------------------------------------------------------------------------- ! calculation in spectral domain do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) ! CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). or .( abs_prec ( tmp2 ) < epsilon )) then cw1 ( i , j , k ) = zero else cw1 ( i , j , k ) = cx ( rl ( cw1 ( i , j , k )) / ( - tmp1 ), & iy ( cw1 ( i , j , k )) / ( - tmp2 )) end if end do end do end do !---------------------------------------------------------------------------------------------------------- !   spectral data back to grid call fft3d_sp_shift_half_z0 ( cw1 , IFORWARD ) call fft3d_sp_shift_half_y0 ( cw1 , IFORWARD ) call fft3d_sp_shift_half_x0 ( cw1 , IFORWARD ) !---------------------------------------------------------------------------------------------------------- #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## hat_lmn(rhs_ijk/wave) ' , avg_param #endif ! compute c2r transform call decomp_2d_fft_3d ( cw1 , rhs ) ! #ifdef DEBUG_FFT !     do k = ph%zst(3), ph%zen(3) !       do j = ph%zst(2), ph%zen(2) !         do i = ph%zst(1), ph%zen(1) !           write(*, *) 'd-back', k, j, i, rhs(i, j, k) !         end do !       end do !     end do ! #endif #ifdef DEBUG_FFT avg_param = zero call avg3d ( rhs , avg_param ) if ( nrank == 0 ) write ( * , * ) '## rhs_ijk physical new' , avg_param #endif !   call decomp_2d_fft_finalize return end subroutine poisson_000 subroutine poisson_100 ( rhs ) !use dbg_schemes, only: abs_prec use math_mod , only : abs_prec implicit none real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs complex ( mytype ) :: xyzk real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 real ( mytype ) :: xx1 , xx2 , xx3 , xx4 , xx5 , xx6 , xx7 , xx8 integer :: nx , ny , nz , i , j , k , itmp complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy 100 format ( 1 x , a8 , 3 I4 , 2 F12 . 6 ) nx = nx_global - 1 ny = ny_global nz = nz_global !write(*,*) 'Poisson_100' ! rhs is in Z-pencil but requires global operations in X call transpose_z_to_y ( rhs , rw2 , ph ) call transpose_y_to_x ( rw2 , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( i , j , k ) = rw1 ( 2 * ( i - 1 ) + 1 , j , k ) enddo do i = nx / 2 + 1 , nx rw1b ( i , j , k ) = rw1 ( 2 * nx - 2 * i + 2 , j , k ) enddo enddo end do call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z , nx , ny , nz ) fft_initialised = . true . end if ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'START' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! post-processing in spectral space ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after z' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Y do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * by ( j ) + tmp2 * ay ( j ), & tmp2 * by ( j ) - tmp1 * ay ( j )) if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after y' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1b ( 1 , j , k ) = cw1 ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) tmp3 = rl ( cw1 ( nx - i + 2 , j , k )) tmp4 = iy ( cw1 ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) xx2 = tmp1 * ax ( i ) xx3 = tmp2 * bx ( i ) xx4 = tmp2 * ax ( i ) xx5 = tmp3 * bx ( i ) xx6 = tmp3 * ax ( i ) xx7 = tmp4 * bx ( i ) xx8 = tmp4 * ax ( i ) cw1b ( i , j , k ) = half * cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'after x' , i , j , k , cw1b ( i , j , k ) end if end do end do end do #endif ! Solve Poisson do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) ! CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( zero , zero ) end if if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( zero , iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( rl ( cw1b ( i , j , k )) / ( - tmp1 ), zero ) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( rl ( cw1b ( i , j , k )) / ( - tmp1 ), iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if #ifdef DEBUG_FFT if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'AFTER' , i , j , k , cw1b ( i , j , k ) #endif end do end do end do ! post-processing backward ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1 ( 1 , j , k ) = cw1b ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1b ( i , j , k )) tmp2 = iy ( cw1b ( i , j , k )) tmp3 = rl ( cw1b ( nx - i + 2 , j , k )) tmp4 = iy ( cw1b ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) xx2 = tmp1 * ax ( i ) xx3 = tmp2 * bx ( i ) xx4 = tmp2 * ax ( i ) xx5 = tmp3 * bx ( i ) xx6 = tmp3 * ax ( i ) xx7 = tmp4 * bx ( i ) xx8 = tmp4 * ax ( i ) cw1 ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER X' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! POST PROCESSING IN Y do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * by ( j ) - tmp2 * ay ( j ), & tmp2 * by ( j ) + tmp1 * ay ( j )) if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'AFTER Y' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'END' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! compute c2r transform call decomp_2d_fft_3d ( cw1 , rhs ) ! rhs is in Z-pencil but requires global operations in X call transpose_z_to_y ( rhs , rw2 , ph ) call transpose_y_to_x ( rw2 , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( 2 * i - 1 , j , k ) = rw1 ( i , j , k ) enddo do i = 1 , nx / 2 rw1b ( 2 * i , j , k ) = rw1 ( nx - i + 1 , j , k ) enddo enddo end do call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) !  call decomp_2d_fft_finalize return end subroutine poisson_100 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Solving 3D Poisson equation: Neumann in Y; periodic in X & Z !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine poisson_010 ( rhs ) !use dbg_schemes, only: abs_prec use math_mod , only : abs_prec implicit none real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs complex ( mytype ) :: xyzk real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 real ( mytype ) :: xx1 , xx2 , xx3 , xx4 , xx5 , xx6 , xx7 , xx8 integer :: nx , ny , nz , i , j , k complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy !real(mytype) :: avg_param 100 format ( 1 x , a8 , 3 I4 , 2 F12 . 6 ) nx = nx_global ny = ny_global - 1 nz = nz_global #ifdef DEBUG_FFT if ( nrank . eq . 0 ) write ( * , * ) '# Poisoon_010 Init' #endif ! rhs is in Z-pencil but requires global operations in Y call transpose_z_to_y ( rhs , rw2 , ph ) do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , j , k ) = rw2 ( i , 2 * ( j - 1 ) + 1 , k ) enddo do j = ny / 2 + 1 , ny rw2b ( i , j , k ) = rw2 ( i , 2 * ny - 2 * j + 2 , k ) enddo enddo end do call transpose_y_to_z ( rw2b , rhs , ph ) if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z , nx , ny , nz ) fft_initialised = . true . end if ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'START' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! post-processing in spectral space ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after z' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bx ( i ) + tmp2 * ax ( i ), & tmp2 * bx ( i ) - tmp1 * ax ( i )) if ( i . gt .( nx / 2 + 1 )) cw1 ( i , j , k ) =- cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after x' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Y ! NEED TO BE IN Y PENCILS!!!!!!!!!!!!!!! call transpose_x_to_y ( cw1 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , 1 , k ) = cw2 ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2 ( i , j , k )) tmp2 = iy ( cw2 ( i , j , k )) tmp3 = rl ( cw2 ( i , ny - j + 2 , k )) tmp4 = iy ( cw2 ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) xx2 = tmp1 * ay ( j ) xx3 = tmp2 * by ( j ) xx4 = tmp2 * ay ( j ) xx5 = tmp3 * by ( j ) xx6 = tmp3 * ay ( j ) xx7 = tmp4 * by ( j ) xx8 = tmp4 * ay ( j ) cw2b ( i , j , k ) = half * cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( abs_prec ( cw2b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'after y' , i , j , k , cw2b ( i , j , k ) write ( * , * ) kxyz ( i , j , k ) end if end do end do end do #endif if ( istret == ISTRET_NO ) then ! Solve Poisson ! doing wave number division in Y-pencil do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) !CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw2b ( i , j , k ) = cx ( zero , zero ) end if if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw2b ( i , j , k ) = cx ( zero , iy ( cw2b ( i , j , k )) / ( - tmp2 )) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw2b ( i , j , k ) = cx ( rl ( cw2b ( i , j , k )) / ( - tmp1 ), zero ) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw2b ( i , j , k ) = cx ( rl ( cw2b ( i , j , k )) / ( - tmp1 ), iy ( cw2b ( i , j , k )) / ( - tmp2 )) end if end do end do end do else !call matrice_refinement() !write(*,*) 'PO_010 ii1 A rl ', rl(a(1,1,1,1)),rl(a(1,1,1,2)),rl(a(1,1,1,3)),& !                              rl(a(1,1,1,4)),rl(a(1,1,1,5)) !write(*,*) 'PO_010 ii1 A iy ', iy(a(1,1,1,1)),iy(a(1,1,1,2)),iy(a(1,1,1,3)),& !                              iy(a(1,1,1,4)),iy(a(1,1,1,5)) !! !write(*,*) 'PO_010 ii5 A rl ', rl(a(5,5,5,1)),rl(a(5,5,5,2)),rl(a(5,5,5,3)),& !                              rl(a(5,5,5,4)),rl(a(5,5,5,5)) !write(*,*) 'PO_010 ii5 A iy ', iy(a(5,5,5,1)),iy(a(5,5,5,2)),iy(a(5,5,5,3)),& !                              iy(a(5,5,5,4)),iy(a(5,5,5,5)) !! !write(*,*) 'PO_010 ii1 A2 rl ', rl(a2(1,1,1,1)),rl(a2(1,1,1,2)),rl(a2(1,1,1,3)),& !                               rl(a2(1,1,1,4)),rl(a2(1,1,1,5)) !write(*,*) 'PO_010 ii1 A2 iy ', iy(a2(1,1,1,1)),iy(a2(1,1,1,2)),iy(a2(1,1,1,3)),& !                               iy(a2(1,1,1,4)),iy(a2(1,1,1,5)) !! !write(*,*) 'PO_010 ii5 A2 rl ', rl(a2(5,5,5,1)),rl(a2(5,5,5,2)),rl(a2(5,5,5,3)),& !                               rl(a2(5,5,5,4)),rl(a2(5,5,5,5)) !write(*,*) 'PO_010 ii5 A2 iy ', iy(a2(5,5,5,1)),iy(a2(5,5,5,2)),iy(a2(5,5,5,3)),& !                               iy(a2(5,5,5,4)),iy(a2(5,5,5,5)) !!! !!! !write(*,*) 'PO_010 ii1 A3 rl ', rl(a3(1,1,1,1)),rl(a3(1,1,1,2)),rl(a3(1,1,1,3)),& !                          rl(a3(1,1,1,4)),rl(a3(1,1,1,5)) !write(*,*) 'PO_010 ii1 A3 iy ', iy(a3(1,1,1,1)),iy(a3(1,1,1,2)),iy(a3(1,1,1,3)),& !                          iy(a3(1,1,1,4)),iy(a3(1,1,1,5)) !! !write(*,*) 'PO_010 ii5 A3 rl ', rl(a3(5,5,5,1)),rl(a3(5,5,5,2)),rl(a3(5,5,5,3)),& !                             rl(a3(5,5,5,4)),rl(a3(5,5,5,5)) !write(*,*) 'PO_010 ii5 A3 iy ', iy(a3(5,5,5,1)),iy(a3(5,5,5,2)),iy(a3(5,5,5,3)),& !                             iy(a3(5,5,5,4)),iy(a3(5,5,5,5)) if ( istret /= ISTRET_BOTTOM ) then cw2 = zero cw2c = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny / 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , 2 * j - 1 , k ) cw2c ( i , j , k ) = cw2b ( i , 2 * j , k ) enddo enddo enddo call inversion5_v1 ( a , cw2 , sp ) call inversion5_v1 ( a2 , cw2c , sp ) cw2b = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny - 1 , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i ,( j + 1 ) / 2 , k ) enddo enddo do j = 2 , ny , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2c ( i , j / 2 , k ) enddo enddo enddo else do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , j , k ) enddo enddo enddo call inversion5_v2 ( a3 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i , j , k ) enddo enddo enddo endif endif !we are in Y pencil do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if (( i == nx / 2 + 1 ). and .( k == nz / 2 + 1 )) then cw2b ( i ,:, k ) = zero endif enddo enddo #ifdef DEBUG_FFT do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( abs_prec ( cw2b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER' , i , j , k , cw2b ( i , j , k ) write ( * , * ) kxyz ( i , j , k ) end if end do end do end do #endif ! post-processing backward ! POST PROCESSING IN Y do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , 1 , k ) = cw2b ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2b ( i , j , k )) tmp2 = iy ( cw2b ( i , j , k )) tmp3 = rl ( cw2b ( i , ny - j + 2 , k )) tmp4 = iy ( cw2b ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) xx2 = tmp1 * ay ( j ) xx3 = tmp2 * by ( j ) xx4 = tmp2 * ay ( j ) xx5 = tmp3 * by ( j ) xx6 = tmp3 * ay ( j ) xx7 = tmp4 * by ( j ) xx8 = tmp4 * ay ( j ) cw2 ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do ! Back to X-pencil call transpose_y_to_x ( cw2 , cw1 , sp ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER Y' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bx ( i ) - tmp2 * ax ( i ), & tmp2 * bx ( i ) + tmp1 * ax ( i )) if ( i > ( nx / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'AFTER X' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'END' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do ! compute c2r transform, back to physical space call decomp_2d_fft_3d ( cw1 , rhs ) ! rhs is in Z-pencil but requires global operations in Y call transpose_z_to_y ( rhs , rw2 , ph ) do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , 2 * j - 1 , k ) = rw2 ( i , j , k ) enddo do j = 1 , ny / 2 rw2b ( i , 2 * j , k ) = rw2 ( i , ny - j + 1 , k ) enddo enddo end do call transpose_y_to_z ( rw2b , rhs , ph ) !  call decomp_2d_fft_finalize return end subroutine poisson_010 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Solving 3D Poisson equation: Neumann in X, Y; Neumann/periodic in Z !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine poisson_11x ( rhs ) !use dbg_schemes, only: abs_prec use math_mod , only : abs_prec implicit none real ( mytype ), dimension (:,:,:), intent ( INOUT ) :: rhs complex ( mytype ) :: xyzk real ( mytype ) :: tmp1 , tmp2 , tmp3 , tmp4 real ( mytype ) :: xx1 , xx2 , xx3 , xx4 , xx5 , xx6 , xx7 , xx8 integer :: nx , ny , nz , i , j , k complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy #ifdef DEBUG_FFT real ( mytype ) avg_param #endif 100 format ( 1 x , a8 , 3 I4 , 2 F12 . 6 ) nx = nx_global - 1 ny = ny_global - 1 !write(*,*) 'Poisson_11x' if ( bcz == 1 ) then nz = nz_global - 1 else if ( bcz == 0 ) then nz = nz_global end if if ( bcz == 1 ) then do j = 1 , ph % zsz ( 2 ) do i = 1 , ph % zsz ( 1 ) do k = 1 , nz / 2 rw3 ( i , j , k ) = rhs ( i , j , 2 * ( k - 1 ) + 1 ) end do do k = nz / 2 + 1 , nz rw3 ( i , j , k ) = rhs ( i , j , 2 * nz - 2 * k + 2 ) end do end do end do call transpose_z_to_y ( rw3 , rw2 , ph ) else if ( bcz == 0 ) then call transpose_z_to_y ( rhs , rw2 , ph ) end if do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , j , k ) = rw2 ( i , 2 * ( j - 1 ) + 1 , k ) end do do j = ny / 2 + 1 , ny rw2b ( i , j , k ) = rw2 ( i , 2 * ny - 2 * j + 2 , k ) end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( rw2b , avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Start rw2 ' , avg_param #endif ! the global operations in X call transpose_y_to_x ( rw2b , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( i , j , k ) = rw1 ( 2 * ( i - 1 ) + 1 , j , k ) end do do i = nx / 2 + 1 , nx rw1b ( i , j , k ) = rw1 ( 2 * nx - 2 * i + 2 , j , k ) end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( rw1b , avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Start rw1 ' , avg_param #endif ! back to Z-pencil call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) if (. not . fft_initialised ) then call decomp_2d_fft_init ( PHYSICAL_IN_Z , nx , ny , nz ) fft_initialised = . true . end if ! compute r2c transform call decomp_2d_fft_3d ( rhs , cw1 ) ! normalisation cw1 = cw1 / real ( nx , kind = mytype ) / real ( ny , kind = mytype ) & / real ( nz , kind = mytype ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'START' , i , j , k , cw1 ( i , j , k ) end if end do end do end do #endif ! post-processing in spectral space ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) + tmp2 * az ( k ), & tmp2 * bz ( k ) - tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'after z' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Post in Z cw1 ' , avg_param #endif ! POST PROCESSING IN Y ! WE HAVE TO BE IN Y PENCILS call transpose_x_to_y ( cw1 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , 1 , k ) = cw2 ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2 ( i , j , k )) tmp2 = iy ( cw2 ( i , j , k )) tmp3 = rl ( cw2 ( i , ny - j + 2 , k )) tmp4 = iy ( cw2 ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) * half xx2 = tmp1 * ay ( j ) * half xx3 = tmp2 * by ( j ) * half xx4 = tmp2 * ay ( j ) * half xx5 = tmp3 * by ( j ) * half xx6 = tmp3 * ay ( j ) * half xx7 = tmp4 * by ( j ) * half xx8 = tmp4 * ay ( j ) * half cw2b ( i , j , k ) = cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw2 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Post in Y cw2 ' , avg_param #endif ! back to X-pencil call transpose_y_to_x ( cw2b , cw1 , sp ) #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'after y' , i , j , k , cw1 ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Back to X cw1 ' , avg_param #endif ! POST PROCESSING IN X do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1b ( 1 , j , k ) = cw1 ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) tmp3 = rl ( cw1 ( nx - i + 2 , j , k )) tmp4 = iy ( cw1 ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) * half xx2 = tmp1 * ax ( i ) * half xx3 = tmp2 * bx ( i ) * half xx4 = tmp2 * ax ( i ) * half xx5 = tmp3 * bx ( i ) * half xx6 = tmp3 * ax ( i ) * half xx7 = tmp4 * bx ( i ) * half xx8 = tmp4 * ax ( i ) * half cw1b ( i , j , k ) = cx ( xx1 + xx4 + xx5 - xx8 , & - xx2 + xx3 + xx6 + xx7 ) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , * ) 'BEFORE' , i , j , k , cw1b ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Back to X cw1b ' , avg_param #endif if ( istret == ISTRET_NO ) then ! Solve Poisson do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( kxyz ( i , j , k )) tmp2 = iy ( kxyz ( i , j , k )) !CANNOT DO A DIVISION BY ZERO if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( zero , zero ) end if if (( abs_prec ( tmp1 ) < epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( zero , iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) < epsilon )) then cw1b ( i , j , k ) = cx ( rl ( cw1b ( i , j , k )) / ( - tmp1 ), zero ) end if if (( abs_prec ( tmp1 ) >= epsilon ). and .( abs_prec ( tmp2 ) >= epsilon )) then cw1b ( i , j , k ) = cx ( real ( cw1b ( i , j , k )) / ( - tmp1 ), iy ( cw1b ( i , j , k )) / ( - tmp2 )) end if end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois istret 0 ' , avg_param #endif else call matrice_refinement () !write(*,*) 'PO_11X ii1 arl ', rl(a(1,1,1,1)),rl(a(1,1,1,2)),rl(a(1,1,1,3)),& !                              rl(a(1,1,1,4)),rl(a(1,1,1,5)) !write(*,*) 'PO_11X ii1 aiy ', iy(a(1,1,1,1)),iy(a(1,1,1,2)),iy(a(1,1,1,3)),& !                              iy(a(1,1,1,4)),iy(a(1,1,1,5)) !! !write(*,*) 'PO_11X ii5 arl ', rl(a(5,5,5,1)),rl(a(5,5,5,2)),rl(a(5,5,5,3)),& !                              rl(a(5,5,5,4)),rl(a(5,5,5,5)) !write(*,*) 'PO_11X ii5 aiy ', iy(a(5,5,5,1)),iy(a(5,5,5,2)),iy(a(5,5,5,3)),& !                              iy(a(5,5,5,4)),iy(a(5,5,5,5)) !! !write(*,*) 'PO_11X ii1 a2rl ', rl(a2(1,1,1,1)),rl(a2(1,1,1,2)),rl(a2(1,1,1,3)),& !                               rl(a2(1,1,1,4)),rl(a2(1,1,1,5)) !write(*,*) 'PO_11X ii1 a2iy ', iy(a2(1,1,1,1)),iy(a2(1,1,1,2)),iy(a2(1,1,1,3)),& !                               iy(a2(1,1,1,4)),iy(a2(1,1,1,5)) !! !write(*,*) 'PO_11X ii5 a2rl ', rl(a2(5,5,5,1)),rl(a2(5,5,5,2)),rl(a2(5,5,5,3)),& !                               rl(a2(5,5,5,4)),rl(a2(5,5,5,5)) !write(*,*) 'PO_11X ii5 a2iy ', iy(a2(5,5,5,1)),iy(a2(5,5,5,2)),iy(a2(5,5,5,3)),& !                               iy(a2(5,5,5,4)),iy(a2(5,5,5,5)) !!! !write(*,*) 'PO_11X ii1 rl ', rl(a3(1,1,1,1)),rl(a3(1,1,1,2)),rl(a3(1,1,1,3)),& !                             rl(a3(1,1,1,4)),rl(a3(1,1,1,5)) !write(*,*) 'PO_11X ii1 iy ', iy(a3(1,1,1,1)),iy(a3(1,1,1,2)),iy(a3(1,1,1,3)),& !                             iy(a3(1,1,1,4)),iy(a3(1,1,1,5)) !! !write(*,*) 'PO_11X ii1 rl ', rl(a3(5,5,5,1)),rl(a3(5,5,5,2)),rl(a3(5,5,5,3)),& !                             rl(a3(5,5,5,4)),rl(a3(5,5,5,5)) !write(*,*) 'PO_11X ii1 iy ', iy(a3(5,5,5,1)),iy(a3(5,5,5,2)),iy(a3(5,5,5,3)),& !                             iy(a3(5,5,5,4)),iy(a3(5,5,5,5)) ! the stretching is only working in Y pencils call transpose_x_to_y ( cw1b , cw2b , sp ) !we are now in Y pencil if ( istret /= ISTRET_BOTTOM ) then cw2 = zero cw2c = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny / 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , 2 * j - 1 , k ) cw2c ( i , j , k ) = cw2b ( i , 2 * j , k ) enddo enddo enddo call inversion5_v1 ( a , cw2 , sp ) call inversion5_v1 ( a2 , cw2c , sp ) cw2b = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny - 1 , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i ,( j + 1 ) / 2 , k ) enddo enddo do j = 2 , ny , 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2c ( i , j / 2 , k ) enddo enddo enddo #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw2b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois istret < 3 ' , avg_param #endif else cw2 = zero do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2 ( i , j , k ) = cw2b ( i , j , k ) enddo enddo enddo call inversion5_v2 ( a3 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , j , k ) = cw2 ( i , j , k ) enddo enddo enddo endif #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw2b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois istret = 3 ' , avg_param #endif !we have to go back in X pencils call transpose_y_to_x ( cw2b , cw1b , sp ) endif #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1b ( i , j , k )) > 1.0e-6 ) then write ( * , * ) 'AFTER' , i , j , k , cw1b ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois AFTER ' , avg_param #endif !stop ! post-processing backward do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1 ( 1 , j , k ) = cw1b ( 1 , j , k ) do i = 2 , nx tmp1 = rl ( cw1b ( i , j , k )) tmp2 = iy ( cw1b ( i , j , k )) tmp3 = rl ( cw1b ( nx - i + 2 , j , k )) tmp4 = iy ( cw1b ( nx - i + 2 , j , k )) xx1 = tmp1 * bx ( i ) xx2 = tmp1 * ax ( i ) xx3 = tmp2 * bx ( i ) xx4 = tmp2 * ax ( i ) xx5 = tmp3 * bx ( i ) xx6 = tmp3 * ax ( i ) xx7 = tmp4 * bx ( i ) xx8 = tmp4 * ax ( i ) cw1 ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do #ifdef DEBUG_FFT do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER X' , i , j , k , cw1 ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois POSTPR X ' , avg_param #endif ! POST PROCESSING IN Y ! NEED to be in Y-pencil call transpose_x_to_y ( cw1 , cw2 , sp ) do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) cw2b ( i , 1 , k ) = cw2 ( i , 1 , k ) do j = 2 , ny tmp1 = rl ( cw2 ( i , j , k )) tmp2 = iy ( cw2 ( i , j , k )) tmp3 = rl ( cw2 ( i , ny - j + 2 , k )) tmp4 = iy ( cw2 ( i , ny - j + 2 , k )) xx1 = tmp1 * by ( j ) xx2 = tmp1 * ay ( j ) xx3 = tmp2 * by ( j ) xx4 = tmp2 * ay ( j ) xx5 = tmp3 * by ( j ) xx6 = tmp3 * ay ( j ) xx7 = tmp4 * by ( j ) xx8 = tmp4 * ay ( j ) cw2b ( i , j , k ) = cx ( xx1 - xx4 + xx6 + xx7 , & - ( - xx2 - xx3 + xx5 - xx8 )) end do end do end do #ifdef DEBUG_FFT do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if ( abs_prec ( cw2b ( i , j , k )) > 1.0e-4_mytype ) then write ( * , 100 ) 'AFTER Y' , i , j , k , cw2b ( i , j , k ) end if end do end do end do avg_param = zero call avg3d ( abs_prec ( cw2b ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois POSTPR Y ' , avg_param #endif ! back to X-pencil call transpose_y_to_x ( cw2b , cw1 , sp ) ! POST PROCESSING IN Z do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) tmp1 = rl ( cw1 ( i , j , k )) tmp2 = iy ( cw1 ( i , j , k )) cw1 ( i , j , k ) = cx ( tmp1 * bz ( k ) - tmp2 * az ( k ), & tmp2 * bz ( k ) + tmp1 * az ( k )) #ifdef DEBUG_FFT if ( abs_prec ( cw1 ( i , j , k )) > 1.0e-4_mytype ) & write ( * , 100 ) 'END' , i , j , k , cw1 ( i , j , k ) #endif end do end do end do #ifdef DEBUG_FFT avg_param = zero call avg3d ( abs_prec ( cw1 ), avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois POSTPR Z ' , avg_param #endif ! compute c2r transform, back to physical space call decomp_2d_fft_3d ( cw1 , rhs ) #ifdef DEBUG_FFT avg_param = zero call avg3d ( rhs , avg_param ) if ( nrank == 0 ) write ( * , * ) '## Poisson11X Solve Pois Back Phy RHS ' , avg_param #endif if ( bcz == 1 ) then do j = 1 , ph % zsz ( 2 ) do i = 1 , ph % zsz ( 1 ) do k = 1 , nz / 2 rw3 ( i , j , 2 * k - 1 ) = rhs ( i , j , k ) end do do k = 1 , nz / 2 rw3 ( i , j , 2 * k ) = rhs ( i , j , nz - k + 1 ) end do end do end do call transpose_z_to_y ( rw3 , rw2 , ph ) else if ( bcz == 0 ) then call transpose_z_to_y ( rhs , rw2 , ph ) end if do k = ph % yst ( 3 ), ph % yen ( 3 ) do i = ph % yst ( 1 ), ph % yen ( 1 ) do j = 1 , ny / 2 rw2b ( i , 2 * j - 1 , k ) = rw2 ( i , j , k ) end do do j = 1 , ny / 2 rw2b ( i , 2 * j , k ) = rw2 ( i , ny - j + 1 , k ) end do enddo end do call transpose_y_to_x ( rw2b , rw1 , ph ) do k = ph % xst ( 3 ), ph % xen ( 3 ) do j = ph % xst ( 2 ), ph % xen ( 2 ) do i = 1 , nx / 2 rw1b ( 2 * i - 1 , j , k ) = rw1 ( i , j , k ) enddo do i = 1 , nx / 2 rw1b ( 2 * i , j , k ) = rw1 ( nx - i + 1 , j , k ) enddo enddo end do call transpose_x_to_y ( rw1b , rw2 , ph ) call transpose_y_to_z ( rw2 , rhs , ph ) !  call decomp_2d_fft_finalize return end subroutine poisson_11x !========================================================================================================== ! complex unit half: !   positive = e&#94;{I PI/N * k} = cos(PI/N * k ) + i sin(PI/N * k) !   negtive = e&#94;{-I PI/N * k} = cos(PI/N * k ) + i sin(-PI/N * k) !========================================================================================================== subroutine complex_half_unit integer :: i , j , k real ( mytype ) :: a , b real ( mytype ) :: theta ! theta = pi/n, or 1/2 pi/n !---------------------------------------------------------------------------------------------------------- ! x unit !---------------------------------------------------------------------------------------------------------- if ( bcx == 0 ) then theta = PI / real ( nx , kind = mytype ) elseif ( bcx == 1 ) then theta = PI * half / real ( nx , kind = mytype ) end if do i = 1 , nx wx ( i ) = real ( i - 1 , kind = mytype ) * theta a = sin_prec ( wx ( i ) ) b = cos_prec ( wx ( i ) ) cplx_circle_unit_halfx ( i ) = CMPLX ( b , a ) end do !---------------------------------------------------------------------------------------------------------- ! y unit !---------------------------------------------------------------------------------------------------------- if ( bcy == 0 ) then theta = PI / real ( ny , kind = mytype ) elseif ( bcy == 1 ) then theta = PI * half / real ( ny , kind = mytype ) end if do j = 1 , ny wy ( j ) = real ( j - 1 , kind = mytype ) * theta a = sin_prec ( wy ( j ) ) b = cos_prec ( wy ( j ) ) cplx_circle_unit_halfy ( j ) = CMPLX ( b , a ) end do !---------------------------------------------------------------------------------------------------------- ! z unit !---------------------------------------------------------------------------------------------------------- if ( bcz == 0 ) then theta = PI / real ( nz , kind = mytype ) elseif ( bcz == 1 ) then theta = PI * half / real ( nz , kind = mytype ) end if do k = 1 , nz wz ( k ) = real ( k - 1 , kind = mytype ) * theta a = sin_prec ( wz ( k ) ) b = cos_prec ( wz ( k ) ) cplx_circle_unit_halfz ( k ) = CMPLX ( b , a ) end do return end subroutine complex_half_unit !========================================================================================================== ! FFT lib operates below calculation (forward, after fft): !   <f>_k&#94;i = 1/N * sum_{k = 0}&#94;{N-1} f_i e&#94;{- I k_x x_i} = 1/N * sum_{k = 0}&#94;{N-1} f_i e&#94;{- I 2 pi/N * k i} ! if input is located at i+1/2, then !  <f>_k&#94;{i+1/2} = 1/N * sum_{k = 0}&#94;{N-1} f_{i+1/2} e&#94;{- I k_x x_{i+1/2}} !                = 1/N * sum_{k = 0}&#94;{N-1} f_{i+1/2} e&#94;{- I k_x x_{i}} * e&#94;{-I k_x 1/2 dx} !                = e&#94;{-I k_x 1/2 dx} * 1/N * sum_{k = 0}&#94;{N-1} f_{i+1/2} e&#94;{- I k_x x_{i}} !                = e&#94;{-I k_x 1/2 dx} *  <f> !                = <f> shifted backward !                = [cos(k_x * 1/2 * dx) - I sin(k_x * 1/2 * dx) ] * FFT_lib_caculated a sequence of data without grid info. !                = (bx - I ax)(tmp1 + I tmp2) !                =  (bx * tmp1 + ax * tmp2) + I (bx * tmp2 - ax * tmp1) ! FFT lib operates below calculation (backward, before ifft): !   f_{i} = sum_{k = 0}&#94;{N-1} <f>_k e&#94;{I k_x x_i} = sum_{k = 0}&#94;{N-1} <f>_k e&#94;{I 2 pi/N * k i} ! if input is located at i+1/2, then !  f_{i+1/2} = sum_{k = 0}&#94;{N-1} <f>_{i+1/2} e&#94;{I k_x x_{i+1/2}} !            = sum_{k = 0}&#94;{N-1} <f>_{i+1/2} e&#94;{I k_x x_{i}} * e&#94;{I k_x 1/2 dx} !            = sum_{k = 0}&#94;{N-1} (<f>_{i+1/2} e&#94;{I k_x 1/2 dx}) *  e&#94;{ I k_x x_{i}} !            = sum_{k = 0}&#94;{N-1} <f>_shifted *  e&#94;{ I k_x x_{i}} !    <f>_shifted_forward = (<f>_{i+1/2} e&#94;{I k_x 1/2 dx}) !                = (bx + I ax)(tmp1 + I tmp2) !                = (bx * tmp1 - ax * tmp2) + i (ax * tmp1 + bx * tmp2) ! isign = 1,  multiplied by !========================================================================================================== subroutine fft3d_sp_shift_half_x0 ( cw1 , isign ) ! input, output both x-pencil, periodic implicit none complex ( mytype ), dimension ( sp % xst ( 1 ) : sp % xen ( 1 ), & sp % xst ( 2 ) : sp % xen ( 2 ), & sp % xst ( 3 ) : sp % xen ( 3 )), intent ( inout ) :: cw1 integer , intent ( in ) :: isign complex ( mytype ) :: cplx_circle_unit , cw_cp ! all based on x-pencil do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) if ( isign == IBACKWARD ) then cplx_circle_unit = CONJG ( cplx_circle_unit_halfx ( i )) else if ( isign == IFORWARD ) then cplx_circle_unit = cplx_circle_unit_halfx ( i ) end if cw1 ( i , j , k ) = cw1 ( i , j , k ) * cplx_circle_unit if ( i > ( nx / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) end do end do end do return end subroutine fft3d_sp_shift_half_x0 subroutine fft3d_sp_shift_half_x1 ( cw1 , isign ) ! input, output both x-pencil, x non-periodic implicit none complex ( mytype ), dimension ( sp % xst ( 1 ) : sp % xen ( 1 ), & sp % xst ( 2 ) : sp % xen ( 2 ), & sp % xst ( 3 ) : sp % xen ( 3 )), intent ( inout ) :: cw1 complex ( mytype ), dimension ( sp % xst ( 1 ) : sp % xen ( 1 )) :: cw1b complex ( mytype ) :: cplx_circle_unit_neg , cplx_circle_unit_pos , cw_cp ! this is based the specified data reconstruction, not universal. nx = nx_global - 1 do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) cw1b ( 1 ) = cw1 ( 1 , j , k ) do i = 2 , nx cplx_circle_unit_pos = cplx_circle_unit_halfx ( i ) cplx_circle_unit_neg = CONJG ( cplx_circle_unit_halfx ( i )) cw_cp = cw1 ( nx - i + 2 , j , k ) if ( isign == IBACKWARD ) then cw1b ( i ) = half * cw1 ( i , j , k ) * cplx_circle_unit_neg + & cw_cp * cplx_circle_unit_pos else if ( isign == IFORWARD ) then cw1b ( i ) = cw1 ( i , j , k ) * cplx_circle_unit_pos + & cw_cp * cplx_circle_unit_neg end if end do cw1 ( i , j , k ) = cw1b ( i ) end do end do return end subroutine fft3d_sp_shift_half_x1 subroutine fft3d_sp_shift_half_y0 ( cw1 , isign ) implicit none complex ( mytype ), dimension ( sp % xst ( 1 ) : sp % xen ( 1 ), & sp % xst ( 2 ) : sp % xen ( 2 ), & sp % xst ( 3 ) : sp % xen ( 3 )), intent ( in ) :: cw1 integer , intent ( in ) :: isign complex ( mytype ) :: cplx_circle_unit_neg , cplx_circle_unit_pos , cw_cp ! all based on x-pencil do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) if ( isign == IBACKWARD ) then cplx_circle_unit = CONJG ( cplx_circle_unit_halfy ( j )) else if ( isign == IFORWARD ) then cplx_circle_unit = cplx_circle_unit_halfy ( j ) end if do i = sp % xst ( 1 ), sp % xen ( 1 ) cw1 ( i , j , k ) = cw1 ( i , j , k ) * cplx_circle_unit_neg end do if ( j > ( ny / 2 + 1 )) cw1 ( i , j , k ) = - cw1 ( i , j , k ) end do end do return end subroutine fft3d_sp_shift_half_y0 subroutine fft3d_sp_shift_half_y1 ( cw1 ) implicit none complex ( mytype ), dimension ( sp % xst ( 1 ) : sp % xen ( 1 ), & sp % xst ( 2 ) : sp % xen ( 2 ), & sp % xst ( 3 ) : sp % xen ( 3 )), intent ( in ) :: cw1 complex ( mytype ), dimension ( sp % yst ( 1 ) : sp % yen ( 1 )) :: cw1b complex ( mytype ) :: cplx_circle_unit_neg , cplx_circle_unit_pos , cw_cp ! all based on y-pencil ! this is based the specified data reconstruction, not universal. ny = ny_global - 1 do k = sp % xst ( 3 ), sp % xen ( 3 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) cw2b ( 1 ) = cw2 ( i , 1 , k ) do j = 2 , ny cplx_circle_unit_pos = cplx_circle_unit_halfy ( j ) cplx_circle_unit_neg = CONJG ( cplx_circle_unit_halfy ( j )) cw_cp = cw1 ( i , ny - j + 2 , k ) if ( isign == IBACKWARD ) then cw1b ( j ) = half * cw1 ( i , j , k ) * cplx_circle_unit_neg + & cw_cp * cplx_circle_unit_pos else if ( isign == IFORWARD ) then cw1b ( j ) = cw1 ( i , j , k ) * cplx_circle_unit_pos + & cw_cp * cplx_circle_unit_neg end if end do cw1 ( i , j , k ) = cw1b ( j ) end do end do return end subroutine fft3d_sp_shift_half_y1 subroutine fft3d_sp_shift_half_z0 ( cw1 , isign ) implicit none complex ( mytype ), dimension ( sp % xst ( 1 ) : sp % xen ( 1 ), & sp % xst ( 2 ) : sp % xen ( 2 ), & sp % xst ( 3 ) : sp % xen ( 3 )), intent ( in ) :: cw1 integer , intent ( in ) :: isign complex ( mytype ) :: cplx_circle_unit_neg , cplx_circle_unit_pos , cw_cp ! all based on x-pencil do k = sp % xst ( 3 ), sp % xen ( 3 ) if ( isign == IBACKWARD ) then cplx_circle_unit = CONJG ( cplx_circle_unit_halfz ( k )) else if ( isign == IFORWARD ) then cplx_circle_unit = cplx_circle_unit_halfz ( k ) end if do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) cw1 ( i , j , k ) = cw1 ( i , j , k ) * cplx_circle_unit_neg end do end do end do return end subroutine fft3d_sp_shift_half_z0 subroutine ! *********************************************************** ! subroutine waves () use decomp_2d use decomp_2d_fft use poisson_interface_mod implicit none integer :: i , j , k , nn real ( mytype ) :: w , wp , w1 , w1p xk2 = zero ykz = zero zk2 = zero kxyz = zero !---------------------------------------------------------------------------------------------------------- !WAVE NUMBER IN X !---------------------------------------------------------------------------------------------------------- if ( bcx == 0 ) then nn = nx / 2 + 1 else nn = nx end if do i = 1 , nn w = two * wx ( i ) wp = acix6 * two * sin_prec ( half * w ) + & bcix6 * two * sin_prec ( three * half * w ) xkx ( i ) = wp / ( one + two * alcaix6 * cos_prec ( w )) xk2 ( i ) = cx_one_one * ( xkx ( i ) ** 2 ) enddo if ( bcx == 0 ) then do i = nn + 1 , nx xk2 ( i ) = xk2 ( nx - i + 2 ) enddo else xk2 ( 1 ) = zero endif !---------------------------------------------------------------------------------------------------------- !WAVE NUMBER IN Y !---------------------------------------------------------------------------------------------------------- if ( bcy == 0 ) then nn = ny / 2 + 1 else nn = ny end if do j = 1 , nn w = two * wy ( j ) wp = aciy6 * two * sin_prec ( half * w ) + & bciy6 * two * sin_prec ( three * half * w ) if ( istret == ISTRET_NO ) yky ( j ) = wp / ( one + two * alcaiy6 * cos_prec ( w )) if ( istret /= ISTRET_NO ) yky ( j ) = wp / ( one + two * alcaiy6 * cos_prec ( w )) * yly yk2 ( j ) = cx_one_one * ( yky ( j ) ** 2 ) enddo if ( bcy == 0 ) then do j = nn + 1 , ny yk2 ( j ) = yk2 ( ny - j + 2 ) enddo else yk2 ( 1 ) = zero endif !---------------------------------------------------------------------------------------------------------- !WAVE NUMBER IN Z !---------------------------------------------------------------------------------------------------------- nn = nz / 2 + 1 do k = 1 , nn w = two * wz ( k ) wp = aciz6 * two * sin_prec ( half * w ) + & bciz6 * two * sin_prec ( three * half * w ) zkz ( k ) = wp / ( one + two * alcaiz6 * cos_prec ( w )) if ( bcz == 0 ) then zk2 ( j ) = cx_one_one * ( zkz ( k ) ** 2 ) else w_cp = two * wz ( nz - k + 1 ) wp_cp = aciz6 * two * sin_prec ( half * w_cp ) + & bciz6 * two * sin_prec ( three * half * w_cp ) zkz_cp ( k ) = - wp_cp / ( one + two * alcaiz6 * cos_prec ( w_cp )) zk2 ( k ) = cx ( zkz ( k ) ** 2 , zkz_cp ( k ) ** 2 ) end if enddo !---------------------------------------------------------------------------------------------------------- !combine all three directions !---------------------------------------------------------------------------------------------------------- if (( bcx == 0 ). and .( bcz == 0 ). and .( bcy /= 0 )) then do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = sp % yst ( 2 ), sp % yen ( 2 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) kxyz ( i , j , k ) = xk2 ( i ) + yk2 ( j ) + zk2 ( k ) enddo enddo enddo else do k = sp % xst ( 3 ), sp % xen ( 3 ) do j = sp % xst ( 2 ), sp % xen ( 2 ) do i = sp % xst ( 1 ), sp % xen ( 1 ) kxyz ( i , j , k ) = xk2 ( i ) + yk2 ( j ) + zk2 ( k ) enddo enddo enddo endif return end subroutine waves !************************************************************************** ! subroutine matrice_refinement () ! !************************************************************************** use decomp_2d !use variables !use param !use var !use MPI !use derivX !use derivY !use derivZ !use dbg_schemes, only: cos_prec implicit none integer :: i , j , k complex ( mytype ), dimension ( sp % yst ( 1 ): sp % yen ( 1 )) :: transx complex ( mytype ), dimension ( sp % yst ( 2 ): sp % yen ( 2 )) :: transy complex ( mytype ), dimension ( sp % yst ( 3 ): sp % yen ( 3 )) :: transz real ( mytype ), dimension ( sp % yst ( 1 ): sp % yen ( 1 )) :: transx_rl , transx_rl2 real ( mytype ), dimension ( sp % yst ( 2 ): sp % yen ( 2 )) :: transy_rl , transy_rl2 real ( mytype ), dimension ( sp % yst ( 3 ): sp % yen ( 3 )) :: transz_rl , transz_iy , transz_rl2 , transz_iy2 real ( mytype ) :: xa0 , xa1 complex ( mytype ) :: ytt , xtt , ztt , yt1 , xt1 , yt2 , xt2 complex ( mytype ) :: xtt1 , ytt1 , ztt1 , zt1 , zt2 , tmp1 , tmp2 , tmp3 complex ( mytype ) :: cx real ( mytype ) :: rl , iy external cx , rl , iy real ( mytype ) :: xtt_rl , xtt1_rl , xt1_rl real ( mytype ) :: rlexs real ( mytype ) :: ytt_rl , ytt1_rl , yt1_rl real ( mytype ) :: rleys real ( mytype ) :: ztt_rl , ztt1_rl , zt1_rl real ( mytype ) :: rlezs , iyezs ! real ( mytype ) :: xa0_2 , xa1_2 , xa01 , xa0p1_2 ! if (( istret == ISTRET_CENTRE ) . or . ( istret == ISTRET_2SIDES )) then ! xa0 = alpha / pi + half / beta / pi if ( istret == ISTRET_CENTRE ) xa1 = + one / four / beta / pi if ( istret == ISTRET_2SIDES ) xa1 = - one / four / beta / pi ! xa0_2 = xa0 ** 2 xa1_2 = xa1 ** 2 xa01 = xa0 * xa1 xa0p1_2 = ( xa0 + xa1 ) ** 2 ! !      construction of the pentadiagonal matrice ! do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , ny / 2 do i = sp % yst ( 1 ), sp % yen ( 1 ) ! cw22 ( i , j , k ) = yky ( 2 * j - 1 ) cw2 ( i , j , k ) = yky ( 2 * j ) ! enddo enddo enddo !main diagonal do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 2 , ny / 2 - 1 do i = sp % yst ( 1 ), sp % yen ( 1 ) a ( i , j , k , 3 ) =- cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0_2 * rl ( cw22 ( i , j , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , j , k )) * ( rl ( cw22 ( i , j - 1 , k )) + rl ( cw22 ( i , j + 1 , k ))), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw22 ( i , j , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , j , k )) * ( iy ( cw22 ( i , j - 1 , k )) + iy ( cw22 ( i , j + 1 , k ))) ) ! a2 ( i , j , k , 3 ) =- cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0_2 * rl ( cw2 ( i , j , k )) ** 2 & + xa1_2 * rl ( cw2 ( i , j , k )) * ( rl ( cw2 ( i , j - 1 , k )) + rl ( cw2 ( i , j + 1 , k ))), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw2 ( i , j , k )) ** 2 & + xa1_2 * iy ( cw2 ( i , j , k )) * ( iy ( cw2 ( i , j - 1 , k )) + iy ( cw2 ( i , j + 1 , k )))) enddo enddo ! do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , 1 , k , 3 ) =- cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0_2 * rl ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , 1 , k )) * rl ( cw22 ( i , 2 , k )),& iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , 1 , k )) * iy ( cw22 ( i , 2 , k ))) ! a ( i , ny / 2 , k , 3 ) =- cx ( rl ( xk2 ( i )) + rl ( zk2 ( k ))& + xa0_2 * rl ( cw22 ( i , ny / 2 , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , ny / 2 , k )) * rl ( cw22 ( i , ny / 2 - 1 , k )), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw22 ( i , ny / 2 , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , ny / 2 , k )) * iy ( cw22 ( i , ny / 2 - 1 , k ))) ! a2 ( i , 1 , k , 3 ) =- cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + ( xa0_2 - xa1_2 ) * rl ( cw2 ( i , 1 , k )) ** 2 & + xa1_2 * rl ( cw2 ( i , 1 , k )) * rl ( cw2 ( i , 2 , k )), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + ( xa0_2 - xa1_2 ) * iy ( cw2 ( i , 1 , k )) ** 2 & + xa1_2 * iy ( cw2 ( i , 1 , k )) * iy ( cw2 ( i , 2 , k ))) ! a2 ( i , ny / 2 , k , 3 ) =- cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0p1_2 * rl ( cw2 ( i , ny / 2 , k )) ** 2 & + xa1_2 * rl ( cw2 ( i , ny / 2 , k )) * rl ( cw2 ( i , ny / 2 - 1 , k )), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0p1_2 * iy ( cw2 ( i , ny / 2 , k )) ** 2 & + xa1_2 * iy ( cw2 ( i , ny / 2 , k )) * iy ( cw2 ( i , ny / 2 - 1 , k ))) ! enddo enddo !sup diag +1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 2 , ny / 2 - 1 do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , j , k , 4 ) = xa01 * cx ( rl ( cw22 ( i , j + 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j + 1 , k ))), & iy ( cw22 ( i , j + 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j + 1 , k )))) ! a2 ( i , j , k , 4 ) = xa01 * cx ( rl ( cw2 ( i , j + 1 , k )) * ( rl ( cw2 ( i , j , k )) + rl ( cw2 ( i , j + 1 , k ))), & iy ( cw2 ( i , j + 1 , k )) * ( iy ( cw2 ( i , j , k )) + iy ( cw2 ( i , j + 1 , k )))) ! enddo enddo ! do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a ( i , 1 , k , 4 ) = two * xa01 * cx ( rl ( cw22 ( i , 1 , k )) * rl ( cw22 ( i , 2 , k )) + & rl ( cw22 ( i , 2 , k )) * rl ( cw22 ( i , 2 , k )), & iy ( cw22 ( i , 1 , k )) * iy ( cw22 ( i , 2 , k )) + & iy ( cw22 ( i , 2 , k )) * iy ( cw22 ( i , 2 , k ))) ! a2 ( i , 1 , k , 4 ) = cx (( xa0 - xa1 ) * xa1 * ( rl ( cw2 ( i , 1 , k )) * rl ( cw2 ( i , 2 , k ))) + & xa0 * xa1 * ( rl ( cw2 ( i , 2 , k )) * rl ( cw2 ( i , 2 , k ))) , & ( xa0 - xa1 ) * xa1 * ( iy ( cw2 ( i , 1 , k )) * iy ( cw2 ( i , 2 , k ))) + & xa0 * xa1 * ( iy ( cw2 ( i , 2 , k )) * iy ( cw2 ( i , 2 , k ))) ) ! a2 ( i , ny / 2 - 1 , k , 4 ) = cx ( xa0 * xa1 * rl ( cw2 ( i , ny / 2 - 1 , k )) * rl ( cw2 ( i , ny / 2 , k )) + & ( xa0 + xa1 ) * xa1 * ( rl ( cw2 ( i , ny / 2 , k )) ** 2 ), & xa0 * xa1 * iy ( cw2 ( i , ny / 2 - 1 , k )) * iy ( cw2 ( i , ny / 2 , k )) + & ( xa0 + xa1 ) * xa1 * ( iy ( cw2 ( i , ny / 2 , k )) ** 2 )) ! a2 ( i , ny / 2 , k , 4 ) = zero ! enddo enddo ! !sup diag +2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 1 , ny / 2 - 2 ! a ( i , j , k , 5 ) = xa1_2 * cx ( - rl ( cw22 ( i , j + 1 , k )) * rl ( cw22 ( i , j + 2 , k )),& - iy ( cw22 ( i , j + 1 , k )) * iy ( cw22 ( i , j + 2 , k ))) a2 ( i , j , k , 5 ) = xa1_2 * cx ( - rl ( cw2 ( i , j + 1 , k )) * rl ( cw2 ( i , j + 2 , k )),& - iy ( cw2 ( i , j + 1 , k )) * iy ( cw2 ( i , j + 2 , k ))) ! enddo ! a ( i , 1 , k , 5 ) = two * cx ( rl ( a ( i , 1 , k , 5 )), iy ( a ( i , 1 , k , 5 ))) a ( i , ny / 2 - 1 , k , 5 ) = zero a ( i , ny / 2 , k , 5 ) = zero a2 ( i , ny / 2 - 1 , k , 5 ) = zero a2 ( i , ny / 2 , k , 5 ) = zero ! enddo enddo !inf diag -1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 2 , ny / 2 a ( i , j , k , 2 ) = xa01 * cx ( rl ( cw22 ( i , j - 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j - 1 , k ))), & iy ( cw22 ( i , j - 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j - 1 , k )))) a2 ( i , j , k , 2 ) = xa01 * cx ( rl ( cw2 ( i , j - 1 , k )) * ( rl ( cw2 ( i , j , k )) + rl ( cw2 ( i , j - 1 , k ))), & iy ( cw2 ( i , j - 1 , k )) * ( iy ( cw2 ( i , j , k )) + iy ( cw2 ( i , j - 1 , k )))) enddo a ( i , 1 , k , 2 ) = zero a2 ( i , 1 , k , 2 ) = zero a2 ( i , 2 , k , 2 ) = cx ( xa0 * xa1 * ( rl ( cw2 ( i , 2 , k )) * rl ( cw2 ( i , 1 , k ))) & + ( xa0 + xa1 ) * xa1 * ( rl ( cw2 ( i , 1 , k )) * rl ( cw2 ( i , 1 , k ))), & xa0 * xa1 * ( iy ( cw2 ( i , 2 , k )) * iy ( cw2 ( i , 1 , k ))) & + ( xa0 + xa1 ) * xa1 * ( iy ( cw2 ( i , 1 , k )) * iy ( cw2 ( i , 1 , k )))) a2 ( i , ny / 2 , k , 2 ) = cx (( xa0 + xa1 ) * xa1 * ( rl ( cw2 ( i , ny / 2 , k )) * rl ( cw2 ( i , ny / 2 - 1 , k ))) & + xa0 * xa1 * ( rl ( cw2 ( i , ny / 2 - 1 , k )) * rl ( cw2 ( i , ny / 2 - 1 , k ))), & ( xa0 + xa1 ) * xa1 * ( iy ( cw2 ( i , ny / 2 , k )) * iy ( cw2 ( i , ny / 2 - 1 , k ))) & + xa0 * xa1 * ( iy ( cw2 ( i , ny / 2 - 1 , k )) * iy ( cw2 ( i , ny / 2 - 1 , k )))) ! enddo enddo !inf diag -2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 3 , ny / 2 a ( i , j , k , 1 ) = xa1_2 * cx ( - rl ( cw22 ( i , j - 1 , k )) * rl ( cw22 ( i , j - 2 , k )),& - iy ( cw22 ( i , j - 1 , k )) * iy ( cw22 ( i , j - 2 , k ))) a2 ( i , j , k , 1 ) = xa1_2 * cx ( - rl ( cw2 ( i , j - 1 , k )) * rl ( cw2 ( i , j - 2 , k )),& - iy ( cw2 ( i , j - 1 , k )) * iy ( cw2 ( i , j - 2 , k ))) enddo a ( i , 1 , k , 1 ) = zero a ( i , 2 , k , 1 ) = zero a2 ( i , 1 , k , 1 ) = zero a2 ( i , 2 , k , 1 ) = zero enddo enddo !not to have a singular matrice do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) if (( rl ( xk2 ( i )) == zero ). and .( rl ( zk2 ( k )) == zero )) then a ( i , 1 , k , 3 ) = cx_one_one a ( i , 1 , k , 4 ) = zero a ( i , 1 , k , 5 ) = zero endif enddo enddo ! else ! xa0 = alpha / pi + half / beta / pi xa1 = - one / four / beta / pi ! xa0_2 = xa0 ** 2 xa1_2 = xa1 ** 2 xa01 = xa0 * xa1 ! !construction of the pentadiagonal matrice ! do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 1 , nym do i = sp % yst ( 1 ), sp % yen ( 1 ) cw22 ( i , j , k ) = yky ( j ) enddo enddo enddo !main diagonal do k = sp % yst ( 3 ), sp % yen ( 3 ) do j = 2 , nym - 1 do i = sp % yst ( 1 ), sp % yen ( 1 ) a3 ( i , j , k , 3 ) = - cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0_2 * rl ( cw22 ( i , j , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , j , k )) * ( rl ( cw22 ( i , j - 1 , k )) + rl ( cw22 ( i , j + 1 , k ))), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw22 ( i , j , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , j , k )) * ( iy ( cw22 ( i , j - 1 , k )) + iy ( cw22 ( i , j + 1 , k )))) enddo enddo enddo do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) ! a3 ( i , 1 , k , 3 ) = - cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0_2 * rl ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , 1 , k )) * rl ( cw22 ( i , 2 , k )),& iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw22 ( i , 1 , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , 1 , k )) * iy ( cw22 ( i , 2 , k ))) ! a3 ( i , nym , k , 3 ) = - cx ( rl ( xk2 ( i )) + rl ( zk2 ( k )) & + xa0_2 * rl ( cw22 ( i , nym , k )) ** 2 & + xa1_2 * rl ( cw22 ( i , nym , k )) * rl ( cw22 ( i , nym - 1 , k )), & iy ( xk2 ( i )) + iy ( zk2 ( k )) & + xa0_2 * iy ( cw22 ( i , nym , k )) ** 2 & + xa1_2 * iy ( cw22 ( i , nym , k )) * iy ( cw22 ( i , nym - 1 , k ))) ! enddo enddo !sup diag +1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 2 , nym - 1 a3 ( i , j , k , 4 ) = xa01 * cx ( rl ( cw22 ( i , j + 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j + 1 , k ))), & iy ( cw22 ( i , j + 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j + 1 , k )))) enddo a3 ( i , 1 , k , 4 ) = xa01 * cx ( rl ( cw22 ( i , 2 , k )) * ( rl ( cw22 ( i , 1 , k )) + rl ( cw22 ( i , 2 , k ))), & iy ( cw22 ( i , 2 , k )) * ( iy ( cw22 ( i , 1 , k )) + iy ( cw22 ( i , 2 , k )))) enddo enddo !sup diag +2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 1 , nym - 2 a3 ( i , j , k , 5 ) = - xa1_2 * cx ( rl ( cw22 ( i , j + 1 , k )) * rl ( cw22 ( i , j + 2 , k )), & iy ( cw22 ( i , j + 1 , k )) * iy ( cw22 ( i , j + 2 , k ))) enddo a3 ( i , nym - 1 , k , 5 ) = zero a3 ( i , nym , k , 5 ) = zero enddo enddo !inf diag -1 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 2 , nym a3 ( i , j , k , 2 ) = xa01 * cx ( rl ( cw22 ( i , j - 1 , k )) * ( rl ( cw22 ( i , j , k )) + rl ( cw22 ( i , j - 1 , k ))), & iy ( cw22 ( i , j - 1 , k )) * ( iy ( cw22 ( i , j , k )) + iy ( cw22 ( i , j - 1 , k )))) enddo a3 ( i , 1 , k , 2 ) = zero enddo enddo !inf diag -2 do k = sp % yst ( 3 ), sp % yen ( 3 ) do i = sp % yst ( 1 ), sp % yen ( 1 ) do j = 3 , nym a3 ( i , j , k , 1 ) = - xa1_2 * cx ( rl ( cw22 ( i , j - 1 , k )) * rl ( cw22 ( i , j - 2 , k )),& iy ( cw22 ( i , j - 1 , k )) * iy ( cw22 ( i , j - 2 , k ))) enddo a3 ( i , 1 , k , 1 ) = zero a3 ( i , 2 , k , 1 ) = zero enddo enddo !not to have a singular matrice if ( nrank == 0 ) then a3 ( 1 , 1 , 1 , 3 ) = cx_one_one a3 ( 1 , 1 , 1 , 4 ) = zero a3 ( 1 , 1 , 1 , 5 ) = zero endif endif return end subroutine matrice_refinement !===================================== subroutine avg3d ( var , avg ) use decomp_2d , only : real_type , xsize , xend !use param !use dbg_schemes, only: sqrt_prec !use variables, only: nx,ny,nz,nxm,nym,nzm !use mpi implicit none real ( mytype ), dimension ( xsize ( 1 ), xsize ( 2 ), xsize ( 3 )), intent ( in ) :: var real ( mytype ), intent ( out ) :: avg real ( mytype ) :: dep integer :: i , j , k , code integer :: nxc , nyc , nzc , xsize1 , xsize2 , xsize3 if ( nclx1 == 1. and . xend ( 1 ) == nx ) then xsize1 = xsize ( 1 ) - 1 else xsize1 = xsize ( 1 ) endif if ( ncly1 == 1. and . xend ( 2 ) == ny ) then xsize2 = xsize ( 2 ) - 1 else xsize2 = xsize ( 2 ) endif if ( nclz1 == 1. and . xend ( 3 ) == nz ) then xsize3 = xsize ( 3 ) - 1 else xsize3 = xsize ( 3 ) endif if ( nclx1 == 1 ) then nxc = nxm else nxc = nx endif if ( ncly1 == 1 ) then nyc = nym else nyc = ny endif if ( nclz1 == 1 ) then nzc = nzm else nzc = nz endif dep = zero do k = 1 , xsize3 do j = 1 , xsize2 do i = 1 , xsize1 !dep=dep+var(i,j,k)**2 dep = dep + var ( i , j , k ) enddo enddo enddo call MPI_ALLREDUCE ( dep , avg , 1 , real_type , MPI_SUM , MPI_COMM_WORLD , code ) !avg=sqrt_prec(avg)/(nxc*nyc*nzc) avg = avg / ( nxc * nyc * nzc ) return end subroutine avg3d end module decomp_2d_poisson","tags":"","url":"sourcefile/.poisson_1stderivcomp_reform.f90.html"},{"title":"bc_ndomain_interior.f90 – CHAPSim2","text":"Source Code module bc_ndomain_interior_mod ! not used anymore use parameters_constant_mod use udf_type_mod use decomp_2d use print_msg_mod private integer , parameter :: IFBC ( 1 : 2 ) = ( / 1 , 2 / ) private :: apply_fbcx_2dm_halo private :: apply_fbcy_2dm_halo private :: apply_fbcz_2dm_halo private :: apply_fbc_2dm_flow_halo public :: update_fbc_2dm_flow_halo ! for multiple domains only, update every NS public :: update_fbc_2dm_thermo_halo ! for multiple domains only, update every NS contains !========================================================================================================== subroutine apply_fbcx_2dm_halo ( fbcx , var , iside , dtmp ) use print_msg_mod type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ) :: iside real ( WP ), intent ( in ) :: var ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )) real ( WP ), intent ( inout ) :: fbcx (:, :, :) if ( iside == IFBC ( 1 )) then !122 fbcx ( 1 , :, :) = var ( dtmp % xsz ( 1 ), :, :) ! interior there is a repeated shared points. fbcx ( 3 , :, :) = var ( dtmp % xsz ( 1 ) - 1 , :, :) else if ( iside == IFBC ( 2 )) then !221 fbcx ( 2 , :, :) = var ( 1 , :, :) fbcx ( 4 , :, :) = var ( 2 , :, :) else call Print_error_msg ( 'Error input for apply_fbcx_2dm_halo' ) end if return end subroutine !========================================================================================================== subroutine apply_fbcy_2dm_halo ( fbcy , var , iside , dtmp ) type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ) :: iside real ( WP ), intent ( in ) :: var ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 )) real ( WP ), intent ( inout ) :: fbcy (:, :, :) real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 ) ) :: var_ypencil call transpose_x_to_y ( var , var_ypencil , dtmp ) if ( iside == IFBC ( 1 )) then fbcy (:, 1 , :) = var_ypencil (:, dtmp % ysz ( 2 ), :) ! interior there is a repeated shared points. fbcy (:, 3 , :) = var_ypencil (:, dtmp % ysz ( 2 ) - 1 , :) else if ( iside == IFBC ( 2 )) then fbcy (:, 2 , :) = var_ypencil (:, 1 , :) fbcy (:, 4 , :) = var_ypencil (:, 2 , :) else call Print_error_msg ( 'Error input for apply_fbcy_2dm_halo' ) end if return end subroutine !========================================================================================================== subroutine apply_fbcz_2dm_halo ( fbcz , var , iside , dtmp ) type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ) :: iside real ( WP ), intent ( in ) :: var ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 )) real ( WP ), intent ( inout ) :: fbcz (:, :, :) real ( WP ), dimension ( dtmp % ysz ( 1 ), dtmp % ysz ( 2 ), dtmp % ysz ( 3 ) ) :: var_ypencil real ( WP ), dimension ( dtmp % zsz ( 1 ), dtmp % zsz ( 2 ), dtmp % zsz ( 3 ) ) :: var_zpencil call transpose_x_to_y ( var , var_ypencil , dtmp ) call transpose_y_to_z ( var_ypencil , var_zpencil , dtmp ) if ( iside == IFBC ( 1 )) then fbcz (:, :, 1 ) = var_zpencil (:, :, dtmp % ysz ( 2 ) ) ! interior there is a repeated shared points. fbcz (:, :, 3 ) = var_zpencil (:, :, dtmp % ysz ( 2 ) - 1 ) else if ( iside == IFBC ( 2 )) then fbcz (:, 2 , :) = var_zpencil (:, :, 1 ) fbcz (:, 4 , :) = var_zpencil (:, :, 2 ) else call Print_error_msg ( 'Error input for apply_fbcz_2dm_halo' ) end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine apply_fbc_2dm_flow_halo ( dm , fl , iside , bc_type ) use cylindrical_rn_mod type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( in ) :: fl integer , intent ( in ) :: iside character ( len =* ), intent ( in ) :: bc_type real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), 4 , dm % dcpc % ysz ( 3 ) ) :: ac4c_ypencil real ( WP ), dimension ( dm % dcpp % ysz ( 1 ), 4 , dm % dcpp % ysz ( 3 ) ) :: ac4p_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), 4 ) :: acc4_zpencil real ( WP ), dimension ( dm % dcpp % zsz ( 1 ), dm % dcpp % zsz ( 2 ), 4 ) :: acp4_zpencil !---------------------------------------------------------------------------------------------------------- !   one repeat on nodes: 1'-2'-3'-4'-5'          no repeat of cells 1--2--3--4--5- !                                    1'-2'-3'-4'-5'                               -1--2--3--4--5 !                                 f2 f1 f2                                   f2 f1 f1 f2 !   iside = 122, 1-->2  : |-domain-1----3-1|-domain-2-----| !   iside = 221, 1<--2  : |-domain-1---|-2-4-domain-2-----| !---------------------------------------------------------------------------------------------------------- select case ( bc_type ) case ( 'x' ) if ( dm % ibcx_qx ( iside ) == IBC_INTERIOR ) then call apply_fbcx_2dm_halo ( dm % fbcx_qx , fl % qx , iside , dm % dpcc ) if ( dm % is_thermo ) & call apply_fbcx_2dm_halo ( dm % fbcx_gx , fl % gx , iside , dm % dpcc ) end if if ( dm % ibcx_qy ( iside ) == IBC_INTERIOR ) then call apply_fbcx_2dm_halo ( dm % fbcx_qy , fl % qy , iside , dm % dcpc ) if ( dm % is_thermo ) & call apply_fbcx_2dm_halo ( dm % fbcx_gy , fl % gy , iside , dm % dcpc ) end if if ( dm % ibcx_qz ( iside ) == IBC_INTERIOR ) then call apply_fbcx_2dm_halo ( dm % fbcx_qz , fl % qz , iside , dm % dccp ) if ( dm % is_thermo ) & call apply_fbcx_2dm_halo ( dm % fbcx_gz , fl % gz , iside , dm % dccp ) end if if ( dm % ibcx_pr ( iside ) == IBC_INTERIOR ) then call apply_fbcx_2dm_halo ( dm % fbcx_pr , fl % pres , iside , dm % dccc ) end if case ( 'y' ) if ( dm % ibcy_qx ( iside ) == IBC_INTERIOR ) then call apply_fbcy_2dm_halo ( dm % fbcy_qx , fl % qx , iside , dm % dpcc ) if ( dm % is_thermo ) & call apply_fbcy_2dm_halo ( dm % fbcy_gx , fl % gx , iside , dm % dpcc ) end if if ( dm % ibcy_qy ( iside ) == IBC_INTERIOR ) then call apply_fbcy_2dm_halo ( dm % fbcy_qy , fl % qy , iside , dm % dcpc ) if ( dm % is_thermo ) & call apply_fbcy_2dm_halo ( dm % fbcy_gy , fl % gy , iside , dm % dcpc ) if ( dm % icoordinate == ICYLINDRICAL ) then ! ac4c_ypencil = dm%fbcy_qy ! call multiple_cylindrical_rn_x4x(ac4c_ypencil, dm%dcpc, dm%rpi, 1, IPENCIL(2)) ! dm%fbcy_qyr = ac4c_ypencil !if (dm%is_thermo) then !ac4c_ypencil = dm%fbcy_gy !call multiple_cylindrical_rn_x4x(ac4c_ypencil, dm%dcpc, dm%rpi, 1, IPENCIL(2)) !dm%fbcy_gyr = ac4c_ypencil ! end if end if end if if ( dm % ibcy_qz ( iside ) == IBC_INTERIOR ) then call apply_fbcy_2dm_halo ( dm % fbcy_qz , fl % qz , iside , dm % dccp ) if ( dm % is_thermo ) & call apply_fbcy_2dm_halo ( dm % fbcy_gz , fl % gz , iside , dm % dccp ) if ( dm % icoordinate == ICYLINDRICAL ) then ! ac4p_ypencil = dm%fbcy_qz ! call multiple_cylindrical_rn_x4x(ac4p_ypencil, dm%dcpp, dm%rci, 1, IPENCIL(2)) ! dm%fbcy_qzr = ac4p_ypencil ! if (dm%is_thermo) then !   ac4p_ypencil = dm%fbcy_gz !   call multiple_cylindrical_rn_x4x(ac4p_ypencil, dm%dcpp, dm%rci, 1, IPENCIL(2)) !   dm%fbcy_gzr = ac4p_ypencil ! end if end if end if if ( dm % ibcy_pr ( iside ) == IBC_INTERIOR ) then call apply_fbcy_2dm_halo ( dm % fbcy_pr , fl % pres , iside , dm % dccc ) end if case ( 'z' ) if ( dm % ibcz_qx ( iside ) == IBC_INTERIOR ) then call apply_fbcz_2dm_halo ( dm % fbcz_qx , fl % qx , iside , dm % dpcc ) if ( dm % is_thermo ) & call apply_fbcz_2dm_halo ( dm % fbcz_gx , fl % gx , iside , dm % dpcc ) end if if ( dm % ibcz_qy ( iside ) == IBC_INTERIOR ) then call apply_fbcz_2dm_halo ( dm % fbcz_qy , fl % qy , iside , dm % dcpc ) if ( dm % is_thermo ) & call apply_fbcz_2dm_halo ( dm % fbcz_gy , fl % gy , iside , dm % dcpc ) if ( dm % icoordinate == ICYLINDRICAL ) then ! acp4_zpencil = dm%fbcz_qy ! call multiple_cylindrical_rn_xx4(acp4_zpencil, dm%dcpc, dm%rpi, 1, IPENCIL(3)) ! dm%fbcz_qyr = acp4_zpencil ! if (dm%is_thermo) then !   acp4_zpencil = dm%fbcz_gy !   call multiple_cylindrical_rn_xx4(acp4_zpencil, dm%dcpc, dm%rpi, 1, IPENCIL(3)) !   dm%fbcz_gyr = acp4_zpencil ! end if end if end if if ( dm % ibcz_qz ( iside ) == IBC_INTERIOR ) then call apply_fbcz_2dm_halo ( dm % fbcz_qz , fl % qz , iside , dm % dccp ) if ( dm % is_thermo ) & call apply_fbcz_2dm_halo ( dm % fbcz_gz , fl % gz , iside , dm % dccp ) if ( dm % icoordinate == ICYLINDRICAL ) then ! acc4_zpencil = dm%fbcz_qz ! call multiple_cylindrical_rn_xx4(acc4_zpencil, dm%dccp, dm%rci, 1, IPENCIL(3)) ! dm%fbcz_qzr = acc4_zpencil ! if (dm%is_thermo) then !   acc4_zpencil = dm%fbcz_gz !   call multiple_cylindrical_rn_xx4(acc4_zpencil, dm%dccp, dm%rci, 1, IPENCIL(3)) !   dm%fbcz_gzr = acc4_zpencil ! end if end if end if if ( dm % ibcz_pr ( iside ) == IBC_INTERIOR ) then call apply_fbcz_2dm_halo ( dm % fbcz_pr , fl % pres , iside , dm % dccc ) end if end select end subroutine apply_fbc_2dm_flow_halo !========================================================================================================== !========================================================================================================== subroutine update_fbc_2dm_flow_halo ( dm1 , fl1 , dm2 , fl2 ) type ( t_domain ), intent ( inout ) :: dm1 , dm2 type ( t_flow ), intent ( in ) :: fl1 , fl2 integer :: n ! x-boundary conditions call apply_fbc_2dm_flow_halo ( dm2 , fl1 , IFBC ( 1 ), 'x' ) call apply_fbc_2dm_flow_halo ( dm1 , fl2 , IFBC ( 2 ), 'x' ) ! y-boundary conditions call apply_fbc_2dm_flow_halo ( dm2 , fl1 , IFBC ( 1 ), 'y' ) call apply_fbc_2dm_flow_halo ( dm1 , fl2 , IFBC ( 2 ), 'y' ) ! z-boundary conditions call apply_fbc_2dm_flow_halo ( dm2 , fl1 , IFBC ( 1 ), 'z' ) call apply_fbc_2dm_flow_halo ( dm1 , fl2 , IFBC ( 2 ), 'z' ) ! for turb inlet only, no thermal inlet if ( dm2 % is_thermo . and . (. not . dm1 % is_thermo )) then do n = 1 , 3 , 2 ! x-boundary conditions if ( dm2 % ibcx_qx ( 1 ) == IBC_INTERIOR ) & dm2 % fbcx_gx ( n , :, :) = dm2 % fbcx_qx ( n , :, :) * dm2 % fbcx_ftp ( 1 , :, :)% d if ( dm2 % ibcx_qy ( 1 ) == IBC_INTERIOR ) & dm2 % fbcx_gy ( n , :, :) = dm2 % fbcx_qy ( n , :, :) * dm2 % fbcx_ftp ( 1 , :, :)% d if ( dm2 % ibcx_qz ( 1 ) == IBC_INTERIOR ) & dm2 % fbcx_gz ( n , :, :) = dm2 % fbcx_qz ( n , :, :) * dm2 % fbcx_ftp ( 1 , :, :)% d ! x-boundary conditions if ( dm2 % ibcy_qx ( 1 ) == IBC_INTERIOR ) & dm2 % fbcy_gx (:, n , :) = dm2 % fbcy_qx (:, n , :) * dm2 % fbcy_ftp (:, 1 , :)% d if ( dm2 % ibcy_qy ( 1 ) == IBC_INTERIOR ) then dm2 % fbcy_gy (:, n , :) = dm2 % fbcy_qy (:, n , :) * dm2 % fbcy_ftp (:, 1 , :)% d !if(dm2%icoordinate == ICYLINDRICAL) & !dm2%fbcy_gyr(:, n, :)= dm2%fbcy_qyr(:, n, :) * dm2%fbcy_ftp(:, 1, :)%d end if if ( dm2 % ibcy_qz ( 1 ) == IBC_INTERIOR ) then dm2 % fbcy_gz (:, n , :) = dm2 % fbcy_qz (:, n , :) * dm2 % fbcy_ftp (:, 1 , :)% d !if(dm2%icoordinate == ICYLINDRICAL) & !dm2%fbcy_gzr(:, n, :)= dm2%fbcy_qzr(:, n, :) * dm2%fbcy_ftp(:, 1, :)%d end if ! z-boundary conditions if ( dm2 % ibcz_qx ( 1 ) == IBC_INTERIOR ) & dm2 % fbcz_gx (:, :, n ) = dm2 % fbcz_qx (:, :, n ) * dm2 % fbcz_ftp (:, :, 1 )% d if ( dm2 % ibcz_qy ( 1 ) == IBC_INTERIOR ) then dm2 % fbcz_gy (:, :, n ) = dm2 % fbcz_qy (:, :, n ) * dm2 % fbcz_ftp (:, :, 1 )% d !if(dm2%icoordinate == ICYLINDRICAL) & !dm2%fbcz_gyr(:, :, n) = dm2%fbcz_qyr(:, :, n) * dm2%fbcz_ftp(:, :, 1)%d end if if ( dm2 % ibcz_qz ( 1 ) == IBC_INTERIOR ) then dm2 % fbcz_gz (:, :, n ) = dm2 % fbcz_qz (:, :, n ) * dm2 % fbcz_ftp (:, :, 1 )% d !if(dm2%icoordinate == ICYLINDRICAL) & !dm2%fbcz_gzr(:, :, n) = dm2%fbcz_qzr(:, :, n) * dm2%fbcz_ftp(:, :, 1)%d end if end do end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine update_fbc_2dm_thermo_halo ( dm1 , tm1 , dm2 , tm2 ) use thermo_info_mod type ( t_domain ), intent ( inout ) :: dm1 , dm2 type ( t_thermo ), intent ( in ) :: tm1 , tm2 integer :: i , j , k real ( WP ), dimension ( dm1 % dccc % ysz ( 1 ), dm1 % dccc % ysz ( 2 ), dm1 % dccc % ysz ( 3 ) ) :: accc0_ypencil real ( WP ), dimension ( dm1 % dccc % zsz ( 1 ), dm1 % dccc % zsz ( 2 ), dm1 % dccc % zsz ( 3 ) ) :: accc0_zpencil real ( WP ), dimension ( dm2 % dccc % ysz ( 1 ), dm2 % dccc % ysz ( 2 ), dm2 % dccc % ysz ( 3 ) ) :: accc1_ypencil real ( WP ), dimension ( dm2 % dccc % zsz ( 1 ), dm2 % dccc % zsz ( 2 ), dm2 % dccc % zsz ( 3 ) ) :: accc1_zpencil !---------------------------------------------------------------------------------------------------------- !   bc in x - direction !---------------------------------------------------------------------------------------------------------- ! thermal field, dm1-dm2 if ( dm2 % ibcx_Tm ( 1 ) == IBC_INTERIOR ) then dm2 % fbcx_ftp ( 1 , :, :)% t = tm1 % tTemp ( dm1 % nc ( 1 ), :, :) dm2 % fbcx_ftp ( 3 , :, :)% t = tm1 % tTemp ( dm1 % nc ( 1 ) - 1 , :, :) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm2 % fbcx_ftp ) end if if ( dm1 % ibcx_Tm ( 2 ) == IBC_INTERIOR ) then dm1 % fbcx_ftp ( 2 , :, :)% t = tm2 % tTemp ( 1 , :, :) dm1 % fbcx_ftp ( 4 , :, :)% t = tm2 % tTemp ( 2 , :, :) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm1 % fbcx_ftp ) end if !---------------------------------------------------------------------------------------------------------- !   bc in y - direction !---------------------------------------------------------------------------------------------------------- ! thermal field, dm1-dm2 if ( dm2 % ibcy_Tm ( 1 ) == IBC_INTERIOR ) then call transpose_x_to_y ( tm1 % tTemp , accc0_ypencil , dm1 % dccc ) dm2 % fbcy_ftp (:, 1 , :)% t = accc0_ypencil (:, dm1 % nc ( 1 ), :) dm2 % fbcy_ftp (:, 3 , :)% t = accc0_ypencil (:, dm1 % nc ( 1 ) - 1 , :) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm2 % fbcy_ftp ) end if if ( dm1 % ibcy_Tm ( 2 ) == IBC_INTERIOR ) then call transpose_x_to_y ( tm2 % tTemp , accc1_ypencil , dm2 % dccc ) dm1 % fbcy_ftp (:, 2 , :)% t = accc1_ypencil (:, 1 , :) dm1 % fbcy_ftp (:, 4 , :)% t = accc1_ypencil (:, 2 , :) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm1 % fbcy_ftp ) end if !---------------------------------------------------------------------------------------------------------- !   bc in z - direction !---------------------------------------------------------------------------------------------------------- ! thermal field, dm1-dm2 if ( dm2 % ibcz_Tm ( 1 ) == IBC_INTERIOR ) then call transpose_x_to_y ( tm1 % tTemp , accc0_ypencil , dm1 % dccc ) call transpose_y_to_z ( accc0_ypencil , accc0_zpencil , dm1 % dccc ) dm2 % fbcz_ftp (:, :, 1 )% t = accc0_zpencil (:, :, dm1 % nc ( 1 ) ) dm2 % fbcz_ftp (:, :, 3 )% t = accc0_zpencil (:, :, dm1 % nc ( 1 ) - 1 ) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm2 % fbcz_ftp ) end if if ( dm1 % ibcz_Tm ( 2 ) == IBC_INTERIOR ) then call transpose_x_to_y ( tm2 % tTemp , accc1_ypencil , dm2 % dccc ) call transpose_y_to_z ( accc1_ypencil , accc1_zpencil , dm2 % dccc ) dm1 % fbcz_ftp (:, :, 2 )% t = accc1_zpencil (:, :, 1 ) dm1 % fbcz_ftp (:, :, 4 )% t = accc1_zpencil (:, :, 2 ) call ftp_refresh_thermal_properties_from_T_undim_3D ( dm1 % fbcz_ftp ) end if return end subroutine end module","tags":"","url":"sourcefile/bc_ndomain_interior.f90.html"},{"title":"post_statistics.f90 – CHAPSim2","text":"Source Code module statistics_mod use print_msg_mod use parameters_constant_mod implicit none character ( 13 ), parameter :: io_name = \"statistics-io\" integer , allocatable :: ncl_stat (:, :) private :: write_statistics_array private :: read_statistics_array public :: init_statistics_flow public :: update_statistics_flow public :: read_statistics_flow public :: write_statistics_flow public :: init_statistics_thermo public :: update_statistics_thermo public :: write_statistics_thermo public :: read_statistics_thermo contains !========================================================================================================== !========================================================================================================== subroutine init_statistics_flow ( fl , dm ) use udf_type_mod use parameters_constant_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl !integer :: i if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialise flow statistics ...\" ) if (. not . allocated ( ncl_stat )) then allocate ( ncl_stat ( 3 , nxdomain )) ncl_stat = 0 ! do i = 1, 3 !   if(dm%is_periodic(i)) then !     ncl_stat(i, dm%idom) = xszS(i) !   else !     ncl_stat(i, dm%idom) = MAX(xszS(i) - 1, 1) !   end if ! end do ncl_stat ( 1 , dm % idom ) = dm % dccc % xsz ( 1 ) ! default skip is 1. ncl_stat ( 2 , dm % idom ) = dm % dccc % xsz ( 2 ) ! default skip is 1. ncl_stat ( 3 , dm % idom ) = dm % dccc % xsz ( 3 ) ! default skip is 1. end if allocate ( fl % pr_mean ( ncl_stat ( 1 , dm % idom ), ncl_stat ( 2 , dm % idom ), ncl_stat ( 3 , dm % idom ) ) ) allocate ( fl % u_vector_mean ( ncl_stat ( 1 , dm % idom ), ncl_stat ( 2 , dm % idom ), ncl_stat ( 3 , dm % idom ), 3 ) ) allocate ( fl % uu_tensor6_mean ( ncl_stat ( 1 , dm % idom ), ncl_stat ( 2 , dm % idom ), ncl_stat ( 3 , dm % idom ), 6 ) ) fl % u_vector_mean = ZERO fl % pr_mean = ZERO fl % uu_tensor6_mean = ZERO if ( fl % inittype == INIT_RESTART . and . fl % iteration > dm % stat_istart ) then call read_statistics_flow ( fl , dm ) end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine read_statistics_flow ( fl , dm ) use udf_type_mod use parameters_constant_mod use io_visualisation_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl !integer :: i if ( nrank == 0 ) call Print_debug_inline_msg ( \"Reading flow statistics ...\" ) if ( fl % inittype == INIT_RESTART . and . fl % iteration > dm % stat_istart ) then call read_statistics_array ( fl % pr_mean , 'time_averaged_pr' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % u_vector_mean (:, :, :, 1 ), 'time_averaged_ux' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % u_vector_mean (:, :, :, 2 ), 'time_averaged_uy' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % u_vector_mean (:, :, :, 3 ), 'time_averaged_uz' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % uu_tensor6_mean (:, :, :, 1 ), 'time_averaged_uu' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % uu_tensor6_mean (:, :, :, 2 ), 'time_averaged_vv' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % uu_tensor6_mean (:, :, :, 3 ), 'time_averaged_ww' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % uu_tensor6_mean (:, :, :, 4 ), 'time_averaged_uv' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % uu_tensor6_mean (:, :, :, 5 ), 'time_averaged_uw' , dm % idom , fl % iterfrom , dm % dccc ) call read_statistics_array ( fl % uu_tensor6_mean (:, :, :, 6 ), 'time_averaged_vw' , dm % idom , fl % iterfrom , dm % dccc ) call write_visu_stats_flow ( fl , dm ) end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine init_statistics_thermo ( tm , dm ) use udf_type_mod use parameters_constant_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( inout ) :: tm if (. not . dm % is_thermo ) return if (. not . allocated ( ncl_stat )) then allocate ( ncl_stat ( 3 , nxdomain )) ncl_stat = 0 ncl_stat ( 1 , dm % idom ) = dm % dccc % xsz ( 1 ) ! default skip is 1. ncl_stat ( 2 , dm % idom ) = dm % dccc % xsz ( 2 ) ! default skip is 1. ncl_stat ( 3 , dm % idom ) = dm % dccc % xsz ( 3 ) ! default skip is 1. end if if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialise thermo statistics ...\" ) allocate ( tm % t_mean ( ncl_stat ( 1 , dm % idom ), ncl_stat ( 2 , dm % idom ), ncl_stat ( 3 , dm % idom )) ) allocate ( tm % tt_mean ( ncl_stat ( 1 , dm % idom ), ncl_stat ( 2 , dm % idom ), ncl_stat ( 3 , dm % idom )) ) tm % t_mean = ZERO tm % tt_mean = ZERO if ( tm % inittype == INIT_RESTART . and . tm % iteration > dm % stat_istart ) then call read_statistics_array ( tm % t_mean , 'time_averaged_t' , dm % idom , tm % iterfrom , dm % dccc ) call read_statistics_array ( tm % tt_mean , 'time_averaged_tt' , dm % idom , tm % iterfrom , dm % dccc ) end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine read_statistics_thermo ( tm , dm ) use udf_type_mod use parameters_constant_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( inout ) :: tm if (. not . dm % is_thermo ) return if ( nrank == 0 ) call Print_debug_inline_msg ( \"Reading thermo statistics ...\" ) if ( tm % inittype == INIT_RESTART . and . tm % iteration > dm % stat_istart ) then call read_statistics_array ( tm % t_mean , 'time_averaged_t' , dm % idom , tm % iterfrom , dm % dccc ) call read_statistics_array ( tm % tt_mean , 'time_averaged_tt' , dm % idom , tm % iterfrom , dm % dccc ) end if return end subroutine !========================================================================================================== !========================================================================================================== subroutine update_statistics_flow ( fl , dm ) use udf_type_mod use parameters_constant_mod use operations implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc1 real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc2 real ( WP ), dimension ( dm % dccc % xsz ( 1 ), dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ) ) :: accc3 real ( WP ), dimension ( dm % dccc % ysz ( 1 ), dm % dccc % ysz ( 2 ), dm % dccc % ysz ( 3 ) ) :: accc_ypencil real ( WP ), dimension ( dm % dccc % zsz ( 1 ), dm % dccc % zsz ( 2 ), dm % dccc % zsz ( 3 ) ) :: accc_zpencil real ( WP ), dimension ( dm % dcpc % ysz ( 1 ), dm % dcpc % ysz ( 2 ), dm % dcpc % ysz ( 3 ) ) :: acpc_ypencil real ( WP ), dimension ( dm % dccp % ysz ( 1 ), dm % dccp % ysz ( 2 ), dm % dccp % ysz ( 3 ) ) :: accp_ypencil real ( WP ), dimension ( dm % dccp % zsz ( 1 ), dm % dccp % zsz ( 2 ), dm % dccp % zsz ( 3 ) ) :: accp_zpencil real ( WP ) :: ac , am integer :: nstat ! to do: coarse mesh does not work right now due to the above allocation. !---------------------------------------------------------------------------------------------------------- !   this is for a asymptotic averaging ... !---------------------------------------------------------------------------------------------------------- nstat = fl % iteration - dm % stat_istart + 1 ac = ONE / real ( nstat , WP ) am = real ( nstat - 1 , WP ) / real ( nstat , WP ) !if(nrank==0) write(*,*) 'averaging..', fl%iteration,  dm%stat_istart, nstat, ac, am !---------------------------------------------------------------------------------------------------------- !   pressure, stored in cell centre !---------------------------------------------------------------------------------------------------------- fl % pr_mean (:, :, :) = am * fl % pr_mean (:, :, :) + ac * fl % pres (:, :, :) !---------------------------------------------------------------------------------------------------------- !   ux !---------------------------------------------------------------------------------------------------------- call Get_x_midp_P2C_3D ( fl % qx , accc1 , dm , dm % iAccuracy , dm % ibcx_qx (:), dm % fbcx_qx ) fl % u_vector_mean (:, :, :, 1 ) = am * fl % u_vector_mean (:, :, :, 1 ) + ac * accc1 (:, :, :) !---------------------------------------------------------------------------------------------------------- !   uy !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( fl % qy , acpc_ypencil , dm % dcpc ) call Get_y_midp_P2C_3D ( acpc_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy (:), dm % fbcy_qy ) call transpose_y_to_x ( accc_ypencil , accc2 , dm % dccc ) fl % u_vector_mean (:, :, :, 2 ) = am * fl % u_vector_mean (:, :, :, 2 ) + ac * accc2 (:, :, :) !---------------------------------------------------------------------------------------------------------- !   uz !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( fl % qz , accp_ypencil , dm % dccp ) call transpose_y_to_z ( accp_ypencil , accp_zpencil , dm % dccp ) call Get_z_midp_P2C_3D ( accp_zpencil , accc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz (:), dm % fbcz_qz ) call transpose_z_to_y ( accc_zpencil , accc_ypencil , dm % dccc ) call transpose_y_to_x ( accc_ypencil , accc3 , dm % dccc ) fl % u_vector_mean (:, :, :, 3 ) = am * fl % u_vector_mean (:, :, :, 3 ) + ac * accc3 (:, :, :) !---------------------------------------------------------------------------------------------------------- !   tensor, uu, vv, ww, uv, uw, vw, x-pencil, stored in cell centre !---------------------------------------------------------------------------------------------------------- fl % uu_tensor6_mean (:, :, :, 1 ) = am * fl % uu_tensor6_mean (:, :, :, 1 ) + ac * accc1 (:, :, :) * accc1 (:, :, :) fl % uu_tensor6_mean (:, :, :, 2 ) = am * fl % uu_tensor6_mean (:, :, :, 2 ) + ac * accc2 (:, :, :) * accc2 (:, :, :) fl % uu_tensor6_mean (:, :, :, 3 ) = am * fl % uu_tensor6_mean (:, :, :, 3 ) + ac * accc3 (:, :, :) * accc3 (:, :, :) fl % uu_tensor6_mean (:, :, :, 4 ) = am * fl % uu_tensor6_mean (:, :, :, 4 ) + ac * accc1 (:, :, :) * accc2 (:, :, :) fl % uu_tensor6_mean (:, :, :, 5 ) = am * fl % uu_tensor6_mean (:, :, :, 5 ) + ac * accc1 (:, :, :) * accc3 (:, :, :) fl % uu_tensor6_mean (:, :, :, 6 ) = am * fl % uu_tensor6_mean (:, :, :, 6 ) + ac * accc2 (:, :, :) * accc3 (:, :, :) return end subroutine !========================================================================================================== !========================================================================================================== subroutine write_statistics_flow ( fl , dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl ! here is not only a repeat of those in io_visualisation ! because they have different written freqence and to be used for restart as well. if ( nrank == 0 ) call Print_debug_inline_msg ( \"Writing flow statistics ...\" ) call write_statistics_array ( fl % pr_mean , 'time_averaged_pr' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % u_vector_mean (:, :, :, 1 ), 'time_averaged_ux' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % u_vector_mean (:, :, :, 2 ), 'time_averaged_uy' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % u_vector_mean (:, :, :, 3 ), 'time_averaged_uz' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % uu_tensor6_mean (:, :, :, 1 ), 'time_averaged_uu' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % uu_tensor6_mean (:, :, :, 2 ), 'time_averaged_vv' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % uu_tensor6_mean (:, :, :, 3 ), 'time_averaged_ww' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % uu_tensor6_mean (:, :, :, 4 ), 'time_averaged_uv' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % uu_tensor6_mean (:, :, :, 5 ), 'time_averaged_uw' , dm % idom , fl % iteration , dm % dccc ) call write_statistics_array ( fl % uu_tensor6_mean (:, :, :, 6 ), 'time_averaged_vw' , dm % idom , fl % iteration , dm % dccc ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine update_statistics_thermo ( tm , dm ) use udf_type_mod use parameters_constant_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( inout ) :: tm real ( WP ) :: ac , am integer :: nstat ! to do: coarse mesh does not work right now due to the above allocation. !---------------------------------------------------------------------------------------------------------- !   this is for a asymptotic averaging ... !---------------------------------------------------------------------------------------------------------- nstat = tm % iteration - dm % stat_istart + 1 ac = ONE / real ( nstat , WP ) am = real ( nstat - 1 , WP ) / real ( nstat , WP ) !---------------------------------------------------------------------------------------------------------- !   temperature !---------------------------------------------------------------------------------------------------------- tm % t_mean (:, :, :) = am * tm % t_mean (:, :, :) + ac * tm % tTemp (:, :, :) tm % tt_mean (:, :, :) = am * tm % tt_mean (:, :, :) + ac * tm % tTemp (:, :, :) * tm % tTemp (:, :, :) return end subroutine !========================================================================================================== !========================================================================================================== subroutine write_statistics_thermo ( tm , dm ) use udf_type_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( in ) :: tm if ( nrank == 0 ) call Print_debug_inline_msg ( \"Writing thermo statistics ...\" ) call write_statistics_array ( tm % t_mean , 'time_averaged_t' , dm % idom , tm % iteration , dm % dccc ) call write_statistics_array ( tm % tt_mean , 'time_averaged_tt' , dm % idom , tm % iteration , dm % dccc ) return end subroutine !========================================================================================================== !========================================================================================================== subroutine write_statistics_array ( var , keyword , idm , iter , dtmp ) use udf_type_mod use io_files_mod use io_tools_mod use decomp_2d_io implicit none real ( WP ), contiguous , intent ( in ) :: var ( :, :, :) type ( DECOMP_INFO ), intent ( in ) :: dtmp character ( * ), intent ( in ) :: keyword integer , intent ( in ) :: idm integer , intent ( in ) :: iter character ( 120 ) :: data_flname_path call generate_pathfile_name ( data_flname_path , idm , trim ( keyword ), dir_data , 'bin' , iter ) !if(.not.file_exists(data_flname_path)) & call decomp_2d_write_one ( IPENCIL ( 1 ), var , trim ( data_flname_path ), opt_decomp = dtmp ) return end subroutine !========================================================================================================== !========================================================================================================== subroutine read_statistics_array ( var , keyword , idom , iter , dtmp ) use precision_mod use io_files_mod use io_tools_mod use decomp_2d_io implicit none integer , intent ( in ) :: idom character ( * ), intent ( in ) :: keyword integer , intent ( in ) :: iter type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), dimension (:, :, :), intent ( out ) :: var ( ncl_stat ( 1 , idom ), & ncl_stat ( 2 , idom ), & ncl_stat ( 3 , idom )) character ( 120 ) :: data_flname call generate_file_name ( data_flname , idom , trim ( keyword ), 'bin' , iter ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"Reading \" // trim ( dir_data ) // \"/\" // trim ( data_flname )) call decomp_2d_read_one ( IPENCIL ( 1 ), var , trim ( data_flname ), & opt_dirname = trim ( dir_data ), & opt_decomp = dtmp , & opt_reduce_prec = . false .) return end subroutine end module","tags":"","url":"sourcefile/post_statistics.f90.html"},{"title":"tools_solver.f90 – CHAPSim2","text":"Source Code module solver_tools_mod ! procedure private public :: Check_cfl_convection public :: Check_cfl_diffusion public :: Update_Re public :: Update_PrGr public :: Calculate_xz_mean_yprofile public :: Adjust_to_xzmean_zero !public  :: Get_volumetric_average_3d ! not used anymore public :: get_fbcx_ftp_4pc contains !========================================================================================================== !> \\brief The main code for initialising flow variables !> This subroutine is called once in \\ref initialise_chapsim. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout] !========================================================================================================== subroutine Update_Re ( iter , fl ) use parameters_constant_mod use thermo_info_mod use udf_type_mod implicit none integer , intent ( in ) :: iter type ( t_flow ), intent ( inout ) :: fl !---------------------------------------------------------------------------------------------------------- !  1/Re !---------------------------------------------------------------------------------------------------------- if ( iter < fl % initReTo ) then fl % rre = ONE / fl % reninit else fl % rre = ONE / fl % ren end if return end subroutine Update_Re subroutine Update_PrGr ( fl , tm ) use parameters_constant_mod use thermo_info_mod use udf_type_mod implicit none type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm real ( WP ) :: u0 , rtmp !---------------------------------------------------------------------------------------------------------- !  1/(Re*Pr) !---------------------------------------------------------------------------------------------------------- tm % rPrRen = fl % rre * fluidparam % ftp0ref % k / fluidparam % ftp0ref % m / fluidparam % ftp0ref % cp !---------------------------------------------------------------------------------------------------------- !  gravity force !---------------------------------------------------------------------------------------------------------- u0 = ONE / fl % rre * fluidparam % ftp0ref % m / fluidparam % ftp0ref % d / tm % ref_l0 rtmp = tm % ref_l0 / u0 / u0 * GRAVITY fl % fgravity = ZERO if ( fl % igravity == 1 ) then ! flow/gravity same dirction - x fl % fgravity ( 1 ) = rtmp else if ( fl % igravity == 2 ) then ! flow/gravity same dirction - y fl % fgravity ( 2 ) = rtmp else if ( fl % igravity == 3 ) then ! flow/gravity same dirction - z fl % fgravity ( 3 ) = rtmp else if ( fl % igravity == - 1 ) then ! flow/gravity opposite dirction - x fl % fgravity ( 1 ) = - rtmp else if ( fl % igravity == - 2 ) then ! flow/gravity opposite dirction - y fl % fgravity ( 2 ) = - rtmp else if ( fl % igravity == - 3 ) then ! flow/gravity opposite dirction - z fl % fgravity ( 3 ) = - rtmp else ! no gravity fl % fgravity = ZERO end if return end subroutine Update_PrGr !========================================================================================================== !> \\brief The main code for initialising flow variables !> !> not changing storage position, exclude b.c. values, for example, developing !> flow. !> MPI : x-pencil !>  (y) &#94;_____ _____ ______ !>      |_____|_____|______| !>      |_____|_____|______|__> (z) !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout]  none          NA !========================================================================================================== subroutine Calculate_xz_mean_yprofile ( var , dtmp , n , varxz_work1 ) use mpi_mod use udf_type_mod use parameters_constant_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( in ) :: var ! x-pencil default integer , intent ( in ) :: n real ( WP ), dimension ( n ), optional , intent ( out ) :: varxz_work1 real ( wp ) :: varxz ( n ) integer :: jj , i , j , k integer :: nk , ni !, nk_work, ni_work real ( WP ) :: varxz_work ( n ) !---------------------------------------------------------------------------------------------------------- !   Default X-pencil !---------------------------------------------------------------------------------------------------------- varxz = ZERO varxz_work = ZERO do j = 1 , dtmp % xsz ( 2 ) nk = 0 ni = 0 jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) do k = 1 , dtmp % xsz ( 3 ) nk = nk + 1 do i = 1 , dtmp % xsz ( 1 ) ni = ni + 1 varxz ( jj ) = varxz ( jj ) + var ( i , j , k ) ! end do end do varxz ( jj ) = varxz ( jj ) / real ( nk * ni , wp ) end do !call mpi_barrier(MPI_COMM_WORLD, ierror) !call mpi_allreduce(ni, ni_work, 1, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, ierror) !call mpi_allreduce(nk, nk_work, 1, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, ierror) call mpi_allreduce ( varxz , varxz_work , n , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) varxz_work = varxz_work / real ( p_col * p_col , wp ) if ( PRESENT ( varxz_work1 )) varxz_work1 = varxz_work #ifdef DEBUG_STEPS if ( nrank == 0 ) then open ( 121 , file = 'check_calculate_xz_mean_yprofile.dat' , position = \"append\" ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) write ( 121 , * ) jj , varxz_work ( jj ) end do end if #endif return end subroutine !========================================================================================================== !> \\brief : !> MPI : x-pencil !>  (y) &#94;_____ _____ ______ !>      |_____|_____|______| !>      |_____|_____|______|__> (z) !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout] !========================================================================================================== subroutine Adjust_to_xzmean_zero ( var , dtmp , n , varxz ) use mpi_mod use udf_type_mod implicit none type ( DECOMP_INFO ), intent ( in ) :: dtmp integer , intent ( in ) :: n real ( WP ), dimension ( n ), intent ( in ) :: varxz real ( WP ), dimension ( dtmp % xsz ( 1 ), dtmp % xsz ( 2 ), dtmp % xsz ( 3 )), intent ( inout ) :: var integer :: jj , i , j , k do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) do k = 1 , dtmp % xsz ( 3 ) do i = 1 , dtmp % xsz ( 1 ) var (:, j , :) = var (:, j , :) - varxz ( jj ) end do end do end do #ifdef DEBUG_STEPS open ( 121 , file = 'check_adjust_to_xzmean_zero.dat' , position = \"append\" ) do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) do i = 1 , dtmp % xsz ( 1 ) write ( 121 , * ) k , j , i , var ( i , j , k ) end do end do end do close ( 121 ) #endif return end subroutine !========================================================================================================== !> \\brief : !> MPI : x-pencil !>  (y) &#94;_____ _____ ______ !>      |_____|_____|______| !>      |_____|_____|______|__> (z) !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout] !========================================================================================================== subroutine Check_cfl_diffusion ( fl , dm ) use parameters_constant_mod use udf_type_mod use mpi_mod use wtformat_mod use print_msg_mod implicit none type ( t_flow ), intent ( in ) :: fl type ( t_domain ), intent ( in ) :: dm real ( WP ) :: cfl_diff , cfl_diff_work , rtmp , dyi , dtmax , dtmax_work integer :: i , j , k , jj real ( wp ) :: rsp ( 3 ), rmax ( 3 ), rmax_work ( 3 ), var ( 5 ), var_work ( 5 ) rmax (:) = ZERO cfl_diff = ZERO rsp ( 1 ) = dm % h2r ( 1 ) rsp ( 2 ) = dm % h2r ( 2 ) rsp ( 3 ) = dm % h2r ( 3 ) do j = 1 , dm % dccc % xsz ( 2 ) jj = dm % dccc % xst ( 2 ) + j - 1 !local2global_yid(j, dm%dccc) if ( dm % is_stretching ( 2 )) then dyi = dm % yMappingcc ( jj , 1 ) / dm % h ( 2 ) rsp ( 2 ) = dyi * dyi end if do k = 1 , dm % dccc % xsz ( 3 ) if ( dm % icoordinate == ICYLINDRICAL ) & rsp ( 3 ) = dm % h2r ( 3 ) * dm % rci ( jj ) * dm % rci ( jj ) do i = 1 , dm % dccc % xsz ( 1 ) rtmp = rsp ( 1 ) + rsp ( 2 ) + rsp ( 3 ) if ( dm % is_thermo ) rtmp = rtmp * fl % mVisc ( i , j , k ) / fl % dDens ( i , j , k ) if ( rtmp > cfl_diff ) then cfl_diff = rtmp rmax (:) = rsp (:) end if end do end do end do dtmax = ONE / ( TWO * fl % rre * cfl_diff ) cfl_diff = cfl_diff * TWO * dm % dt * fl % rre !call mpi_barrier(MPI_COMM_WORLD, ierror) var ( 1 : 3 ) = rmax ( 1 : 3 ) var ( 4 ) = dtmax var ( 5 ) = cfl_diff call mpi_allreduce ( var , var_work , 5 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) rmax_work ( 1 : 3 ) = var ( 1 : 3 ) dtmax_work = var ( 4 ) cfl_diff_work = var ( 5 ) if ( nrank == 0 ) then write ( * , wrtfmt1el ) \"Diffusion number :\" , cfl_diff_work if ( cfl_diff_work > ONE ) then call Print_warning_msg ( \"Warning: Diffusion number is larger than 1. Numerical instability could occur.\" ) write ( * , * ) 'Please reduce the time step size lower than ' , dtmax_work write ( * , * ) 'Or Please consider increase your mesh size' write ( * , * ) '1/delta&#94;2 Contributes from x, y, z directions:' , rmax_work ( 1 : 3 ) end if end if return end subroutine !========================================================================================================== !> \\brief : to check CFL for convection terms !> CFL = u&#94;x/dx + v&#94;y/dy + w&#94;z/dz < limit !> MPI : x-pencil !>  (y) &#94;_____ _____ ______ !>      |_____|_____|______| !>      |_____|_____|______|__> (z) !> !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout] !========================================================================================================== subroutine Check_cfl_convection ( u , v , w , dm ) use parameters_constant_mod use udf_type_mod use operations use decomp_2d use wtformat_mod use find_max_min_ave_mod implicit none type ( t_domain ), intent ( inout ) :: dm real ( WP ), dimension ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )), intent ( in ) :: u real ( WP ), dimension ( dm % dcpc % xsz ( 1 ), dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 )), intent ( in ) :: v real ( WP ), dimension ( dm % dccp % xsz ( 1 ), dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 )), intent ( in ) :: w real ( WP ) :: var_xpencil ( dm % dccc % xsz ( 1 ), & dm % dccc % xsz ( 2 ), & dm % dccc % xsz ( 3 )) real ( WP ) :: var_ypencil ( dm % dccc % ysz ( 1 ), & dm % dccc % ysz ( 2 ), & dm % dccc % ysz ( 3 )) real ( WP ) :: var_zpencil ( dm % dccc % zsz ( 1 ), & dm % dccc % zsz ( 2 ), & dm % dccc % zsz ( 3 )) real ( WP ) :: accc_xpencil ( dm % dccc % xsz ( 1 ), & dm % dccc % xsz ( 2 ), & dm % dccc % xsz ( 3 )) real ( WP ) :: accc_ypencil ( dm % dccc % ysz ( 1 ), & dm % dccc % ysz ( 2 ), & dm % dccc % ysz ( 3 )) real ( WP ) :: accc_zpencil ( dm % dccc % zsz ( 1 ), & dm % dccc % zsz ( 2 ), & dm % dccc % zsz ( 3 )) real ( WP ) :: v_ypencil ( dm % dcpc % ysz ( 1 ), & dm % dcpc % ysz ( 2 ), & dm % dcpc % ysz ( 3 )) real ( WP ) :: w_ypencil ( dm % dccp % ysz ( 1 ), & dm % dccp % ysz ( 2 ), & dm % dccp % ysz ( 3 )) real ( WP ) :: w_zpencil ( dm % dccp % zsz ( 1 ), & dm % dccp % zsz ( 2 ), & dm % dccp % zsz ( 3 )) !real(WP)   :: cfl_convection, cfl_convection_work real ( wp ) :: cfl , dy integer :: j !---------------------------------------------------------------------------------------------------------- ! Initialisation !---------------------------------------------------------------------------------------------------------- var_xpencil = ZERO var_ypencil = ZERO var_zpencil = ZERO accc_xpencil = ZERO accc_ypencil = ZERO accc_zpencil = ZERO !---------------------------------------------------------------------------------------------------------- ! X-pencil : u_ccc / dx * dt !---------------------------------------------------------------------------------------------------------- call Get_x_midp_P2C_3D ( u , accc_xpencil , dm , dm % iAccuracy , dm % ibcx_qx , dm % fbcx_qx ) var_xpencil = accc_xpencil * dm % h1r ( 1 ) * dm % dt !---------------------------------------------------------------------------------------------------------- ! Y-pencil : v_ccc / dy / r * dt !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( var_xpencil , var_ypencil , dm % dccc ) call transpose_x_to_y ( v , v_ypencil , dm % dcpc ) call Get_y_midp_P2C_3D ( v_ypencil , accc_ypencil , dm , dm % iAccuracy , dm % ibcy_qy , dm % fbcy_qy ) accc_ypencil = accc_ypencil * dm % h1r ( 2 ) * dm % dt if ( dm % is_stretching ( 2 )) then do j = 1 , dm % dccc % ysz ( 2 ) accc_ypencil (:, j , :) = accc_ypencil (:, j , :) * dm % yMappingcc ( j , 1 ) end do end if if ( dm % icoordinate == ICYLINDRICAL ) then do j = 1 , dm % dccc % ysz ( 2 ) accc_ypencil (:, j , :) = accc_ypencil (:, j , :) * dm % rci ( j ) end do end if var_ypencil = var_ypencil + accc_ypencil !---------------------------------------------------------------------------------------------------------- ! Z-pencil : w_ccc / dz /r2 !---------------------------------------------------------------------------------------------------------- call transpose_y_to_z ( var_ypencil , var_zpencil , dm % dccc ) call transpose_x_to_y ( w , w_ypencil , dm % dccp ) if ( dm % icoordinate == ICYLINDRICAL ) then do j = 1 , dm % dccp % ysz ( 2 ) w_ypencil (:, j , :) = w_ypencil (:, j , :) * dm % rci ( j ) * dm % rci ( j ) end do end if call transpose_y_to_z ( w_ypencil , w_zpencil , dm % dccp ) call Get_z_midp_P2C_3D ( w_zpencil , accc_zpencil , dm , dm % iAccuracy , dm % ibcz_qz , dm % fbcz_qz ) var_zpencil = var_zpencil + accc_zpencil * dm % h1r ( 3 ) * dm % dt !---------------------------------------------------------------------------------------------------------- ! Z-pencil : Find the maximum !---------------------------------------------------------------------------------------------------------- call transpose_z_to_y ( var_zpencil , var_ypencil , dm % dccc ) call transpose_y_to_x ( var_ypencil , var_xpencil , dm % dccc ) call Find_maximum_absvar3d ( var_xpencil , cfl , dm % dccc , \"CFL (convection) :\" ) if ( cfl > ONE ) then dm % dt = dm % dt / REAL ( ceiling ( cfl / 5.0_WP ) * 5 , WP ) if ( nrank == 0 ) then call Print_warning_msg ( \"Warning: CFL is larger than 1.\" ) write ( * , wrtfmt1e ) 'dt reduced to ' , dm % dt end if end if return end subroutine !========================================================================================================== !>\\brief : to calculate: !>         fo = \\int_1&#94;nx \\int_ !> This is based only y-direction stretching. !> \\todo Here is 2nd order Trapezoid Method. Need to improve! Check! !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    needed         specified   pubic !---------------------------------------------------------------------------------------------------------- !> MPI : !>     default x-pencil !>     working in : y-pencil !>  (y) &#94;_____ _____ ______ !>      |_____|_____|______| !>      |_____|_____|______|__> (z) !> Y: index arrangment !>      j'-1   j'-1  j'    j'+1  j'+2 !>      _|__.__|__.__|__.__|__.__|__.__ !>         j-2   j-1   j     j+1    j+2 !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[inout] !========================================================================================================== !   subroutine Get_volumetric_average_3d(is_ynp, ibcy, fbcy, dm, dtmp, var, fo_work) !     use mpi_mod !     use udf_type_mod !     use parameters_constant_mod !     use operations !     use decomp_2d !     use wtformat_mod !     implicit none !     type(t_domain),  intent(in) :: dm !     logical,           intent(in) :: is_ynp !     integer,           intent(in) :: ibcy(2) !     real(WP),          intent(in) :: fbcy(:, :, :) !     type(DECOMP_INFO), intent(in) :: dtmp !     real(WP),          intent(in) :: var(:, :, :) !     real(WP),          intent(out):: fo_work !     real(WP), dimension( dtmp%ysz(1), dtmp%ysz(2), dtmp%ysz(3) )  :: var_ypencil !     real(WP), allocatable   :: vcp_ypencil(:, :, :) !     real(WP)   :: vol, fo, vol_work !     integer :: i, j, k, noy, jp ! ! #ifdef DEBUG_STEPS ! !     if(nrank == 0) then ! !       if(present(str)) then ! !         call Print_debug_inline_msg(\"Calculating volumeric average of \"//trim(str)//\" in 3-D ...\") ! !       else ! !         call Print_debug_inline_msg(\"Calculating volumeric average in 3-D ...\") ! !       end if ! !     end if ! ! #endif !     if(.not. dm%is_stretching(2) ) then !       vol = ZERO !       fo  = ZERO !       do k = 1, dtmp%xsz(3) !         do j = 1, dtmp%xsz(2) !           do i = 1, dtmp%xsz(1) !             fo = fo + var(i, j, k) !             vol = vol + ONE !           end do !         end do !       end do !     else !     !---------------------------------------------------------------------------------------------------------- !     !   transpose to y pencil. Default is x-pencil. !     !---------------------------------------------------------------------------------------------------------- !       var_ypencil = ZERO !       call transpose_x_to_y(var, var_ypencil, dtmp) !       !---------------------------------------------------------------------------------------------------------- !       !   In Y-pencil now !       !---------------------------------------------------------------------------------------------------------- !       if( is_ynp )then !         !---------------------------------------------------------------------------------------------------------- !         !   if variable is stored in y-nodes, extend them to y-cell centres (P2C) !         !   for example, uy. !         !---------------------------------------------------------------------------------------------------------- !         if( dm%is_periodic(2) ) then !           noy = dtmp%ysz(2) !         else !           noy = dtmp%ysz(2) - 1 !         end if !         allocate( vcp_ypencil(dtmp%ysz(1), noy, dtmp%ysz(3)) ) !         vcp_ypencil = ZERO !         call Get_y_midp_P2C_3D(var_ypencil, vcp_ypencil, dm, dm%iAccuracy, ibcy, fbcy) !         fo = ZERO !         vol = ZERO !         do k = 1, dtmp%ysz(3) !           do i = 1, dtmp%ysz(1) !             do j = 1, noy !               !---------------------------------------------------------------------------------------------------------- !               !       j'    j'+1 !               !      _|__.__|_ !               !         j !               !---------------------------------------------------------------------------------------------------------- !               jp = j + 1 !               if( dm%is_periodic(2) .and. jp > dtmp%ysz(2)) jp = 1 !               fo = fo + & !                   ( var_ypencil(i, jp, k) + vcp_ypencil(i, j, k) ) * & !                   ( dm%yp(j + 1) - dm%yc(j) ) * HALF + & !                   ( var_ypencil(i, j,     k) + vcp_ypencil(i, j, k) ) * & !                   ( dm%yc(j    ) - dm%yp(j) ) * HALF !               vol = vol + ( dm%yp(j + 1) - dm%yp(j) ) !             end do !           end do !         end do !         deallocate(vcp_ypencil) !       else !         !---------------------------------------------------------------------------------------------------------- !         !   if variable is not stored in y-nodes, extends them to y-nodes. C2P !         !   for example, ux, density, etc. !         !---------------------------------------------------------------------------------------------------------- !         if( dm%is_periodic(2) ) then !           noy = dtmp%ysz(2) !         else !           noy = dtmp%ysz(2) + 1 !         end if !         allocate( vcp_ypencil(dtmp%ysz(1), noy, dtmp%ysz(3)) ) !         vcp_ypencil = ZERO !         call Get_y_midp_C2P_3D(var_ypencil, vcp_ypencil, dm, dm%iAccuracy, ibcy, fbcy) !         fo = ZERO !         vol = ZERO !         do k = 1, dtmp%ysz(3) !           do i = 1, dtmp%ysz(1) !             do j = 1, dtmp%ysz(2) !               !---------------------------------------------------------------------------------------------------------- !               !      j'    j'+1 !               !      _|__.__|_ !               !         j !               !---------------------------------------------------------------------------------------------------------- !               jp = j + 1 !               if( dm%is_periodic(2) .and. jp > noy) jp = 1 !               ! method 1: 2nd order !               ! fo = fo + & !               !     ( vcp_ypencil(i, jp, k) + var_ypencil(i, j, k) ) * & !               !     ( dm%yp(j + 1) - dm%yc(j) ) * HALF + & !               !     ( var_ypencil(i, j,     k) + var_ypencil(i, j, k) ) * & !               !     ( dm%yc(j    ) - dm%yp(j) ) * HALF !               ! method 2: 1st order, same as CHAPSim1 !               fo = fo + vcp_ypencil(i, j, k)*(dm%yp(j + 1) - dm%yp(j)) !               vol = vol + ( dm%yp(j + 1) - dm%yp(j) ) !             end do !           end do !         end do !         deallocate(vcp_ypencil) !       end if !     end if !     call mpi_barrier(MPI_COMM_WORLD, ierror) !     call mpi_allreduce( fo,  fo_work, 1, MPI_REAL_WP, MPI_SUM, MPI_COMM_WORLD, ierror) !     call mpi_allreduce(vol, vol_work, 1, MPI_REAL_WP, MPI_SUM, MPI_COMM_WORLD, ierror) !     fo_work = fo_work / vol_work ! #ifdef DEBUG_STEPS !     if(nrank == 0 ) then !       write (*, wrtfmt1e) \" volumetric average :\", fo_work !     end if ! #endif !     return !   end subroutine Get_volumetric_average_3d !========================================================================================================== !========================================================================================================== subroutine get_fbcx_ftp_4pc ( fbcx_ftp_4cc , fbcx_ftp_4pc , dm ) use udf_type_mod use parameters_constant_mod use operations use print_msg_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), dimension ( dm % d4cc % xsz ( 1 ), dm % d4cc % xsz ( 2 ), dm % d4cc % xsz ( 3 )), intent ( in ) :: fbcx_ftp_4cc real ( WP ), dimension ( dm % d4pc % xsz ( 1 ), dm % d4pc % xsz ( 2 ), dm % d4pc % xsz ( 3 )), intent ( out ) :: fbcx_ftp_4pc real ( WP ), dimension ( dm % d4cc % xsz ( 1 ), dm % d4cc % xsz ( 2 ), dm % d4cc % xsz ( 3 )) :: fbcx_4cc real ( WP ), dimension ( dm % d4cc % ysz ( 1 ), dm % d4cc % ysz ( 2 ), dm % d4cc % ysz ( 3 )) :: a4cc_ypencil real ( WP ), dimension ( dm % d4pc % ysz ( 1 ), dm % d4pc % ysz ( 2 ), dm % d4pc % ysz ( 3 )) :: a4pc_ypencil real ( WP ), dimension ( dm % d4pc % xsz ( 1 ), dm % d4pc % xsz ( 2 ), dm % d4pc % xsz ( 3 )) :: a4pc_xpencil integer :: ibcy ( 2 ), i , j , k real ( WP ) :: fbc if ( dm % ibcx_nominal ( 2 , 5 ) == IBC_CONVECTIVE ) then fbcx_4cc (:, :, :) = fbcx_ftp_4cc (:, :, :) call transpose_x_to_y ( fbcx_4cc , a4cc_ypencil , dm % d4cc ) do i = 1 , dm % d4pc % ysz ( 1 ) do k = 1 , dm % d4pc % ysz ( 3 ) do j = 1 , dm % d4pc % ysz ( 2 ) if ( j == 1 ) then a4pc_ypencil ( i , j , k ) = ( THREE * a4cc_ypencil ( i , j , k ) - a4cc_ypencil ( i , j + 1 , k )) / TWO else if ( j == dm % d4pc % ysz ( 2 )) then if ( j <= 2 ) call Print_error_msg ( 'get_fbcx_ftp_4pc decomposition error' ) a4pc_ypencil ( i , j , k ) = ( THREE * a4cc_ypencil ( i , j - 1 , k ) - a4cc_ypencil ( i , j - 2 , k )) / TWO else a4pc_ypencil ( i , j , k ) = ( a4cc_ypencil ( i , j - 1 , k ) + a4cc_ypencil ( i , j , k )) / TWO end if end do end do end do ! ibcy = IBC_INTRPL ! call Get_y_midp_C2P_3D(a4cc_ypencil, a4pc_ypencil, dm, dm%iAccuracy, dm%ibcy_ftp, fbcy_44c) call transpose_y_to_x ( a4pc_ypencil , a4pc_xpencil , dm % d4pc ) fbcx_ftp_4pc (:, :, :) = a4pc_xpencil (:, :, :) !else !fbcx_ftp_4pc(2, :, :) = MAXP end if if ( dm % ibcx_ftp ( 1 ) == IBC_DIRICHLET ) then fbc = fbcx_ftp_4cc ( 1 , 1 , 1 ) fbcx_ftp_4pc ( 1 , :, :) = fbc ! check else fbcx_ftp_4pc ( 1 , :, :) = MAXP end if ! write(*,*) '1-', fbcx_ftp_4pc(1, :, :) ! write(*,*) '2-', fbcx_ftp_4pc(2, :, :) ! write(*,*) '3-', fbcx_ftp_4pc(3, :, :) ! write(*,*) '4-', fbcx_ftp_4pc(4, :, :) return end subroutine !========================================================================================================== !========================================================================================================== end module","tags":"","url":"sourcefile/tools_solver.f90.html"},{"title":"initialisation.f90 – CHAPSim2","text":"Source Code !---------------------------------------------------------------------------------------------------------- !                      CHAPSim version 2.0.0 !                      -------------------------- ! This file is part of CHAPSim, a general-purpose CFD tool. ! ! This program is free software; you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation; either version 3 of the License, or (at your option) any later ! version. ! ! This program is distributed in the hope that it will be useful, but WITHOUT ! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS ! FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more ! details. ! ! You should have received a copy of the GNU General Public License along with ! this program; if not, write to the Free Software Foundation, Inc., 51 Franklin ! Street, Fifth Floor, Boston, MA 02110-1301, USA. !---------------------------------------------------------------------------------------------------------- module flow_thermo_initialiasation use vars_df_mod use solver_tools_mod use print_msg_mod implicit none public :: Allocate_flow_variables public :: Allocate_thermo_variables private :: Generate_poiseuille_flow_profile private :: Generate_random_field private :: initialise_poiseuille_flow private :: initialise_flow_from_given_values private :: initialise_vortexgreen_2dflow private :: initialise_vortexgreen_3dflow public :: Validate_TGV2D_error public :: initialise_flow_fields public :: initialise_thermo_fields contains !========================================================================================================== !> \\brief Allocate flow and thermal variables. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     none          NA !> \\param[out]    none          NA !========================================================================================================== subroutine Allocate_flow_variables ( fl , dm ) use parameters_constant_mod use mpi_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl if ( nrank == 0 ) call Print_debug_start_msg ( \"Allocating flow variables ...\" ) !---------------------------------------------------------------------------------------------------------- ! default : x pencil. ! varaible index is LOCAL. means 1:xsize(1) !---------------------------------------------------------------------------------------------------------- call alloc_x ( fl % qx , dm % dpcc ) ; fl % qx = ZERO call alloc_x ( fl % qy , dm % dcpc ) ; fl % qy = ZERO call alloc_x ( fl % qz , dm % dccp ) ; fl % qz = ZERO call alloc_x ( fl % pres , dm % dccc ) ; fl % pres = ZERO call alloc_x ( fl % pcor , dm % dccc ) ; fl % pcor = ZERO call alloc_z ( fl % pcor_zpencil_ggg , dm % dccc , . true .) ; fl % pcor_zpencil_ggg = ZERO call alloc_x ( fl % mx_rhs , dm % dpcc ) ; fl % mx_rhs = ZERO call alloc_x ( fl % my_rhs , dm % dcpc ) ; fl % my_rhs = ZERO call alloc_x ( fl % mz_rhs , dm % dccp ) ; fl % mz_rhs = ZERO call alloc_x ( fl % mx_rhs0 , dm % dpcc ) ; fl % mx_rhs0 = ZERO call alloc_x ( fl % my_rhs0 , dm % dcpc ) ; fl % my_rhs0 = ZERO call alloc_x ( fl % mz_rhs0 , dm % dccp ) ; fl % mz_rhs0 = ZERO if ( dm % is_conv_outlet ) then allocate ( fl % fbcx_qx_rhs0 ( dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ))); fl % fbcx_qx_rhs0 = ZERO allocate ( fl % fbcx_qy_rhs0 ( dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ))); fl % fbcx_qy_rhs0 = ZERO allocate ( fl % fbcx_qz_rhs0 ( dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ))); fl % fbcx_qz_rhs0 = ZERO end if if ( dm % is_thermo ) then call alloc_x ( fl % gx , dm % dpcc ) ; fl % gx = ZERO call alloc_x ( fl % gy , dm % dcpc ) ; fl % gy = ZERO call alloc_x ( fl % gz , dm % dccp ) ; fl % gz = ZERO call alloc_x ( fl % dDens , dm % dccc ) ; fl % dDens = ONE call alloc_x ( fl % mVisc , dm % dccc ) ; fl % mVisc = ONE call alloc_x ( fl % drhodt , dm % dccc ) ; fl % drhodt = ZERO call alloc_x ( fl % dDensm1 , dm % dccc ) ; fl % dDensm1 = ONE call alloc_x ( fl % dDensm2 , dm % dccc ) ; fl % dDensm2 = ONE call alloc_x ( fl % gx0 , dm % dpcc ) ; fl % gx0 = ZERO call alloc_x ( fl % gy0 , dm % dcpc ) ; fl % gy0 = ZERO call alloc_x ( fl % gz0 , dm % dccp ) ; fl % gz0 = ZERO if ( dm % is_conv_outlet ) then allocate ( fl % fbcx_gx_rhs0 ( dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 ))); fl % fbcx_gx_rhs0 = ZERO allocate ( fl % fbcx_gy_rhs0 ( dm % dcpc % xsz ( 2 ), dm % dcpc % xsz ( 3 ))); fl % fbcx_gy_rhs0 = ZERO allocate ( fl % fbcx_gz_rhs0 ( dm % dccp % xsz ( 2 ), dm % dccp % xsz ( 3 ))); fl % fbcx_gz_rhs0 = ZERO end if end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine Allocate_flow_variables !========================================================================================================== subroutine Allocate_thermo_variables ( tm , dm ) use parameters_constant_mod use mpi_mod use udf_type_mod use thermo_info_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_thermo ), intent ( inout ) :: tm if (. not . dm % is_thermo ) return if ( nrank == 0 ) call Print_debug_start_msg ( \"Allocating thermal variables ...\" ) !---------------------------------------------------------------------------------------------------------- ! default : x pencil. ! varaible index is LOCAL. means 1:xsize(1) !---------------------------------------------------------------------------------------------------------- call alloc_x ( tm % rhoh , dm % dccc ) ; tm % rhoh = ZERO call alloc_x ( tm % hEnth , dm % dccc ) ; tm % hEnth = ZERO call alloc_x ( tm % kCond , dm % dccc ) ; tm % kCond = ONE call alloc_x ( tm % tTemp , dm % dccc ) ; tm % tTemp = ONE call alloc_x ( tm % ene_rhs , dm % dccc ) ; tm % ene_rhs = ZERO call alloc_x ( tm % ene_rhs0 , dm % dccc ) ; tm % ene_rhs0 = ZERO if ( dm % is_conv_outlet ) then allocate ( tm % fbcx_rhoh_rhs0 ( dm % dccc % xsz ( 2 ), dm % dccc % xsz ( 3 ))); tm % fbcx_rhoh_rhs0 = ZERO end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine Allocate_thermo_variables !========================================================================================================== !> \\brief Generate a flow profile for Poiseuille flow in channel or pipe. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in] !> \\param[out] !========================================================================================================== subroutine Generate_random_field ( dm , fl ) use random_number_generation_mod use parameters_constant_mod use mpi_mod use math_mod use boundary_conditions_mod use flatten_index_mod use io_visualisation_mod use wtformat_mod use find_max_min_ave_mod use wrt_debug_field_mod type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl integer :: seed integer :: i , j , k ! local id integer :: n , nsz integer :: ii , jj , kk ! global id integer :: seed0 = 123456 real ( WP ) :: rd , lownoise type ( DECOMP_INFO ) :: dtmp if ( nrank == 0 ) call Print_debug_inline_msg ( \"Generating random field ...\" ) !---------------------------------------------------------------------------------------------------------- !   Initialisation in x pencil !---------------------------------------------------------------------------------------------------------- seed = 0 fl % pres (:, :, :) = ZERO fl % pcor (:, :, :) = ZERO fl % qx (:, :, :) = ZERO fl % qy (:, :, :) = ZERO fl % qz (:, :, :) = ZERO nsz = dm % np ( 1 ) * dm % np ( 2 ) * dm % np ( 3 ) do n = 1 , NDIM if ( n == 1 ) then dtmp = dm % dpcc else if ( n == 2 ) then dtmp = dm % dcpc else if ( n == 3 ) then dtmp = dm % dccp else end if !     random field from 0 to 1 do k = 1 , dtmp % xsz ( 3 ) kk = dtmp % xst ( 3 ) + k - 1 do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) !if( ( ONE - abs_wp(dm%yp(jj)) ) .LT. QUARTER) then !lownoise = fl%noiselevel * fl%noiselevel !else lownoise = fl % noiselevel !end if do i = 1 , dtmp % xsz ( 1 ) ii = i seed = flatten_index ( ii , jj , kk , dtmp % xsz ( 1 ), dtmp % ysz ( 2 )) + seed0 * n call initialise_random_number ( seed ) call Generate_r_random ( - ONE , ONE , rd ) if ( n == 1 ) fl % qx ( i , j , k ) = lownoise * rd if ( n == 2 ) fl % qy ( i , j , k ) = lownoise * HALF * rd * dm % rp ( jj ) if ( n == 3 ) fl % qz ( i , j , k ) = lownoise * HALF * rd ! * dm%rc(jj) end do end do end do end do !     for dirichelt, the perturbation velocity should be zero. call enforce_velo_from_fbc ( dm , fl % qx , fl % qy , fl % qz ) if ( nrank == 0 ) call Print_debug_inline_msg ( \"Max/min velocity for generated random velocities:\" ) call Find_max_min_absvar3d ( fl % qx , \"qx\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % qy , \"qy\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % qz , \"qz\" , wrtfmt2ae ) ! to validate the random number generated is MPI processor independent. #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % qx , dm % dpcc , fl % iteration , 0 , 'qx@af radm' ) ! debug_ww call wrt_3d_pt_debug ( fl % qy , dm % dcpc , fl % iteration , 0 , 'qy@af radm' ) ! debug_ww call wrt_3d_pt_debug ( fl % qz , dm % dccp , fl % iteration , 0 , 'qz@af radm' ) ! debug_ww call wrt_3d_pt_debug ( fl % pres , dm % dccc , fl % iteration , 0 , 'pr@af radm' ) ! debug_ww #endif return end subroutine !========================================================================================================== !> \\brief Generate a flow profile for Poiseuille flow in channel or pipe. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     d             domain !> \\param[out]    ux_1c1          u(yc), velocity profile along wall-normal direction !========================================================================================================== subroutine Generate_poiseuille_flow_profile ( dm , ux_1c1 ) use parameters_constant_mod use udf_type_mod use math_mod use io_files_mod implicit none type ( t_domain ), intent ( in ) :: dm real ( WP ), intent ( out ) :: ux_1c1 (:) real ( WP ) :: a , b , c , yy , ymax , ymin integer :: pf_unit integer :: j if ( nrank == 0 ) call Print_debug_inline_msg ( \"Generate poiseuille flow profile ...\" ) ux_1c1 (:) = ZERO ymax = dm % yp ( dm % np_geo ( 2 ) ) ymin = dm % yp ( 1 ) if ( dm % icase == ICASE_CHANNEL ) then a = ( ymax - ymin ) * HALF b = ZERO c = ONEPFIVE else if ( dm % icase == ICASE_PIPE ) then a = ( ymax - ymin ) b = ZERO c = TWO else if ( dm % icase == ICASE_ANNULAR ) then a = ( ymax - ymin ) * HALF b = ( ymax + ymin ) * HALF c = TWO else a = ( ymax - ymin ) * HALF b = ZERO c = ONEPFIVE end if do j = 1 , dm % nc ( 2 ) yy = dm % yc ( j ) ux_1c1 ( j ) = ( ONE - ( ( yy - b ) ** 2 ) / a / a ) * c end do !---------------------------------------------------------------------------------------------------------- !   Y-pencil : write out velocity profile !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then open ( newunit = pf_unit , & file = trim ( dir_chkp ) // '/check_poiseuille_ux_profile.dat' , & status = 'replace' , & action = 'write' ) write ( pf_unit , '(A)' ) \"#id,  yc, ux_laminar, ux_real\" do j = 1 , dm % nc ( 2 ) write ( pf_unit , '(1I3.1, 2ES15.7)' ) j , dm % yc ( j ), ux_1c1 ( j ) end do close ( pf_unit ) end if return end subroutine Generate_poiseuille_flow_profile !========================================================================================================== !> \\brief initialise Poiseuille flow in channel or pipe. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   private !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     d             domain !> \\param[out]    f             flow !========================================================================================================== subroutine initialise_poiseuille_flow ( dm , fl ) use input_general_mod use udf_type_mod use boundary_conditions_mod use parameters_constant_mod use wtformat_mod use io_files_mod use io_restart_mod use convert_primary_conservative_mod use find_max_min_ave_mod use wrt_debug_field_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl integer :: pf_unit integer :: i , j , k , jj real ( WP ) :: ubulk real ( WP ) :: ux_1c1 ( dm % nc ( 2 )) real ( WP ) :: ux ( dm % dpcc % xsz ( 1 ), dm % dpcc % xsz ( 2 ), dm % dpcc % xsz ( 3 )) real ( WP ) :: ux_ypencil ( dm % dpcc % ysz ( 1 ), dm % dpcc % ysz ( 2 ), dm % dpcc % ysz ( 3 )) character ( 2 ) :: str type ( DECOMP_INFO ) :: dtmp if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialising Poiseuille flow field ...\" ) !---------------------------------------------------------------------------------------------------------- !   x-pencil : to get Poiseuille profile for all ranks !---------------------------------------------------------------------------------------------------------- ux_1c1 (:) = ZERO call Generate_poiseuille_flow_profile ( dm , ux_1c1 ) !---------------------------------------------------------------------------------------------------------- !   x-pencil : to add profile to ux (default: x streamwise) !---------------------------------------------------------------------------------------------------------- dtmp = dm % dpcc do i = 1 , dtmp % xsz ( 1 ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) do k = 1 , dtmp % xsz ( 3 ) fl % qx ( i , j , k ) = fl % qx ( i , j , k ) + ux_1c1 ( jj ) end do end do end do #ifdef DEBUG_STEPS call wrt_3d_pt_debug ( fl % qx , dm % dpcc , fl % iteration , 0 , 'qx@af init' ) ! debug_ww call wrt_3d_pt_debug ( fl % qy , dm % dcpc , fl % iteration , 0 , 'qy@af init' ) ! debug_ww call wrt_3d_pt_debug ( fl % qz , dm % dccp , fl % iteration , 0 , 'qz@af init' ) ! debug_ww call wrt_3d_pt_debug ( fl % pres , dm % dccc , fl % iteration , 0 , 'pr@af init' ) ! debug_ww #endif !---------------------------------------------------------------------------------------------------------- !   x-pencil : Ensure the mass flow rate is 1. !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then call convert_primary_conservative ( fl , dm , IQ2G ) ux = fl % gx str = 'gx' else ux = fl % qx str = 'qx' end if if ( nrank == 0 ) call Print_debug_inline_msg ( \"Max/min velocity for generated initial velocities:\" ) call Find_max_min_absvar3d ( fl % qx , \"qx\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % qy , \"qy\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % qz , \"qz\" , wrtfmt2ae ) call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , ux , ubulk , SPACE_AVERAGE , str ) if ( nrank == 0 ) then write ( * , wrtfmt1e ) \"The initial, [original] bulk \" // str // \" = \" , ubulk end if ux (:, :, :) = ux (:, :, :) / ubulk ux_1c1 = ux_1c1 / ubulk if ( dm % is_thermo ) then fl % gx = ux call convert_primary_conservative ( fl , dm , IG2Q ) else fl % qx = ux end if call Get_volumetric_average_3d_for_var_xcx ( dm , dm % dpcc , ux , ubulk , SPACE_AVERAGE , str ) if ( nrank == 0 ) then write ( * , wrtfmt1e ) \"The initial, [scaled] bulk \" // str // \" = \" , ubulk end if if ( nrank == 0 ) call Print_debug_inline_msg ( \"Maximum [velocity] for real initial flow field:\" ) call Find_max_min_absvar3d ( fl % qx , \"qx\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % qy , \"qy\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % qz , \"qz\" , wrtfmt2ae ) if ( dm % is_thermo ) then if ( nrank == 0 ) call Print_debug_inline_msg ( \"Maximum [mass flux] for real initial flow field:\" ) call Find_max_min_absvar3d ( fl % gx , \"gx\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % gy , \"gy\" , wrtfmt2ae ) call Find_max_min_absvar3d ( fl % gz , \"gz\" , wrtfmt2ae ) end if ! to do : to add a scaling for turbulence generator inlet scaling, u = u * m / rho !---------------------------------------------------------------------------------------------------------- !   some checking !---------------------------------------------------------------------------------------------------------- call transpose_x_to_y ( ux , ux_ypencil , dm % dpcc ) if ( dm % ibcx_nominal ( 1 , 1 ) == IBC_PROFILE1D ) then call initialise_fbcx_given_profile ( dm % fbcx_qx , ux_1c1 , dm % dpcc % xst ( 2 ), 'qx' ) end if if ( dm % ibcx_nominal ( 1 , 1 ) == IBC_DATABASE . and . & dm % ibcx_nominal ( 2 , 1 ) == IBC_CONVECTIVE ) then call extract_dirichlet_fbcx ( dm % fbcx_qx , fl % qx , dm % dpcc ) call extract_dirichlet_fbcx ( dm % fbcx_qy , fl % qy , dm % dcpc ) call extract_dirichlet_fbcx ( dm % fbcx_qz , fl % qz , dm % dccp ) end if !if(nrank == 0) call Print_debug_end_msg() return end subroutine initialise_poiseuille_flow !========================================================================================================== !========================================================================================================== subroutine initialise_flow_from_given_values ( fl ) use udf_type_mod , only : t_domain use precision_mod , only : WP use parameters_constant_mod , only : ZERO use boundary_conditions_mod implicit none !type(t_domain),  intent(in) :: dm type ( t_flow ), intent ( inout ) :: fl if ( nrank == 0 ) call Print_debug_inline_msg ( \"Initialising flow field with given values...\" ) !---------------------------------------------------------------------------------------------------------- !   x-pencil : update values !---------------------------------------------------------------------------------------------------------- fl % qx (:, :, :) = fl % qx (:, :, :) + fl % init_velo3d ( 1 ) fl % qy (:, :, :) = fl % qy (:, :, :) + fl % init_velo3d ( 2 ) fl % qz (:, :, :) = fl % qz (:, :, :) + fl % init_velo3d ( 3 ) !---------------------------------------------------------------------------------------------------------- !   x-pencil : apply b.c. !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== subroutine initialise_flow_from_given_inlet ( dm , fl ) use udf_type_mod , only : t_domain use precision_mod , only : WP use parameters_constant_mod , only : ZERO use boundary_conditions_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl integer :: i , j , k , ii , jj , kk if ( nrank == 0 ) call Print_debug_inline_msg ( \"Initialising flow field with given profile...\" ) !---------------------------------------------------------------------------------------------------------- !   x-pencil : update values !---------------------------------------------------------------------------------------------------------- do k = 1 , dm % dpcc % xsz ( 3 ) kk = dm % dpcc % xst ( 3 ) + k - 1 do j = 1 , dm % dpcc % xsz ( 2 ) jj = dm % dpcc % xst ( 2 ) + j - 1 !local2global_yid(j, dm%dpcc) do i = 1 , dm % dpcc % xsz ( 1 ) ii = dm % dpcc % xst ( 1 ) + i - 1 fl % qx ( i , j , k ) = fl % qx ( i , j , k ) + dm % fbcx_qx ( 1 , j , k ) end do end do end do do k = 1 , dm % dcpc % xsz ( 3 ) kk = dm % dcpc % xst ( 3 ) + k - 1 do j = 1 , dm % dcpc % xsz ( 2 ) jj = dm % dcpc % xst ( 2 ) + j - 1 !local2global_yid(j, dm%dcpc) do i = 1 , dm % dcpc % xsz ( 1 ) ii = dm % dcpc % xst ( 1 ) + i - 1 fl % qy ( i , j , k ) = fl % qy ( i , j , k ) + dm % fbcx_qy ( 1 , j , k ) end do end do end do do k = 1 , dm % dccp % xsz ( 3 ) kk = dm % dccp % xst ( 3 ) + k - 1 do j = 1 , dm % dccp % xsz ( 2 ) jj = dm % dccp % xst ( 2 ) + j - 1 !(j, dm%dccp) do i = 1 , dm % dccp % xsz ( 1 ) ii = dm % dccp % xst ( 1 ) + i - 1 fl % qz ( i , j , k ) = fl % qz ( i , j , k ) + dm % fbcx_qz ( 1 , j , k ) end do end do end do !---------------------------------------------------------------------------------------------------------- !   x-pencil : apply b.c. !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== subroutine initialise_flow_fields ( fl , dm ) use udf_type_mod use parameters_constant_mod use io_restart_mod use io_visualisation_mod use wtformat_mod use solver_tools_mod use continuity_eq_mod use boundary_conditions_mod use statistics_mod use convert_primary_conservative_mod use wrt_debug_field_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl real ( WP ) :: velo ( 3 ) if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialise flow fields ...\" ) !---------------------------------------------------------------------------------------------------------- ! to set up Re !---------------------------------------------------------------------------------------------------------- call Update_Re ( fl % iterfrom , fl ) !---------------------------------------------------------------------------------------------------------- ! initialise primary variables !---------------------------------------------------------------------------------------------------------- fl % time = ZERO fl % iteration = 0 if ( fl % inittype == INIT_RESTART ) then fl % iteration = fl % iterfrom fl % time = real ( fl % iterfrom , WP ) * dm % dt call read_instantaneous_flow ( fl , dm ) call restore_flow_variables_from_restart ( fl , dm ) !call read_statistics_flow(fl, dm) else if ( fl % inittype == INIT_INTERPL ) then else if ( fl % inittype == INIT_RANDOM ) then call Generate_random_field ( dm , fl ) else if ( fl % inittype == INIT_INLET ) then call Generate_random_field ( dm , fl ) call initialise_flow_from_given_inlet ( dm , fl ) else if ( fl % inittype == INIT_GVCONST ) then call Generate_random_field ( dm , fl ) call initialise_flow_from_given_values ( fl ) else if ( fl % inittype == INIT_POISEUILLE ) then call Generate_random_field ( dm , fl ) call initialise_poiseuille_flow ( dm , fl ) else if ( fl % inittype == INIT_FUNCTION ) then if ( dm % icase == ICASE_TGV2D ) then call initialise_vortexgreen_2dflow ( dm , fl ) else if ( dm % icase == ICASE_TGV3D ) then call initialise_vortexgreen_3dflow ( dm , fl ) else if ( dm % icase == ICASE_BURGERS ) then !call initialise_burgers_flow      (dm, fl) else end if else end if !---------------------------------------------------------------------------------------------------------- ! to initialise pressure correction term !---------------------------------------------------------------------------------------------------------- if ( dm % is_thermo ) then call convert_primary_conservative ( fl , dm , IQ2G ) !call update_dyn_fbcx_from_flow(dm, fl%gx, fl%gy, fl%gz, dm%fbcx_gx, dm%fbcx_gy, dm%fbcx_gz) !call convert_primary_conservative(fl, dm, IG2Q) end if #ifdef DEBUG_STEPS !call wrt_3d_pt_debug(fl%qx, dm%dpcc,   fl%iteration, 0, 'qx@bf inoutlet') ! debug_ww !call wrt_3d_pt_debug(fl%qy, dm%dcpc,   fl%iteration, 0, 'qy@bf inoutlet') ! debug_ww !call wrt_3d_pt_debug(fl%qz, dm%dccp,   fl%iteration, 0, 'qz@bf inoutlet') ! debug_ww !call wrt_3d_pt_debug(fl%pres, dm%dccc, fl%iteration, 0, 'pr@bf inoutlet') ! debug_ww #endif !call update_dyn_fbcx_from_flow(dm, fl%qx, fl%qy, fl%qz, dm%fbcx_qx, dm%fbcx_qy, dm%fbcx_qz) !call enforce_domain_mass_balance_dyn_fbc(fl, dm) !---------------------------------------------------------------------------------------------------------- ! to initialise pressure correction term !---------------------------------------------------------------------------------------------------------- fl % pcor (:, :, :) = ZERO call Check_element_mass_conservation ( fl , dm , 0 , opt_str = 'initial' ) call write_visu_flow ( fl , dm , 'init' ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== subroutine initialise_thermo_fields ( tm , fl , dm ) use udf_type_mod use parameters_constant_mod use eq_energy_mod use thermo_info_mod use io_restart_mod use statistics_mod use io_visualisation_mod implicit none type ( t_domain ), intent ( inout ) :: dm type ( t_flow ), intent ( inout ) :: fl type ( t_thermo ), intent ( inout ) :: tm integer :: i if (. not . dm % is_thermo ) return if ( nrank == 0 ) call Print_debug_start_msg ( \"Initialise thermo fields ...\" ) !---------------------------------------------------------------------------------------------------------- ! to set up Fr etc, require update flow Re first !---------------------------------------------------------------------------------------------------------- call Update_Re ( fl % iterfrom , fl ) call Update_PrGr ( fl , tm ) !---------------------------------------------------------------------------------------------------------- ! initialise primary variables !---------------------------------------------------------------------------------------------------------- if ( tm % inittype == INIT_RESTART ) then tm % iteration = tm % iterfrom tm % time = real ( tm % iterfrom , WP ) * dm % dt call read_instantaneous_thermo ( tm , dm ) call restore_thermo_variables_from_restart ( fl , tm , dm ) call read_statistics_thermo ( tm , dm ) else if ( tm % inittype == INIT_INTERPL ) then else call initialise_thermal_properties ( fl , tm ) tm % time = ZERO tm % iteration = 0 end if fl % dDensm1 (:, :, :) = fl % dDens (:, :, :) fl % dDensm2 (:, :, :) = fl % dDens (:, :, :) call write_visu_thermo ( tm , fl , dm , 'init' ) if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief initialise Vortex Green flow !> !> This subroutine is called locally once. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !> \\param[out]    f             flow !_______________________________________________________________________________ subroutine initialise_vortexgreen_2dflow ( dm , fl ) use parameters_constant_mod !, only : HALF, ZERO, SIXTEEN, TWO use udf_type_mod use math_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl real ( WP ) :: xc , yc real ( WP ) :: xp , yp integer :: i , j , ii , jj type ( DECOMP_INFO ) :: dtmp if ( nrank == 0 ) call Print_debug_inline_msg ( \"Initialising vortexgreen 2dflow ...\" ) !---------------------------------------------------------------------------------------------------------- !   ux in x-pencil !---------------------------------------------------------------------------------------------------------- dtmp = dm % dpcc do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) yc = dm % yc ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xp = dm % h ( 1 ) * real ( ii - 1 , WP ) fl % qx ( i , j , :) = sin_wp ( xp ) * cos_wp ( yc ) end do end do !---------------------------------------------------------------------------------------------------------- !   uy in x-pencil !---------------------------------------------------------------------------------------------------------- dtmp = dm % dcpc do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) yp = dm % yp ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) fl % qy ( i , j , :) = - cos_wp ( xc ) * sin_wp ( yp ) end do end do !---------------------------------------------------------------------------------------------------------- !   uz in x-pencil !---------------------------------------------------------------------------------------------------------- fl % qz (:, :, :) = ZERO !---------------------------------------------------------------------------------------------------------- !   p in x-pencil !---------------------------------------------------------------------------------------------------------- fl % pres (:, :, :) = ZERO ! dtmp = dm%dccc ! do j = 1, dtmp%xsz(2) !   jj = dtmp%xst(2) + j - 1 !local2global_yid(j, dtmp) !   yc = dm%yc(jj) !   do i = 1, dtmp%xsz(1) !     ii = dtmp%xst(1) + i - 1 !     xc = dm%h(1) * (real(ii - 1, WP) + HALF) !     p(i, j, :)= ( cos_wp(TWO * xc) + sin(TWO * yc) ) * QUARTER !   end do ! end do if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine initialise_vortexgreen_2dflow !========================================================================================================== !========================================================================================================== subroutine Validate_TGV2D_error ( fl , dm ) use parameters_constant_mod use udf_type_mod use math_mod use io_files_mod !use iso_fortran_env implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( in ) :: fl integer :: k , i , j , ii , jj !, kk real ( wp ) :: uerr , ue , uc , verr , perr real ( wp ) :: xc , yc , xp , yp real ( wp ) :: uerrmax , verrmax , perrmax real ( wp ) :: perr_work , perrmax_work real ( wp ) :: uerr_work , uerrmax_work real ( wp ) :: verr_work , verrmax_work type ( DECOMP_INFO ) :: dtmp character ( len = 128 ) :: filename integer :: outputunit !---------------------------------------------------------------------------------------------------------- !   X-pencil : Find Max. error of ux !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) call Print_debug_inline_msg ( \"Validat TGV2D error ...\" ) dtmp = dm % dpcc uerr = ZERO uerrmax = ZERO do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !(j, dtmp) yc = dm % yc ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xp = dm % h ( 1 ) * real ( ii - 1 , WP ) uc = fl % qx ( i , j , k ) ue = sin_wp ( xp ) * cos_wp ( yc ) * exp ( - TWO * fl % rre * fl % time ) uerr = uerr + ( uc - ue ) ** 2 if ( abs_wp ( uc - ue ) > uerrmax ) uerrmax = abs_wp ( uc - ue ) end do end do end do call mpi_barrier ( MPI_COMM_WORLD , ierror ) call mpi_allreduce ( uerr , uerr_work , 1 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) call mpi_allreduce ( uerrmax , uerrmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) uerr_work = uerr_work / real ( dm % np ( 1 ), wp ) / real ( dm % nc ( 2 ), wp ) / real ( dm % nc ( 3 ), wp ) uerr_work = sqrt_wp ( uerr_work ) !---------------------------------------------------------------------------------------------------------- !   X-pencil : Find Max. error of uy !---------------------------------------------------------------------------------------------------------- dtmp = dm % dcpc verr = ZERO verrmax = ZERO do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) yp = dm % yp ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) uc = fl % qy ( i , j , k ) ue = - cos_wp ( xc ) * sin_wp ( yp ) * exp ( - TWO * fl % rre * fl % time ) verr = verr + ( uc - ue ) ** 2 if ( abs_wp ( uc - ue ) > verrmax ) verrmax = abs_wp ( uc - ue ) end do end do end do call mpi_barrier ( MPI_COMM_WORLD , ierror ) call mpi_allreduce ( verr , verr_work , 1 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) call mpi_allreduce ( verrmax , verrmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) verr_work = verr_work / real ( dm % nc ( 1 ), wp ) / real ( dm % np ( 2 ), wp ) / real ( dm % nc ( 3 ), wp ) verr_work = sqrt_wp ( verr_work ) !---------------------------------------------------------------------------------------------------------- !   X-pencil : Find Max. error of p !---------------------------------------------------------------------------------------------------------- dtmp = dm % dccc perr = ZERO perrmax = ZERO do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) yc = dm % yc ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) uc = fl % pres ( i , j , k ) ue = ( cos_wp ( TWO * xc ) + sin_wp ( TWO * yc ) ) * QUARTER * ( exp ( - TWO * fl % rre * fl % time )) ** 2 perr = perr + ( uc - ue ) ** 2 if ( abs_wp ( uc - ue ) > perrmax ) perrmax = abs_wp ( uc - ue ) end do end do end do call mpi_barrier ( MPI_COMM_WORLD , ierror ) call mpi_allreduce ( perr , perr_work , 1 , MPI_REAL_WP , MPI_SUM , MPI_COMM_WORLD , ierror ) call mpi_allreduce ( perrmax , perrmax_work , 1 , MPI_REAL_WP , MPI_MAX , MPI_COMM_WORLD , ierror ) perr_work = perr_work / real ( dm % nc ( 1 ), wp ) / real ( dm % nc ( 2 ), wp ) / real ( dm % nc ( 3 ), wp ) perr_work = sqrt_wp ( perr_work ) !---------------------------------------------------------------------------------------------------------- !   X-pencil : write data in rank=0 !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) then filename = 'Validation_TGV2d.dat' if (. not . file_exists ( trim ( filename ))) then open ( newunit = outputunit , file = trim ( filename ), action = \"write\" , status = \"new\" ) write ( outputunit , '(A)' ) 'Time, SD(u), SD(v), SD(p)' else open ( newunit = outputunit , file = trim ( filename ), action = \"write\" , status = \"old\" , position = \"append\" ) end if write ( outputunit , '(1F10.4, 6ES17.7E3)' ) fl % time , uerr_work , verr_work , perr_work , & uerrmax_work , verrmax_work , perrmax_work close ( outputunit ) end if if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine !========================================================================================================== !========================================================================================================== !> \\brief initialise Vortex Green flow !> !> This subroutine is called locally once. !> !---------------------------------------------------------------------------------------------------------- ! Arguments !______________________________________________________________________________. !  mode           name          role                                           ! !______________________________________________________________________________! !> \\param[in]     d             domain !> \\param[out]    f             flow !_______________________________________________________________________________ subroutine initialise_vortexgreen_3dflow ( dm , fl ) use parameters_constant_mod !, only : HALF, ZERO, SIXTEEN, TWO, PI use udf_type_mod use math_mod implicit none type ( t_domain ), intent ( in ) :: dm type ( t_flow ), intent ( inout ) :: fl real ( WP ) :: xc , yc , zc real ( WP ) :: xp , yp , zp integer :: i , j , k , ii , jj , kk type ( DECOMP_INFO ) :: dtmp if ( nrank == 0 ) call Print_debug_inline_msg ( \"Initialising Taylor Green Vortex flow field ...\" ) !---------------------------------------------------------------------------------------------------------- !   ux in x-pencil !---------------------------------------------------------------------------------------------------------- dtmp = dm % dpcc do k = 1 , dtmp % xsz ( 3 ) kk = dtmp % xst ( 3 ) + k - 1 zc = dm % h ( 3 ) * ( real ( kk - 1 , WP ) + HALF ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) yc = dm % yc ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xp = dm % h ( 1 ) * real ( ii - 1 , WP ) fl % qx ( i , j , k ) = sin_wp ( xp ) * cos_wp ( yc ) * cos_wp ( zc ) !write(*,*) k, j, i, sin_wp ( xp ) , cos_wp ( yc ) , cos_wp ( zc ), ux(i,j,k) end do end do end do !---------------------------------------------------------------------------------------------------------- !   uy in x-pencil !---------------------------------------------------------------------------------------------------------- dtmp = dm % dcpc do k = 1 , dtmp % xsz ( 3 ) kk = dtmp % xst ( 3 ) + k - 1 zc = dm % h ( 3 ) * ( real ( kk - 1 , WP ) + HALF ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !(j, dtmp) yp = dm % yp ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) fl % qy ( i , j , k ) = - cos_wp ( xc ) * sin_wp ( yp ) * cos_wp ( zc ) end do end do end do !---------------------------------------------------------------------------------------------------------- !   uz in x-pencil !---------------------------------------------------------------------------------------------------------- !uz(:, :, :) =  ZERO dtmp = dm % dccp do k = 1 , dtmp % xsz ( 3 ) do j = 1 , dtmp % xsz ( 2 ) do i = 1 , dtmp % xsz ( 1 ) fl % qz ( i , j , k ) = zero end do end do end do !---------------------------------------------------------------------------------------------------------- !   p in x-pencil !---------------------------------------------------------------------------------------------------------- dtmp = dm % dccc do k = 1 , dtmp % xsz ( 3 ) kk = dtmp % xst ( 3 ) + k - 1 zc = dm % h ( 3 ) * ( real ( kk - 1 , WP ) + HALF ) do j = 1 , dtmp % xsz ( 2 ) jj = dtmp % xst ( 2 ) + j - 1 !local2global_yid(j, dtmp) yc = dm % yc ( jj ) do i = 1 , dtmp % xsz ( 1 ) ii = dtmp % xst ( 1 ) + i - 1 xc = dm % h ( 1 ) * ( real ( ii - 1 , WP ) + HALF ) fl % pres ( i , j , k ) = ONE / SIXTEEN * ( cos ( TWO * xc ) + cos ( TWO * yc ) ) * & ( cos ( TWO * zc ) + TWO ) end do end do end do if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine initialise_vortexgreen_3dflow end module flow_thermo_initialiasation","tags":"","url":"sourcefile/initialisation.f90.html"},{"title":"domain_decomposition.f90 – CHAPSim2","text":"Source Code !############################################################################## module domain_decomposition_mod use mpi_mod use decomp_2d implicit none private :: initialise_domain_decomposition public :: Buildup_mpi_domain_decomposition contains !========================================================================================================== !> \\brief domain decompistion. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain     module !>         all    once           specified   priviate !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     d          domain type !========================================================================================================== subroutine initialise_domain_decomposition ( dm ) use udf_type_mod !use iso_fortran_env use wtformat_mod use print_msg_mod implicit none type ( t_domain ), intent ( inout ) :: dm #ifdef DEBUG_STEPS type ( DECOMP_INFO ) :: dtmp integer :: i #endif !---------------------------------------------------------------------------------------------------------- ! basic 2D decompistion API ! limits: p_row <= min(nx, ny) !         p_col <= min(ny, nz) ! xsize(i), ysize(i), zsize(i), i = 1,2,3 : !   sizes of the sub-domains held by the current process. !   The first letter refers to the pencil orientation and the three 1D array elements !   contain the sub-domain sizes in X, Y and Z directions, respectively. !   example: xsize(1:3) means the subdomain size in xyz direction of x-pencil !   In a 2D pencil decomposition, there is always one dimension which completely !   resides in local memory. So by definition, below relations hold !   xsize(1)==nx_global, ysize(2)==ny_global and zsize(3)==nz_global ! xstart(i), ystart(i), zstart(i), xend(i), yend(i), zend(i), i=1,2,3 : (Global index) !   the starting and ending indices for each sub-domain, as in the global coordinate system. !   Obviously, it can be seen that xsize(i)=xend(i)-xstart(i)+1. !   It may be convenient for certain applications to use global coordinate !   (for example when extracting a 2D plane from a 3D domain, it is easier to know which !   process owns the plane if global index is used). !---------------------------------------------------------------------------------------------------------- !---------------------------------------------------------------------------------------------------------- ! initialise decomp !---------------------------------------------------------------------------------------------------------- if ( nrank == 0 ) call Print_debug_start_msg ( 'Initialising decomp_info_init for domain decomposition' ) call decomp_info_init ( dm % np ( 1 ), dm % nc ( 2 ), dm % nc ( 3 ), dm % dpcc ) ! for ux, gx call decomp_info_init ( dm % nc ( 1 ), dm % np ( 2 ), dm % nc ( 3 ), dm % dcpc ) ! for uy, gy call decomp_info_init ( dm % nc ( 1 ), dm % nc ( 2 ), dm % np ( 3 ), dm % dccp ) ! for uz, gz call decomp_info_init ( dm % nc ( 1 ), dm % nc ( 2 ), dm % nc ( 3 ), dm % dccc ) ! for p, T, h call decomp_info_init ( dm % np ( 1 ), dm % np ( 2 ), dm % nc ( 3 ), dm % dppc ) ! for intermediate vars call decomp_info_init ( dm % nc ( 1 ), dm % np ( 2 ), dm % np ( 3 ), dm % dcpp ) ! for intermediate vars call decomp_info_init ( dm % np ( 1 ), dm % nc ( 2 ), dm % np ( 3 ), dm % dpcp ) ! for intermediate vars call decomp_info_init ( dm % np ( 1 ), dm % np ( 2 ), dm % np ( 3 ), dm % dppp ) ! this is only used in test. if ( dm % is_record_xoutlet . or . dm % is_read_xinlet ) then call decomp_info_init ( dm % ndbfre , dm % nc ( 2 ), dm % nc ( 3 ), dm % dxcc ) ! for ux, gx call decomp_info_init ( dm % ndbfre , dm % np ( 2 ), dm % nc ( 3 ), dm % dxpc ) ! for uy, gy call decomp_info_init ( dm % ndbfre , dm % nc ( 2 ), dm % np ( 3 ), dm % dxcp ) ! for uz, gz end if call decomp_info_init ( 4 , dm % nc ( 2 ), dm % nc ( 3 ), dm % d4cc ) ! this is fbcx operation call decomp_info_init ( 4 , dm % np ( 2 ), dm % nc ( 3 ), dm % d4pc ) ! this is fbcx operation #ifdef DEBUG_STEPS call mpi_barrier ( MPI_COMM_WORLD , ierror ) if ( nrank == 0 ) call Print_debug_inline_msg ( ' domain decomposition info' ) do i = 1 , 7 select case ( i ) case ( 1 ) dtmp = dm % dpcc if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - pcc grids (for ux, gx) :' case ( 2 ) dtmp = dm % dcpc if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - cpc grids (for uy, gy) :' case ( 3 ) dtmp = dm % dccp if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - ccp grids (for uz, gz) :' case ( 4 ) dtmp = dm % dccc if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - ccc grids (for rho, p) :' case ( 5 ) dtmp = dm % dppc if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - ppc grids (for dux/dy, duy/dx) :' case ( 6 ) dtmp = dm % dcpp if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - cpp grids (for duy/dz, duz/dy) :' case ( 7 ) dtmp = dm % dpcp if ( nrank == 0 ) write ( * , wrtfmt1s ) 'In the decomp - pcp grids (for dux/dz, duz/dx) :' case default end select call mpi_barrier ( MPI_COMM_WORLD , ierror ) write ( * , wrtfmt4i ) 'x-pencil, x id in rank ' , nrank , dtmp % xst ( 1 ), dtmp % xen ( 1 ), dtmp % xsz ( 1 ) write ( * , wrtfmt4i ) 'x-pencil, y id in rank ' , nrank , dtmp % xst ( 2 ), dtmp % xen ( 2 ), dtmp % xsz ( 2 ) write ( * , wrtfmt4i ) 'x-pencil, z id in rank ' , nrank , dtmp % xst ( 3 ), dtmp % xen ( 3 ), dtmp % xsz ( 3 ) call mpi_barrier ( MPI_COMM_WORLD , ierror ) write ( * , wrtfmt4i ) 'y-pencil, x id in rank ' , nrank , dtmp % yst ( 1 ), dtmp % yen ( 1 ), dtmp % ysz ( 1 ) write ( * , wrtfmt4i ) 'y-pencil, y id in rank ' , nrank , dtmp % yst ( 2 ), dtmp % yen ( 2 ), dtmp % ysz ( 2 ) write ( * , wrtfmt4i ) 'y-pencil, z id in rank ' , nrank , dtmp % yst ( 3 ), dtmp % yen ( 3 ), dtmp % ysz ( 3 ) call mpi_barrier ( MPI_COMM_WORLD , ierror ) write ( * , wrtfmt4i ) 'z-pencil, x id in rank ' , nrank , dtmp % zst ( 1 ), dtmp % zen ( 1 ), dtmp % zsz ( 1 ) write ( * , wrtfmt4i ) 'z-pencil, y id in rank ' , nrank , dtmp % zst ( 2 ), dtmp % zen ( 2 ), dtmp % zsz ( 2 ) write ( * , wrtfmt4i ) 'z-pencil, z id in rank ' , nrank , dtmp % zst ( 3 ), dtmp % zen ( 3 ), dtmp % zsz ( 3 ) call mpi_barrier ( MPI_COMM_WORLD , ierror ) end do #endif if ( nrank == 0 ) call Print_debug_end_msg () return end subroutine initialise_domain_decomposition !========================================================================================================== !> \\brief domain decompistion. !---------------------------------------------------------------------------------------------------------- !> Scope:  mpi    called-freq    xdomain   module !>         all    once           all       public !---------------------------------------------------------------------------------------------------------- ! Arguments !---------------------------------------------------------------------------------------------------------- !  mode           name          role !---------------------------------------------------------------------------------------------------------- !> \\param[in]     none          NA !========================================================================================================== subroutine Buildup_mpi_domain_decomposition use vars_df_mod use mpi_mod use io_tools_mod use io_monitor_mod use io_visualisation_mod use statistics_mod implicit none integer :: i #ifdef DEBUG_STEPS real ( WP ), allocatable :: id (:, :, :) #endif call decomp_2d_init ( domain ( 1 )% np ( 1 ), domain ( 1 )% np ( 2 ), domain ( 1 )% np ( 3 ), p_row , p_col ) do i = 1 , nxdomain call initialise_domain_decomposition ( domain ( i )) call initialise_decomp_io ( domain ( i )) call write_monitor_ini ( domain ( i )) call write_visu_ini ( domain ( i )) call init_statistics_flow ( flow ( i ), domain ( i )) if ( domain ( i )% is_thermo ) call init_statistics_thermo ( thermo ( i ), domain ( i )) #ifdef DEBUG_STEPS allocate ( id ( domain ( i )% dccc % xsz ( 1 ), domain ( i )% dccc % xsz ( 2 ), domain ( i )% dccc % xsz ( 3 )) ) id (:, :, :) = real ( nrank , WP ) call write_visu_any3darray ( id , 'rank' , 'mesh' , domain ( i )% dpcc , domain ( i ), 0 ) deallocate ( id ) #endif end do return end subroutine Buildup_mpi_domain_decomposition end module domain_decomposition_mod","tags":"","url":"sourcefile/domain_decomposition.f90.html"}]}